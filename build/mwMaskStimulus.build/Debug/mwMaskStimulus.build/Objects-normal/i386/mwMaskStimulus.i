# 1 "/Users/graham/Developer/mwMaskStimulus/mwMaskStimulus.cpp"
# 1 "/Users/graham/Developer/mwMaskStimulus//"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "/Users/graham/Developer/mwMaskStimulus/mwMaskStimulus_Prefix.pch" 1
# 1 "<command line>" 2
# 1 "/Users/graham/Developer/mwMaskStimulus/mwMaskStimulus.cpp"
# 10 "/Users/graham/Developer/mwMaskStimulus/mwMaskStimulus.cpp"
# 1 "/Users/graham/Developer/mwMaskStimulus/mwMaskStimulus.h" 1
# 14 "/Users/graham/Developer/mwMaskStimulus/mwMaskStimulus.h"
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Plugin.h" 1 3
# 26 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Plugin.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentRegistry.h" 1 3
# 31 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentRegistry.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Clock.h" 1 3
# 15 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Clock.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/MonkeyWorksTypes.h" 1 3
# 15 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/MonkeyWorksTypes.h" 3
namespace mw {

typedef long long MonkeyWorksTime;

typedef unsigned long long NetworkStats;
}
# 16 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Clock.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Component.h" 1 3
# 12 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Component.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/string" 1 3
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/string" 3
       
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/string" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++config.h" 1 3
# 35 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++config.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/os_defines.h" 1 3
# 36 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++config.h" 2 3
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++config.h" 3
namespace __gnu_debug_def { }

namespace __gnu_debug
{
  using namespace __gnu_debug_def;
}
# 45 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/string" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stringfwd.h" 1 3
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stringfwd.h" 3
       
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stringfwd.h" 3



namespace std
{
  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;

}
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/string" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/char_traits.h" 1 3
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/char_traits.h" 3
       
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/char_traits.h" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstring" 1 3
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstring" 3
       
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstring" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstddef" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstddef" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstddef" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stddef.h" 1 3 4
# 152 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 214 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 49 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstddef" 2 3

namespace std
{
  using ::ptrdiff_t;
  using ::size_t;
}
# 50 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstring" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/string.h" 1 3 4
# 60 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/string.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_types.h" 1 3 4
# 27 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_types.h" 1 3 4
# 32 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/cdefs.h" 1 3 4
# 33 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/_types.h" 1 3 4
# 34 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/_types.h" 1 3 4
# 37 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef int __darwin_ptrdiff_t;





typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 35 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_types.h" 2 3 4
# 58 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_types.h" 3 4
struct __darwin_pthread_handler_rec
{
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t { long __sig; char __opaque[36]; };
struct _opaque_pthread_cond_t { long __sig; char __opaque[24]; };
struct _opaque_pthread_condattr_t { long __sig; char __opaque[4]; };
struct _opaque_pthread_mutex_t { long __sig; char __opaque[40]; };
struct _opaque_pthread_mutexattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_once_t { long __sig; char __opaque[4]; };
struct _opaque_pthread_rwlock_t { long __sig; char __opaque[124]; };
struct _opaque_pthread_rwlockattr_t { long __sig; char __opaque[12]; };
struct _opaque_pthread_t { long __sig; struct __darwin_pthread_handler_rec *__cleanup_stack; char __opaque[596]; };
# 94 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;



typedef __uint32_t __darwin_ino_t;

typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef struct _opaque_pthread_attr_t
   __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t
   __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t
   __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t
   __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t
   __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t
   __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t
   __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t
   __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t
   *__darwin_pthread_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
# 28 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_types.h" 2 3 4

typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;



typedef unsigned long __darwin_wctype_t;
# 61 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/string.h" 2 3 4
# 70 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/string.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 80 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/string.h" 3 4
extern "C" {
void *memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memmove(void *, const void *, size_t);
void *memset(void *, int, size_t);

char *stpcpy(char *, const char *);
char *strcasestr(const char *, const char *);

char *strcat(char *, const char *);
char *strchr(const char *, int);
int strcmp(const char *, const char *);
int strcoll(const char *, const char *);
char *strcpy(char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int) __asm("_" "strerror" "$UNIX2003");
int strerror_r(int, char *, size_t);
size_t strlen(const char *);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);

char *strnstr(const char *, const char *, size_t);

char *strpbrk(const char *, const char *);
char *strrchr(const char *, int);
size_t strspn(const char *, const char *);
char *strstr(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);



void *memccpy(void *, const void *, int, size_t);
char *strtok_r(char *, const char *, char **);
char *strdup(const char *);

int bcmp(const void *, const void *, size_t);
void bcopy(const void *, void *, size_t);
void bzero(void *, size_t);
int ffs(int);
int ffsl(long);
int fls(int);
int flsl(long);
char *index(const char *, int);
void memset_pattern4(void *, const void *, size_t);
void memset_pattern8(void *, const void *, size_t);
void memset_pattern16(void *, const void *, size_t);
char *rindex(const char *, int);
int strcasecmp(const char *, const char *);
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
void strmode(int, char *);
int strncasecmp(const char *, const char *, size_t);
char *strsep(char **, const char *);
char *strsignal(int sig);
void swab(const void * , void * , ssize_t);


}
# 52 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstring" 2 3
# 77 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstring" 3
namespace std
{
  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;

  using ::memchr;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }
}
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/char_traits.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 1 3
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/climits" 1 3
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/climits" 3
       
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/climits" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/limits.h" 1 3 4






# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/syslimits.h" 1 3 4
# 8 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/limits.h" 2 3 4


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/limits.h" 1 3 4
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/limits.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/limits.h" 1 3 4







# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/limits.h" 1 3 4
# 40 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/limits.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/_limits.h" 1 3 4
# 41 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/limits.h" 2 3 4
# 9 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/limits.h" 2 3 4
# 65 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/limits.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/syslimits.h" 1 3 4
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/limits.h" 2 3 4
# 11 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/limits.h" 2 3 4
# 50 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/climits" 2 3
# 67 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdlib" 1 3
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdlib" 3
       
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdlib" 3
# 57 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdlib" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdlib.h" 1 3 4
# 61 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdlib.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/available.h" 1 3 4
# 62 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdlib.h" 2 3 4



# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/wait.h" 1 3 4
# 79 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;






typedef __darwin_pid_t pid_t;




typedef __darwin_id_t id_t;
# 116 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 1 3 4
# 73 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 2 3 4







# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/signal.h" 1 3 4
# 34 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/signal.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/signal.h" 1 3 4
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 55 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/signal.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/_structs.h" 1 3 4
# 56 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/signal.h" 2 3 4
# 35 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/signal.h" 2 3 4
# 82 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 2 3 4
# 154 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 1 3 4
# 57 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/_structs.h" 1 3 4
# 31 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/_structs.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/_structs.h" 1 3 4
# 38 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/_structs.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 1 3 4
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 89 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 147 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 191 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 210 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 232 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};
# 308 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state
{
    unsigned int __trapno;
    unsigned int __err;
    unsigned int __faultvaddr;
};
# 326 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 358 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 413 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};
# 517 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64
{
    unsigned int __trapno;
    unsigned int __err;
    __uint64_t __faultvaddr;
};
# 535 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/_structs.h" 2 3 4
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/_structs.h" 3 4
struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};
# 68 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/_structs.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};
# 94 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/_structs.h" 3 4
typedef struct __darwin_mcontext32 *mcontext_t;
# 32 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/_structs.h" 2 3 4
# 58 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 2 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
# 128 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 3 4
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext32 *uc_mcontext;



};
# 218 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 3 4
typedef struct __darwin_sigaltstack stack_t;
# 227 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 3 4
typedef struct __darwin_ucontext ucontext_t;
# 155 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 2 3 4
# 163 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;




typedef __darwin_sigset_t sigset_t;
# 178 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 3 4
typedef __darwin_uid_t uid_t;


union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 292 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 354 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 371 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 3 4
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 390 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 412 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/signal.h" 3 4
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
# 117 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/resource.h" 1 3 4
# 76 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/resource.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 1 3 4
# 100 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 3 4
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 77 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/resource.h" 2 3 4
# 88 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/resource.h" 3 4
typedef __uint64_t rlim_t;
# 142 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 153 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/resource.h" 3 4
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 213 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 235 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/resource.h" 3 4
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int);

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" "$UNIX2003");
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int);

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" "$UNIX2003");
}
# 118 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/wait.h" 2 3 4
# 193 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/endian.h" 1 3 4
# 37 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/endian.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/endian.h" 1 3 4
# 99 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/endian.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_endian.h" 1 3 4
# 124 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((_data << 8) | (_data >> 8));
}

static inline
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{
    __asm__ ("bswap   %0" : "+r" (_data));
    return _data;
}


static inline
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    __asm__ ("bswap   %%eax\n\t"
             "bswap   %%edx\n\t"
             "xchgl   %%eax, %%edx"
             : "+A" (_data));
    return _data;
}
# 67 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 125 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_endian.h" 2 3 4
# 100 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/endian.h" 2 3 4
# 38 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/endian.h" 2 3 4
# 194 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/wait.h" 2 3 4







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
    w_Coredump:1,
    w_Retcode:8,
    w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
    w_Stopsig:8,
    w_Filler:16;






 } w_S;
};
# 254 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/wait.h" 3 4
extern "C" {
pid_t wait(int *) __asm("_" "wait" "$UNIX2003");
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" "$UNIX2003");

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" "$UNIX2003");


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/alloca.h" 1 3 4
# 35 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/alloca.h" 3 4
extern "C" {
void *alloca(size_t);
}
# 68 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdlib.h" 2 3 4
# 81 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdlib.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;




typedef __darwin_rune_t rune_t;
# 97 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdlib.h" 3 4
typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
# 134 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 144 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdlib.h" 3 4
extern "C" {
void abort(void) __attribute__((__noreturn__));
int abs(int) __attribute__((__const__));
int atexit(void (*)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *, const void *, size_t,
     size_t, int (*)(const void *, const void *));
void *calloc(size_t, size_t);
div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
void qsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int rand(void);
void *realloc(void *, size_t);
void srand(unsigned);
double strtod(const char *, char **) __asm("_" "strtod" "$UNIX2003");
float strtof(const char *, char **) __asm("_" "strtof" "$UNIX2003");
long strtol(const char *, char **, int);
long double
  strtold(const char *, char **) ;

long long
  strtoll(const char *, char **, int);

unsigned long
  strtoul(const char *, char **, int);

unsigned long long
  strtoull(const char *, char **, int);

int system(const char *) __asm("_" "system" "$UNIX2003");
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]);
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void);
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void);
long nrand48(unsigned short[3]);
int posix_openpt(int);
char *ptsname(int);
int putenv(char *) __asm("_" "putenv" "$UNIX2003");
long random(void);
int rand_r(unsigned *);

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char *, const char *, int) __asm("_" "setenv" "$UNIX2003");

void setkey(const char *) __asm("_" "setkey" "$UNIX2003");



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" "$UNIX2003");






# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/types.h" 1 3 4
# 37 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/types.h" 1 3 4
# 78 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/i386/types.h" 3 4
typedef signed char int8_t;

typedef unsigned char u_int8_t;


typedef short int16_t;

typedef unsigned short u_int16_t;


typedef int int32_t;

typedef unsigned int u_int32_t;


typedef long long int64_t;

typedef unsigned long long u_int64_t;




typedef int32_t register_t;




typedef __darwin_intptr_t intptr_t;



typedef unsigned long int uintptr_t;




typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;





typedef u_int64_t syscall_arg_t;
# 38 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/machine/types.h" 2 3 4
# 255 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdlib.h" 2 3 4


typedef __darwin_dev_t dev_t;




typedef __darwin_mode_t mode_t;



u_int32_t
  arc4random(void);
void arc4random_addrandom(unsigned char *dat, int datlen);
void arc4random_stir(void);


char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((deprecated));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);

int heapsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int mergesort(void *, size_t, size_t,
     int (*)(const void *, const void *));
void qsort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));
int radixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void setprogname(const char *);
int sradixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *, size_t);

long long
  strtoq(const char *, char **, int);
unsigned long long
  strtouq(const char *, char **, int);

extern char *suboptarg;
void *valloc(size_t);






}
# 58 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdlib" 2 3
# 90 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdlib" 3
namespace std
{

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }
# 143 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdlib" 3
}
# 156 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdlib" 3
namespace __gnu_cxx
{

  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }

  inline long long
  llabs(long long __x) { return __x >= 0 ? __x : -__x; }


  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  inline lldiv_t
  lldiv(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }
# 192 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;
}

namespace std
{

  using __gnu_cxx::lldiv_t;

  using __gnu_cxx::_Exit;
  using __gnu_cxx::abs;
  using __gnu_cxx::llabs;

  using __gnu_cxx::div;
  using __gnu_cxx::lldiv;

  using __gnu_cxx::atoll;
  using __gnu_cxx::strtof;
  using __gnu_cxx::strtoll;
  using __gnu_cxx::strtoull;
  using __gnu_cxx::strtold;
}
# 68 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iosfwd" 1 3
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iosfwd" 3
       
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iosfwd" 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++locale.h" 1 3
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++locale.h" 3
       
# 40 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++locale.h" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/clocale" 1 3
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/clocale" 3
       
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/clocale" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/locale.h" 1 3 4
# 40 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/locale.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_locale.h" 1 3 4
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_locale.h" 3 4
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};





extern "C" {
struct lconv *localeconv(void);
}
# 41 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/locale.h" 2 3 4
# 52 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/locale.h" 3 4
extern "C" {
char *setlocale(int, const char *);
}
# 50 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/clocale" 2 3





namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++locale.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdio" 1 3
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdio" 3
       
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdio" 3




# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdio.h" 1 3 4
# 70 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdio.h" 3 4
typedef __darwin_va_list va_list;




typedef __darwin_off_t off_t;
# 87 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdio.h" 3 4
typedef __darwin_off_t fpos_t;
# 98 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 132 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read) (void *, char *, int);
 fpos_t (*_seek) (void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern "C" {

extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;



}
# 248 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdio.h" 3 4
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);
FILE *fopen(const char * , const char * );
int fprintf(FILE * , const char * , ...) ;
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" "$UNIX2003");
size_t fread(void * , size_t, size_t, FILE * );
FILE *freopen(const char * , const char * ,
     FILE * ) __asm("_" "freopen" "$UNIX2003");
int fscanf(FILE * , const char * , ...) ;
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * , size_t, size_t, FILE * ) __asm("_" "fwrite" "$UNIX2003");
int getc(FILE *);
int getchar(void);
char *gets(char *);

extern const int sys_nerr;
extern const char *const sys_errlist[];

void perror(const char *);
int printf(const char * , ...) ;
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *, const char *);
void rewind(FILE *);
int scanf(const char * , ...) ;
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) ;
int sscanf(const char * , const char * , ...) ;
FILE *tmpfile(void);
char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) ;
int vprintf(const char * , va_list) ;
int vsprintf(char * , const char * , va_list) ;

int asprintf(char **, const char *, ...) ;
int vasprintf(char **, const char *, va_list) ;

}







extern "C" {
char *ctermid(char *);

char *ctermid_r(char *);

FILE *fdopen(int, const char *);

char *fgetln(FILE *, size_t *);

int fileno(FILE *);
void flockfile(FILE *);

const char
 *fmtcheck(const char *, const char *);
int fpurge(FILE *);

int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);

int getw(FILE *);

int pclose(FILE *);
FILE *popen(const char *, const char *);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);

int putw(int, FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);

int snprintf(char * , size_t, const char * , ...) ;
char *tempnam(const char *, const char *) __asm("_" "tempnam" "$UNIX2003");
int vfscanf(FILE * , const char * , va_list) ;
int vscanf(const char * , va_list) ;
int vsnprintf(char * , size_t, const char * , va_list) ;
int vsscanf(const char * , const char * , va_list) ;

FILE *zopen(const char *, const char *, int);

}





extern "C" {
FILE *funopen(const void *,
  int (*)(void *, char *, int),
  int (*)(void *, const char *, int),
  fpos_t (*)(void *, fpos_t, int),
  int (*)(void *));
}
# 371 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/stdio.h" 3 4
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) ;
int __swbuf(int, FILE *);
}







static inline int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 53 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdio" 2 3
# 97 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 153 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdio" 3
namespace __gnu_cxx
{
# 167 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using __gnu_cxx::snprintf;
  using __gnu_cxx::vfscanf;
  using __gnu_cxx::vscanf;
  using __gnu_cxx::vsnprintf;
  using __gnu_cxx::vsscanf;
}
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++locale.h" 2 3



namespace std
{
  typedef int* __c_locale;





  template<typename _Tv>
    int
    __convert_from_v(char* __out,
       const int __size __attribute__((__unused__)),
       const char* __fmt,
       _Tv __v, const __c_locale&, int __prec)
    {
      char* __old = std::setlocale(4, __null);
      char* __sav = __null;
      if (std::strcmp(__old, "C"))
 {
   __sav = new char[std::strlen(__old) + 1];
   std::strcpy(__sav, __old);
   std::setlocale(4, "C");
 }


      const int __ret = std::snprintf(__out, __size, __fmt, __prec, __v);




      if (__sav)
 {
   std::setlocale(4, __sav);
   delete [] __sav;
 }
      return __ret;
    }
}
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iosfwd" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++io.h" 1 3
# 37 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++io.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr.h" 1 3
# 33 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 114 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr-default.h" 1 3
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr-default.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/pthread.h" 1 3 4
# 57 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/pthread.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/pthread_impl.h" 1 3 4
# 58 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/pthread.h" 2 3 4

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sched.h" 1 3 4
# 30 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sched.h" 3 4
extern "C" {




struct sched_param { int sched_priority; char __opaque[4]; };


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 60 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/time.h" 1 3 4
# 69 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/time.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_structs.h" 1 3 4
# 24 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_structs.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 1 3 4
# 88 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 25 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_structs.h" 2 3 4
# 70 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/time.h" 2 3 4







typedef __darwin_clock_t clock_t;
# 87 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/time.h" 3 4
typedef __darwin_time_t time_t;


struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 113 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" "$UNIX2003");

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" "$UNIX2003");
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" "$UNIX2003");
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" "$UNIX2003");
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" "$UNIX2003");
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *, struct timespec *) __asm("_" "nanosleep" "$UNIX2003");

}
# 61 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/pthread.h" 2 3 4
# 69 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/pthread.h" 3 4
typedef __darwin_pthread_cond_t pthread_cond_t;




typedef __darwin_pthread_condattr_t pthread_condattr_t;




typedef __darwin_pthread_key_t pthread_key_t;




typedef __darwin_pthread_mutex_t pthread_mutex_t;




typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;




typedef __darwin_pthread_once_t pthread_once_t;




typedef __darwin_pthread_rwlock_t pthread_rwlock_t;




typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;




typedef __darwin_pthread_t pthread_t;






typedef __darwin_mach_port_t mach_port_t;
# 148 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/pthread.h" 3 4
extern "C" {
# 244 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/pthread.h" 3 4
int pthread_atfork(void (*)(void), void (*)(void),
                      void (*)(void));
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getdetachstate(const pthread_attr_t *,
          int *);
int pthread_attr_getguardsize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_getinheritsched(const pthread_attr_t * ,
           int * );
int pthread_attr_getschedparam(const pthread_attr_t * ,
                                     struct sched_param * );
int pthread_attr_getschedpolicy(const pthread_attr_t * ,
          int * );
int pthread_attr_getscope(const pthread_attr_t * , int * );
int pthread_attr_getstack(const pthread_attr_t * ,
                                      void ** , size_t * );
int pthread_attr_getstackaddr(const pthread_attr_t * ,
                                      void ** );
int pthread_attr_getstacksize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_setdetachstate(pthread_attr_t *,
          int );
int pthread_attr_setguardsize(pthread_attr_t *, size_t );
int pthread_attr_setinheritsched(pthread_attr_t *,
           int );
int pthread_attr_setschedparam(pthread_attr_t * ,
                                     const struct sched_param * );
int pthread_attr_setschedpolicy(pthread_attr_t *,
          int );
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_attr_setstack(pthread_attr_t *,
                                      void *, size_t );
int pthread_attr_setstackaddr(pthread_attr_t *,
                                      void *);
int pthread_attr_setstacksize(pthread_attr_t *, size_t );
int pthread_cancel(pthread_t ) __asm("_" "pthread_cancel" "$UNIX2003");

int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_init(pthread_cond_t * ,
                            const pthread_condattr_t * ) __asm("_" "pthread_cond_init" "$UNIX2003");
int pthread_cond_signal(pthread_cond_t *);
int pthread_cond_timedwait(pthread_cond_t * ,
     pthread_mutex_t * ,
     const struct timespec * ) __asm("_" "pthread_cond_timedwait" "$UNIX2003");
int pthread_cond_wait(pthread_cond_t * ,
       pthread_mutex_t * ) __asm("_" "pthread_cond_wait" "$UNIX2003");
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_getpshared(const pthread_condattr_t * ,
   int * );
int pthread_condattr_setpshared(pthread_condattr_t *,
   int );
int pthread_create(pthread_t * ,
                         const pthread_attr_t * ,
                         void *(*)(void *),
                         void * );
int pthread_detach(pthread_t );
int pthread_equal(pthread_t ,
   pthread_t );
void pthread_exit(void *) __attribute__((__noreturn__));
int pthread_getconcurrency(void);
int pthread_getschedparam(pthread_t , int * , struct sched_param * );
void *pthread_getspecific(pthread_key_t );
int pthread_join(pthread_t , void **) __asm("_" "pthread_join" "$UNIX2003");
int pthread_key_create(pthread_key_t *, void (*)(void *));
int pthread_key_delete(pthread_key_t );
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_getprioceiling(const pthread_mutex_t * , int * );
int pthread_mutex_init(pthread_mutex_t * , const pthread_mutexattr_t * );
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_setprioceiling(pthread_mutex_t * , int, int * );
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" "$UNIX2003");
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_gettype(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int );
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_once(pthread_once_t *, void (*)(void));
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" "$UNIX2003");
int pthread_rwlock_init(pthread_rwlock_t * , const pthread_rwlockattr_t * ) __asm("_" "pthread_rwlock_init" "$UNIX2003");
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" "$UNIX2003");
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" "$UNIX2003");
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" "$UNIX2003");
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" "$UNIX2003");
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" "$UNIX2003");
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
   int * );
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,
   int );
pthread_t pthread_self(void);

int pthread_setcancelstate(int , int *) __asm("_" "pthread_setcancelstate" "$UNIX2003");
int pthread_setcanceltype(int , int *) __asm("_" "pthread_setcanceltype" "$UNIX2003");
int pthread_setconcurrency(int);
int pthread_setschedparam(pthread_t ,
    int ,
                                const struct sched_param *);
int pthread_setspecific(pthread_key_t ,
         const void *);
void pthread_testcancel(void) __asm("_" "pthread_testcancel" "$UNIX2003");



int pthread_is_threaded_np(void);


int pthread_main_np(void);


mach_port_t pthread_mach_thread_np(pthread_t);
size_t pthread_get_stacksize_np(pthread_t);
void * pthread_get_stackaddr_np(pthread_t);


int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t);


int pthread_cond_timedwait_relative_np(pthread_cond_t *,
     pthread_mutex_t *,
     const struct timespec *);


int pthread_create_suspended_np(pthread_t *,
                         const pthread_attr_t *,
                         void *(*)(void *),
                         void *);
int pthread_kill(pthread_t, int);

pthread_t pthread_from_mach_thread_np(mach_port_t);

int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask" "$UNIX2003");
void pthread_yield_np(void);

}
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr-default.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/unistd.h" 1 3 4
# 72 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/unistd.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/unistd.h" 1 3 4
# 138 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/unistd.h" 3 4
struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};
# 73 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/unistd.h" 2 3 4
# 83 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/unistd.h" 3 4
typedef __darwin_gid_t gid_t;
# 127 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/unistd.h" 3 4
typedef __darwin_useconds_t useconds_t;





typedef __darwin_uuid_t uuid_t;
# 414 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/unistd.h" 3 4
extern "C" {

void _exit(int) __attribute__((__noreturn__));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);
int close(int) __asm("_" "close" "$UNIX2003");
size_t confstr(int, char *, size_t) __asm("_" "confstr" "$UNIX2003");
char *crypt(const char *, const char *);
char *ctermid(char *);
int dup(int);
int dup2(int, int);

void encrypt(char *, int) __asm("_" "encrypt" "$UNIX2003");



int execl(const char *, const char *, ...);
int execle(const char *, const char *, ...);
int execlp(const char *, const char *, ...);
int execv(const char *, char * const *);
int execve(const char *, char * const *, char * const *);
int execvp(const char *, char * const *);
int fchown(int, uid_t, gid_t);
int fchdir(int);
pid_t fork(void);
long fpathconf(int, int);
int fsync(int) __asm("_" "fsync" "$UNIX2003");
int ftruncate(int, off_t);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);
int getgroups(int, gid_t []);
long gethostid(void);
int gethostname(char *, size_t);
char *getlogin(void);
int getlogin_r(char *, size_t);
int getopt(int, char * const [], const char *) __asm("_" "getopt" "$UNIX2003");
pid_t getpgid(pid_t);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
pid_t getsid(pid_t);
uid_t getuid(void);
char *getwd(char *);
int isatty(int);
int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" "$UNIX2003");
int link(const char *, const char *);
int lockf(int, int, off_t) __asm("_" "lockf" "$UNIX2003");
off_t lseek(int, off_t, int);
int nice(int) __asm("_" "nice" "$UNIX2003");
long pathconf(const char *, int);
int pause(void) __asm("_" "pause" "$UNIX2003");
int pipe(int [2]);
ssize_t pread(int, void *, size_t, off_t) __asm("_" "pread" "$UNIX2003");
ssize_t pwrite(int, const void *, size_t, off_t) __asm("_" "pwrite" "$UNIX2003");
ssize_t read(int, void *, size_t) __asm("_" "read" "$UNIX2003");
ssize_t readlink(const char * , char * , size_t);
int rmdir(const char *);
int setegid(gid_t);
int seteuid(uid_t);
int setgid(gid_t);
int setpgid(pid_t, pid_t);

pid_t setpgrp(void) __asm("_" "setpgrp" "$UNIX2003");



int setregid(gid_t, gid_t) __asm("_" "setregid" "$UNIX2003");
int setreuid(uid_t, uid_t) __asm("_" "setreuid" "$UNIX2003");
pid_t setsid(void);
int setuid(uid_t);
unsigned int
  sleep(unsigned int) __asm("_" "sleep" "$UNIX2003");
void swab(const void * , void * , ssize_t);
int symlink(const char *, const char *);
void sync(void);
long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
int truncate(const char *, off_t);
char *ttyname(int);

int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" "$UNIX2003");



useconds_t
  ualarm(useconds_t, useconds_t);
int unlink(const char *);
int usleep(useconds_t) __asm("_" "usleep" "$UNIX2003");
pid_t vfork(void);
ssize_t write(int, const void *, size_t) __asm("_" "write" "$UNIX2003");

extern char *optarg;
extern int optind, opterr, optopt;


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/select.h" 1 3 4
# 78 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/select.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 1 3 4
# 183 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 3 4
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[(((1024) + (((sizeof(__int32_t) * 8)) - 1)) / ((sizeof(__int32_t) * 8)))];
} fd_set;
}


static inline int
__darwin_fd_isset(int _n, struct fd_set *_p)
{
 return (_p->fds_bits[_n/(sizeof(__int32_t) * 8)] & (1<<(_n % (sizeof(__int32_t) * 8))));
}
# 79 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/select.h" 2 3 4
# 92 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/select.h" 3 4
typedef __darwin_suseconds_t suseconds_t;
# 134 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/select.h" 3 4
extern "C" {


int pselect(int, fd_set * , fd_set * ,
  fd_set * , const struct timespec * ,
  const sigset_t * )






  __asm("_" "pselect" "$UNIX2003")


  ;


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_select.h" 1 3 4
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_select.h" 3 4
int select(int, fd_set * , fd_set * ,
  fd_set * , struct timeval * )






  __asm("_" "select" "$UNIX2003")


  ;
# 153 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/select.h" 2 3 4

}
# 516 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/unistd.h" 2 3 4

void _Exit(int) __attribute__((__noreturn__));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int);
void *brk(const void *);
int chroot(const char *);
void endusershell(void);
int execvP(const char *, const char *, char * const *);
char *fflagstostr(unsigned long);
int getdtablesize(void);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);
mode_t getmode(const void *, mode_t);
int getpagesize(void) __attribute__((__const__));
char *getpass(const char *);
int getpeereid(int, uid_t *, gid_t *);
int getpgid(pid_t _pid);
int getsgroups_np(int *, uuid_t);
int getsid(pid_t _pid);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int iruserok(unsigned long, int, const char *, const char *);
int iruserok_sa(const void *, int, int, const char *, const char *);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);
int rcmd(char **, int, const char *, const char *, const char *, int *);
int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
int reboot(int);
int revoke(const char *);
int rresvport(int *);
int rresvport_af(int *, int);
int ruserok(const char *, int, const char *, const char *);
void *sbrk(int);
int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_" "setkey" "$UNIX2003");



int setlogin(const char *);
void *setmode(const char *);
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int syscall(int, ...);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);
# 597 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/unistd.h" 3 4
int getattrlist(const char*,void*,void*,size_t,unsigned long) __asm("_" "getattrlist" "$UNIX2003");
int setattrlist(const char*,void*,void*,size_t,unsigned long) __asm("_" "setattrlist" "$UNIX2003");
int exchangedata(const char*,const char*,unsigned long);
int getdirentriesattr(int,void*,void*,size_t,unsigned long*,unsigned long*,unsigned long*,unsigned long);
int searchfs(const char*,void*,void*,unsigned long,unsigned long,void*);

int fsctl(const char *,unsigned long,void*,unsigned long);


extern int optreset;


}
# 45 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr-default.h" 2 3

typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
# 116 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 473 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr-default.h" 3
static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (once, func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return pthread_key_create (key, dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return pthread_key_delete (key);
}

static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return pthread_getspecific (key);
}

static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return pthread_setspecific (key, ptr);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (mutex);
  else
    return 0;
}


static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t attr;
      int r;

      r = pthread_mutexattr_init (&attr);
      if (!r)
 r = pthread_mutexattr_settype (&attr, 2);
      if (!r)
 r = pthread_mutex_init (mutex, &attr);
      if (!r)
 r = pthread_mutexattr_destroy (&attr);
      return r;
    }
}


static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_lock (mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_trylock (mutex);
}

static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_unlock (mutex);
}
# 115 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 38 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++io.h" 2 3

namespace std
{
  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;



  struct __ios_flags
  {
    typedef short __int_type;

    static const __int_type _S_boolalpha = 0x0001;
    static const __int_type _S_dec = 0x0002;
    static const __int_type _S_fixed = 0x0004;
    static const __int_type _S_hex = 0x0008;
    static const __int_type _S_internal = 0x0010;
    static const __int_type _S_left = 0x0020;
    static const __int_type _S_oct = 0x0040;
    static const __int_type _S_right = 0x0080;
    static const __int_type _S_scientific = 0x0100;
    static const __int_type _S_showbase = 0x0200;
    static const __int_type _S_showpoint = 0x0400;
    static const __int_type _S_showpos = 0x0800;
    static const __int_type _S_skipws = 0x1000;
    static const __int_type _S_unitbuf = 0x2000;
    static const __int_type _S_uppercase = 0x4000;
    static const __int_type _S_adjustfield = 0x0020 | 0x0080 | 0x0010;
    static const __int_type _S_basefield = 0x0002 | 0x0040 | 0x0008;
    static const __int_type _S_floatfield = 0x0100 | 0x0004;


    static const __int_type _S_badbit = 0x01;
    static const __int_type _S_eofbit = 0x02;
    static const __int_type _S_failbit = 0x04;


    static const __int_type _S_app = 0x01;
    static const __int_type _S_ate = 0x02;
    static const __int_type _S_bin = 0x04;
    static const __int_type _S_in = 0x08;
    static const __int_type _S_out = 0x10;
    static const __int_type _S_trunc = 0x20;
  };
}
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iosfwd" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cctype" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cctype" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cctype" 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/ctype.h" 1 3 4
# 69 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/ctype.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/runetype.h" 1 3 4
# 70 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/runetype.h" 3 4
typedef __darwin_wint_t wint_t;
# 81 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/runetype.h" 3 4
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;



extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 70 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/ctype.h" 2 3 4
# 145 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/ctype.h" 3 4
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

static inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 164 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/ctype.h" 3 4
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}


static inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

static inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 204 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/ctype.h" 3 4
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}


static inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






static inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

static inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

static inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

static inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


static inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

static inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

static inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

static inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

static inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

static inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

static inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


static inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

static inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

static inline int
tolower(int _c)
{
        return (__tolower(_c));
}

static inline int
toupper(int _c)
{
        return (__toupper(_c));
}


static inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

static inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

static inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

static inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

static inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

static inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

static inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 50 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cctype" 2 3
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iosfwd" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/postypes.h" 1 3
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/postypes.h" 3
       
# 45 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/postypes.h" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwchar" 1 3
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwchar" 3
       
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwchar" 3



# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ctime" 1 3
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ctime" 3
       
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ctime" 3
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 52 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwchar" 2 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/wchar.h" 1 3 4
# 83 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/wchar.h" 3 4
typedef __darwin_mbstate_t mbstate_t;
# 111 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/wchar.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stdarg.h" 1 3 4
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 112 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/wchar.h" 2 3 4


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_wctype.h" 1 3 4
# 52 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_wctype.h" 3 4
typedef __darwin_wctype_t wctype_t;
# 71 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_wctype.h" 3 4
static inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

static inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

static inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

static inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

static inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

static inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

static inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

static inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

static inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

static inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

static inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

static inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

static inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

static inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 176 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/_wctype.h" 3 4
extern "C" {
wctype_t
 wctype(const char *);
}
# 115 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/wchar.h" 2 3 4

extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...) ;
int fwscanf(FILE * , const wchar_t * , ...) ;
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * ,
     ...) ;
int swscanf(const wchar_t * , const wchar_t * , ...) ;
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list) ;
int vwprintf(const wchar_t * , __darwin_va_list) ;
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" "$UNIX2003");
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...) ;
int wscanf(const wchar_t * , ...) ;


int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list) ;
int vwscanf(const wchar_t * , __darwin_va_list) ;
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** ) ;

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);



size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
     size_t, mbstate_t * );
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
     size_t, mbstate_t * );






}
# 55 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwchar" 2 3
# 69 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 141 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwchar" 3
namespace std
{
  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;

  using ::vswprintf;

  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;

  using ::wcschr;

  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcspbrk;

  inline wchar_t*
  wcspbrk(wchar_t* __s1, wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wcsrchr;

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcsstr;

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wmemchr;

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }
}







namespace __gnu_cxx
{





  using ::wcstold;
# 258 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using __gnu_cxx::wcstold;
  using __gnu_cxx::wcstoll;
  using __gnu_cxx::wcstoull;
}
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/postypes.h" 2 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stdint.h" 1 3 4
# 40 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stdint.h" 3 4
typedef unsigned char uint8_t;




typedef unsigned short uint16_t;




typedef unsigned int uint32_t;




typedef unsigned long long uint64_t;



typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 97 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stdint.h" 3 4
typedef long long int intmax_t;
# 106 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stdint.h" 3 4
typedef long long unsigned int uintmax_t;
# 50 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/postypes.h" 2 3


namespace std
{
# 72 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/postypes.h" 3
  typedef int64_t streamoff;





  typedef ptrdiff_t streamsize;

  template<typename _StateT>
    class fpos;
# 94 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 116 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }






      bool
      operator==(const fpos& __other) const
      { return _M_off == __other._M_off; }


      bool
      operator!=(const fpos& __other) const
      { return _M_off != __other._M_off; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
}
# 50 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iosfwd" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/functexcept.h" 1 3
# 41 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/functexcept.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/exception_defines.h" 1 3
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char* __s) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char* __s) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char* __s) __attribute__((__noreturn__));

  void
  __throw_length_error(const char* __s) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char* __s) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char* __s) __attribute__((__noreturn__));

  void
  __throw_range_error(const char* __s) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char* __s) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char* __s) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char* __s) __attribute__((__noreturn__));
}
# 51 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iosfwd" 2 3

namespace std
{
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 135 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;


}
# 70 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_pair.h" 1 3
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_pair.h" 3
namespace std
{

  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 142 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
}
# 71 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/cpp_type_traits.h" 1 3
# 41 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/cpp_type_traits.h" 3
       
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/cpp_type_traits.h" 3
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/cpp_type_traits.h" 3
namespace __gnu_internal
{
  typedef char __one;
  typedef char __two[2];

  template<typename _Tp>
  __one __test_type(int _Tp::*);
  template<typename _Tp>
  __two& __test_type(...);
}


namespace __gnu_cxx
{
  template<typename _Iterator, typename _Container>
    class __normal_iterator;
}

struct __true_type { };
struct __false_type { };

namespace std
{
  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename, bool>
    struct __enable_if
    {
    };

  template<typename _Tp>
    struct __enable_if<_Tp, true>
    {
      typedef _Tp __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_pod
    {
      enum
 {
   __value = (sizeof(__gnu_internal::__test_type<_Tp>(0))
       != sizeof(__gnu_internal::__one))
 };
    };

}
# 72 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator_base_types.h" 1 3
# 67 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator_base_types.h" 3
       
# 68 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator_base_types.h" 3

namespace std
{
# 80 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};


  struct bidirectional_iterator_tag : public forward_iterator_tag {};


  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 104 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };







  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 73 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator_base_funcs.h" 1 3
# 67 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator_base_funcs.h" 3
       
# 68 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator_base_funcs.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/concept_check.h" 1 3
# 38 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/concept_check.h" 3
       
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/concept_check.h" 3
# 69 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std
{
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 112 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
              bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 170 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      std::__advance(__i, __n, std::__iterator_category(__i));
    }
}
# 74 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 1 3
# 68 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
namespace std
{
# 89 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 275 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
  const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }
# 335 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 361 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }


      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 395 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 410 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 435 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }


      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 469 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 488 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 530 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }


      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 565 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }
}

namespace __gnu_cxx
{







  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        inline __normal_iterator(const __normal_iterator<_Iter,
     _Container>& __i)
 : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 678 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
}
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/debug/debug.h" 1 3
# 272 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/debug/debug.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 273 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/debug/debug.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stddef.h" 1 3 4
# 275 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/debug/debug.h" 2 3



namespace __gnu_debug
{
  template<typename _Iterator, typename _Sequence>
    class _Safe_iterator;


  inline bool
  __check_singular_aux(const void*) { return false; }



  template<typename _Iterator>
    inline bool
    __check_singular(_Iterator& __x)
    { return __gnu_debug::__check_singular_aux(&__x); }


  template<typename _Tp>
    inline bool
    __check_singular(const _Tp* __ptr)
    { return __ptr == 0; }


  template<typename _Iterator, typename _Sequence>
    inline bool
    __check_singular(const _Safe_iterator<_Iterator, _Sequence>& __x)
    { return __x._M_singular(); }



  template<typename _Iterator>
    inline bool
    __check_dereferenceable(_Iterator&)
    { return true; }


  template<typename _Tp>
    inline bool
    __check_dereferenceable(const _Tp* __ptr)
    { return __ptr; }


  template<typename _Iterator, typename _Sequence>
    inline bool
    __check_dereferenceable(const _Safe_iterator<_Iterator, _Sequence>& __x)
    { return __x._M_dereferenceable(); }




  template<typename _RandomAccessIterator>
    inline bool
    __valid_range_aux2(const _RandomAccessIterator& __first,
         const _RandomAccessIterator& __last,
         std::random_access_iterator_tag)
    { return __last - __first >= 0; }





  template<typename _InputIterator>
    inline bool
    __valid_range_aux2(const _InputIterator&, const _InputIterator&,
         std::input_iterator_tag)
    { return true; }





  template<typename _Integral>
    inline bool
    __valid_range_aux(const _Integral&, const _Integral&, __true_type)
    { return true; }




  template<typename _InputIterator>
    inline bool
    __valid_range_aux(const _InputIterator& __first,
        const _InputIterator& __last, __false_type)
  {
    typedef typename std::iterator_traits<_InputIterator>::iterator_category
      _Category;
    return __gnu_debug::__valid_range_aux2(__first, __last, _Category());
  }






  template<typename _InputIterator>
    inline bool
    __valid_range(const _InputIterator& __first, const _InputIterator& __last)
    {
      typedef typename std::__is_integer<_InputIterator>::__type _Integral;
      return __gnu_debug::__valid_range_aux(__first, __last, _Integral());
    }


  template<typename _Iterator, typename _Sequence>
    inline bool
    __valid_range(const _Safe_iterator<_Iterator, _Sequence>& __first,
    const _Safe_iterator<_Iterator, _Sequence>& __last)
    { return __first._M_valid_range(__last); }





  template<typename _InputIterator>
    inline _InputIterator
    __check_valid_range(const _InputIterator& __first,
   const _InputIterator& __last)
    {
      ;
      return __first;
    }


  template<typename _CharT, typename _Integer>
    inline const _CharT*
    __check_string(const _CharT* __s, const _Integer& __n)
    {



      return __s;
    }


  template<typename _CharT>
    inline const _CharT*
    __check_string(const _CharT* __s)
    {



      return __s;
    }



  template<typename _InputIterator>
    inline bool
    __check_sorted_aux(const _InputIterator&, const _InputIterator&,
                       std::input_iterator_tag)
    { return true; }



  template<typename _ForwardIterator>
    inline bool
    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last,
                       std::forward_iterator_tag)
    {
      if (__first == __last)
        return true;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next) {
        if (*__next < *__first)
          return false;
      }

      return true;
    }



  template<typename _InputIterator, typename _Predicate>
    inline bool
    __check_sorted_aux(const _InputIterator&, const _InputIterator&,
                       _Predicate, std::input_iterator_tag)
    { return true; }



  template<typename _ForwardIterator, typename _Predicate>
    inline bool
    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last,
                       _Predicate __pred, std::forward_iterator_tag)
    {
      if (__first == __last)
        return true;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next) {
        if (__pred(*__next, *__first))
          return false;
      }

      return true;
    }


  template<typename _InputIterator>
    inline bool
    __check_sorted(const _InputIterator& __first, const _InputIterator& __last)
    {
      typedef typename std::iterator_traits<_InputIterator>::iterator_category
        _Category;
      return __gnu_debug::__check_sorted_aux(__first, __last, _Category());
    }

  template<typename _InputIterator, typename _Predicate>
    inline bool
    __check_sorted(const _InputIterator& __first, const _InputIterator& __last,
                   _Predicate __pred)
    {
      typedef typename std::iterator_traits<_InputIterator>::iterator_category
        _Category;
      return __gnu_debug::__check_sorted_aux(__first, __last, __pred,
          _Category());
    }




  template<typename _ForwardIterator, typename _Tp>
    inline bool
    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,
   const _Tp& __value)
    {
      while (__first != __last && *__first < __value)
 ++__first;
      while (__first != __last && !(*__first < __value))
 ++__first;
      return __first == __last;
    }


  template<typename _ForwardIterator, typename _Tp, typename _Pred>
    inline bool
    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,
   const _Tp& __value, _Pred __pred)
    {
      while (__first != __last && __pred(*__first, __value))
 ++__first;
      while (__first != __last && !__pred(*__first, __value))
 ++__first;
      return __first == __last;
    }
}
# 77 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 2 3

namespace std
{
# 90 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      const _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          const _ValueType1 __tmp = *__a;
          *__a = *__b;
          *__b = __tmp;
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 140 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value &&
 __are_same<_ValueType1 &, _ReferenceType1>::__value &&
 __are_same<_ValueType2 &, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 182 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 204 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 226 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 246 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }







  template<bool, typename>
    struct __copy
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };

  template<bool _BoolType>
    struct __copy<_BoolType, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };

  template<>
    struct __copy<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };

  template<typename _II, typename _OI>
    inline _OI
    __copy_aux(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueTypeI>::__value
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy<__simple, _Category>::copy(__first, __last, __result);
    }

  template<bool, bool>
    struct __copy_normal
    {
      template<typename _II, typename _OI>
        static _OI
        copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first, __last, __result); }
    };

  template<>
    struct __copy_normal<true, false>
    {
      template<typename _II, typename _OI>
        static _OI
        copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first.base(), __last.base(), __result); }
    };

  template<>
    struct __copy_normal<false, true>
    {
      template<typename _II, typename _OI>
        static _OI
        copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first, __last, __result.base())); }
    };

  template<>
    struct __copy_normal<true, true>
    {
      template<typename _II, typename _OI>
        static _OI
        copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first.base(), __last.base(),
         __result.base())); }
    };
# 373 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

      ;

       const bool __in = __is_normal_iterator<_InputIterator>::__value;
       const bool __out = __is_normal_iterator<_OutputIterator>::__value;
       return std::__copy_normal<__in, __out>::copy_n(__first, __last,
            __result);
    }

  template<bool, typename>
    struct __copy_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };

  template<bool _BoolType>
    struct __copy_backward<_BoolType, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };

  template<>
    struct __copy_backward<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        copy_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   std::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueType1>::__value
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_backward<__simple, _Category>::copy_b(__first, __last,
              __result);
    }

  template<bool, bool>
    struct __copy_backward_normal
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first, __last, __result); }
    };

  template<>
    struct __copy_backward_normal<true, false>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first.base(), __last.base(),
       __result); }
    };

  template<>
    struct __copy_backward_normal<false, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first, __last,
            __result.base())); }
    };

  template<>
    struct __copy_backward_normal<true, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first.base(), __last.base(),
            __result.base())); }
    };
# 502 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      const bool __bi1 = __is_normal_iterator<_BI1>::__value;
      const bool __bi2 = __is_normal_iterator<_BI2>::__value;
      return std::__copy_backward_normal<__bi1, __bi2>::copy_b_n(__first, __last,
         __result);
    }

  template<bool>
    struct __fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   for (; __first != __last; ++__first)
     *__first = __value;
 }
    };

  template<>
    struct __fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __first != __last; ++__first)
     *__first = __tmp;
 }
    };
# 558 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      const bool __scalar = __is_scalar<_Tp>::__value;
      std::__fill<__scalar>::fill(__first, __last, __value);
    }


  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
    ;
    const unsigned char __tmp = __c;
    std::memset(__first, __tmp, __last - __first);
  }

  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
    ;
    const signed char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  inline void
  fill(char* __first, char* __last, const char& __c)
  {
    ;
    const char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  template<bool>
    struct __fill_n
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   for (; __n > 0; --__n, ++__first)
     *__first = __value;
   return __first;
 }
    };

  template<>
    struct __fill_n<true>
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __n > 0; --__n, ++__first)
     *__first = __tmp;
   return __first;
 }
    };
# 634 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _OutputIterator, typename _Size, typename _Tp>
    _OutputIterator
    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
    {

     

      const bool __scalar = __is_scalar<_Tp>::__value;
      return std::__fill_n<__scalar>::fill_n(__first, __n, __value);
    }

  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline signed char*
    fill_n(char* __first, _Size __n, const signed char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
# 681 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 716 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && __binary_pred(*__first1, *__first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 746 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return true;
    }
# 778 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2,
   _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!__binary_pred(*__first1, *__first2))
   return false;
      return true;
    }
# 810 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     


      ;
      ;

      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (*__first1 < *__first2)
     return true;
   if (*__first2 < *__first1)
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 850 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _Compare __comp)
    {

     
     
      ;
      ;

      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  inline bool
  lexicographical_compare(const unsigned char* __first1,
     const unsigned char* __last1,
     const unsigned char* __first2,
     const unsigned char* __last2)
  {
    ;
    ;

    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = std::memcmp(__first1, __first2,
         std::min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }

  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
     const char* __first2, const char* __last2)
  {
    ;
    ;


    return std::lexicographical_compare((const signed char*) __first1,
     (const signed char*) __last1,
     (const signed char*) __first2,
     (const signed char*) __last2);






  }

}
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/char_traits.h" 2 3


namespace __gnu_cxx
{
# 61 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/char_traits.h" 3
  template <class _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(std::memmove(__s1, __s2,
            __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {
      std::fill_n(__s, __n, __a);
      return __s;
    }
}

namespace std
{
# 224 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c) { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c) { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>(((__darwin_wint_t)-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


}
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/string" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 1 3
# 51 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
       
# 52 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/allocator.h" 1 3
# 52 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/allocator.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++allocator.h" 1 3
# 34 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++allocator.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ext/new_allocator.h" 1 3
# 37 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ext/new_allocator.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/new" 1 3
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/new" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/exception" 1 3
# 40 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/exception" 3
#pragma GCC visibility push(default)

extern "C++" {

namespace std
{
# 54 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 102 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 117 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/exception" 3
  void __verbose_terminate_handler ();
}

}

#pragma GCC visibility pop
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    virtual ~bad_alloc() throw();
  };

  struct nothrow_t { };
  extern const nothrow_t nothrow;


  typedef void (*new_handler)();

  new_handler set_new_handler(new_handler) throw();
}
# 84 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 38 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ext/new_allocator.h" 2 3


namespace __gnu_cxx
{







  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new(__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }
}
# 35 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++allocator.h" 2 3
# 53 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/allocator.h" 2 3

namespace std
{
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };







  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;




}
# 55 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_construct.h" 1 3
# 67 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_construct.h" 3
namespace std
{






  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }







  template<typename _T1>
    inline void
    _Construct(_T1* __p)
    {


      ::new(static_cast<void*>(__p)) _T1();
    }






  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
# 116 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last,
    __false_type)
    {
      for (; __first != __last; ++__first)
 std::_Destroy(&*__first);
    }
# 134 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }
# 146 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename std::__is_scalar<_Value_type>::__type
                _Has_trivial_destructor;

      std::__destroy_aux(__first, __last, _Has_trivial_destructor());
    }
# 166 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_construct.h" 3
  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }

  template<typename _ForwardIterator, typename _Allocator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>)
    {
      _Destroy(__first, __last);
    }


}
# 56 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_uninitialized.h" 1 3
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_uninitialized.h" 3
namespace std
{

  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __true_type)
    { return std::copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __false_type)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     std::_Construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }
# 105 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      return std::__uninitialized_copy_aux(__first, __last, __result,
        _Is_POD());
    }

  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    std::memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }

  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
       wchar_t* __result)
  {
    std::memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }



  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIterator __first,
        _ForwardIterator __last,
        const _Tp& __x, __true_type)
    { std::fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 167 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }



  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __true_type)
    { std::fill_n(__first, __n, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 212 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      _Allocator __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      allocator<_Tp>)
    {
      return std::uninitialized_copy(__first, __last, __result);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>)
    {
      std::uninitialized_fill(__first, __last, __x);
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        allocator<_Tp2>)
    {
      std::uninitialized_fill_n(__first, __n, __x);
    }
# 323 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last,
         _Allocator __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_copy_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }

}
# 58 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_raw_storage_iter.h" 1 3
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_raw_storage_iter.h" 3
namespace std
{




  template <class _ForwardIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _ForwardIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_ForwardIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };
}
# 59 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/limits" 1 3
# 45 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/limits" 3
       
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/limits" 3
# 149 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/limits" 3
namespace std
{





  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 191 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;

    static const int digits10 = 0;

    static const bool is_signed = false;





    static const bool is_integer = false;




    static const bool is_exact = false;


    static const int radix = 0;



    static const int min_exponent = 0;


    static const int min_exponent10 = 0;



    static const int max_exponent = 0;


    static const int max_exponent10 = 0;


    static const bool has_infinity = false;


    static const bool has_quiet_NaN = false;


    static const bool has_signaling_NaN = false;

    static const float_denorm_style has_denorm = denorm_absent;


    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;



    static const bool is_bounded = false;




    static const bool is_modulo = false;


    static const bool traps = false;

    static const bool tinyness_before = false;



    static const float_round_style round_style = round_toward_zero;
  };
# 284 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp min() throw() { return static_cast<_Tp>(0); }

      static _Tp max() throw() { return static_cast<_Tp>(0); }


      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }

      static _Tp round_error() throw() { return static_cast<_Tp>(0); }

      static _Tp infinity() throw() { return static_cast<_Tp>(0); }

      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }


      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };





  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }

      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? ((char)1 << (sizeof(char) * 8 - ((char)(-1) < 0))) - 1 : ~(char)0); }

      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }

      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }

      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? ((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0))) - 1 : ~(wchar_t)0); }

      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }

      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }

      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }

      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }

      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min() throw()
      { return -2147483647L - 1; }
      static long max() throw()
      { return 2147483647L; }

      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 2147483647L * 2UL + 1; }

      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }

      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }

      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }

      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-7F; }
      static float round_error() throw()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1.40129846e-45F) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(4.9406564584124654e-324) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return 4.9406564584124654e-324; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }

      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(3.64519953188247460253e-4951L) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 61 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 2 3

namespace std
{
# 72 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    __get_temporary_buffer(ptrdiff_t __len, _Tp*)
    {
      const ptrdiff_t __max = numeric_limits<ptrdiff_t>::max() / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       nothrow));
   if (__tmp != 0)
     return pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 108 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
  template<typename _Tp>
    inline pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    { return std::__get_temporary_buffer(__len, static_cast<_Tp*>(0)); }
# 120 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
  template<typename _Tp>
    void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, nothrow); }
# 132 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    };
# 173 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 199 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 211 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 222 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 239 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 259 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
      ~auto_ptr() { delete _M_ptr; }
# 269 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 299 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 313 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 328 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 349 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/memory" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
  };
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/string" 2 3



# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_function.h" 1 3
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_function.h" 3
namespace std
{
# 101 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_function.h" 3
  template <class _Arg, class _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template <class _Arg1, class _Arg2, class _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 133 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_function.h" 3
  template <class _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template <class _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template <class _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template <class _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template <class _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template <class _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 195 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_function.h" 3
  template <class _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template <class _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template <class _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template <class _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template <class _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template <class _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 256 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_function.h" 3
  template <class _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template <class _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template <class _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
# 311 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_function.h" 3
  template <class _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) {}

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template <class _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template <class _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type,
        bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      binary_negate(const _Predicate& __x)
      : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template <class _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 391 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_function.h" 3
  template <class _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) {}

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    };


  template <class _Operation, class _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template <class _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) {}

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    };


  template <class _Operation, class _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
# 480 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_function.h" 3
  template <class _Arg, class _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      pointer_to_unary_function() {}

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) {}

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template <class _Arg, class _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template <class _Arg1, class _Arg2, class _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      pointer_to_binary_function() {}

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template <class _Arg1, class _Arg2, class _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template <class _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template <class _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template <class _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 590 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_function.h" 3
  template <class _Ret, class _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
    };


  template <class _Ret, class _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template <class _Ret, class _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
  };


  template <class _Ret, class _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };


  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };


  template <class _Tp>
    class mem_fun_t<void, _Tp> : public unary_function<_Tp*, void>
    {
    public:
      explicit
      mem_fun_t(void (_Tp::*__pf)())
      : _M_f(__pf) {}

      void
      operator()(_Tp* __p) const
      { (__p->*_M_f)(); }
    private:
      void (_Tp::*_M_f)();
    };


  template <class _Tp>
    class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*, void>
    {
    public:
      explicit
      const_mem_fun_t(void (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp* __p) const
      { (__p->*_M_f)(); }
    private:
      void (_Tp::*_M_f)() const;
    };


  template <class _Tp>
    class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp, void>
    {
    public:
      explicit
      mem_fun_ref_t(void (_Tp::*__pf)())
      : _M_f(__pf) {}

      void
      operator()(_Tp& __r) const
      { (__r.*_M_f)(); }
    private:
      void (_Tp::*_M_f)();
    };


  template <class _Tp>
    class const_mem_fun_ref_t<void, _Tp> : public unary_function<_Tp, void>
    {
    public:
      explicit
      const_mem_fun_ref_t(void (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp& __r) const
      { (__r.*_M_f)(); }
    private:
      void (_Tp::*_M_f)() const;
    };


  template <class _Tp, class _Arg>
    class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*, _Arg, void>
    {
    public:
      explicit
      mem_fun1_t(void (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      void
      operator()(_Tp* __p, _Arg __x) const
      { (__p->*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg);
    };


  template <class _Tp, class _Arg>
    class const_mem_fun1_t<void, _Tp, _Arg>
    : public binary_function<const _Tp*, _Arg, void>
    {
    public:
      explicit
      const_mem_fun1_t(void (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp* __p, _Arg __x) const
      { (__p->*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg) const;
    };


  template <class _Tp, class _Arg>
    class mem_fun1_ref_t<void, _Tp, _Arg>
    : public binary_function<_Tp, _Arg, void>
    {
    public:
      explicit
      mem_fun1_ref_t(void (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      void
      operator()(_Tp& __r, _Arg __x) const
      { (__r.*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg);
    };


  template <class _Tp, class _Arg>
    class const_mem_fun1_ref_t<void, _Tp, _Arg>
    : public binary_function<_Tp, _Arg, void>
    {
    public:
      explicit
      const_mem_fun1_ref_t(void (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      void
      operator()(const _Tp& __r, _Arg __x) const
      { (__r.*_M_f)(__x); }
    private:
      void (_Tp::*_M_f)(_Arg) const;
    };



  template <class _Ret, class _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}
# 52 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/string" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 1 3
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
       
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/atomicity.h" 1 3
# 38 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/atomicity.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/atomic_word.h" 1 3
# 33 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/atomicity.h" 2 3

namespace __gnu_cxx
{
  _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add(volatile _Atomic_word* __mem, int __val);

  void
  __attribute__ ((__unused__))
  __atomic_add(volatile _Atomic_word* __mem, int __val);
}
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 2 3


namespace std
{
# 109 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {

    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _Alloc::size_type size_type;
      typedef typename _Alloc::difference_type difference_type;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 144 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 169 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        { return *reinterpret_cast<_Rep*>(&_S_empty_rep_storage); }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {
   this->_M_set_sharable();
   this->_M_length = __n;
   this->_M_refdata()[__n] = _S_terminal;

 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     if (__gnu_cxx::__exchange_and_add(&this->_M_refcount, -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      inline
      basic_string();




      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 442 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());







      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 497 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }






      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 608 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 621 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }





      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 650 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }




      bool
      empty() const
      { return this->size() == 0; }
# 678 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 695 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {
 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 713 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 732 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }






      basic_string&
      append(const basic_string& __str);
# 792 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 824 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 835 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 874 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 890 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 902 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 918 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 930 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 947 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 962 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 978 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1000 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1023 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1041 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1064 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1081 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return this->_M_ibegin() + __pos;
      }
# 1105 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1121 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {
 ;

 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return _M_ibegin() + __pos;
      }
# 1141 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 ;

        const size_type __pos = __first - _M_ibegin();
 _M_mutate(__pos, __last - __first, size_type(0));
 _M_rep()->_M_set_leaked();
 return _M_ibegin() + __pos;
      }
# 1168 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1190 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1214 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1233 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1256 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1274 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1292 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
 ;

 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1313 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1334 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
 ;

 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1356 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
   ;

   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }

      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __true_type)
 { return _S_construct(static_cast<size_type>(__beg),
         static_cast<value_type>(__end), __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1487 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1497 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1507 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1539 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1552 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1566 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1583 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1596 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1611 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1624 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1641 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1654 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1669 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1682 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1701 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1715 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1730 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1743 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1762 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1776 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 1791 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 1805 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 1822 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 1835 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 1851 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 1864 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 1881 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 1896 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 1912 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = __size - __osize;
 return __r;
      }
# 1940 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 1962 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 1977 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 1997 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2020 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()

    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
# 2041 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2112 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2149 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) != 0; }
# 2186 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2223 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2260 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2297 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2334 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2351 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);
# 2365 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str);
# 2383 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2400 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);

}
# 53 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/string" 2 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/algorithm" 1 3
# 63 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/algorithm" 3
       
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/algorithm" 3




# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 1 3
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_heap.h" 1 3
# 65 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_heap.h" 3
namespace std
{



  template<typename _RandomAccessIterator, typename _Distance>
    bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator, typename _Distance,
           typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _StrictWeakOrdering __comp,
       _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _StrictWeakOrdering __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }



  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 139 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;


      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
     typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 187 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;

      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value);
    }

  template<typename _RandomAccessIterator, typename _Tp>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value);
    }
# 251 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value, __comp);
    }
# 317 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;

      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)), __comp);
    }
# 342 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 382 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)), __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 420 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;


      while (__last - __first > 1)
 std::pop_heap(__first, __last--);
    }
# 446 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      while (__last - __first > 1)
 std::pop_heap(__first, __last--, __comp);
    }

}
# 65 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_tempbuf.h" 1 3
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_tempbuf.h" 3
namespace std
{







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

 public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

      void
      _M_initialize_buffer(const _Tp&, __true_type) { }

      void
      _M_initialize_buffer(const _Tp& val, __false_type)
      { std::uninitialized_fill_n(_M_buffer, _M_len, val); }

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {

      typedef typename std::__is_scalar<_Tp>::__type _Trivial;

      try
 {
   pair<pointer, size_type> __p(get_temporary_buffer<
           value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_len > 0)
     _M_initialize_buffer(*__first, _Trivial());
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }
}
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 2 3




namespace std
{
# 84 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {

     
      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
# 118 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {

     
      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }
# 150 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for ( ; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }






  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }






  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(*__first))
 ++__first;
      return __first;
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    find(_RandomAccessIterator __first, _RandomAccessIterator __last,
  const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }






  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
# 304 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::find(__first, __last, __val,
         std::__iterator_category(__first));
    }
# 326 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;
      return std::find_if(__first, __last, __pred,
     std::__iterator_category(__first));
    }
# 348 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 379 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 410 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

     
      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 435 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 474 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 545 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 {
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   while (__first1 != __last1)
     {
       if (__predicate(*__first1, *__first2))
  break;
       ++__first1;
     }
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 623 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

     
      ;

      if (__count <= 0)
 return __first;
      else
 {
   __first = std::find(__first, __last, __val);
   while (__first != __last)
     {
       typename iterator_traits<_ForwardIterator>::difference_type
  __n = __count;
       _ForwardIterator __i = __first;
       ++__i;
       while (__i != __last && __n != 1 && *__i == __val)
  {
    ++__i;
    --__n;
  }
       if (__n == 1)
  return __first;
       else
  __first = std::find(__i, __last, __val);
     }
   return __last;
 }
    }
# 675 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      else
 {
   while (__first != __last)
     {
       if (__binary_pred(*__first, __val))
  break;
       ++__first;
     }
   while (__first != __last)
     {
       typename iterator_traits<_ForwardIterator>::difference_type
  __n = __count;
       _ForwardIterator __i = __first;
       ++__i;
       while (__i != __last && __n != 1 && __binary_pred(*__i, __val))
  {
    ++__i;
    --__n;
  }
       if (__n == 1)
  return __first;
       else
  {
    while (__i != __last)
      {
        if (__binary_pred(*__i, __val))
   break;
        ++__i;
      }
    __first = __i;
  }
     }
   return __last;
 }
    }
# 737 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

     


     


      ;

      for ( ; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 775 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 810 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 842 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for ( ; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 873 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 906 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = *__first == __old_value ? __new_value : *__first;
      return __result;
    }
# 939 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = __pred(*__first) ? __new_value : *__first;
      return __result;
    }
# 970 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for ( ; __first != __last; ++__first)
 *__first = __gen();
    }
# 996 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for ( ; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 1023 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1059 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for ( ; __first != __last; ++__first)
 if (!__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1098 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      __first = std::find(__first, __last, __value);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy(++__i, __last,
        __first, __value);
    }
# 1133 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      __first = std::find_if(__first, __last, __pred);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy_if(++__i, __last,
           __first, __pred);
    }
# 1159 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1184 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }
# 1206 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    _BinaryPredicate __binary_pred,
    output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!__binary_pred(__value, *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1238 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    _BinaryPredicate __binary_pred,
    forward_iterator_tag)
    {

     



      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(*__result, *__first)) *++__result = *__first;
      return ++__result;
    }
# 1270 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      typedef typename iterator_traits<_OutputIterator>::iterator_category
 _IterType;

      if (__first == __last) return __result;
      return std::__unique_copy(__first, __last, __result, _IterType());
    }
# 1305 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      typedef typename iterator_traits<_OutputIterator>::iterator_category
 _IterType;

      if (__first == __last) return __result;
      return std::__unique_copy(__first, __last, __result,
    __binary_pred, _IterType());
    }
# 1339 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1378 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {

     

     


      ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(*__dest, *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1412 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }
# 1434 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1461 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1487 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
        _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }
# 1515 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }






  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }






  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   swap(*__first, *--__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }






  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;

      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      const _Distance __d = __gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++)
 {
   const _ValueType __tmp = *__first;
   _RandomAccessIterator __p = __first;

   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = *(__p - __l);
        __p -= __l;
      }

    *__p = *(__p + __k);
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = *(__p + __k);
        __p += __k;
      }
    *__p = * (__p - __l);
    __p -= __l;
  }
     }

   *__p = __tmp;
   ++__first;
 }
    }
# 1694 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1727 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle, copy(__middle, __last, __result));
    }
# 1752 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 1779 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }







  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred,
  forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     swap(*__first, *__next);
     ++__first;
   }

      return __first;
    }






  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred,
  bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!__pred(*__last))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1873 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }







  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }






  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for ( ; __first != __last ; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 1984 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(), __buf.size());
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }







  enum { _S_threshold = 16 };






  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }






  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }






  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }






  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 1; __n >>= 1)
 ++__k;
      return __k;
    }
# 2273 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i));
      std::sort_heap(__first, __middle);
    }
# 2314 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i), __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 2356 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     
     
      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2420 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     

      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }






  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }






  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }
# 2555 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last, __lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 2589 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last, __lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 2622 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






     
     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2677 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2724 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;



     
     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2776 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }






  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2974 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 3032 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size, __first + __step_size, __last,
   __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge(__first, __first + __step_size,
   __first + __step_size, __last,
   __result,
   __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }






  template<typename _BidirectionalIterator, typename _Distance, typename _Pointer,
    typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }
# 3452 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     
      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3506 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     

      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }
# 3615 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     
      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType>
 buf(__first, __last);
      if (buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, buf.begin(),
        _DistanceType(buf.size()));
    }
# 3656 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     


      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> buf(__first, __last);
      if (buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, buf.begin(),
        _DistanceType(buf.size()), __comp);
    }
# 3697 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    nth_element(_RandomAccessIterator __first,
  _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      while (__last - __first > 3)
 {
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }
# 3748 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    nth_element(_RandomAccessIterator __first,
  _RandomAccessIterator __nth,
  _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      while (__last - __first > 3)
 {
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
             __comp)), __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 3801 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;



     
     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 3863 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     

      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 3921 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {


     
     

     
      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 3953 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {

     
     

     

      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !__comp(__val, *__i);
    }
# 3991 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4037 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
    {

     
     
     


     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4083 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4145 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4206 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4260 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4314 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4372 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4426 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {

     
     
     

     


     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4487 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {

     
     
     


     

     


      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4540 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 4567 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first)) __result = __first;
      return __result;
    }







  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 4619 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 4654 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4710 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*__i, *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4765 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4821 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*--__j, *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 4880 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4916 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4946 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 5096 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 5141 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }

}
# 69 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/algorithm" 2 3
# 56 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/string" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.tcc" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.tcc" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.tcc" 3

namespace std
{
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__builtin_expect(__is_null_pointer(__beg) && __beg != __end, 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 558 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos + __n <= __size)
 {
   const _CharT* __data = _M_data();
   const _CharT* __p = std::search(__data + __pos, __data + __size,
       __s, __s + __n, traits_type::eq);
   if (__p != __data + __size || __n == 0)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = __n - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = __n1 - __n2;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = __size - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = __n1 - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = __n1 - __n2;
      return __r;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);


}
# 57 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/string" 2 3
# 13 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Component.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/user.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/select_compiler_config.hpp" 1 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/compiler/gcc.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/select_stdlib_config.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/select_stdlib_config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/no_tr1/utility.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/no_tr1/utility.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/utility" 1 3
# 63 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/utility" 3
       
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/utility" 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_relops.h" 1 3
# 74 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_relops.h" 3
namespace std
{
  namespace rel_ops
  {
# 90 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 103 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 116 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 129 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  }
}
# 67 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/utility" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/no_tr1/utility.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/select_stdlib_config.hpp" 2 3
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/stdlib/libstdcpp3.hpp" 1 3
# 45 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/select_platform_config.hpp" 1 3
# 50 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/platform/macos.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/platform/macos.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/posix_features.hpp" 1 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/platform/macos.hpp" 2 3
# 54 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/suffix.hpp" 1 3
# 443 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/suffix.hpp" 3
namespace boost{

   __extension__ typedef long long long_long_type;
   __extension__ typedef unsigned long long ulong_long_type;




}
# 58 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 2 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/no_tr1/memory.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/checked_delete.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/checked_delete.hpp" 3
namespace boost
{



template<class T> inline void checked_delete(T * x)
{

    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete x;
}

template<class T> inline void checked_array_delete(T * x)
{
    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete [] x;
}

template<class T> struct checked_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {

        boost::checked_delete(x);
    }
};

template<class T> struct checked_array_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {
        boost::checked_array_delete(x);
    }
};

}
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/throw_exception.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/throw_exception.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/workaround.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/throw_exception.hpp" 2 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/throw_exception.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/enable_current_exception.hpp" 1 3
# 9 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/enable_current_exception.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/exception.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/exception.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/detail/counted_base.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/detail/counted_base.hpp" 3
namespace
boost
    {
    namespace
    exception_detail
        {
        class
        counted_base
            {
            friend
            void
            intrusive_ptr_add_ref( counted_base const * c )
                {
                c->add_ref();
                }

            friend
            void
            intrusive_ptr_release( counted_base const * c )
                {
                c->release();
                }

            virtual void add_ref() const=0;
            virtual void release() const=0;

            protected:


virtual

            ~counted_base() throw()
                {
                }
            };
        }
    }
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/exception.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_convertible.hpp" 1 3
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_convertible.hpp" 3
namespace boost
{

namespace detail
{

template< class Y, class T > struct sp_convertible
{
    typedef char (&yes) [1];
    typedef char (&no) [2];

    static yes f( T* );
    static no f( ... );

    enum _vt { value = sizeof( f( (Y*)0 ) ) == sizeof(yes) };
};

struct sp_empty
{
};

template< bool > struct sp_enable_if_convertible_impl;

template<> struct sp_enable_if_convertible_impl<true>
{
    typedef sp_empty type;
};

template<> struct sp_enable_if_convertible_impl<false>
{
};

template< class Y, class T > struct sp_enable_if_convertible: public sp_enable_if_convertible_impl< sp_convertible< Y, T >::value >
{
};

}

}
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/no_tr1/functional.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/no_tr1/functional.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/functional" 1 3
# 51 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/functional" 3
       
# 52 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/functional" 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/no_tr1/functional.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp" 2 3
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp" 3
namespace boost
{
# 56 "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp" 3
template<class T> class intrusive_ptr
{
private:

    typedef intrusive_ptr this_type;

public:

    typedef T element_type;

    intrusive_ptr(): p_(0)
    {
    }

    intrusive_ptr(T * p, bool add_ref = true): p_(p)
    {
        if(p_ != 0 && add_ref) intrusive_ptr_add_ref(p_);
    }



    template<class U>


    intrusive_ptr( intrusive_ptr<U> const & rhs, typename detail::sp_enable_if_convertible<U,T>::type = detail::sp_empty() )






    : p_( rhs.get() )
    {
        if( p_ != 0 ) intrusive_ptr_add_ref( p_ );
    }



    intrusive_ptr(intrusive_ptr const & rhs): p_(rhs.p_)
    {
        if(p_ != 0) intrusive_ptr_add_ref(p_);
    }

    ~intrusive_ptr()
    {
        if(p_ != 0) intrusive_ptr_release(p_);
    }



    template<class U> intrusive_ptr & operator=(intrusive_ptr<U> const & rhs)
    {
        this_type(rhs).swap(*this);
        return *this;
    }



    intrusive_ptr & operator=(intrusive_ptr const & rhs)
    {
        this_type(rhs).swap(*this);
        return *this;
    }

    intrusive_ptr & operator=(T * rhs)
    {
        this_type(rhs).swap(*this);
        return *this;
    }

    void reset()
    {
        this_type().swap( *this );
    }

    void reset( T * rhs )
    {
        this_type( rhs ).swap( *this );
    }

    T * get() const
    {
        return p_;
    }

    T & operator*() const
    {
        (__builtin_expect(!(p_ != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp", 143, "p_ != 0") : (void)0);
        return *p_;
    }

    T * operator->() const
    {
        (__builtin_expect(!(p_ != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp", 149, "p_ != 0") : (void)0);
        return p_;
    }
# 170 "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp" 3
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type () const
    {
        return p_ == 0? 0: &this_type::p_;
    }




    bool operator! () const
    {
        return p_ == 0;
    }

    void swap(intrusive_ptr & rhs)
    {
        T * tmp = p_;
        p_ = rhs.p_;
        rhs.p_ = tmp;
    }

private:

    T * p_;
};

template<class T, class U> inline bool operator==(intrusive_ptr<T> const & a, intrusive_ptr<U> const & b)
{
    return a.get() == b.get();
}

template<class T, class U> inline bool operator!=(intrusive_ptr<T> const & a, intrusive_ptr<U> const & b)
{
    return a.get() != b.get();
}

template<class T, class U> inline bool operator==(intrusive_ptr<T> const & a, U * b)
{
    return a.get() == b;
}

template<class T, class U> inline bool operator!=(intrusive_ptr<T> const & a, U * b)
{
    return a.get() != b;
}

template<class T, class U> inline bool operator==(T * a, intrusive_ptr<U> const & b)
{
    return a == b.get();
}

template<class T, class U> inline bool operator!=(T * a, intrusive_ptr<U> const & b)
{
    return a != b.get();
}
# 238 "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp" 3
template<class T> inline bool operator<(intrusive_ptr<T> const & a, intrusive_ptr<T> const & b)
{
    return std::less<T *>()(a.get(), b.get());
}

template<class T> void swap(intrusive_ptr<T> & lhs, intrusive_ptr<T> & rhs)
{
    lhs.swap(rhs);
}



template<class T> T * get_pointer(intrusive_ptr<T> const & p)
{
    return p.get();
}

template<class T, class U> intrusive_ptr<T> static_pointer_cast(intrusive_ptr<U> const & p)
{
    return static_cast<T *>(p.get());
}

template<class T, class U> intrusive_ptr<T> const_pointer_cast(intrusive_ptr<U> const & p)
{
    return const_cast<T *>(p.get());
}

template<class T, class U> intrusive_ptr<T> dynamic_pointer_cast(intrusive_ptr<U> const & p)
{
    return dynamic_cast<T *>(p.get());
}
# 292 "/Library/Application Support/MonkeyWorks/Developer/include/boost/intrusive_ptr.hpp" 3
template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, intrusive_ptr<Y> const & p)

{
    os << p.get();
    return os;
}







}
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/exception.hpp" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/typeinfo" 1 3
# 40 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/typeinfo" 3
#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 59 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);

  protected:
    const char *__name;

  protected:
    explicit type_info(const char *__n): __name(__n) { }

  public:



    const char* name() const
    { return __name; }
# 105 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/typeinfo" 3
    bool before(const type_info& __arg) const
    { return __name < __arg.__name; }
    bool operator==(const type_info& __arg) const
    { return __name == __arg.__name; }

    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


  public:

    virtual bool __is_pointer_p() const;

    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;
  };






  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }


    virtual ~bad_cast() throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }


    virtual ~bad_typeid() throw();
  };
}

#pragma GCC visibility pop

}
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/exception.hpp" 2 3

namespace
boost
    {
    template <class T>
    class shared_ptr;

    namespace
    exception_detail
        {
        class error_info_base;

        struct
        error_info_container:
            public exception_detail::counted_base
            {
            virtual char const * diagnostic_information( char const *, std::type_info const & ) const = 0;
            virtual shared_ptr<error_info_base const> get( std::type_info const & ) const = 0;
            virtual void set( shared_ptr<error_info_base const> const & ) = 0;
            };
        }

    template <class Tag,class T>
    class error_info;

    template <class E,class Tag,class T>
    E const & operator<<( E const &, error_info<Tag,T> const & );

    template <class ErrorInfo,class E>
    shared_ptr<typename ErrorInfo::value_type const> get_error_info( E const & );

    class
    exception
        {
        public:

        virtual
        char const *
        diagnostic_information() const throw()
            {
            return _diagnostic_information(0);
            }

        protected:

        exception()
            {
            }

        exception( exception const & e ):
            data_(e.data_)
            {
            }

        char const *
        _diagnostic_information( char const * std_what ) const throw()
            {
            if( data_ )
                try
                    {
                    char const * w = data_->diagnostic_information(std_what,typeid(*this));
                    (__builtin_expect(!(0!=w), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/exception.hpp", 75, "0!=w") : (void)0);
                    return w;
                    }
                catch(...)
                    {
                    }
            return std_what ? std_what : typeid(*this).name();
            }







        virtual

        ~exception() throw()
            {
            }


        private:

        shared_ptr<exception_detail::error_info_base const> get( std::type_info const & ) const;
        void set( shared_ptr<exception_detail::error_info_base const> const & ) const;

        template <class E,class Tag,class T>
        friend E const & operator<<( E const &, error_info<Tag,T> const & );

        template <class ErrorInfo,class E>
        friend shared_ptr<typename ErrorInfo::value_type const> get_error_info( E const & );

        intrusive_ptr<exception_detail::error_info_container> mutable data_;
        };
# 118 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/exception.hpp" 3
    }
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/enable_current_exception.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/detail/cloning_base.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/detail/cloning_base.hpp" 3
namespace
boost
    {
    namespace
    exception_detail
        {
        class clone_base;

        class
        cloning_base
            {
            public:

            virtual clone_base const * clone() const = 0;

            protected:


virtual

            ~cloning_base() throw()
                {
                }
            };
        }
    }
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/enable_current_exception.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/atomic_count.hpp" 1 3
# 98 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/atomic_count.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/atomic_count_gcc_x86.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/atomic_count_gcc_x86.hpp" 3
namespace boost
{

namespace detail
{

class atomic_count
{
public:

    explicit atomic_count( long v ) : value_( static_cast< int >( v ) ) {}

    void operator++()
    {
        __asm__
        (
            "lock\n\t"
            "incl %0":
            "+m"( value_ ):
            :
            "cc"
        );
    }

    long operator--()
    {
        return atomic_exchange_and_add( &value_, -1 ) - 1;
    }

    operator long() const
    {
        return atomic_exchange_and_add( &value_, 0 );
    }

private:

    atomic_count(atomic_count const &);
    atomic_count & operator=(atomic_count const &);

    mutable int value_;

private:

    static int atomic_exchange_and_add( int * pw, int dv )
    {




        int r;

        __asm__ __volatile__
        (
            "lock\n\t"
            "xadd %1, %0":
            "+m"( *pw ), "=r"( r ):
            "1"( dv ):
            "memory", "cc"
        );

        return r;
    }
};

}

}
# 99 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/atomic_count.hpp" 2 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/enable_current_exception.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/enable_current_exception.hpp" 2 3


namespace
boost
    {
    namespace
    exception_detail
        {
        class
        clone_base:
            public counted_base
            {
            public:

            virtual void rethrow() const=0;
            };

        struct
        bad_alloc_impl:
            public clone_base,
            public std::bad_alloc
            {
            void
            add_ref() const
                {
                }

            void
            release() const
                {
                }

            void
            rethrow() const
                {
                throw *this;
                }
            };

        template <class T>
        clone_base * make_clone( T const & );

        template <class T>
        class
        clone_impl:
            public T,
            public cloning_base
            {
            public:

            explicit
            clone_impl( T const & x ):
                T(x)
                {
                if( boost::exception * be1=dynamic_cast<boost::exception *>(this) )
                    if( boost::exception const * be2=dynamic_cast<boost::exception const *>(&x) )
                        *be1 = *be2;
                }

            private:

            clone_base const *
            clone() const
                {
                return make_clone<T>(*this);
                }
            };

        template <class T>
        class
        exception_clone:
            public T,
            public clone_base
            {
            public:

            explicit
            exception_clone( T const & x ):
                T(x),
                count_(0)
                {
                if( boost::exception * be1=dynamic_cast<boost::exception *>(this) )
                    if( boost::exception const * be2=dynamic_cast<boost::exception const *>(&x) )
                        *be1 = *be2;
                }

            private:

            detail::atomic_count mutable count_;

            void
            add_ref() const
                {
                ++count_;
                }

            void
            release() const
                {
                if( !--count_ )
                    delete this;
                }

            void
            rethrow() const
                {
                throw clone_impl<T>(*this);
                }
            };

        template <class T>
        inline
        clone_base *
        make_clone( T const & x )
            {
            try
                {
                return new exception_clone<T>(x);
                }
            catch(
            std::bad_alloc & )
                {
                static bad_alloc_impl bad_alloc;
                return &bad_alloc;
                }
            catch(
            ... )
                {
                (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/enable_current_exception.hpp", 141, "0") : (void)0);
                return 0;
                }
            }
        }

    template <class T>
    inline
    exception_detail::clone_impl<T>
    enable_current_exception( T const & x )
        {
        return exception_detail::clone_impl<T>(x);
        }
    }
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/throw_exception.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/enable_error_info.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/enable_error_info.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stddef.h" 1 3 4
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/enable_error_info.hpp" 2 3

namespace
boost
    {
    namespace
    exception_detail
        {
        template <class T>
        struct
        error_info_injector:
            public T,
            public exception
            {
            explicit
            error_info_injector( T const & x ):
                T(x)
                {
                }

            ~error_info_injector() throw()
                {
                }

            char const *
            diagnostic_information() const throw()
                {
                return boost::exception::_diagnostic_information(T::what());
                }
            };

        struct large_size { char c[256]; };
        large_size dispatch( exception * );

        struct small_size { };
        small_size dispatch( void * );

        template <class,size_t>
        struct enable_error_info_helper;

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(large_size)>
            {
            typedef T type;
            };

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(small_size)>
            {
            typedef error_info_injector<T> type;
            };
# 81 "/Library/Application Support/MonkeyWorks/Developer/include/boost/exception/enable_error_info.hpp" 3
        template <class T>
        struct
        enable_error_info_return_type
            {
            typedef typename enable_error_info_helper<T,sizeof(dispatch((T*)0))>::type type;
            };

        }

    template <class T>
    inline

    typename

    exception_detail::enable_error_info_return_type<T>::type
    enable_error_info( T const & x )
        {
        return

        typename

        exception_detail::enable_error_info_return_type<T>::type(x);
        }
    }
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/throw_exception.hpp" 2 3


namespace boost
{







inline void throw_exception_assert_compatibility( std::exception const & ) { }

template<class E> inline void throw_exception( E const & e )
{


    throw_exception_assert_compatibility(e);


    throw enable_current_exception(enable_error_info(e));



}



}
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/shared_count.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/shared_count.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/bad_weak_ptr.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/bad_weak_ptr.hpp" 3
namespace boost
{
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/bad_weak_ptr.hpp" 3
class bad_weak_ptr: public std::exception
{
public:

    virtual char const * what() const throw()
    {
        return "tr1::bad_weak_ptr";
    }
};





}
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/shared_count.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_base.hpp" 1 3
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_base.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_base_gcc_x86.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_base_gcc_x86.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_typeinfo.hpp" 1 3
# 59 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_typeinfo.hpp" 3
namespace boost
{

namespace detail
{







typedef std::type_info sp_typeinfo;



}

}
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_base_gcc_x86.hpp" 2 3

namespace boost
{

namespace detail
{

inline int atomic_exchange_and_add( int * pw, int dv )
{




    int r;

    __asm__ __volatile__
    (
        "lock\n\t"
        "xadd %1, %0":
        "=m"( *pw ), "=r"( r ):
        "m"( *pw ), "1"( dv ):
        "memory", "cc"
    );

    return r;
}

inline void atomic_increment( int * pw )
{


    __asm__
    (
        "lock\n\t"
        "incl %0":
        "=m"( *pw ):
        "m"( *pw ):
        "cc"
    );
}

inline int atomic_conditional_increment( int * pw )
{




    int rv, tmp;

    __asm__
    (
        "movl %0, %%eax\n\t"
        "0:\n\t"
        "test %%eax, %%eax\n\t"
        "je 1f\n\t"
        "movl %%eax, %2\n\t"
        "incl %2\n\t"
        "lock\n\t"
        "cmpxchgl %2, %0\n\t"
        "jne 0b\n\t"
        "1:":
        "=m"( *pw ), "=&a"( rv ), "=&r"( tmp ):
        "m"( *pw ):
        "cc"
    );

    return rv;
}

class sp_counted_base
{
private:

    sp_counted_base( sp_counted_base const & );
    sp_counted_base & operator= ( sp_counted_base const & );

    int use_count_;
    int weak_count_;

public:

    sp_counted_base(): use_count_( 1 ), weak_count_( 1 )
    {
    }

    virtual ~sp_counted_base()
    {
    }




    virtual void dispose() = 0;



    virtual void destroy()
    {
        delete this;
    }

    virtual void * get_deleter( sp_typeinfo const & ti ) = 0;

    void add_ref_copy()
    {
        atomic_increment( &use_count_ );
    }

    bool add_ref_lock()
    {
        return atomic_conditional_increment( &use_count_ ) != 0;
    }

    void release()
    {
        if( atomic_exchange_and_add( &use_count_, -1 ) == 1 )
        {
            dispose();
            weak_release();
        }
    }

    void weak_add_ref()
    {
        atomic_increment( &weak_count_ );
    }

    void weak_release()
    {
        if( atomic_exchange_and_add( &weak_count_, -1 ) == 1 )
        {
            destroy();
        }
    }

    long use_count() const
    {
        return static_cast<int const volatile &>( use_count_ );
    }
};

}

}
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_base.hpp" 2 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/shared_count.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_impl.hpp" 1 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_impl.hpp" 3
namespace boost
{
# 50 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_impl.hpp" 3
namespace detail
{

template<class X> class sp_counted_impl_p: public sp_counted_base
{
private:

    X * px_;

    sp_counted_impl_p( sp_counted_impl_p const & );
    sp_counted_impl_p & operator= ( sp_counted_impl_p const & );

    typedef sp_counted_impl_p<X> this_type;

public:

    explicit sp_counted_impl_p( X * px ): px_( px )
    {



    }

    virtual void dispose()
    {



        boost::checked_delete( px_ );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & )
    {
        return 0;
    }
# 113 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_impl.hpp" 3
};
# 122 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_impl.hpp" 3
template<class P, class D> class sp_counted_impl_pd: public sp_counted_base
{
private:

    P ptr;
    D del;

    sp_counted_impl_pd( sp_counted_impl_pd const & );
    sp_counted_impl_pd & operator= ( sp_counted_impl_pd const & );

    typedef sp_counted_impl_pd<P, D> this_type;

public:



    sp_counted_impl_pd( P p, D d ): ptr(p), del(d)
    {
    }

    virtual void dispose()
    {
        del( ptr );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( del ): 0;
    }
# 179 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/sp_counted_impl.hpp" 3
};

template<class P, class D, class A> class sp_counted_impl_pda: public sp_counted_base
{
private:

    P p_;
    D d_;
    A a_;

    sp_counted_impl_pda( sp_counted_impl_pda const & );
    sp_counted_impl_pda & operator= ( sp_counted_impl_pda const & );

    typedef sp_counted_impl_pda<P, D, A> this_type;

public:



    sp_counted_impl_pda( P p, D d, A a ): p_( p ), d_( d ), a_( a )
    {
    }

    virtual void dispose()
    {
        d_( p_ );
    }

    virtual void destroy()
    {
        typedef typename A::template rebind< this_type >::other A2;

        A2 a2( a_ );

        this->~this_type();
        a2.deallocate( this, 1 );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( d_ ): 0;
    }
};





}

}
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/shared_count.hpp" 2 3
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/shared_count.hpp" 3
namespace boost
{

namespace detail
{
# 52 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/shared_count.hpp" 3
struct sp_nothrow_tag {};

class weak_count;

class shared_count
{
private:

    sp_counted_base * pi_;





    friend class weak_count;

public:

    shared_count(): pi_(0)



    {
    }

    template<class Y> explicit shared_count( Y * p ): pi_( 0 )



    {


        try
        {
            pi_ = new sp_counted_impl_p<Y>( p );
        }
        catch(...)
        {
            boost::checked_delete( p );
            throw;
        }
# 105 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/shared_count.hpp" 3
    }




    template<class P, class D> shared_count( P p, D d ): pi_(0)




    {





        try
        {
            pi_ = new sp_counted_impl_pd<P, D>(p, d);
        }
        catch(...)
        {
            d(p);
            throw;
        }
# 142 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/shared_count.hpp" 3
    }

    template<class P, class D, class A> shared_count( P p, D d, A a ): pi_( 0 )



    {
        typedef sp_counted_impl_pda<P, D, A> impl_type;
        typedef typename A::template rebind< impl_type >::other A2;

        A2 a2( a );



        try
        {
            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
            new( static_cast< void* >( pi_ ) ) impl_type( p, d, a );
        }
        catch(...)
        {
            d( p );

            if( pi_ != 0 )
            {
                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
            }

            throw;
        }
# 188 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/shared_count.hpp" 3
    }





    template<class Y>
    explicit shared_count( std::auto_ptr<Y> & r ): pi_( new sp_counted_impl_p<Y>( r.get() ) )



    {
# 209 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/shared_count.hpp" 3
        r.release();
    }



    ~shared_count()
    {
        if( pi_ != 0 ) pi_->release();



    }

    shared_count(shared_count const & r): pi_(r.pi_)



    {
        if( pi_ != 0 ) pi_->add_ref_copy();
    }

    explicit shared_count(weak_count const & r);
    shared_count( weak_count const & r, sp_nothrow_tag );

    shared_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if( tmp != 0 ) tmp->add_ref_copy();
            if( pi_ != 0 ) pi_->release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(shared_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool unique() const
    {
        return use_count() == 1;
    }

    bool empty() const
    {
        return pi_ == 0;
    }

    friend inline bool operator==(shared_count const & a, shared_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(shared_count const & a, shared_count const & b)
    {
        return std::less<sp_counted_base *>()( a.pi_, b.pi_ );
    }

    void * get_deleter( sp_typeinfo const & ti ) const
    {
        return pi_? pi_->get_deleter( ti ): 0;
    }
};


class weak_count
{
private:

    sp_counted_base * pi_;





    friend class shared_count;

public:

    weak_count(): pi_(0)



    {
    }

    weak_count(shared_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }

    weak_count(weak_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }

    ~weak_count()
    {
        if(pi_ != 0) pi_->weak_release();



    }

    weak_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    weak_count & operator= (weak_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(weak_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    friend inline bool operator==(weak_count const & a, weak_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(weak_count const & a, weak_count const & b)
    {
        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
    }
};

inline shared_count::shared_count( weak_count const & r ): pi_( r.pi_ )



{
    if( pi_ == 0 || !pi_->add_ref_lock() )
    {
        boost::throw_exception( boost::bad_weak_ptr() );
    }
}

inline shared_count::shared_count( weak_count const & r, sp_nothrow_tag ): pi_( r.pi_ )



{
    if( pi_ != 0 && !pi_->add_ref_lock() )
    {
        pi_ = 0;
    }
}

}

}
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/spinlock_pool.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/spinlock_pool.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/spinlock.hpp" 1 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/spinlock.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/spinlock_pt.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/spinlock_pt.hpp" 3
namespace boost
{

namespace detail
{

class spinlock
{
public:

    pthread_mutex_t v_;

public:

    bool try_lock()
    {
        return pthread_mutex_trylock( &v_ ) == 0;
    }

    void lock()
    {
        pthread_mutex_lock( &v_ );
    }

    void unlock()
    {
        pthread_mutex_unlock( &v_ );
    }

public:

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( spinlock & sp ): sp_( sp )
        {
            sp.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

}
}
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/spinlock.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/spinlock_pool.hpp" 2 3


namespace boost
{

namespace detail
{

template< int I > class spinlock_pool
{
private:

    static spinlock pool_[ 41 ];

public:

    static spinlock & spinlock_for( void const * pv )
    {
        std::size_t i = reinterpret_cast< std::size_t >( pv ) % 41;
        return pool_[ i ];
    }

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( void const * pv ): sp_( spinlock_for( pv ) )
        {
            sp_.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

template< int I > spinlock spinlock_pool< I >::pool_[ 41 ] =
{
    { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} },
    { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} },
    { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} },
    { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} },
    { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} },
    { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} },
    { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} },
    { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} }, { {0x32AAABA7, {0}} },
    { {0x32AAABA7, {0}} }
};

}
}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/memory_order.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/memory_order.hpp" 3
namespace boost
{

enum memory_order
{
    memory_order_relaxed = 0,
    memory_order_acquire = 1,
    memory_order_release = 2,
    memory_order_acq_rel = 3,
    memory_order_seq_cst = 7
};

}
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 2 3
# 58 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
namespace boost
{

template<class T> class weak_ptr;
template<class T> class enable_shared_from_this;

namespace detail
{

struct static_cast_tag {};
struct const_cast_tag {};
struct dynamic_cast_tag {};
struct polymorphic_cast_tag {};

template<class T> struct shared_ptr_traits
{
    typedef T & reference;
};

template<> struct shared_ptr_traits<void>
{
    typedef void reference;
};



template<> struct shared_ptr_traits<void const>
{
    typedef void reference;
};

template<> struct shared_ptr_traits<void volatile>
{
    typedef void reference;
};

template<> struct shared_ptr_traits<void const volatile>
{
    typedef void reference;
};





template<class T, class Y> void sp_enable_shared_from_this( shared_count const & pn, boost::enable_shared_from_this<T> const * pe, Y const * px )
{
    if(pe != 0) pe->_internal_weak_this._internal_assign(const_cast<Y*>(px), pn);
}
# 128 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
inline void sp_enable_shared_from_this( shared_count const & , ... )
{
}
# 142 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
template< class T, class R > struct sp_enable_if_auto_ptr
{
};

template< class T, class R > struct sp_enable_if_auto_ptr< std::auto_ptr< T >, R >
{
    typedef R type;
};



}
# 164 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
template<class T> class shared_ptr
{
private:


    typedef shared_ptr<T> this_type;

public:

    typedef T element_type;
    typedef T value_type;
    typedef T * pointer;
    typedef typename boost::detail::shared_ptr_traits<T>::reference reference;

    shared_ptr(): px(0), pn()
    {
    }

    template<class Y>
    explicit shared_ptr( Y * p ): px( p ), pn( p )
    {
        boost::detail::sp_enable_shared_from_this( pn, p, p );
    }







    template<class Y, class D> shared_ptr(Y * p, D d): px(p), pn(p, d)
    {
        boost::detail::sp_enable_shared_from_this( pn, p, p );
    }



    template<class Y, class D, class A> shared_ptr( Y * p, D d, A a ): px( p ), pn( p, d, a )
    {
        boost::detail::sp_enable_shared_from_this( pn, p, p );
    }






    shared_ptr & operator=(shared_ptr const & r)
    {
        px = r.px;
        pn = r.pn;
        return *this;
    }



    template<class Y>
    explicit shared_ptr(weak_ptr<Y> const & r): pn(r.pn)
    {

        px = r.px;
    }

    template<class Y>
    shared_ptr( weak_ptr<Y> const & r, boost::detail::sp_nothrow_tag ): px( 0 ), pn( r.pn, boost::detail::sp_nothrow_tag() )
    {
        if( !pn.empty() )
        {
            px = r.px;
        }
    }

    template<class Y>


    shared_ptr( shared_ptr<Y> const & r, typename detail::sp_enable_if_convertible<Y,T>::type = detail::sp_empty() )






    : px( r.px ), pn( r.pn )
    {
    }


    template< class Y >
    shared_ptr( shared_ptr<Y> const & r, T * p ): px( p ), pn( r.pn )
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            pn = boost::detail::shared_count();
        }
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            boost::throw_exception(std::bad_cast());
        }
    }



    template<class Y>
    explicit shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
    {
        Y * tmp = r.get();
        pn = boost::detail::shared_count(r);
        boost::detail::sp_enable_shared_from_this( pn, tmp, tmp );
    }



    template<class Ap>
    shared_ptr( Ap r, typename boost::detail::sp_enable_if_auto_ptr<Ap, int>::type = 0 ): px( r.get() ), pn()
    {
        typename Ap::element_type * tmp = r.get();
        pn = boost::detail::shared_count( r );
        boost::detail::sp_enable_shared_from_this( pn, tmp, tmp );
    }
# 311 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
    template<class Y>
    shared_ptr & operator=(shared_ptr<Y> const & r)
    {
        px = r.px;
        pn = r.pn;
        return *this;
    }





    template<class Y>
    shared_ptr & operator=( std::auto_ptr<Y> & r )
    {
        this_type(r).swap(*this);
        return *this;
    }



    template<class Ap>
    typename boost::detail::sp_enable_if_auto_ptr< Ap, shared_ptr & >::type operator=( Ap r )
    {
        this_type( r ).swap( *this );
        return *this;
    }
# 385 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
    void reset()
    {
        this_type().swap(*this);
    }

    template<class Y> void reset(Y * p)
    {
        (__builtin_expect(!(p == 0 || p != px), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp", 392, "p == 0 || p != px") : (void)0);
        this_type(p).swap(*this);
    }

    template<class Y, class D> void reset( Y * p, D d )
    {
        this_type( p, d ).swap( *this );
    }

    template<class Y, class D, class A> void reset( Y * p, D d, A a )
    {
        this_type( p, d, a ).swap( *this );
    }

    template<class Y> void reset( shared_ptr<Y> const & r, T * p )
    {
        this_type( r, p ).swap( *this );
    }

    reference operator* () const
    {
        (__builtin_expect(!(px != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp", 413, "px != 0") : (void)0);
        return *px;
    }

    T * operator-> () const
    {
        (__builtin_expect(!(px != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp", 419, "px != 0") : (void)0);
        return px;
    }

    T * get() const
    {
        return px;
    }
# 464 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return px == 0? 0: &this_type::px;
    }





    bool operator! () const
    {
        return px == 0;
    }

    bool unique() const
    {
        return pn.unique();
    }

    long use_count() const
    {
        return pn.use_count();
    }

    void swap(shared_ptr<T> & other)
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

    template<class Y> bool _internal_less(shared_ptr<Y> const & rhs) const
    {
        return pn < rhs.pn;
    }

    void * _internal_get_deleter( detail::sp_typeinfo const & ti ) const
    {
        return pn.get_deleter( ti );
    }

    bool _internal_equiv( shared_ptr const & r ) const
    {
        return px == r.px && pn == r.pn;
    }






private:

    template<class Y> friend class shared_ptr;
    template<class Y> friend class weak_ptr;




    T * px;
    boost::detail::shared_count pn;

};

template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() == b.get();
}

template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() != b.get();
}
# 550 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a._internal_less(b);
}

template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b)
{
    a.swap(b);
}

template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::static_cast_tag());
}

template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::const_cast_tag());
}

template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
}



template<class T, class U> shared_ptr<T> shared_static_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::static_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_dynamic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_polymorphic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::polymorphic_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_polymorphic_downcast(shared_ptr<U> const & r)
{
    (__builtin_expect(!(dynamic_cast<T *>(r.get()) == r.get()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp", 594, "dynamic_cast<T *>(r.get()) == r.get()") : (void)0);
    return shared_static_cast<T>(r);
}



template<class T> inline T * get_pointer(shared_ptr<T> const & p)
{
    return p.get();
}
# 627 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)

{
    os << p.get();
    return os;
}
# 657 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_ptr.hpp" 3
template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
{
    return static_cast<D *>(p._internal_get_deleter(typeid(D)));
}







template<class T> inline bool atomic_is_lock_free( shared_ptr<T> const * )
{
    return false;
}

template<class T> shared_ptr<T> atomic_load( shared_ptr<T> const * p )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    return *p;
}

template<class T> inline shared_ptr<T> atomic_load_explicit( shared_ptr<T> const * p, memory_order )
{
    return atomic_load( p );
}

template<class T> void atomic_store( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    p->swap( r );
}

template<class T> inline void atomic_store_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    atomic_store( p, r );
}

template<class T> shared_ptr<T> atomic_exchange( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();
    p->swap( r );
    sp.unlock();

    return r;
}

template<class T> shared_ptr<T> atomic_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    return atomic_exchange( p, r );
}

template<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();

    if( p->_internal_equiv( *v ) )
    {
        p->swap( w );

        sp.unlock();

        return true;
    }
    else
    {
        shared_ptr<T> tmp( *p );

        sp.unlock();

        tmp.swap( *v );
        return false;
    }
}

template<class T> inline bool atomic_compare_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w, memory_order , memory_order )
{
    return atomic_compare_exchange( p, v, w );
}



}
# 14 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Component.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/weak_ptr.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/weak_ptr.hpp" 3
namespace boost
{

template<class T> class weak_ptr
{
private:


    typedef weak_ptr<T> this_type;

public:

    typedef T element_type;

    weak_ptr(): px(0), pn()
    {
    }
# 63 "/Library/Application Support/MonkeyWorks/Developer/include/boost/weak_ptr.hpp" 3
    template<class Y>


    weak_ptr( weak_ptr<Y> const & r, typename detail::sp_enable_if_convertible<Y,T>::type = detail::sp_empty() )






    : pn(r.pn)
    {
        px = r.lock().get();
    }

    template<class Y>


    weak_ptr( shared_ptr<Y> const & r, typename detail::sp_enable_if_convertible<Y,T>::type = detail::sp_empty() )






    : px( r.px ), pn( r.pn )
    {
    }



    template<class Y>
    weak_ptr & operator=(weak_ptr<Y> const & r)
    {
        px = r.lock().get();
        pn = r.pn;
        return *this;
    }

    template<class Y>
    weak_ptr & operator=(shared_ptr<Y> const & r)
    {
        px = r.px;
        pn = r.pn;
        return *this;
    }



    shared_ptr<T> lock() const
    {
        return shared_ptr<element_type>( *this, boost::detail::sp_nothrow_tag() );
    }

    long use_count() const
    {
        return pn.use_count();
    }

    bool expired() const
    {
        return pn.use_count() == 0;
    }

    void reset()
    {
        this_type().swap(*this);
    }

    void swap(this_type & other)
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

    void _internal_assign(T * px2, boost::detail::shared_count const & pn2)
    {
        px = px2;
        pn = pn2;
    }

    template<class Y> bool _internal_less(weak_ptr<Y> const & rhs) const
    {
        return pn < rhs.pn;
    }






private:

    template<class Y> friend class weak_ptr;
    template<class Y> friend class shared_ptr;



    T * px;
    boost::detail::weak_count pn;

};

template<class T, class U> inline bool operator<(weak_ptr<T> const & a, weak_ptr<U> const & b)
{
    return a._internal_less(b);
}

template<class T> void swap(weak_ptr<T> & a, weak_ptr<T> & b)
{
    a.swap(b);
}

}
# 15 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Component.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iostream" 1 3
# 41 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iostream" 3
       
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iostream" 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 1 3
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
       
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ios" 1 3
# 41 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ios" 3
       
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ios" 3





# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/localefwd.h" 1 3
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/localefwd.h" 3
       
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/localefwd.h" 3






namespace std
{

  class locale;


  template<typename _CharT>
    inline bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  class __enc_traits;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;


  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ios" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 1 3
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
       
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3



# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 1 3
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
       
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3







namespace std
{
# 67 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 105 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 124 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    locale() throw();
# 133 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 143 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 158 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 171 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 183 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 197 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 212 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 231 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw ();







    inline bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
# 259 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 275 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 310 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    static const size_t _S_categories_size = 6 + 0;


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 343 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 374 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);



    static __c_locale
    _S_get_c_locale();

    static const char*
    _S_get_c_name();

  private:
    inline void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add(&_M_refcount, 1); }

    inline void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch (...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 434 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const;
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    inline void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add(&_M_refcount, 1); }

    inline void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    inline bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = std::strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      inline void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet* __cache, size_t __index) throw()
    {
      __cache->_M_add_reference();
      _M_caches[__index] = __cache;
    }
  };

  template<typename _Facet>
    locale::locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 2 3

namespace std
{




  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 201 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
  class ios_base
  {
  public:



    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 253 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = fmtflags(__ios_flags::_S_boolalpha);


    static const fmtflags dec = fmtflags(__ios_flags::_S_dec);


    static const fmtflags fixed = fmtflags(__ios_flags::_S_fixed);


    static const fmtflags hex = fmtflags(__ios_flags::_S_hex);




    static const fmtflags internal = fmtflags(__ios_flags::_S_internal);



    static const fmtflags left = fmtflags(__ios_flags::_S_left);


    static const fmtflags oct = fmtflags(__ios_flags::_S_oct);



    static const fmtflags right = fmtflags(__ios_flags::_S_right);


    static const fmtflags scientific = fmtflags(__ios_flags::_S_scientific);



    static const fmtflags showbase = fmtflags(__ios_flags::_S_showbase);



    static const fmtflags showpoint = fmtflags(__ios_flags::_S_showpoint);


    static const fmtflags showpos = fmtflags(__ios_flags::_S_showpos);


    static const fmtflags skipws = fmtflags(__ios_flags::_S_skipws);


    static const fmtflags unitbuf = fmtflags(__ios_flags::_S_unitbuf);



    static const fmtflags uppercase = fmtflags(__ios_flags::_S_uppercase);


    static const fmtflags adjustfield = fmtflags(__ios_flags::_S_adjustfield);


    static const fmtflags basefield = fmtflags(__ios_flags::_S_basefield);


    static const fmtflags floatfield = fmtflags(__ios_flags::_S_floatfield);
# 328 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = iostate(__ios_flags::_S_badbit);


    static const iostate eofbit = iostate(__ios_flags::_S_eofbit);




    static const iostate failbit = iostate(__ios_flags::_S_failbit);


    static const iostate goodbit = iostate(0);
# 359 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = openmode(__ios_flags::_S_app);


    static const openmode ate = openmode(__ios_flags::_S_ate);





    static const openmode binary = openmode(__ios_flags::_S_bin);


    static const openmode in = openmode(__ios_flags::_S_in);


    static const openmode out = openmode(__ios_flags::_S_out);


    static const openmode trunc = openmode(__ios_flags::_S_trunc);
# 392 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = seekdir(0);


    static const seekdir cur = seekdir(1);


    static const seekdir end = seekdir(2);


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 418 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 435 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 447 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:






    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    static const int _S_local_word_size = 8;
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    inline fmtflags
    flags() const { return _M_flags; }
# 557 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    inline fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 573 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 590 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    inline void
    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }
# 617 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    inline streamsize
    precision() const { return _M_precision; }






    inline streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    inline streamsize
    width() const { return _M_width; }






    inline streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 666 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 678 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 689 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    inline locale
    getloc() const { return _M_ios_locale; }
# 699 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    inline const locale&
    _M_getloc() const { return _M_ios_locale; }
# 717 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 733 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    inline long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 754 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    inline void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 771 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }
}
# 49 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ios" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 1 3
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
       
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3






namespace std
{





  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout);
# 121 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
# 144 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs<>(__streambuf_type* __sbin,
     __streambuf_type* __sbout);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
# 173 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;






      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 201 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 218 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 231 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 258 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 272 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 290 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 312 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 331 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 345 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 370 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 397 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 423 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 437 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 455 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 471 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 482 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 502 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 518 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 528 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 549 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 564 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 575 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 587 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 600 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual int
      sync() { return 0; }
# 622 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 638 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 660 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 673 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 697 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 715 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 740 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 769 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 3
    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs(basic_streambuf<char>* __sbin,
        basic_streambuf<char>* __sbout);

  template<>
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>* __sbin,
        basic_streambuf<wchar_t>* __sbout);

}


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/streambuf.tcc" 1 3
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/streambuf.tcc" 3
       
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/streambuf.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const size_t __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const size_t __remaining = __n - __ret;
       const size_t __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const size_t __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const size_t __remaining = __n - __ret;
       const size_t __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      streamsize __ret = 0;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     break;
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*, basic_streambuf<char>*);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*, basic_streambuf<wchar_t>*);


}
# 798 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/streambuf" 2 3
# 50 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ios" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 1 3
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
       
# 40 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/streambuf_iterator.h" 1 3
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/streambuf_iterator.h" 3
       
# 40 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/streambuf_iterator.h" 3






namespace std
{


  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {
 ;


 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {
 ;



 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      {
 const bool __thiseof = _M_at_eof();
 const bool __beof = __b._M_at_eof();
 return (__thiseof && __beof || (!__thiseof && !__beof));
      }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };
}
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 2 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 1 3
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
       
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwctype" 1 3
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwctype" 3
       
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwctype" 3




# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/wctype.h" 1 3 4
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/wctype.h" 3 4
typedef __darwin_wctrans_t wctrans_t;
# 62 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/wctype.h" 3 4
static inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


static inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}

static inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

static inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

static inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

static inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

static inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

static inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
# 130 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/wctype.h" 3 4
extern "C" {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}
# 53 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwctype" 2 3
# 79 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cwctype" 3
namespace std
{
  using ::wint_t;

  using ::wctype_t;
  using ::wctrans_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::iswctype;
  using ::towlower;
  using ::towupper;
  using ::towctrans;
  using ::wctrans;
  using ::wctype;
}
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 2 3




namespace std
{
# 63 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, const streamsize __newlen,
      const streamsize __oldlen, const bool __num);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }




# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/ctype_base.h" 1 3
# 38 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/ctype_base.h" 3
  struct ctype_base
  {

    typedef const int* __to_type;

    typedef unsigned long mask;


    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask xdigit = 0x00010000L;
    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask graph = 0x00000100L | 0x00000400L | 0x00002000L;
    static const mask cntrl = 0x00000200L;
    static const mask punct = 0x00002000L;
    static const mask alnum = 0x00000100L | 0x00000400L;
# 71 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/ctype_base.h" 3
  };
# 133 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 2 3
# 144 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 162 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 179 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 195 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 211 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 225 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 240 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 254 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 269 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 286 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 305 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 324 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 346 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 371 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 390 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 409 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 428 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 446 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 463 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 479 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 496 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 515 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 536 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 558 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 582 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 605 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 674 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 711 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 724 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 737 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 752 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 766 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 780 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 795 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 812 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 828 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 845 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 865 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 892 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 923 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 956 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }

    protected:


      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();







      virtual
      ~ctype();
# 1003 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1020 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1036 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1053 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1073 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1096 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1122 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1148 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:

      void _M_widen_init() const
      {
 char __tmp[sizeof(_M_widen)];
 for (size_t __i = 0; __i < sizeof(_M_widen); ++__i)
   __tmp[__i] = __i;
 do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);

 _M_widen_ok = 1;

 if (memcmp(__tmp, _M_widen, sizeof(_M_widen)))
   _M_widen_ok = 2;
      }




      void _M_narrow_init() const
      {
 char __tmp[sizeof(_M_narrow)];
 for (size_t __i = 0; __i < sizeof(_M_narrow); ++__i)
   __tmp[__i] = __i;
 do_narrow(__tmp, __tmp + sizeof(__tmp), 0, _M_narrow);

 _M_narrow_ok = 1;
 if (memcmp(__tmp, _M_narrow, sizeof(_M_narrow)))
   _M_narrow_ok = 2;
 else
   {


     char __c;
     do_narrow(__tmp, __tmp + 1, 1, &__c);
     if (__c == 1)
       _M_narrow_ok = 2;
   }
      }
    };

  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);
# 1212 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1245 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1256 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const;


      virtual
      ~ctype();
# 1280 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1299 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1317 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1335 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1352 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1369 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1385 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1402 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1422 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
# 1444 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
# 1467 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
# 1493 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype();
    };

  template<>
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale& __loc);



# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/ctype_inline.h" 1 3
# 37 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/ctype_inline.h" 3
  bool
  ctype<char>::
  is(mask __m, char __c) const
  {
    if (_M_table)
      return _M_table[static_cast<unsigned char>(__c)] & __m;
    else
      return __istype(__c, __m);
  }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    if (_M_table)
      while (__low < __high)
 *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    else
      for (;__low < __high; ++__vec, ++__low)
 {

   *__vec = __maskrune (*__low, upper | lower | alpha | digit | xdigit
          | space | print | graph | cntrl | punct | alnum);
# 76 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/ctype_inline.h" 3
 }
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    if (_M_table)
      while (__low < __high
      && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
 ++__low;
    else
      while (__low < __high && !this->is(__m, *__low))
 ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    if (_M_table)
      while (__low < __high
      && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
 ++__low;
    else
      while (__low < __high && this->is(__m, *__low) != 0)
 ++__low;
    return __low;
  }


  inline bool
  ctype<wchar_t>::
  do_is(mask __m, wchar_t __c) const
  {
    return __istype (__c, __m);
  }

  inline const wchar_t*
  ctype<wchar_t>::
  do_is(const wchar_t* __lo, const wchar_t* __hi, mask* __vec) const
  {
    for (; __lo < __hi; ++__vec, ++__lo)
      *__vec = __maskrune (*__lo, upper | lower | alpha | digit | xdigit
      | space | print | graph | cntrl | punct | alnum);
    return __hi;
  }

  inline const wchar_t*
  ctype<wchar_t>::
  do_scan_is(mask __m, const wchar_t* __lo, const wchar_t* __hi) const
  {
    while (__lo < __hi && ! __istype (*__lo, __m))
      ++__lo;
    return __lo;
  }

  inline const wchar_t*
  ctype<wchar_t>::
  do_scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
  {
    while (__lo < __hi && __istype (*__lo, __m))
      ++__lo;
    return __lo;
  }
# 1509 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 2 3


  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef _CharT char_type;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    ctype_byname<char>::ctype_byname(const char*, size_t refs);

  template<>
    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/codecvt.h" 1 3
# 45 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/codecvt.h" 3
       
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/codecvt.h" 3


  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 69 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 117 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 156 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 197 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 238 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };



  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };
# 1534 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 2 3


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1656 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1693 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1707 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1721 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1734 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1765 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1778 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1791 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1808 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1820 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1833 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1846 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1859 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };
# 1925 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1946 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1972 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2008 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2067 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2109 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string& __xtrc) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT& __v) const;
# 2142 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
       unsigned short&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned int&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;

    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2204 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2225 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2243 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2285 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2348 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2373 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2421 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;

    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2465 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 2492 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 2506 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 2523 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 2542 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 2556 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 2585 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 2601 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 2614 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };
# 2674 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(__null), _M_date_era_format(__null), _M_time_format(__null),
      _M_time_era_format(__null), _M_date_time_format(__null),
      _M_date_time_era_format(__null), _M_am(__null), _M_pm(__null),
      _M_am_pm_format(__null), _M_day1(__null), _M_day2(__null), _M_day3(__null),
      _M_day4(__null), _M_day5(__null), _M_day6(__null), _M_day7(__null),
      _M_aday1(__null), _M_aday2(__null), _M_aday3(__null), _M_aday4(__null),
      _M_aday5(__null), _M_aday6(__null), _M_aday7(__null), _M_month01(__null),
      _M_month02(__null), _M_month03(__null), _M_month04(__null), _M_month05(__null),
      _M_month06(__null), _M_month07(__null), _M_month08(__null), _M_month09(__null),
      _M_month10(__null), _M_month11(__null), _M_month12(__null), _M_amonth01(__null),
      _M_amonth02(__null), _M_amonth03(__null), _M_amonth04(__null),
      _M_amonth05(__null), _M_amonth06(__null), _M_amonth07(__null),
      _M_amonth08(__null), _M_amonth09(__null), _M_amonth10(__null),
      _M_amonth11(__null), _M_amonth12(__null), _M_allocated(false)
      { }

      ~__timepunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 2832 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const;

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const;



# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/time_members.h" 1 3
# 37 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/time_members.h" 3
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      char* __tmp = new char[std::strlen(__s) + 1];
      std::strcpy(__tmp, __s);
      _M_name_timepunct = __tmp;
      _M_initialize_timepunct(__cloc);
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }
# 2968 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 2 3
# 2981 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;

      typedef basic_string<_CharT> __string_type;


      static locale::id id;
# 3003 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 3020 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 3044 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 3069 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 3097 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 3126 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 3152 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:

      virtual
      ~time_get() { }
# 3172 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual dateorder
      do_date_order() const;
# 3190 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 3209 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 3228 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 3247 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 3266 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;


      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;



      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };
# 3322 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 3343 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 3362 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 3382 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 3409 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };
# 3447 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(__null), _M_curr_symbol_size(0),
      _M_positive_sign(__null), _M_positive_sign_size(0),
      _M_negative_sign(__null), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }







  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 3568 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(); }
# 3580 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 3595 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(__cloc, __s); }
# 3609 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 3622 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 3651 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 3664 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 3681 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 3698 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 3714 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 3749 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 3771 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 3783 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 3796 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 3809 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 3822 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 3835 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 3849 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 3863 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 3877 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
    const char* __name = __null);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;
# 3968 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 3990 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 4020 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 4050 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 4067 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 4078 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;

      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 4103 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 4124 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 4144 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 4166 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 4194 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 4216 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;

      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;




  struct messages_base
  {
    typedef int catalog;
  };
# 4257 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 4285 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      messages(size_t __refs = 0);
# 4299 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 4312 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 4330 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 4348 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 4359 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 4379 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 4398 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {
# 4455 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~messages_byname()
      { }
    };


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/messages_members.h" 1 3
# 37 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/i686-apple-darwin9/bits/messages_members.h" 3
  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale, const char*, size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char*) const
    { return this->do_open(__s, __loc); }


  template<typename _CharT>
    messages<_CharT>::~messages()
    { _S_destroy_c_locale(_M_c_locale_messages); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }

  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
        const string_type& __dfault) const
    { return __dfault; }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_messages);
     this->_S_create_c_locale(this->_M_c_locale_messages, __s);
   }
     }
# 4492 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 2 3
# 4500 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.h" 3
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }
}
# 45 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 2 3

namespace std
{







  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
# 78 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 122 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 133 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 186 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 207 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 242 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
      _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 280 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 292 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 332 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 346 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 375 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 395 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 415 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const;
# 433 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 3
      char_type
      widen(char __c) const;

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
      _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };
}


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.tcc" 1 3
# 38 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.tcc" 3
       
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    char
    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
    { return __check_facet(_M_ctype).narrow(__c, __dfault); }

  template<typename _CharT, typename _Traits>
    _CharT
    basic_ios<_CharT, _Traits>::widen(char __c) const
    { return __check_facet(_M_ctype).widen(__c); }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 159 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;


}
# 465 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/basic_ios.h" 2 3
# 51 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ios" 2 3
# 45 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 2 3

namespace std
{
# 56 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, _CharT2);

      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, char);

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const _CharT2*);

      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, const char*);

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const char*);
# 103 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 129 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      inline __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&));

      inline __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&));

      inline __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&));
# 166 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      __ostream_type&
      operator<<(long __n);

      __ostream_type&
      operator<<(unsigned long __n);

      __ostream_type&
      operator<<(bool __n);

      __ostream_type&
      operator<<(short __n)
      {
 ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
 if (__fmt & ios_base::oct || __fmt & ios_base::hex)
   return this->operator<<(static_cast<unsigned long>
      (static_cast<unsigned short>(__n)));
 else
   return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned short __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }

      __ostream_type&
      operator<<(int __n)
      {
 ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
 if (__fmt & ios_base::oct || __fmt & ios_base::hex)
   return this->operator<<(static_cast<unsigned long>
      (static_cast<unsigned int>(__n)));
 else
   return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned int __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }


      __ostream_type&
      operator<<(long long __n);

      __ostream_type&
      operator<<(unsigned long long __n);


      __ostream_type&
      operator<<(double __f);

      __ostream_type&
      operator<<(float __f)
      { return this->operator<<(static_cast<double>(__f)); }

      __ostream_type&
      operator<<(long double __f);

      __ostream_type&
      operator<<(const void* __p);
# 247 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 280 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 308 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 321 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      __ostream_type&
      flush();
# 332 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      pos_type
      tellp();
# 343 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 355 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      explicit
      basic_ostream() { }
    };
# 373 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT,_Traits>& _M_os;

    public:
# 392 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      explicit
      sentry(basic_ostream<_CharT,_Traits>& __os);
# 402 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      ~sentry()
      {

 if (_M_os.flags() & ios_base::unitbuf && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 420 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 441 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 481 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 515 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ostream.tcc" 1 3
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ostream.tcc" 3
       
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ostream.tcc" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/locale" 1 3
# 41 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/locale" 3
       
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/locale" 3




# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.tcc" 1 3
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.tcc" 3
       
# 40 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.tcc" 3





namespace std
{
  template<typename _Facet>
    locale
    locale::combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
                       const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 86 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.tcc" 3
  template<typename _Facet>
    inline bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size && __facets[__i]);
    }
# 108 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.tcc" 3
  template<typename _Facet>
    inline const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (!(__i < __loc._M_impl->_M_facets_size && __facets[__i]))
        __throw_bad_cast();
      return static_cast<const _Facet&>(*__facets[__i]);
    }



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = __null;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = _M_grouping_size && __np.grouping()[0] != 0;

      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;

      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;

      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_grouping_size = __mp.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __mp.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = _M_grouping_size && __mp.grouping()[0] != 0;

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      _M_curr_symbol_size = __mp.curr_symbol().size();
      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];
      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
      _M_curr_symbol = __curr_symbol;

      _M_positive_sign_size = __mp.positive_sign().size();
      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];
      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
      _M_positive_sign = __positive_sign;

      _M_negative_sign_size = __mp.negative_sign().size();
      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];
      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
      _M_negative_sign = __negative_sign;

      _M_pos_format = __mp.pos_format();
      _M_neg_format = __mp.neg_format();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(money_base::_S_atoms,
   money_base::_S_atoms + money_base::_S_end, _M_atoms);
    }
# 269 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.tcc" 3
  static bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef typename numpunct<_CharT>::__cache_type __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      while (!__testeof)
 {
   if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      int __sep_pos = 0;
      const char_type* __q;
      const char_type* __lit_zero = __lit + __num_base::_S_izero;
      while (!__testeof)
        {


          if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
     {
       if (!__found_dec && !__found_sci)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __err |= ios_base::failbit;
        break;
      }
  }
       else
  break;
            }
   else if (__c == __lc->_M_decimal_point)
     {
       if (!__found_dec && !__found_sci)
  {



    if (__found_grouping.size())
      __found_grouping += static_cast<char>(__sep_pos);
    __xtrc += '.';
    __found_dec = true;
  }
       else
  break;
     }
          else if ((__q = __traits_type::find(__lit_zero, 10, __c)))
     {
       __xtrc += __num_base::_S_atoms_in[__q - __lit];
       __found_mantissa = true;
       ++__sep_pos;
     }
   else if ((__c == __lit[__num_base::_S_ie]
      || __c == __lit[__num_base::_S_iE])
     && __found_mantissa && !__found_sci)
     {

       if (__found_grouping.size() && !__found_dec)
  __found_grouping += static_cast<char>(__sep_pos);
       __xtrc += 'e';
       __found_sci = true;


       if (++__beg != __end)
  {
    __c = *__beg;
    const bool __plus = __c == __lit[__num_base::_S_iplus];
    if ((__plus || __c == __lit[__num_base::_S_iminus])
        && !(__lc->_M_use_grouping
      && __c == __lc->_M_thousands_sep)
        && !(__c == __lc->_M_decimal_point))
      __xtrc += __plus ? '+' : '-';
    else
      continue;
  }
       else
  {
    __testeof = true;
    break;
  }
     }
   else

     break;

   if (++__beg != __end)
     __c = *__beg;
   else
     __testeof = true;
        }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err |= ios_base::failbit;
        }


      if (__testeof)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 typedef typename numpunct<_CharT>::__cache_type __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     if (numeric_limits<_ValueT>::is_signed)
       __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 while (!__testeof)
   {
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       __found_zero = true;
     else if (__found_zero)
       {
  if (__c == __lit[__num_base::_S_ix]
      || __c == __lit[__num_base::_S_iX])
    {
      if (__basefield == 0)
        __base = 16;
      if (__base == 16)
        __found_zero = false;
      else
        break;
    }
  else
    {
      if (__basefield == 0)
        __base = 8;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 int __sep_pos = 0;
 bool __overflow = false;
 _ValueT __result = 0;
 const char_type* __q;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;
 if (__negative)
   {
     const _ValueT __min = numeric_limits<_ValueT>::min() / __base;
     while (!__testeof)
       {


  if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {
   __err |= ios_base::failbit;
   break;
        }
    }
  else if (__c == __lc->_M_decimal_point)
    break;
  else if ((__q = __traits_type::find(__lit_zero, __len, __c)))
    {
      int __digit = __q - __lit_zero;
      if (__digit > 15)
        __digit -= 6;
      if (__result < __min)
        __overflow = true;
      else
        {
   const _ValueT __new_result = (__result * __base
            - __digit);
   __overflow |= __new_result > __result;
   __result = __new_result;
   ++__sep_pos;
        }
    }
  else

    break;

  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }
 else
   {
     const _ValueT __max = numeric_limits<_ValueT>::max() / __base;
     while (!__testeof)
       {
  if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
    {
      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {
   __err |= ios_base::failbit;
   break;
        }
    }
  else if (__c == __lc->_M_decimal_point)
    break;
  else if ((__q = __traits_type::find(__lit_zero, __len, __c)))
    {
      int __digit = __q - __lit_zero;
      if (__digit > 15)
        __digit -= 6;
      if (__result > __max)
        __overflow = true;
      else
        {
   const _ValueT __new_result = (__result * __base
            + __digit);
   __overflow |= __new_result < __result;
   __result = __new_result;
   ++__sep_pos;
        }
    }
  else
    break;

  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err |= ios_base::failbit;
   }

 if (!(__err & ios_base::failbit) && !__overflow
     && (__sep_pos || __found_zero || __found_grouping.size()))
   __v = __result;
 else
   __err |= ios_base::failbit;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = __l;
   else
            __err |= ios_base::failbit;
        }
      else
        {

   typedef typename numpunct<_CharT>::__cache_type __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   size_t __n;
   bool __testeof = __beg == __end;
          for (__n = 0; !__testeof; ++__n)
            {
       const char_type __c = *__beg;

       if (__testf)
  if (__n < __lc->_M_falsename_size)
    __testf = __c == __lc->_M_falsename[__n];
  else
    break;

       if (__testt)
  if (__n < __lc->_M_truename_size)
    __testt = __c == __lc->_M_truename[__n];
  else
    break;

       if (!__testf && !__testt)
  break;

       if (++__beg == __end)
  __testeof = true;
            }
   if (__testf && __n == __lc->_M_falsename_size)
     __v = 0;
   else if (__testt && __n == __lc->_M_truename_size)
     __v = 1;
   else
     __err |= ios_base::failbit;

          if (__testeof)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags(__fmt & ~ios_base::basefield | ios_base::hex);

      unsigned long __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      if (!(__err & ios_base::failbit))
 __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs,
        __w, __len, true);
      __len = static_cast<int>(__w);
    }


  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    {
      unsigned long __ul = static_cast<unsigned long>(__v);
      bool __neg = false;
      if (__v < 0)
 {
   __ul = -__ul;
   __neg = true;
 }
      return __int_to_char(__bufend, __ul, __lit, __flags, __neg);
    }

  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, unsigned long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    {

      return __int_to_char(__bufend, __v, __lit,
      __flags & ~ios_base::showpos, false);
    }


  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, long long __v, const _CharT* __lit,
    ios_base::fmtflags __flags)
    {
      unsigned long long __ull = static_cast<unsigned long long>(__v);
      bool __neg = false;
      if (__v < 0)
 {
   __ull = -__ull;
   __neg = true;
 }
      return __int_to_char(__bufend, __ull, __lit, __flags, __neg);
    }

  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __bufend, unsigned long long __v,
    const _CharT* __lit, ios_base::fmtflags __flags)
    { return __int_to_char(__bufend, __v, __lit,
      __flags & ~ios_base::showpos, false); }


  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __neg)
    {

      const bool __showbase = (__flags & ios_base::showbase) && __v;
      const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
      _CharT* __buf = __bufend - 1;

      if (__builtin_expect(__basefield != ios_base::oct &&
      __basefield != ios_base::hex, true))
 {

   do
     {
       *__buf-- = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
   if (__neg)
     *__buf-- = __lit[__num_base::_S_ominus];
   else if (__flags & ios_base::showpos)
     *__buf-- = __lit[__num_base::_S_oplus];
 }
      else if (__basefield == ios_base::oct)
 {

   do
     {
       *__buf-- = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
   if (__showbase)
     *__buf-- = __lit[__num_base::_S_odigits];
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *__buf-- = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
   if (__showbase)
     {

       *__buf-- = __lit[__num_base::_S_ox + __uppercase];

       *__buf-- = __lit[__num_base::_S_odigits];
     }
 }
      return __bufend - __buf - 1;
    }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base& __io, _CharT* __new, _CharT* __cs, int& __len) const
    {





      streamsize __off = 0;
      const ios_base::fmtflags __basefield = __io.flags()
                                      & ios_base::basefield;
      if ((__io.flags() & ios_base::showbase) && __len > 1)
 if (__basefield == ios_base::oct)
   {
     __off = 1;
     __new[0] = __cs[0];
   }
 else if (__basefield == ios_base::hex)
   {
     __off = 2;
     __new[0] = __cs[0];
     __new[1] = __cs[1];
   }
      _CharT* __p = std::__add_grouping(__new + __off, __sep, __grouping,
     __grouping_size, __cs + __off,
     __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 typedef typename numpunct<_CharT>::__cache_type __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;


 const int __ilen = 4 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 int __len;
 __len = __int_to_char(__cs + __ilen, __v, __lit, __io.flags());
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2, __cs, __len);
     __cs = __cs2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 1078 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef typename numpunct<_CharT>::__cache_type __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 streamsize __prec = __io.precision();
 if (__prec < static_cast<streamsize>(0))
   __prec = static_cast<streamsize>(6);

 const int __max_digits = numeric_limits<_ValueT>::digits10;


 int __len;

 char __fbuf[16];




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));

 __num_base::_S_format_float(__io, __fbuf, __mod);
 __len = std::__convert_from_v(__cs, __cs_size, __fbuf, __v,
          _S_get_c_locale(), __prec);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(__cs, __cs_size, __fbuf, __v,
       _S_get_c_locale(), __prec);
   }
# 1142 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.tcc" 3
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len));
      __ctype.widen(__cs, __cs + __len, __ws);


      const _CharT __cdec = __ctype.widen('.');
      const _CharT __dec = __lc->_M_decimal_point;
      const _CharT* __p = char_traits<_CharT>::find(__ws, __len, __cdec);
      if (__p)
 __ws[__p - __ws] = __dec;




      if (__lc->_M_use_grouping
   && (__p || __len < 3 || (__cs[1] != 'e' && __cs[2] != 'e'
       && __cs[1] != 'E' && __cs[2] != 'E')))
 {


   _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
        * __len * 2));
   _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __p, __ws2, __ws, __len);
   __ws = __ws2;
 }


      const streamsize __w = __io.width();
      if (__w > static_cast<streamsize>(__len))
 {
   _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
        * __w));
   _M_pad(__fill, __w, __io, __ws3, __ws, __len);
   __ws = __ws3;
 }
      __io.width(0);



      return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef typename numpunct<_CharT>::__cache_type __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       _CharT* __cs
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __w));
       _M_pad(__fill, __w, __io, __cs, __name, __len);
       __name = __cs;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const
    { return _M_insert_int(__s, __b, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase
      | ios_base::internal);
      __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<unsigned long>(__v));
      __io.flags(__flags);
      return __s;
    }

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef moneypunct<_CharT, _Intl> __moneypunct_type;
 typedef typename __moneypunct_type::__cache_type __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || __mandatory_sign
         && (static_cast<part>(__p.field[3])
      == money_base::sign))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __testvalid = false;
       }


     if (__testdecfound && __lc->_M_frac_digits > 0
  && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      if (__intl)
 __beg = _M_extract<true>(__beg, __end, __io, __err, __str);
      else
 __beg = _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __units) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      const iter_type __ret = __intl ? _M_extract<true>(__beg, __end, __io,
       __err, __str)
                              : _M_extract<false>(__beg, __end, __io,
        __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __len));
   __ctype.widen(__str.data(), __str.data() + __len, __ws);
   __units.assign(__ws, __len);
 }

      return __ret;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef moneypunct<_CharT, _Intl> __moneypunct_type;
 typedef typename __moneypunct_type::__cache_type __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (*__beg != __lit[money_base::_S_minus])
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     int __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      _CharT* __ws =
          static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
             * 2 * __len));
        _CharT* __ws_end =
        std::__add_grouping(__ws, __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.assign(__ws, __ws_end - __ws);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(__cs, __cs_size, "%.*Lf", __units,
     _S_get_c_locale(), 0);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(__cs, __cs_size, "%.*Lf", __units,
     _S_get_c_locale(), 0);
 }







      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __cs_size));
      __ctype.widen(__cs, __cs + __len, __ws);
      const string_type __digits(__ws, __len);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }





  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      for (size_t __i = 0; __beg != __end && __i < __len && !__err; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __err);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __err);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __err);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __err);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __err);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __err);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __err);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __err);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __err);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __err);
    if (!__err)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __err);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __err |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,



      __io, __err);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __err |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __err,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

    __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
      __io, __err);
    break;
  case 'Y':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __err);
    if (!__err)
      __tm->tm_year = __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __err);


        if (__beg != __end && !__err && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __err);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __err);
   }
      }
    else
      __err |= ios_base::failbit;
    break;
  default:

    __err |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __err |= ios_base::failbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;
      else
 __err |= ios_base::failbit;
      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg, ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (__name[__pos] != *__beg)
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg, ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7, __io, __err);







      if (!__err && __beg != __end)
 {
   size_t __pos = __traits_type::length(__days[__tmpwday]);
   __tp._M_days(__days);
   const char_type* __name = __days[__tmpwday];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __err |= ios_base::failbit;
     }
 }
      if (!__err)
 __tm->tm_wday = __tmpwday;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12,
         __io, __err);







      if (!__err && __beg != __end)
 {
   size_t __pos = __traits_type::length(__months[__tmpmon]);
   __tp._M_months(__months);
   const char_type* __name = __months[__tmpmon];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __err |= ios_base::failbit;
     }
 }
      if (!__err)
 __tm->tm_mon = __tmpmon;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < 4; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     __value = __value * 10 + (__c - '0');
   else
     break;
 }
      if (__i == 2 || __i == 4)
 __tm->tm_year = __i == 2 ? __value : __value - 1900;
      else
 __err |= ios_base::failbit;
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type* __res =
       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }


  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {

      string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      string_type __ret;




      for (;;)
 {

   _CharT* __c =
     static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __len));
   size_t __res = _M_transform(__c, __p, __len);


   if (__res >= __len)
     {
       __len = __res + 1;
       __c = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __len));
       __res = _M_transform(__c, __p, __len);
     }

   __ret.append(__c, __res);
   __p += char_traits<_CharT>::length(__p);
   if (__p == __pend)
     return __ret;

   __p++;
   __ret.push_back(_CharT());
 }
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val = *__lo + ((__val << 7) |
         (__val >> (numeric_limits<unsigned long>::digits - 7)));
      return static_cast<long>(__val);
    }
# 2432 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       const streamsize __newlen,
       const streamsize __oldlen, const bool __num)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, const_cast<_CharT*>(__olds), __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal && __num)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   const bool __testsign = (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0]);
   const bool __testhex = (__ctype.widen('0') == __olds[0]
      && __oldlen > 1
      && (__ctype.widen('x') == __olds[1]
          || __ctype.widen('X') == __olds[1]));
   if (__testhex)
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }
   else if (__testsign)
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, const_cast<_CharT*>(__olds + __mod),
      __oldlen - __mod);
    }

  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp)
  {
    const size_t __n = __grouping_tmp.size() - 1;
    const size_t __min = std::min(__n, size_t(__grouping_size - 1));
    size_t __i = __n;
    bool __test = true;




    for (size_t __j = 0; __j < __min && __test; --__i, ++__j)
      __test = __grouping_tmp[__i] == __grouping[__j];
    for (; __i && __test; --__i)
      __test = __grouping_tmp[__i] == __grouping[__min];


    __test &= __grouping_tmp[0] <= __grouping[__min];
    return __test;
  }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      if (__last - __first > *__gbeg)
 {
   const bool __bump = __gsize != 1;
   __s = std::__add_grouping(__s, __sep, __gbeg + __bump,
        __gsize - __bump, __first,
        __last - *__gbeg);
   __first = __last - *__gbeg;
   *__s++ = __sep;
 }
      do
 *__s++ = *__first++;
      while (__first != __last);
      return __s;
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;
  extern template class ctype_byname<char>;
  extern template class codecvt_byname<char, char, mbstate_t>;
  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;
  extern template class ctype_byname<wchar_t>;
  extern template class codecvt_byname<wchar_t, char, mbstate_t>;
  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const&);

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);


}
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/locale" 2 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/ostream.tcc" 2 3

namespace std
{
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ostream_type& (*__pf)(__ostream_type&))
    {



      return __pf(*this);
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ios_type& (*__pf)(__ios_type&))
    {



      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(ios_base& (*__pf)(ios_base&))
    {



      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(bool __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       bool __b = false;
       const char_type __c = this->fill();
       const ios_base::fmtflags __fmt = (this->flags()
      & ios_base::basefield);
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
  {
    const unsigned long __l = static_cast<unsigned long>(__n);
    __b = __np.put(*this, *this, __c, __l).failed();
  }
       else
  __b = __np.put(*this, *this, __c, __n).failed();
       if (__b)
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       bool __b = false;
       const char_type __c = this->fill();
       const ios_base::fmtflags __fmt = (this->flags()
      & ios_base::basefield);
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
  {
    const unsigned long long __l = (static_cast<
        unsigned long long>(__n));
    __b = __np.put(*this, *this, __c, __l).failed();
  }
       else
  __b = __np.put(*this, *this, __c, __n).failed();
       if (__b)
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(unsigned long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(long double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(const void* __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_put_type& __np = __check_facet(this->_M_num_put);
       if (__np.put(*this, *this, this->fill(), __n).failed())
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = 1;
       _CharT* __cs = &__c;
       if (__w > __len)
  {
    __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __w));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       &__c, __w, __len, false);
    __len = __w;
  }
       __out._M_write(__cs, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = 1;
       char* __cs = &__c;
       if (__w > __len)
  {
    __cs = static_cast<char*>(__builtin_alloca(__w));
    __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs,
            &__c, __w, __len, false);
    __len = __w;
  }
       __out._M_write(__cs, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
     }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(_Traits::length(__s));
       if (__w > __len)
  {
    _CharT* __cs = (static_cast<
      _CharT*>(__builtin_alloca(sizeof(_CharT)
           * __w)));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __s, __w, __len, false);
    __s = __cs;
    __len = __w;
  }
       __out._M_write(__s, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;



      typedef char_traits<char> __traits_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   size_t __clen = __traits_type::length(__s);
   _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
              * __clen));
   for (size_t __i = 0; __i < __clen; ++__i)
     __ws[__i] = __out.widen(__s[__i]);
   _CharT* __str = __ws;

   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(__clen);
       if (__w > __len)
  {
    _CharT* __cs = (static_cast<
      _CharT*>(__builtin_alloca(sizeof(_CharT)
           * __w)));
    __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __ws, __w, __len, false);
    __str = __cs;
    __len = __w;
  }
       __out._M_write(__str, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
 {
   try
     {
       const streamsize __w = __out.width();
       streamsize __len = static_cast<streamsize>(_Traits::length(__s));
       if (__w > __len)
  {
    char* __cs = static_cast<char*>(__builtin_alloca(__w));
    __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs,
       __s, __w, __len, false);
    __s = __cs;
    __len = __w;
  }
       __out._M_write(__s, __len);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      else if (!__s)
 __out.setstate(ios_base::badbit);
      return __out;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   const streamsize __w = __out.width();
   streamsize __len = static_cast<streamsize>(__str.size());
   const _CharT* __s = __str.data();



   if (__w > __len)
     {
       _CharT* __cs = (static_cast<
         _CharT*>(__builtin_alloca(sizeof(_CharT) * __w)));
       __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs, __s,
          __w, __len, false);
       __s = __cs;
       __len = __w;
     }
   __out._M_write(__s, __len);
   __out.width(0);
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);


}
# 545 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ostream" 2 3
# 45 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iostream" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 1 3
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
       
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3




namespace std
{
# 57 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

    protected:







      streamsize _M_gcount;

    public:
# 103 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb): _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 130 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      inline __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&));

      inline __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&));

      inline __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&));
# 168 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      operator>>(bool& __n);

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n);

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n);

      __istream_type&
      operator>>(long& __n);

      __istream_type&
      operator>>(unsigned long& __n);


      __istream_type&
      operator>>(long long& __n);

      __istream_type&
      operator>>(unsigned long long& __n);


      __istream_type&
      operator>>(float& __f);

      __istream_type&
      operator>>(double& __f);

      __istream_type&
      operator>>(long double& __f);

      __istream_type&
      operator>>(void*& __p);
# 229 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 239 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      inline streamsize
      gcount() const
      { return _M_gcount; }
# 271 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      int_type
      get();
# 285 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      get(char_type& __c);
# 312 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 323 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      inline __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 346 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 356 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      inline __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 385 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 396 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      inline __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 420 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
# 437 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      int_type
      peek();
# 455 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 474 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 490 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      putback(char_type __c);
# 505 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      unget();
# 523 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      int
      sync();
# 537 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      pos_type
      tellg();
# 552 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      seekg(pos_type);
# 568 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      explicit
      basic_istream(): _M_gcount(streamsize(0)) { }
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 621 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 653 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 663 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
      operator bool() const { return _M_ok; }

    private:
      bool _M_ok;
    };
# 682 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 723 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 745 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(), __ostream_type()
      { this->init(__sb); }




      virtual
      ~basic_iostream() { }

    protected:
      explicit
      basic_iostream() : __istream_type(), __ostream_type()
      { }
    };
# 808 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
}


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/istream.tcc" 1 3
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/istream.tcc" 3
       
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/istream.tcc" 3




namespace std
{
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && (__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__istream_type& (*__pf)(__istream_type&))
    { return __pf(*this); }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__ios_type& (*__pf)(__ios_type&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(ios_base& (*__pf)(ios_base&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(bool& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);


       if (!(__err & ios_base::failbit)
    && (numeric_limits<short>::min() <= __l
        && __l <= numeric_limits<short>::max()))
  __n = __l;
       else
                __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);


       if (!(__err & ios_base::failbit)
    && (numeric_limits<int>::min() <= __l
        && __l <= numeric_limits<int>::max()))
  __n = __l;
       else
                __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(float& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(void*& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __n);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       if (!__copy_streambufs(this->rdbuf(), __sbout))
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 692 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == numeric_limits<streamsize>::max()
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount = numeric_limits<streamsize>::min();
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = numeric_limits<streamsize>::max();

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == numeric_limits<streamsize>::max()
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount = numeric_limits<streamsize>::min();
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = numeric_limits<streamsize>::max();

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount < numeric_limits<streamsize>::max())
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = numeric_limits<streamsize>::max();

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT,_Traits>&
    ws(basic_istream<_CharT,_Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename __istream_type::int_type __int_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       __in.width(0);
     }
   catch(...)
     {



       __in._M_setstate(ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __sb->sbumpc();
  }
       else
  __err |= ios_base::failbit;
     }
   catch(...)
     {



       __in._M_setstate(ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<class _CharT, class _Traits, class _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT,_Traits,_Alloc>& __str)
    { return getline(__in, __str, __in.widen('\n')); }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template class basic_iostream<wchar_t>;


}
# 815 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/istream" 2 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iostream" 2 3

namespace std
{
# 62 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;
}
# 16 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Component.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/map" 1 3
# 63 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/map" 3
       
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/map" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_tree.h" 1 3
# 72 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_tree.h" 3
namespace std
{
# 90 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;
    };

  _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x);

  _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x);

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x,
                       _Rb_tree_node_base*& __root);

  void
  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x,
                        _Rb_tree_node_base*& __root);

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header);

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header);


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val> _Rb_tree_node;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node* _Link_type;
      typedef const _Rb_tree_node* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

    protected:
      _Rb_tree_node*
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Rb_tree_node* __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }

      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { get_allocator().construct(&__tmp->_M_value_field, __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }

      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

      void
      destroy_node(_Link_type __p)
      {
 get_allocator().destroy(&__p->_M_value_field);
 _M_put_node(__p);
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = std::__is_pod<_Key_compare>::__value>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
   const _Key_compare& __comp = _Key_compare())
   : _Node_allocator(__a), _M_key_compare(__comp), _M_node_count(0)
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };



      template<typename _Key_compare>
        struct _Rb_tree_impl<_Key_compare, true> : public _Node_allocator
 {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
   const _Key_compare& __comp = _Key_compare())
   : _Node_allocator(__a), _M_key_compare(__comp), _M_node_count(0)
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      iterator
      _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

    public:

      _Rb_tree()
      { }

      _Rb_tree(const _Compare& __comp)
      : _M_impl(allocator_type(), __comp)
      { }

      _Rb_tree(const _Compare& __comp, const allocator_type& __a)
      : _M_impl(__a, __comp)
      { }

      _Rb_tree(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
      : _M_impl(__x.get_allocator(), __x._M_impl._M_key_compare)
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }

      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
      operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_left); }

      const_iterator
      begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_left);
      }

      iterator
      end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      const_iterator
      end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return size_type(-1); }

      void
      swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t);


      pair<iterator,bool>
      insert_unique(const value_type& __x);

      iterator
      insert_equal(const value_type& __x);

      iterator
      insert_unique(iterator __position, const value_type& __x);

      iterator
      insert_equal(iterator __position, const value_type& __x);

      template<typename _InputIterator>
      void
      insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
      void
      insert_equal(_InputIterator __first, _InputIterator __last);

      void
      erase(iterator __position);

      size_type
      erase(const key_type& __x);

      void
      erase(iterator __first, iterator __last);

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __x);

      const_iterator
      find(const key_type& __x) const;

      size_type
      count(const key_type& __x) const;

      iterator
      lower_bound(const key_type& __x);

      const_iterator
      lower_bound(const key_type& __x) const;

      iterator
      upper_bound(const key_type& __x);

      const_iterator
      upper_bound(const key_type& __x) const;

      pair<iterator,iterator>
      equal_range(const key_type& __x);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      _Link_type __z = _M_create_node(__v);
      bool __insert_left;

      __insert_left = (__x != 0 || __p == _M_end()
         || _M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key(__p)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_equal(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
    {
      if (_M_root() == 0)
      {
 if (__t._M_root() != 0)
 {
   _M_root() = __t._M_root();
   _M_leftmost() = __t._M_leftmost();
   _M_rightmost() = __t._M_rightmost();
          _M_root()->_M_parent = _M_end();

   __t._M_root() = 0;
   __t._M_leftmost() = __t._M_end();
   __t._M_rightmost() = __t._M_end();
 }
      }
      else if (__t._M_root() == 0)
      {
 __t._M_root() = _M_root();
 __t._M_leftmost() = _M_leftmost();
 __t._M_rightmost() = _M_rightmost();
        __t._M_root()->_M_parent = __t._M_end();

 _M_root() = 0;
 _M_leftmost() = _M_end();
 _M_rightmost() = _M_end();
      }
      else
      {
 std::swap(_M_root(),__t._M_root());
 std::swap(_M_leftmost(),__t._M_leftmost());
 std::swap(_M_rightmost(),__t._M_rightmost());

 _M_root()->_M_parent = _M_end();
 __t._M_root()->_M_parent = __t._M_end();
      }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_unique(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 if (__j == begin())
   return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
 else
   --__j;
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>(_M_insert(__x, __y, __v), true);
      return pair<iterator, bool>(__j, false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_unique(iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_end()
   || __position._M_node == _M_rightmost())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return insert_unique(__v).first;
 }
      else
 {
   iterator __after = __position;
   ++__after;
   if (_M_impl._M_key_compare(_S_key(__position._M_node),
         _KeyOfValue()(__v))
       && _M_impl._M_key_compare(_KeyOfValue()(__v),
     _S_key(__after._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);

     }
   else
     return insert_unique(__v).first;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_equal(iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_end()
   || __position._M_node == _M_rightmost())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return insert_equal(__v);
 }
      else
 {
   iterator __after = __position;
   ++__after;
   if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node))
       && !_M_impl._M_key_compare(_S_key(__after._M_node),
      _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);

     }
   else
     return insert_equal(__v);
 }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   insert_equal(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
    void
    _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
    insert_unique(_II __first, _II __last)
    {
      for (; __first != __last; ++__first)
 insert_unique(end(), *__first);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (__position._M_node,
     this->_M_impl._M_header));
      destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator,iterator> __p = equal_range(__x);
      size_type __n = std::distance(__p.first, __p.second);
      erase(__p.first, __p.second);
      return __n;
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      iterator __j = iterator(__y);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

     while (__x != 0)
       {
  if (!_M_impl._M_key_compare(_S_key(__x), __k))
    __y = __x, __x = _S_left(__x);
  else
    __x = _S_right(__x);
       }
     const_iterator __j = const_iterator(__y);
     return (__j == end()
      || _M_impl._M_key_compare(__k,
           _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    lower_bound(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    lower_bound(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    upper_bound(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    upper_bound(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    inline
    pair<typename _Rb_tree<_Key, _Val, _KoV,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    { return pair<const_iterator, const_iterator>(lower_bound(__k),
        upper_bound(__k)); }

  unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root);

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }
}
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/map" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 1 3
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
namespace std
{
# 89 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = less<_Key>,
            typename _Alloc = allocator<pair<const _Key, _Tp> > >
    class map
    {

     
     


    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;

      class value_compare
      : public binary_function<value_type, value_type, bool>
      {
 friend class map<_Key,_Tp,_Compare,_Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef _Rb_tree<key_type, value_type,
         _Select1st<value_type>, key_compare, _Alloc> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef typename _Rep_type::allocator_type allocator_type;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t(_Compare(), allocator_type()) { }





      explicit
      map(const _Compare& __comp, const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 165 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 177 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      template <typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t(_Compare(), allocator_type())
        { _M_t.insert_unique(__first, __last); }
# 193 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      template <typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp, const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t.insert_unique(__first, __last); }
# 215 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }


      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }





      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }





      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 330 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
# 358 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      pair<iterator,bool>
      insert(const value_type& __x)
      { return _M_t.insert_unique(__x); }
# 382 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      iterator
      insert(iterator position, const value_type& __x)
      { return _M_t.insert_unique(position, __x); }
# 394 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      template <typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t.insert_unique(__first, __last); }
# 408 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 423 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 438 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 453 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      void
      swap(map& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 496 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 511 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 523 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 538 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 553 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 592 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      pair<iterator,iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 611 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
      pair<const_iterator,const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator== (const map<_K1,_T1,_C1,_A1>&,
      const map<_K1,_T1,_C1,_A1>&);

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator< (const map<_K1,_T1,_C1,_A1>&,
     const map<_K1,_T1,_C1,_A1>&);
    };
# 636 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 653 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,
              const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__x == __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x,
              const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__y < __x); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__x < __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key,_Tp,_Compare,_Alloc>& __x, map<_Key,_Tp,_Compare,_Alloc>& __y)
    { __x.swap(__y); }
}
# 67 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/map" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 1 3
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
namespace std
{


  template <typename _Key, typename _Tp,
            typename _Compare = less<_Key>,
            typename _Alloc = allocator<pair<const _Key, _Tp> > >
    class multimap;

  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
        const multimap<_Key,_Tp,_Compare,_Alloc>& __y);

  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
       const multimap<_Key,_Tp,_Compare,_Alloc>& __y);
# 106 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class multimap
    {

     
     


    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;

      class value_compare
      : public binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key,_Tp,_Compare,_Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef _Rb_tree<key_type, value_type,
         _Select1st<value_type>, key_compare, _Alloc> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef typename _Rep_type::allocator_type allocator_type;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t(_Compare(), allocator_type()) { }





      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 181 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 193 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      template <typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t(_Compare(), allocator_type())
        { _M_t.insert_equal(__first, __last); }
# 209 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      template <typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t.insert_equal(__first, __last); }
# 232 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }


      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }



      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 346 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t.insert_equal(__x); }
# 370 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t.insert_equal(__position, __x); }
# 382 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      template <typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t.insert_equal(__first, __last); }
# 397 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 412 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 427 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 442 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 485 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 500 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 524 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 539 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 576 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      pair<iterator,iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 593 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
      pair<const_iterator,const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator== (const multimap<_K1,_T1,_C1,_A1>&,
      const multimap<_K1,_T1,_C1,_A1>&);

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator< (const multimap<_K1,_T1,_C1,_A1>&,
     const multimap<_K1,_T1,_C1,_A1>&);
  };
# 618 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 635 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
              const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__x == __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
              const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__y < __x); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__x < __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x,
         multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { __x.swap(__y); }
}
# 68 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/map" 2 3
# 17 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Component.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Utilities.h" 1 3
# 24 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Utilities.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Event.h" 1 3
# 18 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Event.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScarabServices.h" 1 3
# 16 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScarabServices.h" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab.h" 1 3





extern "C" {




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_datatypes.h" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_datatypes.h" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_mem.h" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_mem.h" 3
extern void scarab_mem_init(void);






extern void *scarab_mem_malloc(int bytes);




extern void scarab_mem_free(void *ptr);
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_datatypes.h" 2 3


struct __ScarabOpaque;typedef struct __ScarabOpaque ScarabOpaque;
struct __ScarabDatum;typedef struct __ScarabDatum ScarabDatum;

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_list.h" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_list.h" 3
struct __ScarabList;typedef struct __ScarabList ScarabList;
struct __ScarabList
{
 int size;
 ScarabDatum ** values;
};





extern ScarabDatum *scarab_list_new(int size);






extern ScarabDatum* scarab_list_put(ScarabDatum *list, int idx,
         ScarabDatum *val);





extern ScarabDatum *scarab_list_get(ScarabDatum *list, int idx);
# 51 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_list.h" 3
extern ScarabDatum *scarab_list_copy(ScarabDatum *dest, int destpos,
          ScarabDatum *source,
          int sourcepos, int count);
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_datatypes.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_dict.h" 1 3







struct __ScarabDict;typedef struct __ScarabDict ScarabDict;




typedef int (*ScarabDictExpFun) (ScarabDict *dict);

struct __ScarabDict
{
 int size;
 int tablesize;
 ScarabDatum **keys;
 ScarabDatum **values;
 ScarabDictExpFun expansion_function;
};





extern ScarabDatum *scarab_dict_new(int initialsize,
         ScarabDictExpFun f);





extern ScarabDatum *scarab_dict_put(ScarabDatum *dict, ScarabDatum *key,
         ScarabDatum *val);





extern ScarabDatum *scarab_dict_get(ScarabDatum *dict, ScarabDatum *key);






extern ScarabDatum *scarab_dict_remove(ScarabDatum *dict, ScarabDatum *key);




extern int scarab_dict_times2(ScarabDict *dict);





extern ScarabDatum ** scarab_dict_keys(ScarabDatum * dict);




extern ScarabDatum ** scarab_dict_values(ScarabDatum * dict);




extern int scarab_dict_number_of_elements(ScarabDatum * dict);
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_datatypes.h" 2 3

struct __ScarabOpaque
{
 int size;
 unsigned char *data;
};




struct __ScarabDatum
{

 union
 {
  long long integer;
  double floatp;
  ScarabOpaque opaque;
  ScarabDict *dict;
  ScarabList *list;
  void *p;
 }
 data;
 ScarabDatum *attributes;
 int type;
 int ref_count;

  pthread_mutex_t *mutex;

};
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_os.h" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_os.h" 3
extern void scarab_os_init(void);




extern const char* scarab_os_strerror(int err);




extern int scarab_os_geterr();
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_utilities.h" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_utilities.h" 3
char * scarab_extract_string(ScarabDatum *d);




int scarab_create_file(const char *filename);





void
scarab_recursive_free_children(ScarabDatum datum);

void
scarab_recursive_free(ScarabDatum *d);
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab.h" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab.h" 3
extern int SCARAB_SELECT_TIMEDOUT;
extern int READ_FUBAR_FLAG;


struct __ScarabEncoderEngine;typedef struct __ScarabEncoderEngine ScarabEncoderEngine;
struct __ScarabStreamEngine;typedef struct __ScarabStreamEngine ScarabStreamEngine;
struct __ScarabStream;typedef struct __ScarabStream ScarabStream;
struct __ScarabSession;typedef struct __ScarabSession ScarabSession;




struct __ScarabEncoderEngine
{



 int api_version;
 int err_code_base;
 int nerr_code;
 int _pad1;




 int (*lib_init) (void);
 int (*session_accept) (ScarabSession * s);
 int (*session_connect) (ScarabSession * s);
 int (*session_close) (ScarabSession * s);




 int (*write_null) (ScarabSession * s);
 int (*write_integer) (ScarabSession * s, long long value);
 int (*write_float) (ScarabSession * s, double value);
 int (*write_float_inf) (ScarabSession * s);
 int (*write_float_nan) (ScarabSession * s);
 int (*write_opaque) (ScarabSession * s, const char *value, int len);
 int (*write_list) (ScarabSession * s, ScarabList * list);
 int (*write_dict) (ScarabSession * s, ScarabDict * dict);




 ScarabDatum *(*read) (ScarabSession * s);

 int (*seek) (ScarabSession *s, long int offset, int origin);
 long int (*tell) (ScarabSession *s);



 char *(*strerr) (int code);




 char uri_scheme[64];
 char engine_author[64];
 char engine_name[64];
};





struct __ScarabStreamEngine
{
 int api_version;
 int err_code_base;
 int nerr_code;
 int _pad1;




 int (*lib_init) (void);
 ScarabStream *(*stream_listen) (ScarabSession * s, const char *uri);
 ScarabStream *(*stream_accept) (ScarabSession * session, const char *uri,
           ScarabStream * binding);
 ScarabStream *(*stream_connect) (ScarabSession * session, const char *uri);
 int (*stream_close) (ScarabStream * self);




 int (*write) (ScarabStream * self, const void *data, int len);
 int (*send) (ScarabStream * self);
 int (*flush) (ScarabStream * self);




 int (*read) (ScarabStream * self, void *data, int len);




 int (*seek)(ScarabStream *self, long int offset, int origin);
 long int (*tell)(ScarabStream *);




 char *(*strerr) (int code);




 char uri_scheme[64];
 char engine_author[64];
 char engine_name[64];




    int (*local_port) (ScarabStream * self);
    char *(*local_address) (ScarabStream * self);
    int (*foreign_port) (ScarabStream * self);
    char *(*foreign_address) (ScarabStream * self);
};


struct __ScarabStream
{
 ScarabStream *next;
 ScarabSession *session;
 ScarabStreamEngine *engine;
};
# 166 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab.h" 3
struct __ScarabSession
{

 ScarabEncoderEngine *encoder_engine;




 void *encoder;
 char *url;
 ScarabStream *stream_head;


 int errcode;
 int os_errno;




 int force_buffering;
 int send_recursion_counter;





 int send_buffer_position;
 unsigned char send_buffer[100000000];


 unsigned char read_buffer[10000000];
 int read_buffer_fill_position;
 int read_buffer_read_position;


};




extern int scarab_init();




extern ScarabSession *scarab_session_connect(const char *url);




extern ScarabSession *scarab_session_listen(const char *url);






extern ScarabSession *scarab_session_accept(ScarabSession * binding);




extern void scarab_session_set_encoder(ScarabSession * session,
             ScarabEncoderEngine * engine,
             void *engine_data);




extern int scarab_session_close(ScarabSession * session);




extern int scarab_session_seterr(ScarabSession * session, int code);




extern int scarab_session_geterr(ScarabSession * session);







extern int scarab_did_select_timeout(int errorCode);




extern int scarab_session_getoserr(ScarabSession * session);




extern const char *scarab_moderror(int errcode);




extern const char *scarab_strerror(int errcode);
# 277 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab.h" 3
extern int scarab_session_push_listen(ScarabSession * session,
           ScarabStream * stream,
           const char *uri);





extern int scarab_session_push_accept(ScarabSession * session,
             ScarabStream * stream,
             char *uri, ScarabStream * binding);







extern int scarab_session_push_connect(ScarabSession * session,
           ScarabStream * stream,
           const char *uri);




extern int scarab_session_read(ScarabSession * session, void *buffer,

         int len);

extern int scarab_session_seek(ScarabSession *session, long int offset, int origin);
extern long int scarab_session_tell(ScarabSession *session);
extern int scarab_session_write(ScarabSession * session, const void *buffer,

          int len);
extern int scarab_session_send(ScarabSession * session);
extern int scarab_session_flush(ScarabSession * session);




extern int scarab_session_local_port(ScarabSession * session);
extern char * scarab_session_local_address(ScarabSession * session);
extern int scarab_session_foreign_port(ScarabSession * session);
extern char * scarab_session_foreign_address(ScarabSession * session);
extern int scarab_session_read_should_die(ScarabSession * session);






extern int scarab_write(ScarabSession * session, ScarabDatum * value);
extern int scarab_write_integer(ScarabSession * session, int value);
extern int scarab_write_float(ScarabSession * session, double value);
extern int scarab_write_string(ScarabSession * session, const char *value);
extern int scarab_write_opaque(ScarabSession * session, const char *value,
         int size);
extern int scarab_write_list(ScarabSession * session, ScarabList * list);
extern int scarab_write_dict(ScarabSession * session, ScarabDict * dict);






extern ScarabDatum *scarab_read(ScarabSession * session);
extern ScarabDatum *scarab_read_integer(ScarabSession * session);
extern ScarabDatum *scarab_read_float(ScarabSession * session);
extern ScarabDatum *scarab_read_opaque(ScarabSession * session);
extern ScarabDatum *scarab_read_list(ScarabSession * session);
extern ScarabDatum *scarab_read_dict(ScarabSession * session);


extern int scarab_seek(ScarabSession *session, long int offset, int origin);
extern long int scarab_tell(ScarabSession *session);




extern ScarabDatum *scarab_new_molecular();





extern ScarabDatum *scarab_new_atomic();




extern ScarabDatum * scarab_copy_datum(ScarabDatum *datum);





void
scarab_free_datum(ScarabDatum *d);


ScarabDatum *scarab_init_lock(ScarabDatum *datum);
ScarabDatum *scarab_lock_datum(ScarabDatum *datum);
ScarabDatum *scarab_unlock_datum(ScarabDatum *datum);
ScarabDatum *scarab_destroy_lock(ScarabDatum *datum);






extern ScarabDatum *scarab_new_integer(long long value);
extern ScarabDatum *scarab_new_float(double value);
extern ScarabDatum *scarab_new_string(const char *value);
extern ScarabDatum *scarab_new_opaque(const char *data, int size);




extern int scarab_hash(ScarabDatum * datum, int modulo, int atry);





extern int scarab_equals(ScarabDatum * dataum1, ScarabDatum * datum2);

void scarab_force_buffering(ScarabSession *s, int value);



}
# 17 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScarabServices.h" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_utilities.h" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/Scarab/scarab_utilities.h" 3
char * scarab_extract_string(ScarabDatum *d);




int scarab_create_file(const char *filename);





void
scarab_recursive_free_children(ScarabDatum datum);

void
scarab_recursive_free(ScarabDatum *d);
# 21 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScarabServices.h" 2 3

namespace mw {




void printDatum(ScarabDatum * datum);




int getScarabError(ScarabSession *);





int getScarabOSError(ScarabSession *);





const char * getScarabErrorName(int error);





const char * getScarabErrorDescription(int error);





const char * getOSErrorDescription(int oserror);




void logDescriptiveScarabMessage(ScarabSession *);
}
# 19 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Event.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericData.h" 1 3
# 16 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericData.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Lockable.h" 1 3
# 15 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Lockable.h" 3
namespace mw {
# 35 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Lockable.h" 3
class Lockable {
    private:

        pthread_mutex_t mutex;

    public:



        Lockable();




        ~Lockable();




  inline void lock(){
   pthread_mutex_lock(&mutex);
  }




  inline void unlock(){
   pthread_mutex_unlock(&mutex);
  }

};
}
# 17 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericData.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/vector" 1 3
# 63 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/vector" 3
       
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/vector" 3






# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 1 3
# 68 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
namespace std
{





  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      struct _Vector_impl
      : public _Alloc
      {
 _Tp* _M_start;
 _Tp* _M_finish;
 _Tp* _M_end_of_storage;
 _Vector_impl(_Alloc const& __a)
 : _Alloc(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return *static_cast<const _Alloc*>(&this->_M_impl); }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a)
      { }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      _Tp*
      _M_allocate(size_t __n)
      { return _M_impl.allocate(__n); }

      void
      _M_deallocate(_Tp* __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 147 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef vector<_Tp, _Alloc> vector_type;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef typename _Base::allocator_type allocator_type;

    protected:





      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;

    public:





      explicit
      vector(const allocator_type& __a = allocator_type())
      : _Base(__a)
      { }
# 199 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          this->get_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_start + __n;
      }
# 215 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      explicit
      vector(size_type __n)
      : _Base(__n, allocator_type())
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, value_type(),
          this->get_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_start + __n;
      }
# 233 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x.get_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          this->get_allocator());
      }
# 256 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        this->get_allocator());
      }
# 285 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 298 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 314 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      using _Base::get_allocator;







      iterator
      begin()
      { return iterator (this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator (this->_M_impl._M_start); }






      iterator
      end()
      { return iterator (this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator (this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }



      size_type
      size() const
      { return size_type(end() - begin()); }


      size_type
      max_size() const
      { return size_type(-1) / sizeof(value_type); }
# 421 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size < size())
   erase(begin() + __new_size, end());
 else
   insert(end(), __new_size - size(), __x);
      }
# 440 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      { resize(__new_size, value_type()); }





      size_type
      capacity() const
      { return size_type(const_iterator(this->_M_impl._M_end_of_storage)
    - begin()); }





      bool
      empty() const
      { return begin() == end(); }
# 478 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 493 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(begin() + __n); }
# 508 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(begin() + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 533 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 551 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 601 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 622 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 640 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 656 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 674 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 699 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 720 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 732 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);
      }







      void
      clear()
      { erase(begin(), end()); }

    protected:






      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       this->get_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }





      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     this->get_allocator());
   this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     this->get_allocator());
 }






      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);





      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


      void
      _M_insert_aux(iterator __position, const value_type& __x);
    };
# 926 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 943 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
}
# 71 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/vector" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_bvector.h" 1 3
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_bvector.h" 3
namespace std
{
  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base : public iterator<random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   _M_offset = static_cast<unsigned int>(__n + int(_S_word_bit));
   --_M_p;
 }
      else
 _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i)
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i)
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  template<class _Alloc>
    class _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;
 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      _Bvector_base(const allocator_type& __a) : _M_impl(__a) { }

      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };
}




namespace std
{
# 424 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : public _Bvector_base<_Alloc>
  {
  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;

    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;

    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;

    typedef typename _Bvector_base<_Alloc>::allocator_type allocator_type;

    allocator_type get_allocator() const
    { return _Bvector_base<_Alloc>::get_allocator(); }

  protected:
    using _Bvector_base<_Alloc>::_M_allocate;
    using _Bvector_base<_Alloc>::_M_deallocate;

  protected:
    void
    _M_fill(iterator __first, iterator __last, bool __x)
    {
      if (__first._M_p != __last._M_p)
        {
          std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
          std::fill(__first, iterator(__first._M_p + 1, 0), __x);
          std::fill(iterator(__last._M_p, 0), __last, __x);
        }
      else
        std::fill(__first, __last, __x);
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len = size() ? 2 * size()
                                  : static_cast<size_type>(_S_word_bit);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = std::copy(begin(), __position, iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    template<class _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     input_iterator_tag)
      {
 this->_M_impl._M_start = iterator();
 this->_M_impl._M_finish = iterator();
 this->_M_impl._M_end_of_storage = 0;
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<class _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }

    template<class _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<class _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len = size() + std::max(size(), __n);
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = std::copy(begin(), __position,
      iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  public:
    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }

    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    { return size_type(-1); }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }
    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    { return *(begin() + difference_type(__n)); }

    const_reference
    operator[](size_type __n) const
    { return *(begin() + difference_type(__n)); }

    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    explicit
    vector(const allocator_type& __a = allocator_type())
    : _Bvector_base<_Alloc>(__a) { }

    vector(size_type __n, bool __value,
    const allocator_type& __a = allocator_type())
    : _Bvector_base<_Alloc>(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    explicit
    vector(size_type __n)
    : _Bvector_base<_Alloc>(allocator_type())
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p,
  this->_M_impl._M_end_of_storage, 0);
    }

    vector(const vector& __x)
    : _Bvector_base<_Alloc>(__x.get_allocator())
    {
      _M_initialize(__x.size());
      std::copy(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    template<class _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(__n);
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<class _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<class _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Bvector_base<_Alloc>(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      std::copy(__x.begin(), __x.end(), begin());
      this->_M_impl._M_finish = begin() + difference_type(__x.size());
      return *this;
    }






    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   erase(begin() + __n, end());
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    void
    assign(size_t __n, bool __x)
    { _M_fill_assign(__n, __x); }

    template<class _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }

    template<class _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign((size_t) __n, (bool) __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    template<class _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   erase(__cur, end());
 else
   insert(end(), __first, __last);
      }

    template<class _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   erase(std::copy(__first, __last, begin()), end());
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }

    void
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = std::copy(begin(), end(),
           iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector<bool, _Alloc>& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, bool __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }



    template<class _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<class _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    template<class _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   _M_fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len = size() + std::max(size(), __n);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = std::copy(begin(), __position, iterator(__q, 0));
   _M_fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    void
    insert(iterator __position, size_type __n, bool __x)
    { _M_fill_insert(__position, __n, __x); }

    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      this->_M_impl._M_finish = std::copy(__last, end(), __first);
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        erase(begin() + difference_type(__new_size), end());
      else
        insert(end(), __new_size - size(), __x);
    }

    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { erase(begin(), end()); }
  };
}
# 72 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/vector" 2 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/vector.tcc" 1 3
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/vector.tcc" 3
namespace std
{
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
            this->_M_impl._M_start,
            this->_M_impl._M_finish);
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   this->get_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      iterator __i(std::copy(__last, end(), __first));
      std::_Destroy(__i, end(), this->get_allocator());
      this->_M_impl._M_finish = this->_M_impl._M_finish - (__last - __first);
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       this->get_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       iterator __i(std::copy(__x.begin(), __x.end(), begin()));
       std::_Destroy(__i, end(), this->get_allocator());
     }
   else
     {
       std::copy(__x.begin(), __x.begin() + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x.begin() + size(),
       __x.end(), this->_M_impl._M_finish,
       this->get_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, get_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     this->get_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        erase(fill_n(begin(), __n, __val), end());
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      input_iterator_tag)
      {
 iterator __cur(begin());
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   erase(__cur, end());
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     this->get_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   {
     iterator __new_finish(std::copy(__first, __last,
           this->_M_impl._M_start));
     std::_Destroy(__new_finish, end(), this->get_allocator());
     this->_M_impl._M_finish = __new_finish.base();
   }
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       this->get_allocator());
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)
    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      *(this->_M_impl._M_finish - 1));
   ++this->_M_impl._M_finish;
   _Tp __x_copy = __x;
   std::copy_backward(__position,
        iterator(this->_M_impl._M_finish-2),
        iterator(this->_M_impl._M_finish-1));
   *__position = __x_copy;
 }
      else
 {
   const size_type __old_size = size();
   if (__old_size == this->max_size())
     __throw_length_error(("vector::_M_insert_aux"));




   size_type __len = __old_size != 0 ? 2 * __old_size : 1;
   if (__len < __old_size)
     __len = this->max_size();

   iterator __new_start(this->_M_allocate(__len));
   iterator __new_finish(__new_start);
   try
     {
       __new_finish =
  std::__uninitialized_copy_a(iterator(this->_M_impl._M_start),
         __position,
         __new_start,
         this->get_allocator());
       this->_M_impl.construct(__new_finish.base(), __x);
       ++__new_finish;
       __new_finish =
  std::__uninitialized_copy_a(__position,
         iterator(this->_M_impl._M_finish),
         __new_finish,
         this->get_allocator());
     }
   catch(...)
     {
       std::_Destroy(__new_start, __new_finish, this->get_allocator());
       _M_deallocate(__new_start.base(),__len);
       throw;
     }
   std::_Destroy(begin(), end(), this->get_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start.base();
   this->_M_impl._M_finish = __new_finish.base();
   this->_M_impl._M_end_of_storage = __new_start.base() + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       iterator __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           this->get_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position, __old_finish - __n,
         __old_finish);
    std::fill(__position, __position + __n, __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      this->get_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_copy_a(__position, __old_finish,
           this->_M_impl._M_finish,
           this->get_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position, __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __old_size = size();
       if (this->max_size() - __old_size < __n)
  __throw_length_error(("vector::_M_fill_insert"));


       size_type __len = __old_size + std::max(__old_size, __n);
       if (__len < __old_size)
  __len = this->max_size();

       iterator __new_start(this->_M_allocate(__len));
       iterator __new_finish(__new_start);
       try
  {
    __new_finish =
      std::__uninitialized_copy_a(begin(), __position,
      __new_start,
      this->get_allocator());
    std::__uninitialized_fill_n_a(__new_finish, __n, __x,
      this->get_allocator());
    __new_finish += __n;
    __new_finish =
      std::__uninitialized_copy_a(__position, end(), __new_finish,
      this->get_allocator());
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    this->get_allocator());
    _M_deallocate(__new_start.base(), __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       this->get_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start.base();
       this->_M_impl._M_finish = __new_finish.base();
       this->_M_impl._M_end_of_storage = __new_start.base() + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc> template<typename _InputIterator>
    void
    vector<_Tp, _Alloc>::
    _M_range_insert(iterator __pos, _InputIterator __first,
      _InputIterator __last, input_iterator_tag)
    {
      for (; __first != __last; ++__first)
 {
   __pos = insert(__pos, *__first);
   ++__pos;
 }
    }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  iterator __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      this->get_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position, __old_finish - __n,
           __old_finish);
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      this->get_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_copy_a(__position, __old_finish,
      this->_M_impl._M_finish,
      this->get_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __old_size = size();
  if (this->max_size() - __old_size < __n)
    __throw_length_error(("vector::_M_range_insert"));


  size_type __len = __old_size + std::max(__old_size, __n);
  if (__len < __old_size)
    __len = this->max_size();

  iterator __new_start(this->_M_allocate(__len));
  iterator __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_copy_a(iterator(this->_M_impl._M_start),
        __position,
        __new_start,
        this->get_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last, __new_finish,
        this->get_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__position,
        iterator(this->_M_impl._M_finish),
        __new_finish,
        this->get_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start,__new_finish,
      this->get_allocator());
      _M_deallocate(__new_start.base(), __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         this->get_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start.base();
  this->_M_impl._M_finish = __new_finish.base();
  this->_M_impl._M_end_of_storage = __new_start.base() + __len;
       }
   }
      }
}
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/vector" 2 3
# 19 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericData.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 1 3
# 31 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/stdexcept" 1 3
# 41 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/stdexcept" 3
       
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/stdexcept" 3




#pragma GCC visibility push(default)

namespace std
{





  class logic_error : public exception
  {
    string _M_msg;

  public:

    explicit
    logic_error(const string& __arg);

    virtual
    ~logic_error() throw();



    virtual const char*
    what() const throw();
  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
  };






  class runtime_error : public exception
  {
    string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg);

    virtual
    ~runtime_error() throw();



    virtual const char*
    what() const throw();
  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
  };
}

#pragma GCC visibility pop
# 32 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 2 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 35 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 2 3

namespace stx {
# 45 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
class AnyScalar
{
public:



    enum attrtype_t
    {

 ATTRTYPE_INVALID = 0x00,


 ATTRTYPE_BOOL = 0x01,



 ATTRTYPE_CHAR = 0x10,


 ATTRTYPE_SHORT = 0x11,


 ATTRTYPE_INTEGER = 0x12,


 ATTRTYPE_LONG = 0x13,



 ATTRTYPE_BYTE = 0x20,


 ATTRTYPE_WORD = 0x21,


 ATTRTYPE_DWORD = 0x22,


 ATTRTYPE_QWORD = 0x23,


 ATTRTYPE_FLOAT = 0x30,


 ATTRTYPE_DOUBLE = 0x31,



 ATTRTYPE_STRING = 0x40
    };

private:

    attrtype_t atype;


    union value_t
    {

 int _int;


 unsigned int _uint;


 long long _long;


 unsigned long long _ulong;


 float _float;


 double _double;


 std::string* _string;
    };


    union value_t val;

public:

    explicit inline AnyScalar(attrtype_t t = ATTRTYPE_INVALID)
 : atype(t)
    {
 if (atype == ATTRTYPE_STRING) {
     val._string = new std::string;
 }
 else {
     val._ulong = 0;
 }
    }





    inline AnyScalar(bool b)
 : atype(ATTRTYPE_BOOL)
    {
 val._int = b;
    }





    inline AnyScalar(char c)
 : atype(ATTRTYPE_CHAR)
    {
 val._int = c;
    }



    inline AnyScalar(short s)
 : atype(ATTRTYPE_SHORT)
    {
 val._int = s;
    }


    inline AnyScalar(int i)
 : atype(ATTRTYPE_INTEGER)
    {
 val._int = i;
    }


    inline AnyScalar(long i)
 : atype(ATTRTYPE_INTEGER)
    {
 val._int = i;
    }


    inline AnyScalar(long long l)
 : atype(ATTRTYPE_LONG)
    {
 val._long = l;
    }


    inline AnyScalar(unsigned char c)
 : atype(ATTRTYPE_BYTE)
    {
 val._uint = c;
    }


    inline AnyScalar(unsigned short s)
 : atype(ATTRTYPE_WORD)
    {
 val._uint = s;
    }


    inline AnyScalar(unsigned int i)
 : atype(ATTRTYPE_DWORD)
    {
 val._uint = i;
    }


    inline AnyScalar(unsigned long i)
 : atype(ATTRTYPE_DWORD)
    {
 val._uint = i;
    }


    inline AnyScalar(unsigned long long l)
 : atype(ATTRTYPE_QWORD)
    {
 val._ulong = l;
    }


    inline AnyScalar(float f)
 : atype(ATTRTYPE_FLOAT)
    {
 val._float = f;
    }


    inline AnyScalar(double d)
 : atype(ATTRTYPE_DOUBLE)
    {
 val._double = d;
    }


    inline AnyScalar(const char *s)
 : atype(ATTRTYPE_STRING)
    {
 if (s == __null)
     val._string = new std::string;
 else
     val._string = new std::string(s);
    }


    inline AnyScalar(const std::string &s)
 : atype(ATTRTYPE_STRING)
    {
 val._string = new std::string(s);
    }


    inline ~AnyScalar()
    {
 if (atype == ATTRTYPE_STRING) {
     delete val._string;
     val._string = __null;
 }
    }



    inline AnyScalar(const AnyScalar &a)
 : atype(a.atype)
    {
 switch(atype)
 {
 case ATTRTYPE_INVALID:
     break;

 case ATTRTYPE_BOOL:
 case ATTRTYPE_CHAR:
 case ATTRTYPE_SHORT:
 case ATTRTYPE_INTEGER:
     val._int = a.val._int;
     break;

 case ATTRTYPE_BYTE:
 case ATTRTYPE_WORD:
 case ATTRTYPE_DWORD:
     val._uint = a.val._uint;
     break;

 case ATTRTYPE_LONG:
     val._long = a.val._long;
     break;

 case ATTRTYPE_QWORD:
     val._ulong = a.val._ulong;
     break;

 case ATTRTYPE_FLOAT:
     val._float = a.val._float;
     break;

 case ATTRTYPE_DOUBLE:
     val._double = a.val._double;
     break;

 case ATTRTYPE_STRING:
     val._string = new std::string(*a.val._string);
     break;
 }
    }



    inline AnyScalar& operator=(const AnyScalar &a)
    {

 if (this == &a) return *this;

 if (atype == ATTRTYPE_STRING) {
     delete val._string;
     val._string = __null;
 }

 atype = a.atype;

 switch(atype)
 {
 case ATTRTYPE_INVALID:
     (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h", 327, "0") : (void)0);
     break;

 case ATTRTYPE_BOOL:
 case ATTRTYPE_CHAR:
 case ATTRTYPE_SHORT:
 case ATTRTYPE_INTEGER:
     val._int = a.val._int;
     break;

 case ATTRTYPE_BYTE:
 case ATTRTYPE_WORD:
 case ATTRTYPE_DWORD:
     val._uint = a.val._uint;
     break;

 case ATTRTYPE_LONG:
     val._long = a.val._long;
     break;

 case ATTRTYPE_QWORD:
     val._ulong = a.val._ulong;
     break;

 case ATTRTYPE_FLOAT:
     val._float = a.val._float;
     break;

 case ATTRTYPE_DOUBLE:
     val._double = a.val._double;
     break;

 case ATTRTYPE_STRING:
     val._string = new std::string(*a.val._string);
     break;
 }

 return *this;
    }



    bool operator==(const AnyScalar &a) const;



    inline bool operator!=(const AnyScalar &a) const
    { return !(*this == a); }


    inline attrtype_t getType() const
    {
 return atype;
    }


    inline bool isBooleanType() const
    {
 return (atype == ATTRTYPE_BOOL);
    }


    inline bool isIntegerType() const
    {
 return (atype == ATTRTYPE_BOOL ||
  atype == ATTRTYPE_CHAR || atype == ATTRTYPE_SHORT ||
  atype == ATTRTYPE_INTEGER || atype == ATTRTYPE_LONG ||
  atype == ATTRTYPE_BYTE || atype == ATTRTYPE_WORD ||
  atype == ATTRTYPE_DWORD || atype == ATTRTYPE_QWORD);
    }


    inline bool isFloatingType() const
    {
 return (atype == ATTRTYPE_FLOAT || atype == ATTRTYPE_DOUBLE);
    }





    bool convertType(attrtype_t t);



    void resetType(attrtype_t t);




    static bool isValidAttrtype(attrtype_t at);



    static attrtype_t stringToType(const std::string &s)
    {
 return stringToType(s.c_str());
    }



    static attrtype_t stringToType(const char *s);


    static std::string getTypeString(attrtype_t at);


    inline std::string getTypeString() const
    {
 return getTypeString(atype);
    }





    inline int getTypeLength() const
    {
 return getTypeLength(atype);
    }



    static int getTypeLength(attrtype_t t);


    static bool isFixedLength(attrtype_t t)
    {
 return getTypeLength(t) >= 0;
    }


    inline bool isFixedLength() const
    {
 return isFixedLength(atype);
    }



    unsigned int getValueLength() const;
# 490 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    bool setInteger(int i);
# 509 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    bool setLong(long long l);
# 527 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    bool setDouble(double d);
# 552 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    bool setString(const std::string &s);



    bool setStringQuoted(const std::string &s);
# 573 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    AnyScalar& setAutoString(const std::string &input);
# 592 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    bool getBoolean() const;
# 605 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    int getInteger() const;
# 618 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    unsigned int getUnsignedInteger() const;


    inline int getInt() const
    {
 return getInteger();
    }


    inline unsigned int getUInt() const
    {
 return getUnsignedInteger();
    }
# 643 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    long long getLong() const;
# 656 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    unsigned long long getUnsignedLong() const;


    unsigned long long getULong() const
    {
 return getUnsignedLong();
    }
# 674 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    double getDouble() const;
# 685 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    std::string getString() const;




    std::string getStringQuoted() const;
# 704 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    AnyScalar operator-() const;







private:
# 735 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    template <template <typename Type> class Operator, char OpName>
    AnyScalar binary_arith_op(const AnyScalar &b) const;


public:

    inline AnyScalar operator+(const AnyScalar &b) const
    {
 return binary_arith_op<std::plus, '+'>(b);
    }


    inline AnyScalar operator-(const AnyScalar &b) const
    {
 return binary_arith_op<std::minus, '-'>(b);
    }


    inline AnyScalar operator*(const AnyScalar &b) const
    {
 return binary_arith_op<std::multiplies, '*'>(b);
    }


    inline AnyScalar operator/(const AnyScalar &b) const
    {
 return binary_arith_op<std::divides, '/'>(b);
    }


    inline AnyScalar add(const AnyScalar &b) const
    {
 return (*this + b);
    }


    inline AnyScalar subtract(const AnyScalar &b) const
    {
 return (*this - b);
    }


    inline AnyScalar multiply(const AnyScalar &b) const
    {
 return (*this * b);
    }


    inline AnyScalar divide(const AnyScalar &b) const
    {
 return (*this / b);
    }


private:
# 815 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/AnyScalar.h" 3
    template <template <typename Type> class Operator, int OpNum>
    bool binary_comp_op(const AnyScalar &b) const;




public:

    inline bool equal_to(const AnyScalar &b) const
    {
 return binary_comp_op<std::equal_to, 0>(b);
    }


    inline bool not_equal_to(const AnyScalar &b) const
    {
 return binary_comp_op<std::not_equal_to, 1>(b);
    }


    inline bool less(const AnyScalar &b) const
    {
 return binary_comp_op<std::less, 2>(b);
    }


    inline bool greater(const AnyScalar &b) const
    {
 return binary_comp_op<std::greater, 3>(b);
    }


    inline bool less_equal(const AnyScalar &b) const
    {
 return binary_comp_op<std::less_equal, 4>(b);
    }


    inline bool greater_equal(const AnyScalar &b) const
    {
 return binary_comp_op<std::greater_equal, 5>(b);
    }
};


static inline std::ostream& operator<< (std::ostream &stream, const AnyScalar &as)
{
    return stream << as.getString();
}

}
# 20 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericData.h" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/list.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/list.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/list" 1 3
# 63 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/list" 3
       
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/list" 3






# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 1 3
# 66 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
namespace std
{






  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;

    static void
    swap(_List_node_base& __x, _List_node_base& __y);

    void
    transfer(_List_node_base * const __first,
      _List_node_base * const __last);

    void
    reverse();

    void
    hook(_List_node_base * const __position);

    void
    unhook();
  };


  template<typename _Tp>
    struct _List_node : public _List_node_base
    {
      _Tp _M_data;
    };
# 110 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      _List_iterator(_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      _List_node_base* _M_node;
    };
# 186 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      _List_const_iterator(const _List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const _List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }







  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 295 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other

      _Node_Alloc_type;

      struct _List_impl
      : public _Node_Alloc_type
      {
 _List_node_base _M_node;
 _List_impl (const _Node_Alloc_type& __a)
 : _Node_Alloc_type(__a)
 { }
      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_Alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_Alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(*static_cast<
         const _Node_Alloc_type*>(&this->_M_impl)); }

      _List_base(const allocator_type& __a)
      : _M_impl(__a)
      { _M_init(); }


      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 390 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

     

      typedef _List_base<_Tp, _Alloc> _Base;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef typename _Base::allocator_type allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;







      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
# 434 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     this->get_allocator().construct(&__p->_M_data, __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }

    public:





      explicit
      list(const allocator_type& __a = allocator_type())
      : _Base(__a) { }
# 467 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      list(size_type __n, const value_type& __value,
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { this->insert(begin(), __n, __value); }
# 479 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      explicit
      list(size_type __n)
      : _Base(allocator_type())
      { this->insert(begin(), __n, value_type()); }
# 491 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x.get_allocator())
      { this->insert(begin(), __x.begin(), __x.end()); }
# 509 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        { this->insert(begin(), __first, __last); }
# 530 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 543 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 559 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_node._M_next; }






      const_iterator
      begin() const
      { return this->_M_impl._M_node._M_next; }






      iterator
      end() { return &this->_M_impl._M_node; }






      const_iterator
      end() const
      { return &this->_M_impl._M_node; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }






      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return size_type(-1); }
# 673 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      resize(size_type __new_size, const value_type& __x);
# 685 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      resize(size_type __new_size)
      { this->resize(__new_size, value_type()); }






      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 741 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
# 757 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 771 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
# 786 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(this->_M_impl._M_node._M_prev); }
# 801 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 817 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 835 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 860 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 882 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 899 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      swap(list& __x)
      { _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node); }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 926 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x)
      {
 if (!__x.empty())
   this->_M_transfer(__position, __x.begin(), __x.end());
      }
# 942 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      splice(iterator __position, list&, iterator __i)
      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;
 this->_M_transfer(__position, __i, __j);
      }
# 964 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      splice(iterator __position, list&, iterator __first, iterator __last)
      {
 if (__first != __last)
   this->_M_transfer(__position, __first, __last);
      }
# 982 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 996 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      template<typename _Predicate>
      void
      remove_if(_Predicate);
# 1010 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      unique();
# 1025 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1038 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      void
      merge(list& __x);
# 1053 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&, _StrictWeakOrdering);






      void
      reverse()
      { this->_M_impl._M_node.reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:



      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);





      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
      __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__x));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   for (; __first != __last; ++__first)
     _M_insert(__pos, *__first);
 }



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
      {
 for (; __n > 0; --__n)
   _M_insert(__pos, __x);
      }



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->transfer(__first._M_node, __last._M_node); }


      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->hook(__position._M_node);
      }


      void
      _M_erase(iterator __position)
      {
        __position._M_node->unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);
        this->get_allocator().destroy(&__n->_M_data);
        _M_put_node(__n);
      }
    };
# 1176 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1205 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
}
# 71 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/list" 2 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/list.tcc" 1 3
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/list.tcc" 3
namespace std
{
  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);
   this->get_allocator().destroy(&__tmp->_M_data);
   _M_put_node(__tmp);
 }
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->hook(__position._M_node);
      return __tmp;
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = __position._M_node->_M_next;
      _M_erase(__position);
      return __ret;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, const value_type& __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }

  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     _M_erase(__first);
   __first = __next;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    merge(list& __x)
    {


      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      merge(list& __x, _StrictWeakOrdering __comp)
      {


 if (this != &__x)
   {
     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }
}
# 74 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/list" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/list.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collections_save_imp.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collections_save_imp.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/nvp.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/nvp.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c_fwd.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/workaround.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c_fwd.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/adl_barrier.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/adl_barrier.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/adl.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/adl.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/msvc.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/adl.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/intel.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/adl.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/gcc.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/adl.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/adl_barrier.hpp" 2 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/adl_barrier.hpp" 3
namespace mpl_ { namespace aux {} }
namespace boost { namespace mpl { using namespace mpl_;
namespace aux { using namespace mpl_::aux; }
}}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c_fwd.hpp" 2 3

namespace mpl_ {





template< typename T, T N > struct integral_c;


}
namespace boost { namespace mpl { using ::mpl_::integral_c; } }
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/ctps.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/static_constant.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c_tag.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c_tag.hpp" 3
namespace mpl_ {
struct integral_c_tag { static const int value = 0; };
}
namespace boost { namespace mpl { using ::mpl_::integral_c_tag; } }
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/static_cast.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/nttp_decl.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/nttp_decl.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/nttp.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/nttp_decl.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/cat.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/cat.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/config/config.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/cat.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 3
namespace mpl_ {

template< typename T, T N >
struct integral_c
{
    static const T value = N;





    typedef integral_c type;

    typedef T value_type;
    typedef integral_c_tag tag;
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 3
    typedef integral_c< T, static_cast<T>((value + 1)) > next;
    typedef integral_c< T, static_cast<T>((value - 1)) > prior;






    operator T() const { return static_cast<T>(this->value); }
};


template< typename T, T N >
T const integral_c< T, N >::value;


}
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/integral_c.hpp" 2 3




namespace mpl_ {

template< bool C >
struct integral_c<bool, C>
{
    static const bool value = C;
    typedef integral_c_tag tag;
    typedef integral_c type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};
}
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/nvp.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/level.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/level.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_fundamental.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_fundamental.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_arithmetic.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_arithmetic.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_integral.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_integral.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/int.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/int.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/int_fwd.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/int_fwd.hpp" 3
namespace mpl_ {

template< int N > struct int_;

}
namespace boost { namespace mpl { using ::mpl_::int_; } }
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/int.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 3
namespace mpl_ {

template< int N >
struct int_
{
    static const int value = N;





    typedef int_ type;

    typedef int value_type;
    typedef integral_c_tag tag;
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 3
    typedef mpl_::int_< static_cast<int>((value + 1)) > next;
    typedef mpl_::int_< static_cast<int>((value - 1)) > prior;






    operator int() const { return static_cast<int>(this->value); }
};


template< int N >
int const mpl_::int_< N >::value;


}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/int.hpp" 2 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/template_arity_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/template_arity_fwd.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename F > struct template_arity;

}}}
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/params.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/params.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/preprocessor.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3
# 45 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/params.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comma_if.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comma_if.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/punctuation/comma_if.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/punctuation/comma_if.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/if.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/if.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/iif.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/if.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/logical/bool.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/if.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/facilities/empty.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/punctuation/comma.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comma_if.hpp" 2 3
# 46 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repeat.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repeat.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/repeat.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/repeat.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/debug/error.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/repeat.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/repeat.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/tuple/eat.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/repeat.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repeat.hpp" 2 3
# 47 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/inc.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/inc.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/arithmetic/inc.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/inc.hpp" 2 3
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/lambda.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/lambda.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/ttp.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/lambda.hpp" 2 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/overload_resolution.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/integral_constant.hpp" 1 3
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/integral_constant.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bool.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bool.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bool_fwd.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bool_fwd.hpp" 3
namespace mpl_ {

template< bool C_ > struct bool_;


typedef bool_<true> true_;
typedef bool_<false> false_;

}

namespace boost { namespace mpl { using ::mpl_::bool_; } }
namespace boost { namespace mpl { using ::mpl_::true_; } }
namespace boost { namespace mpl { using ::mpl_::false_; } }
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bool.hpp" 2 3



namespace mpl_ {

template< bool C_ > struct bool_
{
    static const bool value = C_;
    typedef integral_c_tag tag;
    typedef bool_ type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};


template< bool C_ >
bool const bool_<C_>::value;


}
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/integral_constant.hpp" 2 3


namespace boost{




template <class T, T val>

struct integral_constant : public mpl::integral_c<T, val>
{
   typedef integral_constant<T,val> type;
};

template<> struct integral_constant<bool,true> : public mpl::true_
{







   typedef integral_constant<bool,true> type;
};
template<> struct integral_constant<bool,false> : public mpl::false_
{







   typedef integral_constant<bool,false> type;
};

typedef integral_constant<bool,true> true_type;
typedef integral_constant<bool,false> false_type;

}
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/lambda_support.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_integral.hpp" 2 3

namespace boost {




template< typename T > struct is_integral : ::boost::integral_constant<bool,false> { };

template<> struct is_integral< unsigned char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned short > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned int > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned long > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long const volatile > : ::boost::integral_constant<bool,true> { };

template<> struct is_integral< signed char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed short > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed int > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed long > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long const volatile > : ::boost::integral_constant<bool,true> { };

template<> struct is_integral< bool > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char const volatile > : ::boost::integral_constant<bool,true> { };





template<> struct is_integral< wchar_t > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t const volatile > : ::boost::integral_constant<bool,true> { };
# 62 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_integral.hpp" 3
template<> struct is_integral< ::boost::ulong_long_type > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< ::boost::long_long_type > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type const volatile > : ::boost::integral_constant<bool,true> { };





}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_integral.hpp" 2 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_arithmetic.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_float.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_float.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_float.hpp" 2 3

namespace boost {


template< typename T > struct is_float : ::boost::integral_constant<bool,false> { };
template<> struct is_float< float > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_float< double > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_float< long double > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double const volatile > : ::boost::integral_constant<bool,true> { };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_float.hpp" 2 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_arithmetic.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/ice_or.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/ice_or.hpp" 3
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = false, bool b4 = false, bool b5 = false, bool b6 = false, bool b7 = false>
struct ice_or;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_or
{
    static const bool value = true;
};

template <>
struct ice_or<false, false, false, false, false, false, false>
{
    static const bool value = false;
};

}
}
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_arithmetic.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_arithmetic.hpp" 2 3

namespace boost {

namespace detail {

template< typename T >
struct is_arithmetic_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_float<T>::value >::value);




};

}


template< typename T > struct is_arithmetic : ::boost::integral_constant<bool,::boost::detail::is_arithmetic_impl<T>::value> { };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_arithmetic.hpp" 2 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_fundamental.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_void.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_void.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_void.hpp" 2 3

namespace boost {


template< typename T > struct is_void : ::boost::integral_constant<bool,false> { };
template<> struct is_void< void > : ::boost::integral_constant<bool,true> { };


template<> struct is_void< void const > : ::boost::integral_constant<bool,true> { };
template<> struct is_void< void volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_void< void const volatile > : ::boost::integral_constant<bool,true> { };


}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_void.hpp" 2 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_fundamental.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_fundamental.hpp" 2 3

namespace boost {

namespace detail {

template <typename T>
struct is_fundamental_impl
    : ::boost::type_traits::ice_or<
          ::boost::is_arithmetic<T>::value
        , ::boost::is_void<T>::value
        >
{
};

}


template< typename T > struct is_fundamental : ::boost::integral_constant<bool,::boost::detail::is_fundamental_impl<T>::value> { };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_fundamental.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/level.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/intrinsics.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/intrinsics.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/config.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/intrinsics.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_reference.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_reference.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_reference.hpp" 1 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_reference.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_reference.hpp" 2 3

namespace boost {



template< typename T > struct is_reference : ::boost::integral_constant<bool,false> { };
template< typename T > struct is_reference< T& > : ::boost::integral_constant<bool,true> { };
# 111 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_reference.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 114 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_reference.hpp" 2 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_reference.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_reference.hpp" 2 3

namespace boost {

namespace detail {
# 55 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_reference.hpp" 3
template <typename T>
struct add_reference_impl
{
    typedef T& type;
};


template< typename T > struct add_reference_impl<T&> { typedef T& type; };





template<> struct add_reference_impl<void> { typedef void type; };

template<> struct add_reference_impl<void const> { typedef void const type; };
template<> struct add_reference_impl<void volatile> { typedef void volatile type; };
template<> struct add_reference_impl<void const volatile> { typedef void const volatile type; };


}

template< typename T > struct add_reference { typedef typename boost::detail::add_reference_impl<T>::type type; };







}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 88 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_reference.hpp" 2 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/yes_no_type.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/yes_no_type.hpp" 3
namespace boost {
namespace type_traits {

typedef char yes_type;
struct no_type
{
   char padding[8];
};

}
}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_array.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_array.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_array.hpp" 2 3

namespace boost {



template< typename T > struct is_array : ::boost::integral_constant<bool,false> { };

template< typename T, std::size_t N > struct is_array< T[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T const[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T volatile[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T const volatile[N] > : ::boost::integral_constant<bool,true> { };

template< typename T > struct is_array< T[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T const[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T volatile[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T const volatile[] > : ::boost::integral_constant<bool,true> { };
# 86 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_array.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 89 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_array.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/ice.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/ice.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/ice_and.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/ice_and.hpp" 3
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = true, bool b4 = true, bool b5 = true, bool b6 = true, bool b7 = true>
struct ice_and;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_and
{
    static const bool value = false;
};

template <>
struct ice_and<true, true, true, true, true, true, true>
{
    static const bool value = true;
};

}
}
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/ice.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/ice_not.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/ice_not.hpp" 3
namespace boost {
namespace type_traits {

template <bool b>
struct ice_not
{
    static const bool value = true;
};

template <>
struct ice_not<true>
{
    static const bool value = false;
};

}
}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/ice.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/ice_eq.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/ice_eq.hpp" 3
namespace boost {
namespace type_traits {

template <int b1, int b2>
struct ice_eq
{
    static const bool value = (b1 == b2);
};

template <int b1, int b2>
struct ice_ne
{
    static const bool value = (b1 != b2);
};


template <int b1, int b2> bool const ice_eq<b1,b2>::value;
template <int b1, int b2> bool const ice_ne<b1,b2>::value;


}
}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/ice.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_abstract.hpp" 1 3
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_abstract.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/static_assert.hpp" 1 3
# 45 "/Library/Application Support/MonkeyWorks/Developer/include/boost/static_assert.hpp" 3
namespace boost{


template <bool x> struct STATIC_ASSERTION_FAILURE;

template <> struct STATIC_ASSERTION_FAILURE<true> { enum { value = 1 }; };


template<int x> struct static_assert_test{};

}
# 54 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_abstract.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_class.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_class.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_union.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_union.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_cv.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_cv.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/broken_compiler_spec.hpp" 1 3
# 95 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/broken_compiler_spec.hpp" 3















# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_cv.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/cv_traits_impl.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/cv_traits_impl.hpp" 3
namespace boost {
namespace detail {







template <typename T> struct cv_traits_imp {};

template <typename T>
struct cv_traits_imp<T*>
{
    static const bool is_const = false;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const T*>
{
    static const bool is_const = true;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<volatile T*>
{
    static const bool is_const = false;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const volatile T*>
{
    static const bool is_const = true;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};
# 92 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/cv_traits_impl.hpp" 3
}
}
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_cv.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_cv.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_cv.hpp" 2 3

namespace boost {




template< typename T > struct remove_cv { typedef typename boost::detail::cv_traits_imp<T*>::unqualified_type type; };
template< typename T > struct remove_cv<T&> { typedef T& type; };

template< typename T, std::size_t N > struct remove_cv<T const[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T volatile[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T const volatile[N]> { typedef T type[N]; };
# 57 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_cv.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 60 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_cv.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_union.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_union.hpp" 2 3

namespace boost {

namespace detail {
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_union.hpp" 3
template <typename T> struct is_union_impl
{
   static const bool value = false;
};

}

template< typename T > struct is_union : ::boost::integral_constant<bool,::boost::detail::is_union_impl<T>::value> { };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_union.hpp" 2 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_class.hpp" 2 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_class.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_class.hpp" 2 3

namespace boost {

namespace detail {
# 57 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_class.hpp" 3
template <class U> ::boost::type_traits::yes_type is_class_tester(void(U::*)(void));
template <class U> ::boost::type_traits::no_type is_class_tester(...);

template <typename T>
struct is_class_impl
{

    static const bool value = (::boost::type_traits::ice_and< sizeof(is_class_tester<T>(0)) == sizeof(::boost::type_traits::yes_type), ::boost::type_traits::ice_not< ::boost::is_union<T>::value >::value >::value);





};
# 126 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_class.hpp" 3
}





template< typename T > struct is_class : ::boost::integral_constant<bool,::boost::detail::is_class_impl<T>::value> { };


}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 138 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_class.hpp" 2 3
# 56 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_abstract.hpp" 2 3






# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 63 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_abstract.hpp" 2 3


namespace boost {
namespace detail{
# 75 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_abstract.hpp" 3
template<class T>
struct is_abstract_imp2
{




   template<class U>
   static type_traits::no_type check_sig(U (*)[1]);
   template<class U>
   static type_traits::yes_type check_sig(...);




   typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((sizeof(T) != 0) == 0 ? false : true) >)> boost_static_assert_typedef_90;




   static const unsigned s1 = sizeof(is_abstract_imp2<T>::template check_sig<T>(0));
# 107 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_abstract.hpp" 3
   static const bool value = (s1 == sizeof(type_traits::yes_type));

};

template <bool v>
struct is_abstract_select
{
   template <class T>
   struct rebind
   {
      typedef is_abstract_imp2<T> type;
   };
};
template <>
struct is_abstract_select<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_abstract_imp
{
   typedef is_abstract_select< ::boost::is_class<T>::value> selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;

   static const bool value = type::value;
};


}


template< typename T > struct is_abstract : ::boost::integral_constant<bool,::boost::detail::is_abstract_imp<T>::value> { };




}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 152 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_abstract.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 2 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 2 3

namespace boost {
# 52 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 3
namespace detail {
# 119 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 3
struct any_conversion
{
    template <typename T> any_conversion(const volatile T&);
    template <typename T> any_conversion(T&);
};

template <typename T> struct checker
{
    static boost::type_traits::no_type _m_check(any_conversion ...);
    static boost::type_traits::yes_type _m_check(T, int);
};

template <typename From, typename To>
struct is_convertible_basic_impl
{
    static From _m_from;
    static bool const value = sizeof( detail::checker<To>::_m_check(_m_from, 0) )
        == sizeof(::boost::type_traits::yes_type);
};
# 291 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 3
template <typename From, typename To>
struct is_convertible_impl
{
    typedef typename add_reference<From>::type ref_type;
    static const bool value = (::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::detail::is_convertible_basic_impl<ref_type,To>::value, ::boost::is_void<To>::value >::value, ::boost::type_traits::ice_not< ::boost::is_array<To>::value >::value >::value);
# 306 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 3
};


template <bool trivial1, bool trivial2, bool abstract_target>
struct is_convertible_impl_select
{
   template <class From, class To>
   struct rebind
   {
      typedef is_convertible_impl<From, To> type;
   };
};

template <>
struct is_convertible_impl_select<true, true, false>
{
   template <class From, class To>
   struct rebind
   {
      typedef true_type type;
   };
};

template <>
struct is_convertible_impl_select<false, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <>
struct is_convertible_impl_select<true, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <typename From, typename To>
struct is_convertible_impl_dispatch_base
{

   typedef is_convertible_impl_select<
      ::boost::is_arithmetic<From>::value,
      ::boost::is_arithmetic<To>::value,

      ::boost::is_abstract<To>::value



   > selector;



   typedef typename selector::template rebind<From, To> isc_binder;
   typedef typename isc_binder::type type;
};

template <typename From, typename To>
struct is_convertible_impl_dispatch
   : public is_convertible_impl_dispatch_base<From, To>::type
{};
# 394 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 3
    template<> struct is_convertible_impl< void,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void const volatile > { static const bool value = (true); };
# 404 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 3
template< typename To > struct is_convertible_impl< void,To > { static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void > { static const bool value = (true); };

template< typename To > struct is_convertible_impl< void const,To > { static const bool value = (false); };
template< typename To > struct is_convertible_impl< void volatile,To > { static const bool value = (false); };
template< typename To > struct is_convertible_impl< void const volatile,To > { static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void const > { static const bool value = (true); };
template< typename From > struct is_convertible_impl< From,void volatile > { static const bool value = (true); };
template< typename From > struct is_convertible_impl< From,void const volatile > { static const bool value = (true); };



}

template< typename From, typename To > struct is_convertible : ::boost::integral_constant<bool,(::boost::detail::is_convertible_impl_dispatch<From,To>::value)> { };







}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 429 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_convertible.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_function.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_function.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/false_result.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/false_result.hpp" 3
namespace boost {
namespace type_traits {


struct false_result
{
    template <typename T> struct result_
    {
        static const bool value = false;
    };
};

}}
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_function.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/is_function_ptr_helper.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/is_function_ptr_helper.hpp" 3
namespace boost {
namespace type_traits {

template <class R>
struct is_function_ptr_helper
{
    static const bool value = false;
};




template <class R >
struct is_function_ptr_helper<R (*)()> { static const bool value = true; };

template <class R >
struct is_function_ptr_helper<R (*)( ...)> { static const bool value = true; };

template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0)> { static const bool value = true; };

template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0 ...)> { static const bool value = true; };

template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1)> { static const bool value = true; };

template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...)> { static const bool value = true; };
# 203 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/is_function_ptr_helper.hpp" 3
}
}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_function.hpp" 2 3






# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_function.hpp" 2 3







namespace boost {
namespace detail {


template<bool is_ref = true>
struct is_function_chooser
    : ::boost::type_traits::false_result
{
};

template <>
struct is_function_chooser<false>
{
    template< typename T > struct result_
        : ::boost::type_traits::is_function_ptr_helper<T*>
    {
    };
};

template <typename T>
struct is_function_impl
    : is_function_chooser< ::boost::is_reference<T>::value >
        ::template result_<T>
{
};
# 87 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_function.hpp" 3
}

template< typename T > struct is_function : ::boost::integral_constant<bool,::boost::detail::is_function_impl<T>::value> { };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 94 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_function.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 2 3

namespace boost {




namespace detail {



template <typename T>
struct is_class_or_union
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_class<T>::value , ::boost::is_union<T>::value >::value);




};
# 78 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 3
struct int_convertible
{
    int_convertible(int);
};



template <bool is_typename_arithmetic_or_reference = true>
struct is_enum_helper
{
    template <typename T> struct type
    {
        static const bool value = false;
    };
};

template <>
struct is_enum_helper<false>
{
    template <typename T> struct type
       : ::boost::is_convertible<typename boost::add_reference<T>::type,::boost::detail::int_convertible>
    {
    };
};

template <typename T> struct is_enum_impl
{
# 115 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 3
   static const bool selector = (::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value , ::boost::is_reference<T>::value , ::boost::is_function<T>::value , is_class_or_union<T>::value , is_array<T>::value >::value);
# 152 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 3
    typedef ::boost::detail::is_enum_helper<selector> se_t;


    typedef typename se_t::template type<T> helper;
    static const bool value = helper::value;
};


template<> struct is_enum_impl< void > { static const bool value = (false); };

template<> struct is_enum_impl< void const > { static const bool value = (false); };
template<> struct is_enum_impl< void volatile > { static const bool value = (false); };
template<> struct is_enum_impl< void const volatile > { static const bool value = (false); };


}

template< typename T > struct is_enum : ::boost::integral_constant<bool,::boost::detail::is_enum_impl<T>::value> { };
# 185 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 188 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_enum.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/level.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_base_and_derived.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_base_and_derived.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_same.hpp" 1 3
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_same.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_same.hpp" 2 3

namespace boost {



template< typename T, typename U > struct is_same : ::boost::integral_constant<bool,false> { };
template< typename T > struct is_same< T,T > : ::boost::integral_constant<bool,true> { };
# 98 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_same.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 101 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_same.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_base_and_derived.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_base_and_derived.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_base_and_derived.hpp" 2 3

namespace boost {

namespace detail {
# 115 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_base_and_derived.hpp" 3
template <typename B, typename D>
struct bd_helper
{






    template <typename T>
    static type_traits::yes_type check_sig(D const volatile *, T);
    static type_traits::no_type check_sig(B const volatile *, int);




};

template<typename B, typename D>
struct is_base_and_derived_impl2
{
# 144 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_base_and_derived.hpp" 3
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((sizeof(B) != 0) == 0 ? false : true) >)> boost_static_assert_typedef_144;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((sizeof(D) != 0) == 0 ? false : true) >)> boost_static_assert_typedef_145;

    struct Host
    {

        operator B const volatile *() const;



        operator D const volatile *();
    };

    static const bool value = sizeof(bd_helper<B,D>::check_sig(Host(), 0)) == sizeof(type_traits::yes_type);




};
# 180 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_base_and_derived.hpp" 3
template <typename B, typename D>
struct is_base_and_derived_impl3
{
    static const bool value = false;
};

template <bool ic1, bool ic2, bool iss>
struct is_base_and_derived_select
{
   template <class T, class U>
   struct rebind
   {
      typedef is_base_and_derived_impl3<T,U> type;
   };
};

template <>
struct is_base_and_derived_select<true,true,false>
{
   template <class T, class U>
   struct rebind
   {
      typedef is_base_and_derived_impl2<T,U> type;
   };
};

template <typename B, typename D>
struct is_base_and_derived_impl
{
    typedef typename remove_cv<B>::type ncvB;
    typedef typename remove_cv<D>::type ncvD;

    typedef is_base_and_derived_select<
       ::boost::is_class<B>::value,
       ::boost::is_class<D>::value,
       ::boost::is_same<B,D>::value> selector;
    typedef typename selector::template rebind<ncvB,ncvD> binder;
    typedef typename binder::type bound_type;

    static const bool value = bound_type::value;
};







}

template< typename Base, typename Derived > struct is_base_and_derived : ::boost::integral_constant<bool,(::boost::detail::is_base_and_derived_impl<Base,Derived>::value)> { };







template< typename Base, typename Derived > struct is_base_and_derived< Base&,Derived > : ::boost::integral_constant<bool,false> { };
template< typename Base, typename Derived > struct is_base_and_derived< Base,Derived& > : ::boost::integral_constant<bool,false> { };
template< typename Base, typename Derived > struct is_base_and_derived< Base&,Derived& > : ::boost::integral_constant<bool,false> { };


}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 246 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_base_and_derived.hpp" 2 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/level.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/eval_if.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/eval_if.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/if.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/if.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/value_wknd.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/value_wknd.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/integral.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/value_wknd.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/eti.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/value_wknd.hpp" 2 3
# 73 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/value_wknd.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename T > struct value_type_wknd
{
    typedef typename T::value_type type;
};
# 87 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/value_wknd.hpp" 3
}}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/if.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na_spec.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na_spec.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/lambda_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/lambda_fwd.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/void_fwd.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/void_fwd.hpp" 3
namespace mpl_ {

struct void_;

}
namespace boost { namespace mpl { using ::mpl_::void_; } }
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/lambda_fwd.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na_fwd.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na_fwd.hpp" 3
namespace mpl_ {


struct na
{
    typedef na type;
    enum { value = 0 };
};

}
namespace boost { namespace mpl { using ::mpl_::na; } }
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na.hpp" 2 3



namespace boost { namespace mpl {

template< typename T >
struct is_na
    : false_
{



};

template<>
struct is_na<na>
    : true_
{



};

template< typename T >
struct is_not_na
    : true_
{



};

template<>
struct is_not_na<na>
    : false_
{



};


template< typename T, typename U > struct if_na
{
    typedef T type;
};

template< typename U > struct if_na<na,U>
{
    typedef U type;
};
# 93 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na.hpp" 3
}}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/lambda_fwd.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/lambda_arity_param.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/lambda_fwd.hpp" 2 3


namespace boost { namespace mpl {

template<
      typename T = na
    , typename Tag = void_
    , typename Arity = int_< aux::template_arity<T>::value >


    >
struct lambda;

}}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na_spec.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/arity.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/arity.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/dtp.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/arity.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na_spec.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/enum.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na_spec.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/limits/arity.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/logical/and.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/logical/and.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/logical/bitand.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/logical/and.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/identity.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/identity.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/facilities/identity.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/identity.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/empty.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 66 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/arithmetic/add.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/arithmetic/add.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/arithmetic/dec.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/arithmetic/add.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/while.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/while.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/while.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/fold_left.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/fold_left.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/while.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/fold_left.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/fold_left.hpp" 2 3
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/fold_left.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/detail/fold_left.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/detail/fold_left.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/expr_iif.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/adt.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/adt.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/detail/is_binary.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/detail/is_binary.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/detail/check.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/detail/is_binary.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/adt.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/logical/compl.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/adt.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/fold_left.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/while.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/fold_right.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/fold_right.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/fold_right.hpp" 2 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/fold_right.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/detail/fold_right.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/detail/fold_right.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/reverse.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/detail/fold_right.hpp" 2 3
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/fold_right.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/while.hpp" 2 3
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/while.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/detail/while.hpp" 1 3
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/control/while.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/arithmetic/add.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/tuple/elem.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/arithmetic/add.hpp" 2 3
# 67 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/arithmetic/sub.hpp" 1 3
# 68 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na_spec.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/if.hpp" 2 3





namespace boost { namespace mpl {



template<
      bool C
    , typename T1
    , typename T2
    >
struct if_c
{
    typedef T1 type;
};

template<
      typename T1
    , typename T2
    >
struct if_c<false,T1,T2>
{
    typedef T2 type;
};



template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = na
    >
struct if_
{
 private:

    typedef if_c<



          static_cast<bool>(T1::value)

        , T2
        , T3
        > almost_type_;

 public:
    typedef typename almost_type_::type type;

   
};
# 131 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/if.hpp" 3
template<> struct if_< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : if_< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< if_< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef if_< na , na , na > result_; typedef if_< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< if_< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< if_< na , na , na > > : int_<-1> { }; }

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/eval_if.hpp" 2 3






namespace boost { namespace mpl {

template<
      typename C = na
    , typename F1 = na
    , typename F2 = na
    >
struct eval_if




{
    typedef typename if_<C,F1,F2>::type f_;
    typedef typename f_::type type;




   
};



template<
      bool C
    , typename F1
    , typename F2
    >
struct eval_if_c




{
    typedef typename if_c<C,F1,F2>::type f_;
    typedef typename f_::type type;




};

template<> struct eval_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : eval_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< eval_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef eval_if< na , na , na > result_; typedef eval_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< eval_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< eval_if< na , na , na > > : int_<-1> { }; }

}}
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/level.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/level_enum.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/level_enum.hpp" 3
namespace boost {
namespace serialization {





enum level_type
{


    not_serializable = 0,






    primitive_type = 1,



    object_serializable = 2,







    object_class_info = 3
};

}
}
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/level.hpp" 2 3

namespace boost {
namespace serialization {

struct basic_traits;


template<class T>
struct implementation_level {
    template<class U>
    struct traits_class_level {
        typedef typename U::level type;
    };

    typedef mpl::integral_c_tag tag;


    typedef
        typename mpl::eval_if<
            is_base_and_derived<boost::serialization::basic_traits, T>,
            traits_class_level<T>,

        typename mpl::eval_if<
            is_fundamental<T>,
            mpl::int_<primitive_type>,

        typename mpl::eval_if<
            is_class<T>,
            mpl::int_<object_class_info>,

        typename mpl::eval_if<
            is_array<T>,



                mpl::int_<object_serializable>,


        typename mpl::eval_if<
            is_enum<T>,



                mpl::int_<primitive_type>,


            mpl::int_<not_serializable>
        >
        >
        >
        >
        >::type type;

    static const int value = implementation_level::type::value;
};


template<class T, int L >
inline bool operator>=(implementation_level<T> t, enum level_type l)
{
    return t.value >= (int)l;
}

}
}
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/nvp.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/tracking.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/tracking.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/identity.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/identity.hpp" 3
namespace boost { namespace mpl {

template<
      typename T = na
    >
struct identity
{
    typedef T type;
   
};

template<
      typename T = na
    >
struct make_identity
{
    typedef identity<T> type;
   
};

template<> struct identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : identity< T1 > { }; }; template< typename Tag > struct lambda< identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef identity< na > result_; typedef identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< identity< T1 > > : int_<1> { }; template<> struct template_arity< identity< na > > : int_<-1> { }; }
template<> struct make_identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : make_identity< T1 > { }; }; template< typename Tag > struct lambda< make_identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef make_identity< na > result_; typedef make_identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< make_identity< T1 > > : int_<1> { }; template<> struct template_arity< make_identity< na > > : int_<-1> { }; }

}}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/tracking.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/equal_to.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/equal_to.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/numeric_cast.hpp" 1 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/numeric_cast.hpp" 3
namespace boost { namespace mpl {



template< typename SourceTag, typename TargetTag > struct numeric_cast
{
    template< typename N > struct apply;
};

}}
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/has_apply.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/has_apply.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/has_xxx.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/has_xxx.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/type_wrapper.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/type_wrapper.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< typename T > struct type_wrapper
{
    typedef T type;
};






template< typename T > struct wrapped_type;

template< typename T > struct wrapped_type< type_wrapper<T> >
{
    typedef T type;
};







}}}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/has_xxx.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/yes_no.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/yes_no.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/arrays.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/yes_no.hpp" 2 3




namespace boost { namespace mpl { namespace aux {

typedef char (&no_tag)[1];
typedef char (&yes_tag)[2];

template< bool C_ > struct yes_no_tag
{
    typedef no_tag type;
};

template<> struct yes_no_tag<true>
{
    typedef yes_tag type;
};


template< long n > struct weighted_tag
{

    typedef char (&type)[n];




};
# 56 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/yes_no.hpp" 3
}}}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/has_xxx.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/has_xxx.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/has_xxx.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/msvc_typename.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/has_xxx.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/has_apply.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/has_apply.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/has_apply.hpp" 2 3

namespace boost { namespace mpl { namespace aux {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_apply { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::apply>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };







}}}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/msvc_never_true.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/use_preprocessed.hpp" 1 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/compiler.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/stringize.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp" 3
namespace boost { namespace mpl {

template<
      typename F

    , typename has_apply_ = typename aux::has_apply<F>::type

    >
struct apply_wrap0

    : F::template apply< >
{
};

template< typename F >
struct apply_wrap0< F,true_ >
    : F::apply
{
};

template<
      typename F, typename T1

    >
struct apply_wrap1

    : F::template apply<T1>
{
};

template<
      typename F, typename T1, typename T2

    >
struct apply_wrap2

    : F::template apply< T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3

    >
struct apply_wrap3

    : F::template apply< T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4

    >
struct apply_wrap4

    : F::template apply< T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5

    >
struct apply_wrap5

    : F::template apply< T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/tag.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/tag.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/void.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/void.hpp" 3
namespace mpl_ {





struct void_ { typedef void_ type; };

}

namespace boost { namespace mpl {

template< typename T >
struct is_void_
    : false_
{



};

template<>
struct is_void_<void_>
    : true_
{



};

template< typename T >
struct is_not_void_
    : true_
{



};

template<>
struct is_not_void_<void_>
    : false_
{



};

template<> struct is_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_void_< T1 > { }; }; template< typename Tag > struct lambda< is_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_void_< na > result_; typedef is_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_void_< na > > : int_<-1> { }; }
template<> struct is_not_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_not_void_< T1 > { }; }; template< typename Tag > struct lambda< is_not_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_not_void_< na > result_; typedef is_not_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_not_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_not_void_< na > > : int_<-1> { }; }

}}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/tag.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/has_tag.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/has_tag.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_tag { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::tag>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/tag.hpp" 2 3


namespace boost { namespace mpl {

namespace aux {
template< typename T > struct tag_impl
{
    typedef typename T::tag type;
};
}

template< typename T, typename Default = void_ > struct tag

    : if_<
          aux::has_tag<T>
        , aux::tag_impl<T>
        , Default
        >::type
{
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/tag.hpp" 3
};

}}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_cast_utils.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_cast_utils.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_cast_utils.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/forwarding.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_cast_utils.hpp" 2 3

namespace boost { namespace mpl { namespace aux {

template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast1st_impl
{
    template< typename N1, typename N2 > struct apply

        : apply_wrap2<
              F
            , typename apply_wrap1< numeric_cast<Tag1,Tag2>,N1 >::type
            , N2
            >
    {
# 46 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_cast_utils.hpp" 3
    };
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast2nd_impl
{
    template< typename N1, typename N2 > struct apply

        : apply_wrap2<
              F
            , N1
            , typename apply_wrap1< numeric_cast<Tag2,Tag1>,N2 >::type
            >
    {
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_cast_utils.hpp" 3
    };
};

}}}
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/msvc_eti_base.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/msvc_eti_base.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/is_msvc_eti_arg.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/is_msvc_eti_arg.hpp" 3
namespace boost { namespace mpl { namespace aux {
# 62 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/is_msvc_eti_arg.hpp" 3
}}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/msvc_eti_base.hpp" 2 3




namespace boost { namespace mpl { namespace aux {
# 55 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/msvc_eti_base.hpp" 3
template< typename T > struct msvc_eti_base
    : T
{

    msvc_eti_base();

    typedef T type;
};



template<> struct msvc_eti_base<int>
{
    typedef msvc_eti_base type;
    typedef msvc_eti_base first;
    typedef msvc_eti_base second;
    typedef msvc_eti_base tag;
    enum { value = 0 };
};

}}}
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 2 3







# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/equal_to.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct equal_to_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< equal_to_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< equal_to_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct equal_to_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct equal_to_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct equal_to_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct equal_to_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct equal_to

    : equal_to_impl<
          typename equal_to_tag<N1>::type
        , typename equal_to_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct equal_to< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : equal_to< T1 , T2 > { }; }; template< typename Tag > struct lambda< equal_to< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef equal_to< na , na > result_; typedef equal_to< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< equal_to< T1 , T2 > > : int_<2> { }; template<> struct template_arity< equal_to< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct equal_to_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value == N2::value ) >
    {
    };
};

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/equal_to.hpp" 2 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/tracking.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/greater.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/greater.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 2 3







# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/greater.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct greater_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< greater_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< greater_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct greater_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct greater_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct greater

    : greater_impl<
          typename greater_tag<N1>::type
        , typename greater_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct greater< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : greater< T1 , T2 > { }; }; template< typename Tag > struct lambda< greater< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef greater< na , na > result_; typedef greater< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< greater< T1 , T2 > > : int_<2> { }; template<> struct template_arity< greater< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct greater_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value > N2::value ) >
    {
    };
};

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/greater.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/tracking.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pointer.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pointer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_pointer.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_pointer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_function_pointer.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_function_pointer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 3
namespace boost {
namespace type_traits {

template <typename T>
struct is_mem_fun_pointer_impl
{
    static const bool value = false;
};





template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) > { static const bool value = true; };



template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const volatile > { static const bool value = true; };


template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) > { static const bool value = true; };



template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const volatile > { static const bool value = true; };
# 776 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 3
}
}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_function_pointer.hpp" 2 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_function_pointer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_function_pointer.hpp" 2 3

namespace boost {



template< typename T > struct is_member_function_pointer : ::boost::integral_constant<bool,::boost::type_traits::is_mem_fun_pointer_impl<typename remove_cv<T>::type>::value> { };
# 130 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_function_pointer.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 133 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_function_pointer.hpp" 2 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_pointer.hpp" 2 3
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_pointer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_pointer.hpp" 2 3

namespace boost {






template< typename T > struct is_member_pointer : ::boost::integral_constant<bool,::boost::is_member_function_pointer<T>::value> { };
template< typename T, typename U > struct is_member_pointer< U T::* > : ::boost::integral_constant<bool,true> { };


template< typename T, typename U > struct is_member_pointer< U T::*const > : ::boost::integral_constant<bool,true> { };
template< typename T, typename U > struct is_member_pointer< U T::*volatile > : ::boost::integral_constant<bool,true> { };
template< typename T, typename U > struct is_member_pointer< U T::*const volatile > : ::boost::integral_constant<bool,true> { };
# 110 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_pointer.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 113 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_member_pointer.hpp" 2 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pointer.hpp" 2 3
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pointer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pointer.hpp" 2 3

namespace boost {



namespace detail {

template< typename T > struct is_pointer_helper
{
    static const bool value = false;
};
# 61 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pointer.hpp" 3
template< typename T > struct is_pointer_helper<T*> { static const bool value = true; };



template< typename T >
struct is_pointer_impl
{
# 78 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pointer.hpp" 3
    static const bool value = (::boost::type_traits::ice_and< ::boost::detail::is_pointer_helper<typename remove_cv<T>::type>::value , ::boost::type_traits::ice_not< ::boost::is_member_pointer<T>::value >::value >::value);
# 87 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pointer.hpp" 3
};

}

template< typename T > struct is_pointer : ::boost::integral_constant<bool,::boost::detail::is_pointer_impl<T>::value> { };
# 156 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pointer.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 159 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pointer.hpp" 2 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/tracking.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/tracking_enum.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/tracking_enum.hpp" 3
namespace boost {
namespace serialization {






enum tracking_type
{

    track_never = 0,


    track_selectively = 1,

    track_always = 2
};

}
}
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/tracking.hpp" 2 3

namespace boost {
namespace serialization {

struct basic_traits;


template<class T>
struct tracking_level {
    template<class U>
    struct traits_class_tracking {
        typedef typename U::tracking type;
    };
    typedef mpl::integral_c_tag tag;


    typedef
        typename mpl::eval_if<
            is_base_and_derived<boost::serialization::basic_traits, T>,
            traits_class_tracking<T>,

        typename mpl::eval_if<
            is_pointer<T>,

            mpl::int_<track_never>,

        typename mpl::eval_if<

            typename mpl::equal_to<
                implementation_level<T>,
                mpl::int_<primitive_type>
            >,

            mpl::int_<track_never>,

            mpl::int_<track_selectively>
    > > >::type type;
    static const int value = tracking_level::type::value;
};


template<class T, enum tracking_type L>
inline bool operator>=(tracking_level<T> t, enum tracking_type l)
{
    return t.value >= (int)l;
}

}
}
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/nvp.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/split_member.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/split_member.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/access.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/access.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/pfto.hpp" 1 3
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/pfto.hpp" 3
namespace boost {

template<class T>
struct pfto_wrapper {
    const T & t;
    operator const T & (){
        return t;
    }
    pfto_wrapper (const T & rhs) : t(rhs) {}
};

template<class T>
pfto_wrapper<T> make_pfto_wrapper(const T & t, int){
    return pfto_wrapper<T>(t);
}

template<class T>
pfto_wrapper<T> make_pfto_wrapper(const pfto_wrapper<T> & t, int){
    return t;
}

}
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/access.hpp" 2 3

namespace boost {

namespace archive {
namespace detail {
    template<class Archive, class T>
    class iserializer;
    template<class Archive, class T>
    class oserializer;
}
}

namespace serialization {


template<class Archive, class T>
inline void serialize_adl(Archive &, T &, const unsigned int);
namespace detail {
    template<class Archive, class T>
    struct member_saver;
    template<class Archive, class T>
    struct member_loader;
}






class access {
public:




    template<class Archive, class T>
    friend struct detail::member_saver;
    template<class Archive, class T>
    friend struct detail::member_loader;
    template<class Archive, class T>
    friend class archive::detail::iserializer;
    template<class Archive, class T>
    friend class archive::detail::oserializer;
    template<class Archive, class T>
    friend inline void serialize(
        Archive & ar,
        T & t,
        const unsigned int file_version
    );
    template<class Archive, class T>
    friend inline void save_construct_data(
        Archive & ar,
        const T * t,
        const unsigned int file_version
    );
    template<class Archive, class T>
    friend inline void load_construct_data(
        Archive & ar,
        T * t,
        const unsigned int file_version
    );



    template<class Archive, class T>
    static void member_save(
        Archive & ar,

        T & t,
        const unsigned int file_version
    ){
        t.save(ar, file_version);
    }
    template<class Archive, class T>
    static void member_load(
        Archive & ar,
        T & t,
        const unsigned int file_version
    ){
        t.load(ar, file_version);
    }
    template<class Archive, class T>
    static void serialize(
        Archive & ar,
        T & t,
        const unsigned int file_version
    ){
        t.serialize(ar, file_version);
    }
    template<class T>
    static void destroy( const T * t)
    {


        delete const_cast<T *>(t);
    }
    template<class Archive, class T>
    static void construct(Archive & , T * t){



        ::new(t)T;
    }
};

}
}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/split_member.hpp" 2 3

namespace boost {
namespace archive {
    namespace detail {
        template<class Archive> class interface_oarchive;
        template<class Archive> class interface_iarchive;
    }
}

namespace serialization {
namespace detail {

    template<class Archive, class T>
    struct member_saver {
        static void invoke(
            Archive & ar,
            const T & t,
            const unsigned int file_version
        ){
            access::member_save(ar, t, file_version);
        }
    };

    template<class Archive, class T>
    struct member_loader {
        static void invoke(
            Archive & ar,
            T & t,
            const unsigned int file_version
        ){
            access::member_load(ar, t, file_version);
        }
    };

}

template<class Archive, class T>
inline void split_member(
    Archive & ar, T & t, const unsigned int file_version
){
    typedef typename mpl::eval_if<
        typename Archive::is_saving,
        mpl::identity<detail::member_saver<Archive, T> >,
        mpl::identity<detail::member_loader<Archive, T> >
    >::type typex;
    typex::invoke(ar, t, file_version);
}

}
}
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/nvp.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/base_object.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/base_object.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_const.hpp" 1 3
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_const.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_const.hpp" 2 3

namespace boost {







   template< typename T > struct is_const : ::boost::integral_constant<bool,::boost::detail::cv_traits_imp<T*>::is_const> { };

template< typename T > struct is_const< T& > : ::boost::integral_constant<bool,false> { };
# 137 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_const.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 140 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_const.hpp" 2 3
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/base_object.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_polymorphic.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_polymorphic.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_polymorphic.hpp" 2 3


namespace boost{



namespace detail{

template <class T>
struct is_polymorphic_imp1
{



   typedef typename remove_cv<T>::type ncvT;
   struct d1 : public ncvT
   {
      d1();



      char padding[256];
   private:

      d1(const d1&);
      d1& operator=(const d1&);
   };
   struct d2 : public ncvT
   {
      d2();
      virtual ~d2()throw();



      struct unique{};
      virtual void unique_name_to_boost5487629(unique*);

      char padding[256];
   private:

      d2(const d2&);
      d2& operator=(const d2&);
   };

   static const bool value = (sizeof(d2) == sizeof(d1));
};

template <class T>
struct is_polymorphic_imp2
{
   static const bool value = false;
};

template <bool is_class>
struct is_polymorphic_selector
{
   template <class T>
   struct rebind
   {
      typedef is_polymorphic_imp2<T> type;
   };
};

template <>
struct is_polymorphic_selector<true>
{
   template <class T>
   struct rebind
   {
      typedef is_polymorphic_imp1<T> type;
   };
};

template <class T>
struct is_polymorphic_imp
{
   typedef is_polymorphic_selector< ::boost::is_class<T>::value> selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type imp_type;
   static const bool value = imp_type::value;
};

}

template< typename T > struct is_polymorphic : ::boost::integral_constant<bool,::boost::detail::is_polymorphic_imp<T>::value> { };







}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 113 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_polymorphic.hpp" 2 3
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/base_object.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/force_include.hpp" 1 3
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/base_object.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/void_cast_fwd.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/void_cast_fwd.hpp" 3
namespace boost {
namespace serialization {
namespace void_cast_detail{
class void_caster;
}
template<class Derived, class Base>

inline const void_cast_detail::void_caster & void_cast_register(
    const Derived * dnull = __null,
    const Base * bnull = __null
) __attribute__ ((used));
}
}
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/base_object.hpp" 2 3

namespace boost {
namespace serialization {

namespace detail
{


    template<class B, class D>
    struct base_cast
    {
        typedef typename
        mpl::if_<
            is_const<D>,
            const B,
            B
        >::type type;
        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((is_const<type>::value == is_const<D>::value) == 0 ? false : true) >)> boost_static_assert_typedef_56;
    };


    template<class Base, class Derived>
    struct base_register
    {
        struct polymorphic {
            static void const * invoke(){
                return &void_cast_register((Derived const*)0, (Base const*)0);
            }
        };
        struct non_polymorphic {
            static void const * invoke(){
                return 0;
            }
        };
        static void const * invoke(){
            typedef typename mpl::eval_if<
                is_polymorphic<Base>,
                mpl::identity<polymorphic>,
                mpl::identity<non_polymorphic>
            >::type type;
            return type::invoke();
        }
    };

}
# 95 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/base_object.hpp" 3
template<class Base, class Derived>
typename detail::base_cast<Base, Derived>::type &
base_object(Derived &d)
{
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_base_and_derived<Base,Derived>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_99;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((! is_pointer<Derived>::value) == 0 ? false : true) >)> boost_static_assert_typedef_100;
    typedef typename detail::base_cast<Base, Derived>::type type;
    detail::base_register<type, Derived>::invoke();
    return static_cast<type &>(d);
}


}
}
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/nvp.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/traits.hpp" 1 3
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/traits.hpp" 3
namespace boost {
namespace serialization {


struct basic_traits {};

template <class T>
struct extended_type_info_impl;

template<
    class T,
    int Level,
    int Tracking,
    unsigned int Version = 0,
    class ETII = extended_type_info_impl< T >,
    class Wrapper = mpl::false_
>
struct traits : public basic_traits {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((Version == 0 || Level >= object_class_info) == 0 ? false : true) >)> boost_static_assert_typedef_53;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((Tracking == track_never || Level >= object_serializable) == 0 ? false : true) >)> boost_static_assert_typedef_54;
    typedef typename mpl::int_<Level> level;
    typedef typename mpl::int_<Tracking> tracking;
    typedef typename mpl::int_<Version> version;
    typedef ETII type_info_implementation;
    typedef Wrapper is_wrapper;
};

}
}
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/nvp.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/wrapper.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/wrapper.hpp" 3
namespace boost { namespace serialization {







template<
    class T,
    int Level = object_serializable,
    int Tracking = track_never,
    unsigned int Version = 0,
    class ETII = extended_type_info_impl< T >
>
struct wrapper_traits : public traits<T,Level,Tracking,Version,ETII,mpl::true_>
{};



namespace detail {
template <class T>
struct is_wrapper_member
{
  typedef typename T::is_wrapper type;
};

}


template<class T>
struct is_wrapper
 : mpl::eval_if<
      is_base_and_derived<basic_traits,T>,
      detail::is_wrapper_member<T>,
      mpl::false_
    >::type
{};

} }
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/nvp.hpp" 2 3

namespace boost {
namespace serialization {

template<class T>
struct nvp :
    public std::pair<const char *, T *>,
    public wrapper_traits<nvp<T> >
{
    explicit nvp(const char * name, T & t) :

        std::pair<const char *, T *>(name, (T*)(& t))
    {}
    nvp(const nvp & rhs) :

        std::pair<const char *, T *>(rhs.first, (T*)rhs.second)
    {}

    const char * name() const {
        return this->first;
    }
    T & value() const {
        return *(this->second);
    }

    const T & const_value() const {
        return *(this->second);
    }







    template<class Archivex>
    void save(
        Archivex & ar,
        const unsigned int
    ) const {

        ar.operator<<(const_value());
    }
    template<class Archivex>
    void load(
        Archivex & ar,
        const unsigned int
    ){

        ar.operator>>(value());
    }
    template<class Archive> void serialize( Archive &ar, const unsigned int file_version ){ boost::serialization::split_member(ar, *this, file_version); }
};

template<class T>
inline

const

nvp<T> make_nvp(const char * name, T & t){
    return nvp<T>(name, t);
}
# 127 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/nvp.hpp" 3
}
}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collections_save_imp.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/serialization.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/serialization.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/strong_typedef.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/strong_typedef.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/operators.hpp" 1 3
# 81 "/Library/Application Support/MonkeyWorks/Developer/include/boost/operators.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iterator" 1 3
# 63 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iterator" 3
       
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iterator" 3
# 72 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iterator" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stream_iterator.h" 1 3
# 38 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stream_iterator.h" 3
       
# 39 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stream_iterator.h" 3



namespace std
{

  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      istream_iterator()
      : _M_stream(0), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {
 ;


 return _M_value;
      }

      const _Tp*
      operator->() const { return &(operator*()); }

      istream_iterator&
      operator++()
      {
 ;


 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {
 ;


 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 150 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
# 181 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {
 ;


 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };
}
# 73 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/iterator" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator.hpp" 2 3



namespace boost
{
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator.hpp" 3
  namespace detail {
   template <class Category, class T, class Distance, class Pointer, class Reference>

   struct iterator_base : std::iterator<Category, T, Distance, Pointer, Reference> {};
# 51 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator.hpp" 3
  }

  template <class Category, class T, class Distance = std::ptrdiff_t,
            class Pointer = T*, class Reference = T&>
  struct iterator : boost::detail::iterator_base<Category, T, Distance, Pointer, Reference> {};

}
# 82 "/Library/Application Support/MonkeyWorks/Developer/include/boost/operators.hpp" 2 3
# 92 "/Library/Application Support/MonkeyWorks/Developer/include/boost/operators.hpp" 3
namespace boost {
namespace detail {

template <typename T> class empty_base {






};

}
}
# 115 "/Library/Application Support/MonkeyWorks/Developer/include/boost/operators.hpp" 3
namespace boost
{







template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct less_than_comparable2 : B
{
     friend bool operator<=(const T& x, const U& y) { return !(x > y); }
     friend bool operator>=(const T& x, const U& y) { return !(x < y); }
     friend bool operator>(const U& x, const T& y) { return y < x; }
     friend bool operator<(const U& x, const T& y) { return y > x; }
     friend bool operator<=(const U& x, const T& y) { return !(y < x); }
     friend bool operator>=(const U& x, const T& y) { return !(y > x); }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct less_than_comparable1 : B
{
     friend bool operator>(const T& x, const T& y) { return y < x; }
     friend bool operator<=(const T& x, const T& y) { return !(y < x); }
     friend bool operator>=(const T& x, const T& y) { return !(x < y); }
};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct equality_comparable2 : B
{
     friend bool operator==(const U& y, const T& x) { return x == y; }
     friend bool operator!=(const U& y, const T& x) { return !(x == y); }
     friend bool operator!=(const T& y, const U& x) { return !(y == x); }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct equality_comparable1 : B
{
     friend bool operator!=(const T& x, const T& y) { return !(x == y); }
};
# 251 "/Library/Application Support/MonkeyWorks/Developer/include/boost/operators.hpp" 3
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct multipliable2 : B { friend T operator *( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } friend T operator *( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv *= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct multipliable1 : B { friend T operator *( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct addable2 : B { friend T operator +( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } friend T operator +( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv += lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct addable1 : B { friend T operator +( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct subtractable2 : B { friend T operator -( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct subtractable2_left : B { friend T operator -( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct subtractable1 : B { friend T operator -( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct dividable2 : B { friend T operator /( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct dividable2_left : B { friend T operator /( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct dividable1 : B { friend T operator /( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct modable2 : B { friend T operator %( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct modable2_left : B { friend T operator %( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct modable1 : B { friend T operator %( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct xorable2 : B { friend T operator ^( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } friend T operator ^( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv ^= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct xorable1 : B { friend T operator ^( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct andable2 : B { friend T operator &( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } friend T operator &( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv &= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct andable1 : B { friend T operator &( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct orable2 : B { friend T operator |( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } friend T operator |( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv |= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct orable1 : B { friend T operator |( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } };







template <class T, class B = ::boost::detail::empty_base<T> >
struct incrementable : B
{
  friend T operator++(T& x, int)
  {
    incrementable_type nrv(x);
    ++x;
    return nrv;
  }
private:
  typedef T incrementable_type;
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct decrementable : B
{
  friend T operator--(T& x, int)
  {
    decrementable_type nrv(x);
    --x;
    return nrv;
  }
private:
  typedef T decrementable_type;
};



template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct dereferenceable : B
{
  P operator->() const
  {
    return &*static_cast<const T&>(*this);
  }
};

template <class T, class I, class R, class B = ::boost::detail::empty_base<T> >
struct indexable : B
{
  R operator[](I n) const
  {
    return *(static_cast<const T&>(*this) + n);
  }
};
# 349 "/Library/Application Support/MonkeyWorks/Developer/include/boost/operators.hpp" 3
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct left_shiftable2 : B { friend T operator <<( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct left_shiftable1 : B { friend T operator <<( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct right_shiftable2 : B { friend T operator >>( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct right_shiftable1 : B { friend T operator >>( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } };



template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct equivalent2 : B
{
  friend bool operator==(const T& x, const U& y)
  {
    return !(x < y) && !(x > y);
  }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct equivalent1 : B
{
  friend bool operator==(const T&x, const T&y)
  {
    return !(x < y) && !(y < x);
  }
};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct partially_ordered2 : B
{
  friend bool operator<=(const T& x, const U& y)
    { return (x < y) || (x == y); }
  friend bool operator>=(const T& x, const U& y)
    { return (x > y) || (x == y); }
  friend bool operator>(const U& x, const T& y)
    { return y < x; }
  friend bool operator<(const U& x, const T& y)
    { return y > x; }
  friend bool operator<=(const U& x, const T& y)
    { return (y > x) || (y == x); }
  friend bool operator>=(const U& x, const T& y)
    { return (y < x) || (y == x); }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct partially_ordered1 : B
{
  friend bool operator>(const T& x, const T& y)
    { return y < x; }
  friend bool operator<=(const T& x, const T& y)
    { return (x < y) || (x == y); }
  friend bool operator>=(const T& x, const T& y)
    { return (y < x) || (x == y); }
};



template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct totally_ordered2
    : less_than_comparable2<T, U
    , equality_comparable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct totally_ordered1
    : less_than_comparable1<T
    , equality_comparable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct additive2
    : addable2<T, U
    , subtractable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct additive1
    : addable1<T
    , subtractable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct multiplicative2
    : multipliable2<T, U
    , dividable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct multiplicative1
    : multipliable1<T
    , dividable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct integer_multiplicative2
    : multiplicative2<T, U
    , modable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct integer_multiplicative1
    : multiplicative1<T
    , modable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct arithmetic2
    : additive2<T, U
    , multiplicative2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct arithmetic1
    : additive1<T
    , multiplicative1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct integer_arithmetic2
    : additive2<T, U
    , integer_multiplicative2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct integer_arithmetic1
    : additive1<T
    , integer_multiplicative1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct bitwise2
    : xorable2<T, U
    , andable2<T, U
    , orable2<T, U, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct bitwise1
    : xorable1<T
    , andable1<T
    , orable1<T, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct unit_steppable
    : incrementable<T
    , decrementable<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct shiftable2
    : left_shiftable2<T, U
    , right_shiftable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct shiftable1
    : left_shiftable1<T
    , right_shiftable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ring_operators2
    : additive2<T, U
    , subtractable2_left<T, U
    , multipliable2<T, U, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ring_operators1
    : additive1<T
    , multipliable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_ring_operators2
    : ring_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_ring_operators1
    : ring_operators1<T
    , totally_ordered1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct field_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct field_operators1
    : ring_operators1<T
    , dividable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_field_operators2
    : field_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_field_operators1
    : field_operators1<T
    , totally_ordered1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct euclidian_ring_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U
    , modable2<T, U
    , modable2_left<T, U, B
      > > > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct euclidian_ring_operators1
    : ring_operators1<T
    , dividable1<T
    , modable1<T, B
      > > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidian_ring_operators2
    : totally_ordered2<T, U
    , euclidian_ring_operators2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidian_ring_operators1
    : totally_ordered1<T
    , euclidian_ring_operators1<T, B
      > > {};

template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct input_iteratable
    : equality_comparable1<T
    , incrementable<T
    , dereferenceable<T, P, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct output_iteratable
    : incrementable<T, B
      > {};

template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct forward_iteratable
    : input_iteratable<T, P, B
      > {};

template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct bidirectional_iteratable
    : forward_iteratable<T, P
    , decrementable<T, B
      > > {};





template <class T, class P, class D, class R, class B = ::boost::detail::empty_base<T> >
struct random_access_iteratable
    : bidirectional_iteratable<T, P
    , less_than_comparable1<T
    , additive2<T, D
    , indexable<T, D, R, B
      > > > > {};


}
# 687 "/Library/Application Support/MonkeyWorks/Developer/include/boost/operators.hpp" 3
namespace boost {


namespace detail {
  struct true_t {};
  struct false_t {};
}




template<class T> struct is_chained_base {
  typedef ::boost::detail::false_t value;
};

}
# 798 "/Library/Application Support/MonkeyWorks/Developer/include/boost/operators.hpp" 3
namespace boost {

template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct less_than_comparable : less_than_comparable2<T, U, B> {}; template<class T, class U, class B> struct less_than_comparable<T, U, B, ::boost::detail::true_t> : less_than_comparable1<T, U> {}; template <class T, class B> struct less_than_comparable<T, T, B, ::boost::detail::false_t> : less_than_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::less_than_comparable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::less_than_comparable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::less_than_comparable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equality_comparable : equality_comparable2<T, U, B> {}; template<class T, class U, class B> struct equality_comparable<T, U, B, ::boost::detail::true_t> : equality_comparable1<T, U> {}; template <class T, class B> struct equality_comparable<T, T, B, ::boost::detail::false_t> : equality_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::equality_comparable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::equality_comparable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::equality_comparable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multipliable : multipliable2<T, U, B> {}; template<class T, class U, class B> struct multipliable<T, U, B, ::boost::detail::true_t> : multipliable1<T, U> {}; template <class T, class B> struct multipliable<T, T, B, ::boost::detail::false_t> : multipliable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::multipliable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::multipliable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::multipliable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct addable : addable2<T, U, B> {}; template<class T, class U, class B> struct addable<T, U, B, ::boost::detail::true_t> : addable1<T, U> {}; template <class T, class B> struct addable<T, T, B, ::boost::detail::false_t> : addable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::addable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::addable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::addable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct subtractable : subtractable2<T, U, B> {}; template<class T, class U, class B> struct subtractable<T, U, B, ::boost::detail::true_t> : subtractable1<T, U> {}; template <class T, class B> struct subtractable<T, T, B, ::boost::detail::false_t> : subtractable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::subtractable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::subtractable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::subtractable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::subtractable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct dividable : dividable2<T, U, B> {}; template<class T, class U, class B> struct dividable<T, U, B, ::boost::detail::true_t> : dividable1<T, U> {}; template <class T, class B> struct dividable<T, T, B, ::boost::detail::false_t> : dividable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::dividable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::dividable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::dividable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::dividable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct modable : modable2<T, U, B> {}; template<class T, class U, class B> struct modable<T, U, B, ::boost::detail::true_t> : modable1<T, U> {}; template <class T, class B> struct modable<T, T, B, ::boost::detail::false_t> : modable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::modable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::modable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::modable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::modable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct xorable : xorable2<T, U, B> {}; template<class T, class U, class B> struct xorable<T, U, B, ::boost::detail::true_t> : xorable1<T, U> {}; template <class T, class B> struct xorable<T, T, B, ::boost::detail::false_t> : xorable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::xorable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::xorable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::xorable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct andable : andable2<T, U, B> {}; template<class T, class U, class B> struct andable<T, U, B, ::boost::detail::true_t> : andable1<T, U> {}; template <class T, class B> struct andable<T, T, B, ::boost::detail::false_t> : andable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::andable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::andable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::andable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct orable : orable2<T, U, B> {}; template<class T, class U, class B> struct orable<T, U, B, ::boost::detail::true_t> : orable1<T, U> {}; template <class T, class B> struct orable<T, T, B, ::boost::detail::false_t> : orable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::orable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::orable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::orable1<T, B> > { typedef ::boost::detail::true_t value; };

 template<class T, class B> struct is_chained_base< ::boost::incrementable<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::decrementable<T, B> > { typedef ::boost::detail::true_t value; };

 template<class T, class U, class B> struct is_chained_base< ::boost::dereferenceable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class V, class B> struct is_chained_base< ::boost::indexable<T, U, V, B> > { typedef ::boost::detail::true_t value; };

template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct left_shiftable : left_shiftable2<T, U, B> {}; template<class T, class U, class B> struct left_shiftable<T, U, B, ::boost::detail::true_t> : left_shiftable1<T, U> {}; template <class T, class B> struct left_shiftable<T, T, B, ::boost::detail::false_t> : left_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::left_shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::left_shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::left_shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct right_shiftable : right_shiftable2<T, U, B> {}; template<class T, class U, class B> struct right_shiftable<T, U, B, ::boost::detail::true_t> : right_shiftable1<T, U> {}; template <class T, class B> struct right_shiftable<T, T, B, ::boost::detail::false_t> : right_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::right_shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::right_shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::right_shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equivalent : equivalent2<T, U, B> {}; template<class T, class U, class B> struct equivalent<T, U, B, ::boost::detail::true_t> : equivalent1<T, U> {}; template <class T, class B> struct equivalent<T, T, B, ::boost::detail::false_t> : equivalent1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::equivalent<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::equivalent2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::equivalent1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct partially_ordered : partially_ordered2<T, U, B> {}; template<class T, class U, class B> struct partially_ordered<T, U, B, ::boost::detail::true_t> : partially_ordered1<T, U> {}; template <class T, class B> struct partially_ordered<T, T, B, ::boost::detail::false_t> : partially_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::partially_ordered<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::partially_ordered2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::partially_ordered1<T, B> > { typedef ::boost::detail::true_t value; };

template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct totally_ordered : totally_ordered2<T, U, B> {}; template<class T, class U, class B> struct totally_ordered<T, U, B, ::boost::detail::true_t> : totally_ordered1<T, U> {}; template <class T, class B> struct totally_ordered<T, T, B, ::boost::detail::false_t> : totally_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::totally_ordered<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::totally_ordered2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::totally_ordered1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct additive : additive2<T, U, B> {}; template<class T, class U, class B> struct additive<T, U, B, ::boost::detail::true_t> : additive1<T, U> {}; template <class T, class B> struct additive<T, T, B, ::boost::detail::false_t> : additive1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::additive<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::additive2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::additive1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multiplicative : multiplicative2<T, U, B> {}; template<class T, class U, class B> struct multiplicative<T, U, B, ::boost::detail::true_t> : multiplicative1<T, U> {}; template <class T, class B> struct multiplicative<T, T, B, ::boost::detail::false_t> : multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::multiplicative<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::multiplicative2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::multiplicative1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_multiplicative : integer_multiplicative2<T, U, B> {}; template<class T, class U, class B> struct integer_multiplicative<T, U, B, ::boost::detail::true_t> : integer_multiplicative1<T, U> {}; template <class T, class B> struct integer_multiplicative<T, T, B, ::boost::detail::false_t> : integer_multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::integer_multiplicative<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::integer_multiplicative2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::integer_multiplicative1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct arithmetic : arithmetic2<T, U, B> {}; template<class T, class U, class B> struct arithmetic<T, U, B, ::boost::detail::true_t> : arithmetic1<T, U> {}; template <class T, class B> struct arithmetic<T, T, B, ::boost::detail::false_t> : arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::arithmetic<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::arithmetic2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::arithmetic1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_arithmetic : integer_arithmetic2<T, U, B> {}; template<class T, class U, class B> struct integer_arithmetic<T, U, B, ::boost::detail::true_t> : integer_arithmetic1<T, U> {}; template <class T, class B> struct integer_arithmetic<T, T, B, ::boost::detail::false_t> : integer_arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::integer_arithmetic<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::integer_arithmetic2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::integer_arithmetic1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct bitwise : bitwise2<T, U, B> {}; template<class T, class U, class B> struct bitwise<T, U, B, ::boost::detail::true_t> : bitwise1<T, U> {}; template <class T, class B> struct bitwise<T, T, B, ::boost::detail::false_t> : bitwise1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::bitwise<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::bitwise2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::bitwise1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::unit_steppable<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct shiftable : shiftable2<T, U, B> {}; template<class T, class U, class B> struct shiftable<T, U, B, ::boost::detail::true_t> : shiftable1<T, U> {}; template <class T, class B> struct shiftable<T, T, B, ::boost::detail::false_t> : shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ring_operators : ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ring_operators<T, U, B, ::boost::detail::true_t> : ring_operators1<T, U> {}; template <class T, class B> struct ring_operators<T, T, B, ::boost::detail::false_t> : ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_ring_operators : ordered_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_ring_operators<T, U, B, ::boost::detail::true_t> : ordered_ring_operators1<T, U> {}; template <class T, class B> struct ordered_ring_operators<T, T, B, ::boost::detail::false_t> : ordered_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct field_operators : field_operators2<T, U, B> {}; template<class T, class U, class B> struct field_operators<T, U, B, ::boost::detail::true_t> : field_operators1<T, U> {}; template <class T, class B> struct field_operators<T, T, B, ::boost::detail::false_t> : field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::field_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::field_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::field_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_field_operators : ordered_field_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_field_operators<T, U, B, ::boost::detail::true_t> : ordered_field_operators1<T, U> {}; template <class T, class B> struct ordered_field_operators<T, T, B, ::boost::detail::false_t> : ordered_field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_field_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_field_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_field_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct euclidian_ring_operators : euclidian_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct euclidian_ring_operators<T, U, B, ::boost::detail::true_t> : euclidian_ring_operators1<T, U> {}; template <class T, class B> struct euclidian_ring_operators<T, T, B, ::boost::detail::false_t> : euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::euclidian_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::euclidian_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::euclidian_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_euclidian_ring_operators : ordered_euclidian_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_euclidian_ring_operators<T, U, B, ::boost::detail::true_t> : ordered_euclidian_ring_operators1<T, U> {}; template <class T, class B> struct ordered_euclidian_ring_operators<T, T, B, ::boost::detail::false_t> : ordered_euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_euclidian_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_euclidian_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_euclidian_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::input_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::output_iteratable<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::forward_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::bidirectional_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class V, class W, class B> struct is_chained_base< ::boost::random_access_iteratable<T, U, V, W, B> > { typedef ::boost::detail::true_t value; };
# 858 "/Library/Application Support/MonkeyWorks/Developer/include/boost/operators.hpp" 3
template <class T, class U>
struct operators2
    : totally_ordered2<T,U
    , integer_arithmetic2<T,U
    , bitwise2<T,U
      > > > {};


template <class T, class U = T>
struct operators : operators2<T, U> {};

template <class T> struct operators<T, T>



    : totally_ordered<T
    , integer_arithmetic<T
    , bitwise<T
    , unit_steppable<T
      > > > > {};




template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V const *,
          class R = V const &>
struct input_iterator_helper
  : input_iteratable<T, P
  , boost::iterator<std::input_iterator_tag, V, D, P, R
    > > {};

template<class T>
struct output_iterator_helper
  : output_iteratable<T
  , boost::iterator<std::output_iterator_tag, void, void, void, void
  > >
{
  T& operator*() { return static_cast<T&>(*this); }
  T& operator++() { return static_cast<T&>(*this); }
};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct forward_iterator_helper
  : forward_iteratable<T, P
  , boost::iterator<std::forward_iterator_tag, V, D, P, R
    > > {};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct bidirectional_iterator_helper
  : bidirectional_iteratable<T, P
  , boost::iterator<std::bidirectional_iterator_tag, V, D, P, R
    > > {};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct random_access_iterator_helper
  : random_access_iteratable<T, P, D, R
  , boost::iterator<std::random_access_iterator_tag, V, D, P, R
    > >
{
  friend D requires_difference_operator(const T& x, const T& y) {
    return x - y;
  }
};

}
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/strong_typedef.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/serialization.hpp" 2 3
# 64 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/serialization.hpp" 3
namespace boost {
namespace serialization {

struct version_type : boost::totally_ordered1< version_type , boost::totally_ordered2< version_type, unsigned int > > { unsigned int t; explicit version_type(const unsigned int t_) : t(t_) {}; version_type(){}; version_type(const version_type & t_) : t(t_.t){} version_type & operator=(const version_type & rhs) { t = rhs.t; return *this;} version_type & operator=(const unsigned int & rhs) { t = rhs; return *this;} operator const unsigned int & () const {return t; } operator unsigned int & () { return t; } bool operator==(const version_type & rhs) const { return t == rhs.t; } bool operator<(const version_type & rhs) const { return t < rhs.t; } };


template<class Archive, class T>
inline void serialize(
    Archive & ar, T & t, const unsigned int file_version
){
    access::serialize(ar, t, static_cast<unsigned int>(file_version));
}


template<class Archive, class T>
inline void save_construct_data(
    Archive & ,
    const T * ,
    const unsigned int
){


}


template<class Archive, class T>
inline void load_construct_data(
    Archive & ar,
    T * t,
    const unsigned int
){



    access::construct(ar, t);
}
# 117 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/serialization.hpp" 3
template<class Archive, class T>
inline void serialize_adl(
    Archive & ar,
    T & t,
    const unsigned int file_version
){
# 132 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/serialization.hpp" 3
        const version_type v(file_version);
        serialize(ar, t, v);



}

template<class Archive, class T>
inline void save_construct_data_adl(
    Archive & ar,
    const T * t,
    const unsigned int file_version
){


        const version_type v(file_version);
        save_construct_data(ar, t, v);



}

template<class Archive, class T>
inline void load_construct_data_adl(
    Archive & ar,
    T * t,
    const unsigned int file_version
){


        const version_type v(file_version);
        load_construct_data(ar, t, v);



}

}
}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collections_save_imp.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/version.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/version.hpp" 3
namespace boost {
namespace serialization {

struct basic_traits;



template<class T>
struct version
{
    template<class U>
    struct traits_class_version {
        typedef typename U::version type;
    };

    typedef mpl::integral_c_tag tag;


    typedef
        typename mpl::eval_if<
            is_base_and_derived<boost::serialization::basic_traits,T>,
            traits_class_version<T>,
            mpl::int_<0>
        >::type type;
    static const unsigned int value = version::type::value;
};

}
}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collections_save_imp.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collection_size_type.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collection_size_type.hpp" 3
namespace boost { namespace serialization {

struct collection_size_type : boost::totally_ordered1< collection_size_type , boost::totally_ordered2< collection_size_type, std::size_t > > { std::size_t t; explicit collection_size_type(const std::size_t t_) : t(t_) {}; collection_size_type(){}; collection_size_type(const collection_size_type & t_) : t(t_.t){} collection_size_type & operator=(const collection_size_type & rhs) { t = rhs.t; return *this;} collection_size_type & operator=(const std::size_t & rhs) { t = rhs; return *this;} operator const std::size_t & () const {return t; } operator std::size_t & () { return t; } bool operator==(const collection_size_type & rhs) const { return t == rhs.t; } bool operator<(const collection_size_type & rhs) const { return t < rhs.t; } };

} }

namespace boost { namespace serialization { template <> struct implementation_level< boost::serialization::collection_size_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level::type::value; }; } }
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collections_save_imp.hpp" 2 3

namespace boost{
namespace serialization {
namespace stl {





template<class Archive, class Container>
inline void save_collection(Archive & ar, const Container &s)
{

    collection_size_type const count(s.size());
    ar << boost::serialization::make_nvp("count", count);


    if(3 < ar.get_library_version()){
        const unsigned int item_version = version<
            typename Container::value_type
        >::value;
        ar << boost::serialization::make_nvp("item_version", item_version);
    }
    typename Container::const_iterator it = s.begin();
    std::size_t c=count;
    while(c-- > 0){

            boost::serialization::save_construct_data_adl(
                ar,
                &(*it),
                boost::serialization::version<
                    typename Container::value_type
                >::value
            );
        ar << boost::serialization::make_nvp("item", *it++);
    }
}

}
}
}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/list.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collections_load_imp.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collections_load_imp.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collections_load_imp.hpp" 2 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collections_load_imp.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/stack_constructor.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/stack_constructor.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/aligned_storage.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/aligned_storage.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/alignment_of.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/alignment_of.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/size_t_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/size_t_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/size_t_trait_def.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/size_t.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/size_t.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/size_t_fwd.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/size_t_fwd.hpp" 3
namespace mpl_ {

template< std::size_t N > struct size_t;

}
namespace boost { namespace mpl { using ::mpl_::size_t; } }
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/size_t.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 3
namespace mpl_ {

template< std::size_t N >
struct size_t
{
    static const std::size_t value = N;





    typedef size_t type;

    typedef std::size_t value_type;
    typedef integral_c_tag tag;
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 3
    typedef mpl_::size_t< static_cast<std::size_t>((value + 1)) > next;
    typedef mpl_::size_t< static_cast<std::size_t>((value - 1)) > prior;






    operator std::size_t() const { return static_cast<std::size_t>(this->value); }
};


template< std::size_t N >
std::size_t const mpl_::size_t< N >::value;


}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/size_t.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/size_t_trait_def.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/alignment_of.hpp" 2 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/alignment_of.hpp" 3
namespace boost {

template <typename T> struct alignment_of;


namespace detail {





template <typename T>
struct alignment_of_hack
{
    char c;
    T t;
    alignment_of_hack();
};




template <unsigned A, unsigned S>
struct alignment_logic
{
    static const std::size_t value = A < S ? A : S;
};


template< typename T >
struct alignment_of_impl
{

    static const std::size_t value = (::boost::detail::alignment_logic< sizeof(::boost::detail::alignment_of_hack<T>) - sizeof(T), sizeof(T) >::value);
# 74 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/alignment_of.hpp" 3
};

}

template< typename T > struct alignment_of : ::boost::integral_constant<std::size_t,::boost::detail::alignment_of_impl<T>::value> { };




template <typename T>
struct alignment_of<T&>
    : alignment_of<T*>
{
};
# 98 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/alignment_of.hpp" 3
template<> struct alignment_of<void> : ::boost::integral_constant<std::size_t,0> { };

template<> struct alignment_of<void const> : ::boost::integral_constant<std::size_t,0> { };
template<> struct alignment_of<void volatile> : ::boost::integral_constant<std::size_t,0> { };
template<> struct alignment_of<void const volatile> : ::boost::integral_constant<std::size_t,0> { };


}
# 114 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/alignment_of.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/size_t_trait_undef.hpp" 1 3
# 115 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/alignment_of.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/aligned_storage.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/for_each_i.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/for_each_i.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/for.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/for.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/for.hpp" 2 3
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/for.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/detail/for.hpp" 1 3
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/for.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/for_each_i.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/tuple/rem.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/for_each_i.hpp" 2 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/tuple/to_list.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/transform.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/list/append.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pod.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pod.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_scalar.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_scalar.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_scalar.hpp" 2 3

namespace boost {

namespace detail {

template <typename T>
struct is_scalar_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_enum<T>::value, ::boost::is_pointer<T>::value, ::boost::is_member_pointer<T>::value >::value);






};



template <> struct is_scalar_impl<void>{ static const bool value = false; };

template <> struct is_scalar_impl<void const>{ static const bool value = false; };
template <> struct is_scalar_impl<void volatile>{ static const bool value = false; };
template <> struct is_scalar_impl<void const volatile>{ static const bool value = false; };


}

template< typename T > struct is_scalar : ::boost::integral_constant<bool,::boost::detail::is_scalar_impl<T>::value> { };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 54 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_scalar.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pod.hpp" 2 3






# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pod.hpp" 2 3

namespace boost {


template< typename T > struct is_POD;

namespace detail {



template <typename T> struct is_pod_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_scalar<T>::value, ::boost::is_void<T>::value, false >::value);






};


template <typename T, std::size_t sz>
struct is_pod_impl<T[sz]>
    : is_pod_impl<T>
{
};
# 118 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pod.hpp" 3
template<> struct is_pod_impl< void > { static const bool value = (true); };


template<> struct is_pod_impl< void const > { static const bool value = (true); };
template<> struct is_pod_impl< void volatile > { static const bool value = (true); };
template<> struct is_pod_impl< void const volatile > { static const bool value = (true); };


}

template< typename T > struct is_POD : ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { };
template< typename T > struct is_pod : ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 134 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_pod.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 3
namespace boost {



namespace detail {

class alignment_dummy;
typedef void (*function_ptr)();
typedef int (alignment_dummy::*member_ptr);
typedef int (alignment_dummy::*member_function_ptr)();
# 101 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 3
template <bool found, std::size_t target, class TestType>
struct lower_alignment_helper
{
    typedef char type;
    enum { value = true };
};

template <std::size_t target, class TestType>
struct lower_alignment_helper<false,target,TestType>
{
    enum { value = (alignment_of<TestType>::value == target) };
    typedef typename mpl::if_c<value, TestType, char>::type type;
};
# 127 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 3
template <typename T>
struct has_one_T
{
  T data;
};

template <std::size_t target>
union lower_alignment
{
    enum { found0 = false };

    typename lower_alignment_helper< found0,target,char >::type t0; enum { found1 = lower_alignment_helper<found0,target,char >::value }; typename lower_alignment_helper< found1,target,short >::type t1; enum { found2 = lower_alignment_helper<found1,target,short >::value }; typename lower_alignment_helper< found2,target,int >::type t2; enum { found3 = lower_alignment_helper<found2,target,int >::value }; typename lower_alignment_helper< found3,target,long >::type t3; enum { found4 = lower_alignment_helper<found3,target,long >::value }; typename lower_alignment_helper< found4,target,::boost::long_long_type >::type t4; enum { found5 = lower_alignment_helper<found4,target,::boost::long_long_type >::value }; typename lower_alignment_helper< found5,target,float >::type t5; enum { found6 = lower_alignment_helper<found5,target,float >::value }; typename lower_alignment_helper< found6,target,double >::type t6; enum { found7 = lower_alignment_helper<found6,target,double >::value }; typename lower_alignment_helper< found7,target,long double >::type t7; enum { found8 = lower_alignment_helper<found7,target,long double >::value }; typename lower_alignment_helper< found8,target,void* >::type t8; enum { found9 = lower_alignment_helper<found8,target,void* >::value }; typename lower_alignment_helper< found9,target,function_ptr >::type t9; enum { found10 = lower_alignment_helper<found9,target,function_ptr >::value }; typename lower_alignment_helper< found10,target,member_ptr >::type t10; enum { found11 = lower_alignment_helper<found10,target,member_ptr >::value }; typename lower_alignment_helper< found11,target,member_function_ptr >::type t11; enum { found12 = lower_alignment_helper<found11,target,member_function_ptr >::value }; typename lower_alignment_helper< found12,target,boost::detail::has_one_T< char > >::type t12; enum { found13 = lower_alignment_helper<found12,target,boost::detail::has_one_T< char > >::value }; typename lower_alignment_helper< found13,target,boost::detail::has_one_T< short > >::type t13; enum { found14 = lower_alignment_helper<found13,target,boost::detail::has_one_T< short > >::value }; typename lower_alignment_helper< found14,target,boost::detail::has_one_T< int > >::type t14; enum { found15 = lower_alignment_helper<found14,target,boost::detail::has_one_T< int > >::value }; typename lower_alignment_helper< found15,target,boost::detail::has_one_T< long > >::type t15; enum { found16 = lower_alignment_helper<found15,target,boost::detail::has_one_T< long > >::value }; typename lower_alignment_helper< found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::type t16; enum { found17 = lower_alignment_helper<found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::value }; typename lower_alignment_helper< found17,target,boost::detail::has_one_T< float > >::type t17; enum { found18 = lower_alignment_helper<found17,target,boost::detail::has_one_T< float > >::value }; typename lower_alignment_helper< found18,target,boost::detail::has_one_T< double > >::type t18; enum { found19 = lower_alignment_helper<found18,target,boost::detail::has_one_T< double > >::value }; typename lower_alignment_helper< found19,target,boost::detail::has_one_T< long double > >::type t19; enum { found20 = lower_alignment_helper<found19,target,boost::detail::has_one_T< long double > >::value }; typename lower_alignment_helper< found20,target,boost::detail::has_one_T< void* > >::type t20; enum { found21 = lower_alignment_helper<found20,target,boost::detail::has_one_T< void* > >::value }; typename lower_alignment_helper< found21,target,boost::detail::has_one_T< function_ptr > >::type t21; enum { found22 = lower_alignment_helper<found21,target,boost::detail::has_one_T< function_ptr > >::value }; typename lower_alignment_helper< found22,target,boost::detail::has_one_T< member_ptr > >::type t22; enum { found23 = lower_alignment_helper<found22,target,boost::detail::has_one_T< member_ptr > >::value }; typename lower_alignment_helper< found23,target,boost::detail::has_one_T< member_function_ptr > >::type t23; enum { found24 = lower_alignment_helper<found23,target,boost::detail::has_one_T< member_function_ptr > >::value };




};

union max_align
{
    char t0; short t1; int t2; long t3; ::boost::long_long_type t4; float t5; double t6; long double t7; void* t8; function_ptr t9; member_ptr t10; member_function_ptr t11; boost::detail::has_one_T< char > t12; boost::detail::has_one_T< short > t13; boost::detail::has_one_T< int > t14; boost::detail::has_one_T< long > t15; boost::detail::has_one_T< ::boost::long_long_type > t16; boost::detail::has_one_T< float > t17; boost::detail::has_one_T< double > t18; boost::detail::has_one_T< long double > t19; boost::detail::has_one_T< void* > t20; boost::detail::has_one_T< function_ptr > t21; boost::detail::has_one_T< member_ptr > t22; boost::detail::has_one_T< member_function_ptr > t23;




};
# 161 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 3
template<std::size_t TAlign, std::size_t Align>
struct is_aligned
{
    static const bool value = (TAlign >= Align) & (TAlign % Align == 0);


};
# 180 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 3
}


template<std::size_t Align>
struct is_pod< ::boost::detail::lower_alignment<Align> >
{
        static const std::size_t value = true;
};




namespace detail{

template <std::size_t Align>
class type_with_alignment_imp
{
    typedef ::boost::detail::lower_alignment<Align> t1;
    typedef typename mpl::if_c<
          ::boost::detail::is_aligned< ::boost::alignment_of<t1>::value,Align >::value
        , t1
        , ::boost::detail::max_align
        >::type align_t;

    static const std::size_t found = alignment_of<align_t>::value;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((found >= Align) == 0 ? false : true) >)> boost_static_assert_typedef_206;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((found % Align == 0) == 0 ? false : true) >)> boost_static_assert_typedef_207;

 public:
    typedef align_t type;
};

}

template <std::size_t Align>
class type_with_alignment
  : public ::boost::detail::type_with_alignment_imp<Align>
{
};


namespace align {
struct __attribute__((__aligned__(2))) a2 {};
struct __attribute__((__aligned__(4))) a4 {};
struct __attribute__((__aligned__(8))) a8 {};
struct __attribute__((__aligned__(16))) a16 {};
struct __attribute__((__aligned__(32))) a32 {};
}

template<> class type_with_alignment<1> { public: typedef char type; };
template<> class type_with_alignment<2> { public: typedef align::a2 type; };
template<> class type_with_alignment<4> { public: typedef align::a4 type; };
template<> class type_with_alignment<8> { public: typedef align::a8 type; };
template<> class type_with_alignment<16> { public: typedef align::a16 type; };
template<> class type_with_alignment<32> { public: typedef align::a32 type; };

namespace detail {
template<> struct is_pod_impl< ::boost::align::a2 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a4 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a8 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a16 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a32 > { static const bool value = (true); };
}
# 381 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 3
}





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 388 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/type_with_alignment.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/aligned_storage.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/aligned_storage.hpp" 2 3

namespace boost {

namespace detail { namespace aligned_storage {

static const std::size_t alignment_of_max_align = ::boost::alignment_of<max_align>::value;







template <
      std::size_t size_
    , std::size_t alignment_
>
struct aligned_storage_imp
{
    union data_t
    {
        char buf[size_];

        typename mpl::eval_if_c<
              alignment_ == std::size_t(-1)
            , mpl::identity<detail::max_align>
            , type_with_alignment<alignment_>
            >::type align_;
    } data_;
};

}}

template <
      std::size_t size_
    , std::size_t alignment_ = std::size_t(-1)
>
class aligned_storage
{
private:

   detail::aligned_storage::aligned_storage_imp<size_, alignment_> data_;

public:

    typedef detail::aligned_storage::aligned_storage_imp<size_, alignment_> type;

    static const std::size_t size = size_;



    static const std::size_t alignment = ( alignment_ == std::size_t(-1) ? ::boost::detail::aligned_storage::alignment_of_max_align : alignment_ );
# 93 "/Library/Application Support/MonkeyWorks/Developer/include/boost/aligned_storage.hpp" 3
private:

    aligned_storage(const aligned_storage&);
    aligned_storage& operator=(const aligned_storage&);
# 107 "/Library/Application Support/MonkeyWorks/Developer/include/boost/aligned_storage.hpp" 3
public:

    aligned_storage()
    {
    }

    ~aligned_storage()
    {
    }

public:

    void* address()
    {
        return this;
    }



    const void* address() const
    {
        return this;
    }







};
# 157 "/Library/Application Support/MonkeyWorks/Developer/include/boost/aligned_storage.hpp" 3
template <std::size_t size_, std::size_t alignment_>
struct is_pod<boost::detail::aligned_storage::aligned_storage_imp<size_,alignment_> >
   : ::boost::integral_constant<bool,true>
{
   
};



}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 169 "/Library/Application Support/MonkeyWorks/Developer/include/boost/aligned_storage.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/stack_constructor.hpp" 2 3

namespace boost{
namespace serialization {
namespace detail {



template<typename T >
struct stack_allocate
{
    T * address() {
        return static_cast<T*>(storage_.address());
    }
    T & reference() {
        return * address();
    }
private:
    typedef typename boost::aligned_storage<
        sizeof(T),



            boost::alignment_of<T>::value

    > type;
    type storage_;
};


template<class Archive, class T>
struct stack_construct : public stack_allocate<T>
{
    stack_construct(Archive & ar, const unsigned int version){

        boost::serialization::load_construct_data_adl(
            ar,
            this->address(),
            version
        );
    }
    ~stack_construct(){
        this->address()->~T();
    }
};

}
}
}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collections_load_imp.hpp" 2 3



namespace boost{
namespace serialization {
namespace stl {






template<class Archive, class Container>
struct archive_input_seq
{
    inline void operator()(
        Archive &ar,
        Container &s,
        const unsigned int v
    ){
        typedef typename Container::value_type type;
        detail::stack_construct<Archive, type> t(ar, v);

        ar >> boost::serialization::make_nvp("item", t.reference());
        s.push_back(t.reference());
        ar.reset_object_address(& s.back() , & t.reference());
    }
};


template<class Archive, class Container>
struct archive_input_map
{
    inline void operator()(
        Archive &ar,
        Container &s,
        const unsigned int v
    ){
        typedef typename Container::value_type type;
        detail::stack_construct<Archive, type> t(ar, v);

        ar >> boost::serialization::make_nvp("item", t.reference());
        std::pair<typename Container::const_iterator, bool> result =
            s.insert(t.reference());



        if(result.second){
            ar.reset_object_address(
                & (result.first->second),
                & t.reference().second
            );
        }
    }
};


template<class Archive, class Container>
struct archive_input_multimap
{
    inline void operator()(
        Archive &ar,
        Container &s,
        const unsigned int v
    ){
        typedef typename Container::value_type type;
        detail::stack_construct<Archive, type> t(ar, v);

        ar >> boost::serialization::make_nvp("item", t.reference());
        typename Container::const_iterator result
            = s.insert(t.reference());



        ar.reset_object_address(
            & result->second,
            & t.reference()
        );
    }
};


template<class Archive, class Container>
struct archive_input_set
{
    inline void operator()(
        Archive &ar,
        Container &s,
        const unsigned int v
    ){
        typedef typename Container::value_type type;
        detail::stack_construct<Archive, type> t(ar, v);

        ar >> boost::serialization::make_nvp("item", t.reference());
        std::pair<typename Container::const_iterator, bool> result =
            s.insert(t.reference());
        if(result.second)
            ar.reset_object_address(& (* result.first), & t.reference());
    }
};


template<class Archive, class Container>
struct archive_input_multiset
{
    inline void operator()(
        Archive &ar,
        Container &s,
        const unsigned int v
    ){
        typedef typename Container::value_type type;
        detail::stack_construct<Archive, type> t(ar, v);

        ar >> boost::serialization::make_nvp("item", t.reference());
        typename Container::const_iterator result
            = s.insert(t.reference());
        ar.reset_object_address(& (* result), & t.reference());
    }
};

template<class Container>
class reserve_imp
{
public:
    void operator()(Container &s, std::size_t count) const {
        s.reserve(count);
    }
};

template<class Container>
class no_reserve_imp
{
public:
    void operator()(Container & , std::size_t ) const{}
};

template<class Archive, class Container, class InputFunction, class R>
inline void load_collection(Archive & ar, Container &s)
{
    s.clear();

    collection_size_type count;
    unsigned int item_version;
    ar >> boost::serialization::make_nvp("count", count);
    if(3 < ar.get_library_version())
        ar >> boost::serialization::make_nvp("item_version", item_version);
    else
        item_version = 0;
    R rx;
    rx(s, count);
    std::size_t c = count;
    InputFunction ifunc;
    while(c-- > 0){
        ifunc(ar, s, item_version);
    }
}

}
}
}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/list.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/split_free.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/split_free.hpp" 3
namespace boost {
namespace archive {
    namespace detail {
        template<class Archive> class interface_oarchive;
        template<class Archive> class interface_iarchive;
    }
}

namespace serialization {


template<class Archive, class T>
struct free_saver {
    static void invoke(
        Archive & ar,
        const T & t,
        const unsigned int file_version
    ){


        const version_type v(file_version);
        save(ar, t, v);
    }
};
template<class Archive, class T>
struct free_loader {
    static void invoke(
        Archive & ar,
        T & t,
        const unsigned int file_version
    ){


        const version_type v(file_version);
        load(ar, t, v);
    }
};


template<class Archive, class T>
inline void split_free(
    Archive & ar,
    T & t,
    const unsigned int file_version
){
    typedef typename mpl::eval_if<
        typename Archive::is_saving,
        mpl::identity< free_saver<Archive, T> >,
        mpl::identity< free_loader<Archive, T> >
    >::type typex;
    typex::invoke(ar, t, file_version);
}

}
}
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/list.hpp" 2 3

namespace boost {
namespace serialization {

template<class Archive, class U, class Allocator>
inline void save(
    Archive & ar,
    const std::list<U, Allocator> &t,
    const unsigned int
){
    boost::serialization::stl::save_collection<
        Archive,
        std::list<U, Allocator>
    >(ar, t);
}

template<class Archive, class U, class Allocator>
inline void load(
    Archive & ar,
    std::list<U, Allocator> &t,
    const unsigned int
){
    boost::serialization::stl::load_collection<
        Archive,
        std::list<U, Allocator>,
        boost::serialization::stl::archive_input_seq<
            Archive,
            std::list<U, Allocator>
        >,
        boost::serialization::stl::no_reserve_imp<std::list<U, Allocator> >
    >(ar, t);
}



template<class Archive, class U, class Allocator>
inline void serialize(
    Archive & ar,
    std::list<U, Allocator> & t,
    const unsigned int file_version
){
    boost::serialization::split_free(ar, t, file_version);
}

}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collection_traits.hpp" 1 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collection_traits.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 85 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 3
namespace boost
{

  using ::int8_t;
  using ::int_least8_t;
  using ::int_fast8_t;
  using ::uint8_t;
  using ::uint_least8_t;
  using ::uint_fast8_t;

  using ::int16_t;
  using ::int_least16_t;
  using ::int_fast16_t;
  using ::uint16_t;
  using ::uint_least16_t;
  using ::uint_fast16_t;

  using ::int32_t;
  using ::int_least32_t;
  using ::int_fast32_t;
  using ::uint32_t;
  using ::uint_least32_t;
  using ::uint_fast32_t;



  using ::int64_t;
  using ::int_least64_t;
  using ::int_fast64_t;
  using ::uint64_t;
  using ::uint_least64_t;
  using ::uint_fast64_t;



  using ::intmax_t;
  using ::uintmax_t;

}
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/collection_traits.hpp" 2 3
# 74 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/list.hpp" 2 3

namespace boost { namespace serialization { template<> struct implementation_level< std::list < bool > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < char > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < signed char > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < unsigned char > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < signed int > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < unsigned int > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < signed long > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < unsigned long > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < float > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < double > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < unsigned short > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < signed short > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < boost::int64_t > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < boost::uint64_t > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; template<> struct implementation_level< std::list < wchar_t > > { typedef mpl::integral_c_tag tag; typedef mpl::int_<object_serializable> type; static const int value = object_serializable; }; } }
# 22 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericData.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/string.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/string.hpp" 3
namespace boost { namespace serialization { template <> struct implementation_level< std::string > { typedef mpl::integral_c_tag tag; typedef mpl::int_< boost::serialization::primitive_type > type; static const int value = implementation_level::type::value; }; } }

namespace boost { namespace serialization { template <> struct implementation_level< std::wstring > { typedef mpl::integral_c_tag tag; typedef mpl::int_< boost::serialization::primitive_type > type; static const int value = implementation_level::type::value; }; } }
# 23 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericData.h" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_oarchive.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_oarchive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_oarchive_impl.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_oarchive_impl.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 2 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_ptr.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_ptr.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_ptr.hpp" 2 3







namespace boost
{
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_ptr.hpp" 3
template<class T> class scoped_ptr
{
private:

    T * ptr;

    scoped_ptr(scoped_ptr const &);
    scoped_ptr & operator=(scoped_ptr const &);

    typedef scoped_ptr<T> this_type;

    void operator==( scoped_ptr const& ) const;
    void operator!=( scoped_ptr const& ) const;

public:

    typedef T element_type;

    explicit scoped_ptr(T * p = 0): ptr(p)
    {



    }



    explicit scoped_ptr(std::auto_ptr<T> p): ptr(p.release())
    {



    }



    ~scoped_ptr()
    {



        boost::checked_delete(ptr);
    }

    void reset(T * p = 0)
    {
        (__builtin_expect(!(p == 0 || p != ptr), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_ptr.hpp", 85, "p == 0 || p != ptr") : (void)0);
        this_type(p).swap(*this);
    }

    T & operator*() const
    {
        (__builtin_expect(!(ptr != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_ptr.hpp", 91, "ptr != 0") : (void)0);
        return *ptr;
    }

    T * operator->() const
    {
        (__builtin_expect(!(ptr != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_ptr.hpp", 97, "ptr != 0") : (void)0);
        return ptr;
    }

    T * get() const
    {
        return ptr;
    }
# 124 "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_ptr.hpp" 3
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return ptr == 0? 0: &this_type::ptr;
    }



    bool operator! () const
    {
        return ptr == 0;
    }

    void swap(scoped_ptr & b)
    {
        T * tmp = b.ptr;
        b.ptr = ptr;
        ptr = tmp;
    }
};

template<class T> inline void swap(scoped_ptr<T> & a, scoped_ptr<T> & b)
{
    a.swap(b);
}



template<class T> inline T * get_pointer(scoped_ptr<T> const & p)
{
    return p.get();
}

}
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_streambuf_locale_saver.hpp" 1 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_streambuf_locale_saver.hpp" 3
namespace boost{
namespace archive{

template < typename Ch, class Tr >
class basic_streambuf_locale_saver
{
public:
    typedef ::std::basic_streambuf<Ch, Tr> state_type;
    typedef ::std::locale aspect_type;
    explicit basic_streambuf_locale_saver( state_type &s )
        : s_save_( s ), a_save_( s.getloc() )
        {}
    basic_streambuf_locale_saver( state_type &s, aspect_type const &a )
        : s_save_( s ), a_save_( s.pubimbue(a) )
        {}
    ~basic_streambuf_locale_saver()
        { this->restore(); }
    void restore()
        { s_save_.pubimbue( a_save_ ); }
private:
    state_type & s_save_;
    aspect_type const a_save_;
};

}
}
# 47 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/archive_exception.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/archive_exception.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/archive_exception.hpp" 2 3

namespace boost {
namespace archive {




class archive_exception :
    public virtual std::exception
{
public:
    typedef enum {
        no_exception,
        other_exception,
        unregistered_class,

        invalid_signature,

        unsupported_version,

        pointer_conflict,





        incompatible_native_format,

        array_size_too_short,
        stream_error,
        invalid_class_name,


        unregistered_cast

    } exception_code;
    exception_code code;
    archive_exception(exception_code c) :
        code(c)
    {}
    virtual const char *what( ) const throw( )
    {
        const char *msg = "programming error";
        switch(code){
        case no_exception:
            msg = "uninitialized exception";
            break;
        case unregistered_class:
            msg = "unregistered class";
            break;
        case invalid_signature:
            msg = "invalid signature";
            break;
        case unsupported_version:
            msg = "unsupported version";
            break;
        case pointer_conflict:
            msg = "pointer conflict";
            break;
        case incompatible_native_format:
            msg = "incompatible native format";
            break;
        case array_size_too_short:
            msg = "array size too short";
            break;
        case stream_error:
            msg = "stream error";
            break;
        case invalid_class_name:
            msg = "class name too long";
            break;
        case unregistered_cast:
            msg = "unregistered void cast";
            break;
        case other_exception:


            msg = "unknown derived exception";
            break;
        default:
            (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/archive_exception.hpp", 101, "false") : (void)0);
            break;
        }
        return msg;
    }
protected:
    archive_exception() :
         code(no_exception)
    {}
};

}
}
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/auto_link_archive.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/auto_link_archive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/decl.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/auto_link_archive.hpp" 2 3
# 45 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/auto_link_archive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/auto_link.hpp" 1 3
# 46 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/auto_link_archive.hpp" 2 3
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/is_bitwise_serializable.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/is_bitwise_serializable.hpp" 3
namespace boost {
namespace serialization {
    template<class T>
    struct is_bitwise_serializable
     : public is_arithmetic<T>
    {};
}
}
# 50 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/placeholders.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/placeholders.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/arg.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/arg.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/arg_fwd.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/arg_fwd.hpp" 3
namespace mpl_ {

template< int N > struct arg;

}
namespace boost { namespace mpl { using ::mpl_::arg; } }
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/arg.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na_assert.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na_assert.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/assert.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/assert.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/not.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/not.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/nested_type_wknd.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/nested_type_wknd.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< typename T > struct nested_type_wknd
    : T::type
{
};
}}}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/not.hpp" 2 3



namespace boost { namespace mpl {

namespace aux {

template< long C_ >
struct not_impl
    : bool_<!C_>
{
};

}


template<
      typename T = na
    >
struct not_
    : aux::not_impl<
          ::boost::mpl::aux::nested_type_wknd<T>::value
        >
{
   
};

template<> struct not_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_< T1 > { }; }; template< typename Tag > struct lambda< not_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_< na > result_; typedef not_< na > type; }; namespace aux { template< typename T1 > struct template_arity< not_< T1 > > : int_<1> { }; template<> struct template_arity< not_< na > > : int_<-1> { }; }

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/assert.hpp" 2 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/assert.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/pp_counter.hpp" 1 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/assert.hpp" 2 3
# 62 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/assert.hpp" 3
namespace mpl_ {

struct failed {};
# 75 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/assert.hpp" 3
template< bool C > struct assert { typedef void* type; };
template<> struct assert<false> { typedef assert type; };

template< bool C >
int assertion_failed( typename assert<C>::type );

template< bool C >
struct assertion
{
    static int failed( assert<false> );
};

template<>
struct assertion<true>
{
    static int failed( void* );
};

struct assert_
{

    template< typename T1, typename T2 = na, typename T3 = na, typename T4 = na > struct types {};

    static assert_ const arg;
    enum relations { equal = 1, not_equal, greater, greater_equal, less, less_equal };
};
# 123 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/assert.hpp" 3
boost::mpl::aux::weighted_tag<1>::type operator==( assert_, assert_ );
boost::mpl::aux::weighted_tag<2>::type operator!=( assert_, assert_ );
boost::mpl::aux::weighted_tag<3>::type operator>( assert_, assert_ );
boost::mpl::aux::weighted_tag<4>::type operator>=( assert_, assert_ );
boost::mpl::aux::weighted_tag<5>::type operator<( assert_, assert_ );
boost::mpl::aux::weighted_tag<6>::type operator<=( assert_, assert_ );

template< assert_::relations r, long x, long y > struct assert_relation {};






template< bool > struct assert_arg_pred_impl { typedef int type; };
template<> struct assert_arg_pred_impl<true> { typedef void* type; };

template< typename P > struct assert_arg_pred
{
    typedef typename P::type p_type;
    typedef typename assert_arg_pred_impl< p_type::value >::type type;
};

template< typename P > struct assert_arg_pred_not
{
    typedef typename P::type p_type;
    enum { p = !p_type::value };
    typedef typename assert_arg_pred_impl<p>::type type;
};

template< typename Pred >
failed ************ (Pred::************
      assert_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type )
    );

template< typename Pred >
failed ************ (boost::mpl::not_<Pred>::************
      assert_not_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type )
    );

template< typename Pred >
assert<false>
assert_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type );

template< typename Pred >
assert<false>
assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type );
# 212 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/assert.hpp" 3
}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/na_assert.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/arg.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/arity_spec.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/arg.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/arg_typedef.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/arg.hpp" 2 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/arg.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 3
namespace mpl_ {
template<> struct arg< -1 >
{
    static const int value = -1;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_27 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<1>
{
    static const int value = 1;
    typedef arg<2> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<2>
{
    static const int value = 2;
    typedef arg<3> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U2 type;
        enum { mpl_assertion_in_line_63 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<3>
{
    static const int value = 3;
    typedef arg<4> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U3 type;
        enum { mpl_assertion_in_line_81 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<4>
{
    static const int value = 4;
    typedef arg<5> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U4 type;
        enum { mpl_assertion_in_line_99 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<5>
{
    static const int value = 5;
    typedef arg<6> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U5 type;
        enum { mpl_assertion_in_line_117 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};



}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/arg.hpp" 2 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/placeholders.hpp" 2 3
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/placeholders.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 3
namespace mpl_ {
typedef arg< -1 > _;
}
namespace boost { namespace mpl {

using ::mpl_::_;

namespace placeholders {
using mpl_::_;
}

}}



namespace mpl_ {
typedef arg<1> _1;

}
namespace boost { namespace mpl {

using ::mpl_::_1;

namespace placeholders {
using mpl_::_1;
}

}}
namespace mpl_ {
typedef arg<2> _2;

}
namespace boost { namespace mpl {

using ::mpl_::_2;

namespace placeholders {
using mpl_::_2;
}

}}
namespace mpl_ {
typedef arg<3> _3;

}
namespace boost { namespace mpl {

using ::mpl_::_3;

namespace placeholders {
using mpl_::_3;
}

}}
namespace mpl_ {
typedef arg<4> _4;

}
namespace boost { namespace mpl {

using ::mpl_::_4;

namespace placeholders {
using mpl_::_4;
}

}}
namespace mpl_ {
typedef arg<5> _5;

}
namespace boost { namespace mpl {

using ::mpl_::_5;

namespace placeholders {
using mpl_::_5;
}

}}
namespace mpl_ {
typedef arg<6> _6;

}
namespace boost { namespace mpl {

using ::mpl_::_6;

namespace placeholders {
using mpl_::_6;
}

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/placeholders.hpp" 2 3
# 51 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/array.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/array.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/always.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/always.hpp" 3
namespace boost { namespace mpl {

template< typename Value > struct always
{
    template<
          typename T
        , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na
        >
    struct apply
    {
        typedef Value type;
    };
};



}}
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/array.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_fwd.hpp" 1 3
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_fwd.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp" 3
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct apply;

template<
      typename F
    >
struct apply0;

template<
      typename F, typename T1
    >
struct apply1;

template<
      typename F, typename T1, typename T2
    >
struct apply2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5;

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_fwd.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/placeholders.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/lambda.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/lambda.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind_fwd.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind_fwd.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/config/bind.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind_fwd.hpp" 2 3






# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp" 3
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct bind;

template<
      typename F
    >
struct bind0;

template<
      typename F, typename T1
    >
struct bind1;

template<
      typename F, typename T1, typename T2
    >
struct bind2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5;

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind_fwd.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/placeholders.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/next.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/next.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/next_prior.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/next_prior.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/common_name_wknd.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/next_prior.hpp" 2 3



namespace boost { namespace mpl {




template<
      typename T = na
    >
struct next
{
    typedef typename T::next type;
   
};

template<
      typename T = na
    >
struct prior
{
    typedef typename T::prior type;
   
};

template<> struct next< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : next< T1 > { }; }; template< typename Tag > struct lambda< next< na > , Tag , int_<-1> > { typedef false_ is_le; typedef next< na > result_; typedef next< na > type; }; namespace aux { template< typename T1 > struct template_arity< next< T1 > > : int_<1> { }; template<> struct template_arity< next< na > > : int_<-1> { }; }
template<> struct prior< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : prior< T1 > { }; }; template< typename Tag > struct lambda< prior< na > , Tag , int_<-1> > { typedef false_ is_le; typedef prior< na > result_; typedef prior< na > type; }; namespace aux { template< typename T1 > struct template_arity< prior< T1 > > : int_<1> { }; template<> struct template_arity< prior< na > > : int_<-1> { }; }

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/next.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/protect.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/protect.hpp" 3
namespace boost { namespace mpl {

template<
      typename T = na
    , int not_le_ = 0
    >
struct protect : T
{



    typedef protect type;

};
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/protect.hpp" 3
template<> struct protect< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : protect< T1 > { }; };

namespace aux { template< typename T1 > struct template_arity< protect< T1 > > : int_<1> { }; template<> struct template_arity< protect< na > > : int_<-1> { }; }


}}
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind.hpp" 2 3
# 50 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template<
      typename T, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg
{
    typedef T type;
};

template<
      typename T
    , typename Arg
    >
struct replace_unnamed_arg
{
    typedef Arg next;
    typedef T type;
};

template<
      typename Arg
    >
struct replace_unnamed_arg< arg< -1 >, Arg >
{
    typedef typename Arg::next next;
    typedef Arg type;
};

template<
      int N, typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg< arg<N>, U1, U2, U3, U4, U5 >
{
    typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg< bind< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5 >
{
    typedef bind< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}

template<
      typename F
    >
struct bind0
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

     public:
        typedef typename apply_wrap0<
              f_
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind0<F>, U1, U2, U3, U4, U5
    >
{
    typedef bind0<F> f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 > struct template_arity< bind0< T1> > : int_<1> { }; }

template<
      typename F
    >
struct bind< F,na,na,na,na,na >
    : bind0<F>
{
};

template<
      typename F, typename T1
    >
struct bind1
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

     public:
        typedef typename apply_wrap1<
              f_
            , typename t1::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename U1, typename U2, typename U3
    , typename U4, typename U5
    >
struct resolve_bind_arg<
      bind1< F,T1 >, U1, U2, U3, U4, U5
    >
{
    typedef bind1< F,T1 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 > struct template_arity< bind1< T1 , T2> > : int_<2> { }; }

template<
      typename F, typename T1
    >
struct bind< F,T1,na,na,na,na >
    : bind1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct bind2
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

     public:
        typedef typename apply_wrap2<
              f_
            , typename t1::type, typename t2::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename U1, typename U2
    , typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind2< F,T1,T2 >, U1, U2, U3, U4, U5
    >
{
    typedef bind2< F,T1,T2 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< bind2< T1 , T2 , T3> > : int_<3> { }; }

template<
      typename F, typename T1, typename T2
    >
struct bind< F,T1,T2,na,na,na >
    : bind2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

     public:
        typedef typename apply_wrap3<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename U1
    , typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind3< F,T1,T2,T3 >, U1, U2, U3, U4, U5
    >
{
    typedef bind3< F,T1,T2,T3 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< bind3< T1 , T2 , T3 , T4> > : int_<4> { }; }

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind< F,T1,T2,T3,na,na >
    : bind3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

     public:
        typedef typename apply_wrap4<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind4< F,T1,T2,T3,T4 >, U1, U2, U3, U4, U5
    >
{
    typedef bind4< F,T1,T2,T3,T4 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< bind4< T1 , T2 , T3 , T4 , T5> > : int_<5> { }; }

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind< F,T1,T2,T3,T4,na >
    : bind4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

        typedef aux::replace_unnamed_arg< T5,n5 > r5;
        typedef typename r5::type a5;
        typedef typename r5::next n6;
        typedef aux::resolve_bind_arg< a5,U1,U2,U3,U4,U5 > t5;

     public:
        typedef typename apply_wrap5<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type, typename t5::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind5< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5
    >
{
    typedef bind5< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< bind5< T1 , T2 , T3 , T4 , T5 , T6> > : int_<6> { }; }



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind
    : bind5< F,T1,T2,T3,T4,T5 >
{
};


template< template< typename T1, typename T2, typename T3 > class F, typename Tag >
struct quote3;

template< typename T1, typename T2, typename T3 > struct if_;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< if_,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename if_<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

template<
      template< typename T1, typename T2, typename T3 > class F, typename Tag
    >
struct quote3;

template< typename T1, typename T2, typename T3 > struct eval_if;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< eval_if,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename eval_if<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 51 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/lambda.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/full_lambda.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/full_lambda.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/bind_fwd.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/full_lambda.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/quote.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/quote.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/has_type.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/has_type.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/quote.hpp" 2 3
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/quote.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp" 3
namespace boost { namespace mpl {

template< typename T, bool has_type_ >
struct quote_impl
{
    typedef typename T::type type;
};

template< typename T >
struct quote_impl< T,false >
{
    typedef T type;
};

template<
      template< typename P1 > class F
    , typename Tag = void_
    >
struct quote1
{
    template< typename U1 > struct apply

        : quote_impl<
              F<U1>
            , aux::has_type< F<U1> >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2 > class F
    , typename Tag = void_
    >
struct quote2
{
    template< typename U1, typename U2 > struct apply

        : quote_impl<
              F< U1,U2 >
            , aux::has_type< F< U1,U2 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename Tag = void_
    >
struct quote3
{
    template< typename U1, typename U2, typename U3 > struct apply

        : quote_impl<
              F< U1,U2,U3 >
            , aux::has_type< F< U1,U2,U3 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename Tag = void_
    >
struct quote4
{
    template<
          typename U1, typename U2, typename U3, typename U4
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4 >
            , aux::has_type< F< U1,U2,U3,U4 > >::value
            >

    {
    };
};

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename Tag = void_
    >
struct quote5
{
    template<
          typename U1, typename U2, typename U3, typename U4
        , typename U5
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4,U5 >
            , aux::has_type< F< U1,U2,U3,U4,U5 > >::value
            >

    {
    };
};

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/quote.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/full_lambda.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/arg.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/full_lambda.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/template_arity.hpp" 1 3
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/template_arity.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 3
namespace boost { namespace mpl { namespace aux {

template< int N > struct arity_tag
{
    typedef char (&type)[N + 1];
};

template<
      int C1, int C2, int C3, int C4, int C5, int C6
    >
struct max_arity
{
    static const int value = ( C6 > 0 ? C6 : ( C5 > 0 ? C5 : ( C4 > 0 ? C4 : ( C3 > 0 ? C3 : ( C2 > 0 ? C2 : ( C1 > 0 ? C1 : -1 ) ) ) ) ) );



};

arity_tag<0>::type arity_helper(...);

template<
      template< typename P1 > class F
    , typename T1
    >
typename arity_tag<1>::type
arity_helper(type_wrapper< F<T1> >, arity_tag<1>);

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    >
typename arity_tag<2>::type
arity_helper(type_wrapper< F< T1,T2 > >, arity_tag<2>);

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    >
typename arity_tag<3>::type
arity_helper(type_wrapper< F< T1,T2,T3 > >, arity_tag<3>);

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    >
typename arity_tag<4>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4 > >, arity_tag<4>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    >
typename arity_tag<5>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5 > >, arity_tag<5>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5, typename P6
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename T6
    >
typename arity_tag<6>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5,T6 > >, arity_tag<6>);
template< typename F, int N >
struct template_arity_impl
{
    static const int value = sizeof(arity_helper(type_wrapper<F>(), arity_tag<N>())) - 1;


};

template< typename F >
struct template_arity
{
    static const int value = ( max_arity< template_arity_impl< F,1 >::value, template_arity_impl< F,2 >::value, template_arity_impl< F,3 >::value, template_arity_impl< F,4 >::value, template_arity_impl< F,5 >::value, template_arity_impl< F,6 >::value >::value );




    typedef mpl::int_<value> type;
};

}}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/template_arity.hpp" 2 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/full_lambda.hpp" 2 3
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/full_lambda.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template<
      bool C1 = false, bool C2 = false, bool C3 = false, bool C4 = false
    , bool C5 = false
    >
struct lambda_or
    : true_
{
};

template<>
struct lambda_or< false,false,false,false,false >
    : false_
{
};

}

template<
      typename T
    , typename Tag
    , typename Arity
    >
struct lambda
{
    typedef false_ is_le;
    typedef T result_;
    typedef T type;
};

template<
      typename T
    >
struct is_lambda_expression
    : lambda<T>::is_le
{
};

template< int N, typename Tag >
struct lambda< arg<N>,Tag, int_< -1 > >
{
    typedef true_ is_le;
    typedef mpl::arg<N> result_;
    typedef mpl::protect<result_> type;
};

template<
      typename F
    , typename Tag
    >
struct lambda<
          bind0<F>
        , Tag
        , int_<1>
        >
{
    typedef false_ is_le;
    typedef bind0<
          F
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1
{
    typedef F<
          typename L1::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1< true_,Tag,F,L1 >
{
    typedef bind1<
          quote1< F,Tag >
        , typename L1::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1 > class F
    , typename T1
    , typename Tag
    >
struct lambda<
          F<T1>
        , Tag
        , int_<1>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef typename l1::is_le is_le1;
    typedef typename aux::lambda_or<
          is_le1::value
        >::type is_le;

    typedef aux::le_result1<
          is_le, Tag, F, l1
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1
    , typename Tag
    >
struct lambda<
          bind1< F,T1 >
        , Tag
        , int_<2>
        >
{
    typedef false_ is_le;
    typedef bind1<
          F
        , T1
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2
{
    typedef F<
          typename L1::type, typename L2::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2< true_,Tag,F,L1,L2 >
{
    typedef bind2<
          quote2< F,Tag >
        , typename L1::result_, typename L2::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    , typename Tag
    >
struct lambda<
          F< T1,T2 >
        , Tag
        , int_<2>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value
        >::type is_le;

    typedef aux::le_result2<
          is_le, Tag, F, l1, l2
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2
    , typename Tag
    >
struct lambda<
          bind2< F,T1,T2 >
        , Tag
        , int_<3>
        >
{
    typedef false_ is_le;
    typedef bind2<
          F
        , T1, T2
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3< true_,Tag,F,L1,L2,L3 >
{
    typedef bind3<
          quote3< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3 >
        , Tag
        , int_<3>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value
        >::type is_le;

    typedef aux::le_result3<
          is_le, Tag, F, l1, l2, l3
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          bind3< F,T1,T2,T3 >
        , Tag
        , int_<4>
        >
{
    typedef false_ is_le;
    typedef bind3<
          F
        , T1, T2, T3
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4< true_,Tag,F,L1,L2,L3,L4 >
{
    typedef bind4<
          quote4< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4 >
        , Tag
        , int_<4>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        >::type is_le;

    typedef aux::le_result4<
          is_le, Tag, F, l1, l2, l3, l4
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          bind4< F,T1,T2,T3,T4 >
        , Tag
        , int_<5>
        >
{
    typedef false_ is_le;
    typedef bind4<
          F
        , T1, T2, T3, T4
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type, typename L5::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5< true_,Tag,F,L1,L2,L3,L4,L5 >
{
    typedef bind5<
          quote5< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_, typename L5::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4,T5 >
        , Tag
        , int_<5>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;
    typedef lambda< T5,Tag > l5;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;
    typedef typename l5::is_le is_le5;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        , is_le5::value
        >::type is_le;

    typedef aux::le_result5<
          is_le, Tag, F, l1, l2, l3, l4, l5
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind5< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind5<
          F
        , T1, T2, T3, T4, T5
        > result_;

    typedef result_ type;
};


template< typename T, typename Tag >
struct lambda< mpl::protect<T>,Tag, int_<1> >
{
    typedef false_ is_le;
    typedef mpl::protect<T> result_;
    typedef result_ type;
};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind< F,T1,T2,T3,T4,T5 > result_;
    typedef result_ type;
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    , typename Arity
    >
struct lambda<
          lambda< F,Tag1,Arity >
        , Tag2
        , int_<3>
        >
{
    typedef lambda< F,Tag2 > l1;
    typedef lambda< Tag1,Tag2 > l2;
    typedef typename l1::is_le is_le;
    typedef bind1< quote1<aux::template_arity>, typename l1::result_ > arity_;
    typedef lambda< typename if_< is_le,arity_,Arity >::type, Tag2 > l3;
    typedef aux::le_result3<is_le, Tag2, mpl::lambda, l1, l2, l3> le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<> struct lambda< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : lambda< T1 , T2 > { }; }; template< typename Tag > struct lambda< lambda< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef lambda< na , na > result_; typedef lambda< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< lambda< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< lambda< na , na > > : int_<-1> { }; }

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 45 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/full_lambda.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/lambda.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply.hpp" 2 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp" 3
namespace boost { namespace mpl {

template<
      typename F
    >
struct apply0

    : apply_wrap0<
          typename lambda<F>::type

        >
{
   




};

template<
      typename F
    >
struct apply< F,na,na,na,na,na >
    : apply0<F>
{
};

template<
      typename F, typename T1
    >
struct apply1

    : apply_wrap1<
          typename lambda<F>::type
        , T1
        >
{
   




};

template<
      typename F, typename T1
    >
struct apply< F,T1,na,na,na,na >
    : apply1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct apply2

    : apply_wrap2<
          typename lambda<F>::type
        , T1, T2
        >
{
   




};

template<
      typename F, typename T1, typename T2
    >
struct apply< F,T1,T2,na,na,na >
    : apply2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3

    : apply_wrap3<
          typename lambda<F>::type
        , T1, T2, T3
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply< F,T1,T2,T3,na,na >
    : apply3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4

    : apply_wrap4<
          typename lambda<F>::type
        , T1, T2, T3, T4
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply< F,T1,T2,T3,T4,na >
    : apply4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5

    : apply_wrap5<
          typename lambda<F>::type
        , T1, T2, T3, T4, T5
        >
{
   




};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply
    : apply5< F,T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply.hpp" 2 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/array.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_const.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_const.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_volatile.hpp" 1 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_volatile.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_volatile.hpp" 2 3

namespace boost {







   template< typename T > struct is_volatile : ::boost::integral_constant<bool,::boost::detail::cv_traits_imp<T*>::is_volatile> { };

template< typename T > struct is_volatile< T& > : ::boost::integral_constant<bool,false> { };
# 127 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_volatile.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 130 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/is_volatile.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_const.hpp" 2 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_const.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_const.hpp" 2 3

namespace boost {



namespace detail {

template <typename T, bool is_vol>
struct remove_const_helper
{
    typedef T type;
};

template <typename T>
struct remove_const_helper<T, true>
{
    typedef T volatile type;
};


template <typename T>
struct remove_const_impl
{
    typedef typename remove_const_helper<
          typename cv_traits_imp<T*>::unqualified_type
        , ::boost::is_volatile<T>::value
        >::type type;
};

}



template< typename T > struct remove_const { typedef typename boost::detail::remove_const_impl<T>::type type; };
template< typename T > struct remove_const<T&> { typedef T& type; };

template< typename T, std::size_t N > struct remove_const<T const[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_const<T const volatile[N]> { typedef T volatile type[N]; };
# 74 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_const.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 77 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_const.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/array.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/array.hpp" 1 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/array.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/array.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/iterator.hpp" 1 3
# 77 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/iterator.hpp" 3
namespace boost { namespace detail {


template <class Iterator>
struct iterator_traits
    : std::iterator_traits<Iterator>
{};
using std::distance;

}}
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/array.hpp" 2 3







namespace boost {

    template<class T, std::size_t N>
    class array {
      public:
        T elems[N];

      public:

        typedef T value_type;
        typedef T* iterator;
        typedef const T* const_iterator;
        typedef T& reference;
        typedef const T& const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;


        iterator begin() { return elems; }
        const_iterator begin() const { return elems; }
        iterator end() { return elems+N; }
        const_iterator end() const { return elems+N; }



        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 79 "/Library/Application Support/MonkeyWorks/Developer/include/boost/array.hpp" 3
        reverse_iterator rbegin() { return reverse_iterator(end()); }
        const_reverse_iterator rbegin() const {
            return const_reverse_iterator(end());
        }
        reverse_iterator rend() { return reverse_iterator(begin()); }
        const_reverse_iterator rend() const {
            return const_reverse_iterator(begin());
        }


        reference operator[](size_type i)
        {
            (__builtin_expect(!(i < N && "out of range"), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/array.hpp", 91, "i < N && \"out of range\"") : (void)0);
            return elems[i];
        }

        const_reference operator[](size_type i) const
        {
            (__builtin_expect(!(i < N && "out of range"), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/array.hpp", 97, "i < N && \"out of range\"") : (void)0);
            return elems[i];
        }


        reference at(size_type i) { rangecheck(i); return elems[i]; }
        const_reference at(size_type i) const { rangecheck(i); return elems[i]; }


        reference front()
        {
            return elems[0];
        }

        const_reference front() const
        {
            return elems[0];
        }

        reference back()
        {
            return elems[N-1];
        }

        const_reference back() const
        {
            return elems[N-1];
        }


        static size_type size() { return N; }
        static bool empty() { return false; }
        static size_type max_size() { return N; }
        enum { static_size = N };


        void swap (array<T,N>& y) {
            std::swap_ranges(begin(),end(),y.begin());
        }


        const T* data() const { return elems; }
        T* data() { return elems; }


        T* c_array() { return elems; }


        template <typename T2>
        array<T,N>& operator= (const array<T2,N>& rhs) {
            std::copy(rhs.begin(),rhs.end(), begin());
            return *this;
        }


        void assign (const T& value)
        {
            std::fill_n(begin(),size(),value);
        }


        static void rangecheck (size_type i) {
            if (i >= size()) {
                throw std::out_of_range("array<>: index out of range");
            }
        }

    };


    template< class T >
    class array< T, 0 > {

      public:

        typedef T value_type;
        typedef T* iterator;
        typedef const T* const_iterator;
        typedef T& reference;
        typedef const T& const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;


        iterator begin() { return iterator( reinterpret_cast< T * >( this ) ); }
        const_iterator begin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }
        iterator end() { return begin(); }
        const_iterator end() const { return begin(); }



        typedef std::reverse_iterator<iterator> reverse_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 202 "/Library/Application Support/MonkeyWorks/Developer/include/boost/array.hpp" 3
        reverse_iterator rbegin() { return reverse_iterator(end()); }
        const_reverse_iterator rbegin() const {
            return const_reverse_iterator(end());
        }
        reverse_iterator rend() { return reverse_iterator(begin()); }
        const_reverse_iterator rend() const {
            return const_reverse_iterator(begin());
        }


        reference operator[](size_type i)
        {
            return failed_rangecheck();
        }

        const_reference operator[](size_type i) const
        {
            return failed_rangecheck();
        }


        reference at(size_type i) { return failed_rangecheck(); }
        const_reference at(size_type i) const { return failed_rangecheck(); }


        reference front()
        {
            return failed_rangecheck();
        }

        const_reference front() const
        {
            return failed_rangecheck();
        }

        reference back()
        {
            return failed_rangecheck();
        }

        const_reference back() const
        {
            return failed_rangecheck();
        }


        static size_type size() { return 0; }
        static bool empty() { return true; }
        static size_type max_size() { return 0; }
        enum { static_size = 0 };

        void swap (array<T,0>& y) {
        }


        const T* data() const { return 0; }
        T* data() { return 0; }


        T* c_array() { return 0; }


        template <typename T2>
        array<T,0>& operator= (const array<T2,0>& ) {
            return *this;
        }


        void assign (const T& ) { }


        static reference failed_rangecheck () {
                std::out_of_range e("attempt to access element of an empty array");
                boost::throw_exception(e);





                static T placeholder;
                return placeholder;
            }
    };



    template<class T, std::size_t N>
    bool operator== (const array<T,N>& x, const array<T,N>& y) {
        return std::equal(x.begin(), x.end(), y.begin());
    }
    template<class T, std::size_t N>
    bool operator< (const array<T,N>& x, const array<T,N>& y) {
        return std::lexicographical_compare(x.begin(),x.end(),y.begin(),y.end());
    }
    template<class T, std::size_t N>
    bool operator!= (const array<T,N>& x, const array<T,N>& y) {
        return !(x==y);
    }
    template<class T, std::size_t N>
    bool operator> (const array<T,N>& x, const array<T,N>& y) {
        return y<x;
    }
    template<class T, std::size_t N>
    bool operator<= (const array<T,N>& x, const array<T,N>& y) {
        return !(y<x);
    }
    template<class T, std::size_t N>
    bool operator>= (const array<T,N>& x, const array<T,N>& y) {
        return !(x<y);
    }


    template<class T, std::size_t N>
    inline void swap (array<T,N>& x, array<T,N>& y) {
        x.swap(y);
    }

}
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/array.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/array.hpp" 3
namespace boost { namespace serialization {
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/array.hpp" 3
template <class Archive>
struct use_array_optimization : boost::mpl::always<boost::mpl::false_> {};


template<class T>
class array
 : public wrapper_traits<array<T> >
{
public:
    typedef T value_type;

    array(value_type* t, std::size_t s) :
        m_t(t),
        m_element_count(s)
    {}


    template<class Archive>
    void serialize_optimized(Archive &ar, const unsigned int, mpl::false_ ) const
    {

      std::size_t c = count();
      value_type * t = address();
      while(0 < c--)
            ar & make_nvp("item", *t++);
    }


    template<class Archive>
    void serialize_optimized(Archive &ar, const unsigned int version, mpl::true_ )
    {
      boost::serialization::split_member(ar, *this, version);
    }


    template<class Archive>
    void save(Archive &ar, const unsigned int version) const
    {
      ar.save_array(*this,version);
    }


    template<class Archive>
    void load(Archive &ar, const unsigned int version)
    {
      ar.load_array(*this,version);
    }


    template<class Archive>
    void serialize(Archive &ar, const unsigned int version)
    {
      typedef typename
          boost::serialization::use_array_optimization<Archive>::template apply<
                    typename remove_const<T>::type
                >::type use_optimized;
      serialize_optimized(ar,version,use_optimized());
    }

    value_type* address() const
    {
      return m_t;
    }

    std::size_t count() const
    {
      return m_element_count;
    }


private:
    value_type* m_t;
    std::size_t const m_element_count;
};

template<class T>
inline

const

array<T> make_array( T* t, std::size_t s){
    return array<T>(t, s);
}


template <class Archive, class T, std::size_t N>

void serialize(Archive& ar, boost::array<T,N>& a, const unsigned int version)
{
  ar & make_nvp("elems",a.elems);
}



} }
# 52 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 2 3

namespace boost {
namespace archive {




template<class Archive, class Elem, class Tr>
class basic_binary_oprimitive
{

    friend class save_access;
protected:



    std::basic_streambuf<Elem, Tr> & m_sb;

    Archive * This(){
        return static_cast<Archive *>(this);
    }

    boost::scoped_ptr<std::locale> archive_locale;
    basic_streambuf_locale_saver<Elem, Tr> locale_saver;


    template<class T>
    void save(const T & t)
    {
        save_binary(& t, sizeof(T));
    }






    void save(const bool t){
        (__builtin_expect(!(0 == static_cast<int>(t) || 1 == static_cast<int>(t)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp", 91, "0 == static_cast<int>(t) || 1 == static_cast<int>(t)") : (void)0);
        save_binary(& t, sizeof(t));
    }
    void
    save(const std::string &s);

    void
    save(const std::wstring &ws);

    void
    save(const char * t);
    void
    save(const wchar_t * t);

    void
    init();

   
    basic_binary_oprimitive(
        std::basic_streambuf<Elem, Tr> & sb,
        bool no_codecvt
    );
   
    ~basic_binary_oprimitive();
public:





    struct use_array_optimization {
      template <class T>
      struct apply : public boost::serialization::is_bitwise_serializable<T> {};
    };



    template <class ValueType>
    void save_array(boost::serialization::array<ValueType> const& a, unsigned int)
    {
      save_binary(a.address(),a.count()*sizeof(ValueType));
    }

    void save_binary(const void *address, std::size_t count);
};

template<class Archive, class Elem, class Tr>
inline void
basic_binary_oprimitive<Archive, Elem, Tr>::save_binary(
    const void *address,
    std::size_t count
){
# 153 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 3
    count = ( count + sizeof(Elem) - 1)
        / sizeof(Elem);
    std::streamsize scount = m_sb.sputn(
        static_cast<const Elem *>(address),
        count
    );
    if(count != static_cast<std::size_t>(scount))
        boost::throw_exception(archive_exception(archive_exception::stream_error));





}

}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 172 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oprimitive.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_oarchive_impl.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oarchive.hpp" 1 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oarchive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/common_oarchive.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/common_oarchive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_oarchive.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_oarchive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_archive.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_archive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/noncopyable.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/noncopyable.hpp" 3
namespace boost {






namespace noncopyable_
{
  class noncopyable
  {
   protected:
      noncopyable() {}
      ~noncopyable() {}
   private:
      noncopyable( const noncopyable& );
      const noncopyable& operator=( const noncopyable& );
  };
}

typedef noncopyable_::noncopyable noncopyable;

}
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_archive.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_archive.hpp" 2 3

namespace boost {
namespace archive {

struct version_type : boost::totally_ordered1< version_type , boost::totally_ordered2< version_type, unsigned int > > { unsigned int t; explicit version_type(const unsigned int t_) : t(t_) {}; version_type(){}; version_type(const version_type & t_) : t(t_.t){} version_type & operator=(const version_type & rhs) { t = rhs.t; return *this;} version_type & operator=(const unsigned int & rhs) { t = rhs; return *this;} operator const unsigned int & () const {return t; } operator unsigned int & () { return t; } bool operator==(const version_type & rhs) const { return t == rhs.t; } bool operator<(const version_type & rhs) const { return t < rhs.t; } };
struct class_id_type : boost::totally_ordered1< class_id_type , boost::totally_ordered2< class_id_type, int > > { int t; explicit class_id_type(const int t_) : t(t_) {}; class_id_type(){}; class_id_type(const class_id_type & t_) : t(t_.t){} class_id_type & operator=(const class_id_type & rhs) { t = rhs.t; return *this;} class_id_type & operator=(const int & rhs) { t = rhs; return *this;} operator const int & () const {return t; } operator int & () { return t; } bool operator==(const class_id_type & rhs) const { return t == rhs.t; } bool operator<(const class_id_type & rhs) const { return t < rhs.t; } };
struct class_id_optional_type : boost::totally_ordered1< class_id_optional_type , boost::totally_ordered2< class_id_optional_type, int > > { int t; explicit class_id_optional_type(const int t_) : t(t_) {}; class_id_optional_type(){}; class_id_optional_type(const class_id_optional_type & t_) : t(t_.t){} class_id_optional_type & operator=(const class_id_optional_type & rhs) { t = rhs.t; return *this;} class_id_optional_type & operator=(const int & rhs) { t = rhs; return *this;} operator const int & () const {return t; } operator int & () { return t; } bool operator==(const class_id_optional_type & rhs) const { return t == rhs.t; } bool operator<(const class_id_optional_type & rhs) const { return t < rhs.t; } };
struct class_id_reference_type : boost::totally_ordered1< class_id_reference_type , boost::totally_ordered2< class_id_reference_type, int > > { int t; explicit class_id_reference_type(const int t_) : t(t_) {}; class_id_reference_type(){}; class_id_reference_type(const class_id_reference_type & t_) : t(t_.t){} class_id_reference_type & operator=(const class_id_reference_type & rhs) { t = rhs.t; return *this;} class_id_reference_type & operator=(const int & rhs) { t = rhs; return *this;} operator const int & () const {return t; } operator int & () { return t; } bool operator==(const class_id_reference_type & rhs) const { return t == rhs.t; } bool operator<(const class_id_reference_type & rhs) const { return t < rhs.t; } };
struct object_id_type : boost::totally_ordered1< object_id_type , boost::totally_ordered2< object_id_type, unsigned int > > { unsigned int t; explicit object_id_type(const unsigned int t_) : t(t_) {}; object_id_type(){}; object_id_type(const object_id_type & t_) : t(t_.t){} object_id_type & operator=(const object_id_type & rhs) { t = rhs.t; return *this;} object_id_type & operator=(const unsigned int & rhs) { t = rhs; return *this;} operator const unsigned int & () const {return t; } operator unsigned int & () { return t; } bool operator==(const object_id_type & rhs) const { return t == rhs.t; } bool operator<(const object_id_type & rhs) const { return t < rhs.t; } };
struct object_reference_type : boost::totally_ordered1< object_reference_type , boost::totally_ordered2< object_reference_type, unsigned int > > { unsigned int t; explicit object_reference_type(const unsigned int t_) : t(t_) {}; object_reference_type(){}; object_reference_type(const object_reference_type & t_) : t(t_.t){} object_reference_type & operator=(const object_reference_type & rhs) { t = rhs.t; return *this;} object_reference_type & operator=(const unsigned int & rhs) { t = rhs; return *this;} operator const unsigned int & () const {return t; } operator unsigned int & () { return t; } bool operator==(const object_reference_type & rhs) const { return t == rhs.t; } bool operator<(const object_reference_type & rhs) const { return t < rhs.t; } };

struct tracking_type {
    typedef bool value_type;
    bool t;
    explicit tracking_type(const bool t_ = false)
        : t(t_)
    {};
    tracking_type(const tracking_type & t_)
        : t(t_.t)
    {}
    operator bool () const {
        return t;
    };
    operator bool & () {
        return t;
    };
    tracking_type & operator=(const bool t_){
        t = t_;
        return *this;
    }
    bool operator==(const tracking_type & rhs) const {
        return t == rhs.t;
    }
    bool operator==(const bool & rhs) const {
        return t == rhs;
    }
    tracking_type & operator=(const tracking_type & rhs){
        t = rhs.t;
        return *this;
    }
};

struct class_name_type : private boost::noncopyable {
    char *t;
    operator const char * & () const {
        return const_cast<const char * &>(t);
    }
    operator char * () {
        return t;
    }
    explicit class_name_type(const char *key_)
    : t(const_cast<char *>(key_)){}
    explicit class_name_type(char *key_)
    : t(key_){}
    class_name_type & operator=(const class_name_type & rhs){
        t = rhs.t;
        return *this;
    }
};

enum archive_flags {
    no_header = 1,
    no_codecvt = 2,
    no_xml_tag_checking = 4,
    no_tracking = 8,
    flags_last = 8
};



const char *
ARCHIVE_SIGNATURE();

unsigned char
ARCHIVE_VERSION();

}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 105 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_archive.hpp" 2 3






namespace boost { namespace serialization { template <> struct implementation_level< boost::archive::version_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level< boost::archive::class_id_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level< boost::archive::class_id_reference_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level< boost::archive::class_id_optional_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level< boost::archive::class_name_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level< boost::archive::object_id_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level< boost::archive::object_reference_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level::type::value; }; } }
namespace boost { namespace serialization { template <> struct implementation_level< boost::archive::tracking_type > { typedef mpl::integral_c_tag tag; typedef mpl::int_< primitive_type > type; static const int value = implementation_level::type::value; }; } }
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_oarchive.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_oarchive.hpp" 2 3

namespace boost {
namespace serialization {
    class extended_type_info;
}

namespace archive {
namespace detail {

class basic_oarchive_impl;
class basic_oserializer;
class basic_pointer_oserializer;


class basic_oarchive
{
    friend class basic_oarchive_impl;



    basic_oarchive_impl * pimpl;



    virtual void vsave(const version_type t) = 0;
    virtual void vsave(const object_id_type t) = 0;
    virtual void vsave(const object_reference_type t) = 0;
    virtual void vsave(const class_id_type t) = 0;
    virtual void vsave(const class_id_optional_type t) = 0;
    virtual void vsave(const class_id_reference_type t) = 0;
    virtual void vsave(const class_name_type & t) = 0;
    virtual void vsave(const tracking_type t) = 0;
protected:
    basic_oarchive(unsigned int flags = 0);


    virtual

    ~basic_oarchive();
public:

    void register_basic_serializer(
        const basic_oserializer & bos
    );
    void save_object(
        const void *x,
        const basic_oserializer & bos
    );
    void save_pointer(
        const void * t,
        const basic_pointer_oserializer * bpos_ptr
    );
    void save_null_pointer(){
        vsave(class_id_type(-1));
    }

    void end_preamble();
    unsigned int get_library_version() const;
    unsigned int get_flags() const;
};

}
}
}







# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 102 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_oarchive.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/common_oarchive.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_oarchive.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_oarchive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_oarchive.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_cast.hpp" 1 3
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_cast.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_pointer.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_pointer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_pointer.hpp" 2 3

namespace boost {



template< typename T > struct remove_pointer { typedef T type; };
template< typename T > struct remove_pointer<T*> { typedef T type; };
template< typename T > struct remove_pointer<T* const> { typedef T type; };
template< typename T > struct remove_pointer<T* volatile> { typedef T type; };
template< typename T > struct remove_pointer<T* const volatile> { typedef T type; };







}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_pointer.hpp" 2 3
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_cast.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_reference.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_reference.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_reference.hpp" 2 3

namespace boost {



template< typename T > struct remove_reference { typedef T type; };
template< typename T > struct remove_reference<T&> { typedef T type; };
# 46 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_reference.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_reference.hpp" 2 3
# 50 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_cast.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/or.hpp" 1 3
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/or.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/or.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/or.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct or_impl
    : true_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct or_impl< false,T1,T2,T3,T4 >
    : or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , false_
        >
{
};

template<>
struct or_impl<
          false
        , false_, false_, false_, false_
        >
    : false_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = false_, typename T4 = false_, typename T5 = false_
    >
struct or_

    : aux::or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct or_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : or_< T1 , T2 > { }; }; template< typename Tag > struct lambda< or_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef or_< na , na > result_; typedef or_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< or_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< or_< na , na > > : int_<-1> { }; }





}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/or.hpp" 2 3
# 54 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_cast.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/and.hpp" 1 3
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/and.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/and.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/and.hpp" 3
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct and_impl
    : false_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct and_impl< true,T1,T2,T3,T4 >
    : and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , true_
        >
{
};

template<>
struct and_impl<
          true
        , true_, true_, true_, true_
        >
    : true_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = true_, typename T4 = true_, typename T5 = true_
    >
struct and_

    : aux::and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct and_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : and_< T1 , T2 > { }; }; template< typename Tag > struct lambda< and_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef and_< na , na > result_; typedef and_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< and_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< and_< na , na > > : int_<-1> { }; }





}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/and.hpp" 2 3
# 55 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_cast.hpp" 2 3



namespace boost {
namespace smart_cast_impl {

    template<class T>
    struct reference {

        struct polymorphic {

            struct linear {
                template<class U>
                 static T cast(U & u){
                    return static_cast<T>(u);
                }
            };

            struct cross {
                 template<class U>
                static T cast(U & u){
                    return dynamic_cast<T>(u);
                }
            };

            template<class U>
            static T cast(U & u){





                    return cross::cast(u);
# 112 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_cast.hpp" 3
            }
        };

        struct non_polymorphic {
            template<class U>
             static T cast(U & u){
                return static_cast<T>(u);
            }
        };
        template<class U>
        static T cast(U & u){







                typedef typename mpl::eval_if<
                    boost::is_polymorphic<U>,
                    mpl::identity<polymorphic>,
                    mpl::identity<non_polymorphic>
                >::type typex;
                return typex::cast(u);

        }
    };

    template<class T>
    struct pointer {

        struct polymorphic {
# 198 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_cast.hpp" 3
            template<class U>
            static T cast(U * u){
                T tmp = dynamic_cast<T>(u);

                    if ( tmp == 0 ) throw std::bad_cast();

                return tmp;
            }

        };

        struct non_polymorphic {
            template<class U>
             static T cast(U * u){
                return static_cast<T>(u);
            }
        };

        template<class U>
        static T cast(U * u){







                typedef typename mpl::eval_if<
                    boost::is_polymorphic<U>,
                    mpl::identity<polymorphic>,
                    mpl::identity<non_polymorphic>
                >::type typex;
                return typex::cast(u);

        }

    };

    template<class TPtr>
    struct void_pointer {
        template<class UPtr>
        static TPtr cast(UPtr uptr){
            return static_cast<TPtr>(uptr);
        }
    };

    template<class T>
    struct error {



        template<class U>
        static T cast(U u){
            typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((sizeof(T)==0) == 0 ? false : true) >)> boost_static_assert_typedef_251;
            return * static_cast<T *>(__null);
        }
    };

}






template<class T, class U>
T smart_cast(U u) {
    typedef
        typename mpl::eval_if<
            typename mpl::or_<
                boost::is_same<void *, U>,
                boost::is_same<void *, T>,
                boost::is_same<const void *, U>,
                boost::is_same<const void *, T>
            >,
            mpl::identity<smart_cast_impl::void_pointer<T> >,

        typename mpl::eval_if<boost::is_pointer<U>,
            mpl::identity<smart_cast_impl::pointer<T> >,

        typename mpl::eval_if<boost::is_reference<U>,
            mpl::identity<smart_cast_impl::reference<T> >,

            mpl::identity<smart_cast_impl::error<T>
        >
        >
        >
        >::type typex;
    return typex::cast(u);
}



template<class T, class U>
T smart_cast_reference(U & u) {
    return smart_cast_impl::reference<T>::cast(u);
}

}
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/static_warning.hpp" 1 3
# 93 "/Library/Application Support/MonkeyWorks/Developer/include/boost/static_warning.hpp" 3
namespace boost {

struct STATIC_WARNING;

template<bool>
struct static_warning_impl;

template<>
struct static_warning_impl<false> {
    enum { value = 0 };


        typedef boost::STATIC_WARNING type;






};

template<>
struct static_warning_impl<true> {
    enum { value = 1 };
    struct type { type() { } int* operator&() { return new int; } };



};

}
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 2 3







# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_extent.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_extent.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_extent.hpp" 2 3



namespace boost {

template< typename T > struct remove_extent { typedef T type; };


template< typename T, std::size_t N > struct remove_extent<T[N]> { typedef T type; };
template< typename T, std::size_t N > struct remove_extent<T const[N]> { typedef T const type; };
template< typename T, std::size_t N > struct remove_extent<T volatile[N]> { typedef T volatile type; };
template< typename T, std::size_t N > struct remove_extent<T const volatile[N]> { typedef T const volatile type; };

template< typename T > struct remove_extent<T[]> { typedef T type; };
template< typename T > struct remove_extent<T const[]> { typedef T const type; };
template< typename T > struct remove_extent<T volatile[]> { typedef T volatile type; };
template< typename T > struct remove_extent<T const volatile[]> { typedef T const volatile type; };



}



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 47 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/remove_extent.hpp" 2 3
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/assume_abstract.hpp" 1 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/assume_abstract.hpp" 3
namespace boost {
namespace serialization {
    template<class T>
    struct is_abstract : boost::is_abstract<T> {} ;
}
}
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/greater_equal.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/greater_equal.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 2 3







# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/greater_equal.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct greater_equal_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< greater_equal_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< greater_equal_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct greater_equal_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_equal_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct greater_equal_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct greater_equal_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct greater_equal

    : greater_equal_impl<
          typename greater_equal_tag<N1>::type
        , typename greater_equal_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct greater_equal< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : greater_equal< T1 , T2 > { }; }; template< typename Tag > struct lambda< greater_equal< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef greater_equal< na , na > result_; typedef greater_equal< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< greater_equal< T1 , T2 > > : int_<2> { }; template<> struct template_arity< greater_equal< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct greater_equal_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N1::value >= N2::value ) >
    {
    };
};

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/greater_equal.hpp" 2 3
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 2 3
# 56 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info_typeid.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info_typeid.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdarg" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdarg" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdarg" 3
# 55 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cstdarg" 3
namespace std
{
  using ::va_list;
}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info_typeid.hpp" 2 3
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info_typeid.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/singleton.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/singleton.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/singleton.hpp" 2 3



namespace boost {
namespace serialization {
# 74 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/singleton.hpp" 3
class singleton_module : public boost::noncopyable
{
private:
    static bool & get_lock(){
        static bool lock = false;
        return lock;
    }
public:



    static void lock(){
        get_lock() = true;
    }
    static void unlock(){
        get_lock() = false;
    }
    static bool is_locked() {
        return get_lock();
    }
};

template <class T>
class singleton : public singleton_module
{
private:
    static T & instance;

    static void use(T const &) {}
    static T & get_instance() {
        static T t;


        use(instance);
        return t;
    }
public:
    static T & get_mutable_instance(){
        (__builtin_expect(!(! is_locked()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/singleton.hpp", 112, "! is_locked()") : (void)0);
        return get_instance();
    }
    static const T & get_const_instance(){
        return get_instance();
    }
};

template<class T>
 T & singleton<T>::instance = singleton<T>::get_instance();

}
}
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info_typeid.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/config.hpp" 1 3
# 80 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/auto_link.hpp" 1 3
# 81 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/config.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info.hpp" 2 3







namespace boost {
namespace serialization {

class extended_type_info
{
private:



    const unsigned int m_type_info_key;
    virtual bool
    is_less_than(const extended_type_info & ) const {
        (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info.hpp", 47, "false") : (void)0);
        return false;
    };
    virtual bool
    is_equal(const extended_type_info & ) const {
        (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info.hpp", 52, "false") : (void)0);
        return false;
    };
    void key_unregister();
protected:
    const char * m_key;



    extended_type_info(const unsigned int type_info_key = 0);


    virtual

    ~extended_type_info();
public:
    const char * get_key() const {
        return m_key;
    }
    void key_register(const char *key);
    bool operator<(const extended_type_info &rhs) const;
    bool operator==(const extended_type_info &rhs) const;
    bool operator!=(const extended_type_info &rhs) const {
        return !(operator==(rhs));
    }
    static const extended_type_info * find(const char *key);

    virtual void * construct(unsigned int = 0, ...) const {
        (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info.hpp", 80, "false") : (void)0);
        return __null;
    };
    virtual void destroy(void const * const ) const {
        (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info.hpp", 84, "false") : (void)0);
    }
};

}
}





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 96 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info.hpp" 2 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info_typeid.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/factory.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/factory.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comparison/greater.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comparison/greater.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comparison/less.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comparison/less.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comparison/less_equal.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comparison/less_equal.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/logical/not.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comparison/less_equal.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comparison/less.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comparison/not_equal.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comparison/less.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/comparison/greater.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/factory.hpp" 2 3


namespace std{



}

namespace boost {
namespace serialization {


template<class T, int N>
T * factory(std::va_list){
    (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/factory.hpp", 38, "false") : (void)0);

    return __null;
}

}
}
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info_typeid.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info_typeid.hpp" 2 3





namespace boost {
namespace serialization {
namespace detail {

class extended_type_info_typeid_0 :
    public extended_type_info
{
protected:
    const std::type_info * m_ti;
    extended_type_info_typeid_0();
    ~extended_type_info_typeid_0();
    void type_register(const std::type_info & ti);
    void type_unregister();
    const extended_type_info *
    get_extended_type_info(const std::type_info & ti) const;
public:
    virtual bool
    is_less_than(const extended_type_info &rhs) const;
    virtual bool
    is_equal(const extended_type_info &rhs) const;
    const std::type_info & get_typeid() const {
        return *m_ti;
    }
};

}

template<class T>
class extended_type_info_typeid :
    public detail::extended_type_info_typeid_0,
    public singleton<extended_type_info_typeid<T> >
{
public:
    extended_type_info_typeid() :
        detail::extended_type_info_typeid_0()
    {
        type_register(typeid(T));
    }
    ~extended_type_info_typeid(){
        type_unregister();
    }


    const extended_type_info *
    get_derived_extended_type_info(const T & t) const {


        struct STATIC_WARNING88 { int f() { int STATIC_WARNING = 1; return STATIC_WARNING / boost::static_warning_impl<(bool)( boost::is_polymorphic<T>::value )>::value; } };
        return
            detail::extended_type_info_typeid_0::get_extended_type_info(
                typeid(t)
            );
    }
    void * construct(unsigned int count, ...) const{

        std::va_list ap;
        __builtin_va_start(ap,count);
        switch(count){
        case 0:
            return factory<boost::remove_const<T>, 0>(ap);
        case 1:
            return factory<boost::remove_const<T>, 1>(ap);
        case 2:
            return factory<boost::remove_const<T>, 2>(ap);
        case 3:
            return factory<boost::remove_const<T>, 3>(ap);
        case 4:
            return factory<boost::remove_const<T>, 4>(ap);
        default:
            (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info_typeid.hpp", 110, "false") : (void)0);

            return __null;
        }
    }
    void destroy(void const * const p) const{
        delete static_cast<T const *>(p) ;
    }
};

}
}







    namespace boost {
    namespace serialization {
    template<class T>
    struct extended_type_info_impl {
        typedef typename
            boost::serialization::extended_type_info_typeid<T> type;
    };
    }
    }





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 144 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/extended_type_info_typeid.hpp" 2 3
# 57 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_oserializer.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_oserializer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_serializer.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_serializer.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_serializer.hpp" 2 3






namespace boost {
namespace archive {
namespace detail {

class basic_serializer : private boost::noncopyable
{
    const boost::serialization::extended_type_info & m_eti;
protected:
    explicit basic_serializer(
        const boost::serialization::extended_type_info & eti
    ) :
        m_eti(eti)
    {
        (__builtin_expect(!(__null != & eti), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_serializer.hpp", 39, "NULL != & eti") : (void)0);
    }
public:
    const boost::serialization::extended_type_info & get_eti() const {
        return m_eti;
    }
};

inline bool
operator<(const basic_serializer & lhs, const basic_serializer & rhs) {
  return & lhs.get_eti() < & rhs.get_eti();
}

class basic_serializer_arg : public basic_serializer {
public:
    basic_serializer_arg(const serialization::extended_type_info & eti) :
        basic_serializer(eti)
    {}
};

}
}
}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_oserializer.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_oserializer.hpp" 2 3

namespace boost {

namespace serialization {
    class extended_type_info;
}


namespace archive {
namespace detail {

class basic_oarchive;
class basic_pointer_oserializer;

class basic_oserializer :
    public basic_serializer
{
private:
    basic_pointer_oserializer *m_bpos;
protected:
    explicit basic_oserializer(
        const boost::serialization::extended_type_info & type_
    );


    virtual

    ~basic_oserializer();
public:
    bool serialized_as_pointer() const {
        return m_bpos != __null;
    }
    void set_bpos(basic_pointer_oserializer *bpos){
        m_bpos = bpos;
    }
    const basic_pointer_oserializer * get_bpos() const {
        return m_bpos;
    }
    virtual void save_object_data(
        basic_oarchive & ar, const void * x
    ) const = 0;

    virtual bool class_info() const = 0;

    virtual bool tracking(const unsigned int flags) const = 0;

    virtual unsigned int version() const = 0;

    virtual bool is_polymorphic() const = 0;
};

}
}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 82 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_oserializer.hpp" 2 3
# 61 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_oserializer.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_oserializer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_pointer_oserializer.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_pointer_oserializer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_pointer_oserializer.hpp" 2 3

namespace boost {

namespace serialization {
    class extended_type_info;
}

namespace archive {
namespace detail {

class basic_oarchive;
class basic_oserializer;

class basic_pointer_oserializer :
    public basic_serializer {
protected:
    explicit basic_pointer_oserializer(
        const boost::serialization::extended_type_info & type_
    );
public:


    virtual

    ~basic_pointer_oserializer();
    virtual const basic_oserializer & get_basic_serializer() const = 0;
    virtual void save_object_ptr(
        basic_oarchive & ar,
        const void * x
    ) const = 0;
};

}
}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 61 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_pointer_oserializer.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_oserializer.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_oserializer.hpp" 2 3

namespace boost {

namespace serialization {
    class extended_type_info;
}

namespace archive {
namespace detail {

template<class Archive>
class archive_pointer_oserializer :
    public basic_pointer_oserializer {
protected:
    explicit
    archive_pointer_oserializer(
        const boost::serialization::extended_type_info & eti
    );
   


    virtual

    ~archive_pointer_oserializer();
public:




    static const basic_pointer_oserializer *
    find(
        const boost::serialization::extended_type_info & eti
    );
};

}
}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 65 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_oserializer.hpp" 2 3
# 62 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/type_info_implementation.hpp" 1 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/type_info_implementation.hpp" 3
namespace boost {
namespace serialization {



template<class T>
struct type_info_implementation {
    template<class U>
    struct traits_class_typeinfo_implementation {
      typedef typename U::type_info_implementation::type type;
    };


    typedef
        typename mpl::eval_if<
            is_base_and_derived<boost::serialization::basic_traits, T>,
            traits_class_typeinfo_implementation<T>,

            mpl::identity<
                typename extended_type_info_impl<T>::type
            >
        >::type type;
};

}
}
# 68 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/void_cast.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/void_cast.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/config.hpp" 1 3
# 80 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/auto_link.hpp" 1 3
# 81 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/config.hpp" 2 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/void_cast.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/void_cast.hpp" 2 3






namespace boost {
namespace serialization {

 class extended_type_info;






void const *
void_upcast(
    extended_type_info const & derived,
    extended_type_info const & base,
    void const * const t
);

inline void *
void_upcast(
    extended_type_info const & derived,
    extended_type_info const & base,
    void * const t
){
    return const_cast<void*>(void_upcast(
        derived,
        base,
        const_cast<void const *>(t)
    ));
}

void const *
void_downcast(
    extended_type_info const & derived,
    extended_type_info const & base,
    void const * const t
);

inline void *
void_downcast(
    extended_type_info const & derived,
    extended_type_info const & base,
    void * const t
){
    return const_cast<void*>(void_downcast(
        derived,
        base,
        const_cast<void const *>(t)
    ));
}

namespace void_cast_detail {

class void_caster
{
    friend struct void_caster_compare ;
    friend
    void const *
    boost::serialization::void_upcast(
        extended_type_info const & derived,
        extended_type_info const & base,
        void const * const
    );
    friend
    void const *
    boost::serialization::void_downcast(
        extended_type_info const & derived,
        extended_type_info const & base,
        void const * const
    );

    const extended_type_info & m_derived;
    const extended_type_info & m_base;

    virtual void const * upcast(void const * const t) const = 0;
    virtual void const * downcast(void const * const t) const = 0;

    void_caster& operator=(void_caster const &);
protected:
    void
    static_register() const;
    void
    static_unregister() const;
public:

    void_caster(
        extended_type_info const & derived,
        extended_type_info const & base
    );
    virtual ~void_caster(){};
    bool operator==(const void_caster & rhs) const;
};

template <class Derived, class Base>
class void_caster_primitive :
    public void_caster
{
    virtual void const * downcast(void const * const t) const {
        const Derived * d = boost::smart_cast<const Derived *, const Base *>(
            static_cast<const Base *>(t)
        );
        return d;
    }
    virtual void const * upcast(void const * const t) const {
        const Base * b = boost::smart_cast<const Base *, const Derived *>(
            static_cast<const Derived *>(t)
        );
        return b;
    }
public:
    void_caster_primitive() __attribute__ ((used));
    ~void_caster_primitive();
};

template <class Derived, class Base>
 void_caster_primitive<Derived, Base>::void_caster_primitive() :
    void_caster(
        type_info_implementation<Derived>::type::get_const_instance(),
        type_info_implementation<Base>::type::get_const_instance()
    )
{
    static_register();
}

template <class Derived, class Base>
void_caster_primitive<Derived, Base>::~void_caster_primitive(){
    static_unregister();
}

}





template<class Derived, class Base>

inline const void_cast_detail::void_caster & void_cast_register(
    const Derived * dnull,
    const Base * bnull
) __attribute__ ((used));

template<class Derived, class Base>

inline const void_cast_detail::void_caster & void_cast_register(
    Derived const * ,
    Base const *
){
    return singleton<void_cast_detail::void_caster_primitive<
        Derived, Base
    > >::get_const_instance();
}

}
}





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 193 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/void_cast.hpp" 2 3
# 70 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 2 3






namespace boost {

namespace serialization {
    class extended_type_info;
}

namespace archive {



class save_access {
public:
    template<class Archive>
    static void end_preamble(Archive & ar){
        ar.end_preamble();
    }
    template<class Archive, class T>
    static void save_primitive(Archive & ar, const T & t){
        ar.end_preamble();
        ar.save(t);
    }
};

namespace detail {

template<class Archive, class T>
class oserializer : public basic_oserializer
{
private:


public:
    explicit oserializer() :
        basic_oserializer(
            boost::serialization::type_info_implementation<T>::type
                ::get_const_instance()
        )
    {}
    virtual void save_object_data(
        basic_oarchive & ar,
        const void *x
    ) const __attribute__ ((used));
    virtual bool class_info() const {
        return boost::serialization::implementation_level<T>::value
            >= boost::serialization::object_class_info;
    }
    virtual bool tracking(const unsigned int ) const {
        return boost::serialization::tracking_level<T>::value == boost::serialization::track_always
            || (boost::serialization::tracking_level<T>::value == boost::serialization::track_selectively
                && serialized_as_pointer());
    }
    virtual unsigned int version() const {
        return ::boost::serialization::version<T>::value;
    }
    virtual bool is_polymorphic() const {
        return boost::is_polymorphic<T>::value;
    }
    virtual ~oserializer(){}
};

template<class Archive, class T>
 void oserializer<Archive, T>::save_object_data(
    basic_oarchive & ar,
    const void *x
) const {


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((boost::is_const<T>::value == false) == 0 ? false : true) >)> boost_static_assert_typedef_143;
    boost::serialization::serialize_adl(
        boost::smart_cast_reference<Archive &>(ar),
        * static_cast<T *>(const_cast<void *>(x)),
        version()
    );
}

template<class Archive, class T>
class pointer_oserializer
  : public archive_pointer_oserializer<Archive>
{
    const basic_oserializer & get_basic_serializer() const;
private:
    virtual void save_object_ptr(
        basic_oarchive & ar,
        const void * x
    ) const __attribute__ ((used));
public:
    explicit pointer_oserializer() __attribute__ ((used));
};

template<class Archive, class T>
const basic_oserializer &
pointer_oserializer<Archive, T>::get_basic_serializer() const {
    return boost::serialization::singleton<
        oserializer<Archive, T>
    >::get_const_instance();
}

template<class Archive, class T>
 void pointer_oserializer<Archive, T>::save_object_ptr(
    basic_oarchive & ar,
    const void * x
) const {
    (__builtin_expect(!(__null != x), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp", 178, "NULL != x") : (void)0);


    T * t = static_cast<T *>(const_cast<void *>(x));
    const unsigned int file_version = boost::serialization::version<T>::value;
    Archive & ar_impl = boost::smart_cast_reference<Archive &>(ar);
    boost::serialization::save_construct_data_adl<Archive, T>(
        ar_impl,
        t,
        file_version
    );
    ar_impl << boost::serialization::make_nvp(__null, * t);
}

template<class Archive, class T>
 pointer_oserializer<Archive, T>::pointer_oserializer() :
    archive_pointer_oserializer<Archive>(
        boost::serialization::type_info_implementation<T>::type
            ::get_const_instance()
    )
{

    boost::serialization::singleton<
        oserializer<Archive, T>
    >::get_mutable_instance().set_bpos(this);
}

template<class Archive, class T>
struct save_non_pointer_type {


    struct save_primitive {
        static void invoke(Archive & ar, const T & t){
            save_access::save_primitive(ar, t);
        }
    };

    struct save_only {
        static void invoke(Archive & ar, const T & t){


            boost::serialization::serialize_adl(
                ar,
                const_cast<T &>(t),
                ::boost::serialization::version<T>::value
            );
        }
    };


    struct save_standard {
        static void invoke(Archive &ar, const T & t){
            ar.save_object(
                & t,
                boost::serialization::singleton<
                    oserializer<Archive, T>
                >::get_const_instance()
            );
        }
    };



    struct save_conditional {
        static void invoke(Archive &ar, const T &t){

                save_standard::invoke(ar, t);


        }
    };

    typedef
        typename mpl::eval_if<

            mpl::equal_to<
                boost::serialization::implementation_level<T>,
                mpl::int_<boost::serialization::primitive_type>
            >,
            mpl::identity<save_primitive>,

        typename mpl::eval_if<

            mpl::greater_equal<
                boost::serialization::implementation_level<T>,
                mpl::int_<boost::serialization::object_class_info>
            >,

            mpl::identity<save_standard>,

        typename mpl::eval_if<

            mpl::equal_to<
                boost::serialization::tracking_level<T>,
                mpl::int_<boost::serialization::track_never>
            >,

            mpl::identity<save_only>,


            mpl::identity<save_conditional>
        > > >::type typex;

    static void invoke(Archive & ar, const T & t){





        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( mpl::greater_equal< boost::serialization::implementation_level<T>, mpl::int_<boost::serialization::primitive_type> >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_292;





        typex::invoke(ar, t);
    };
};

template<class Archive, class TPtr>
struct save_pointer_type {
    template<class T>
    struct abstract
    {
        static const basic_pointer_oserializer * register_type(Archive & ){

            typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((boost::is_polymorphic<T>::value) == 0 ? false : true) >)> boost_static_assert_typedef_304;
            return __null;
        }
    };

    template<class T>
    struct non_abstract
    {
        static const basic_pointer_oserializer * register_type(Archive & ar){
            return ar.register_type(static_cast<T *>(__null));
        }
    };

    template<class T>
    static const basic_pointer_oserializer * register_type(Archive &ar, T & ){




        typedef
            typename mpl::eval_if<
                boost::serialization::is_abstract<T>,
                mpl::identity<abstract<T> >,
                mpl::identity<non_abstract<T> >
            >::type typex;
        return typex::register_type(ar);
    }

    template<class T>
    struct non_polymorphic
    {
        static void save(
            Archive &ar,
            T & t
        ){
            const basic_pointer_oserializer & bpos =
                boost::serialization::singleton<
                    pointer_oserializer<Archive, T>
                >::get_const_instance();

            ar.save_pointer(& t, & bpos);
        }
    };

    template<class T>
    struct polymorphic
    {
        static void save(
            Archive &ar,
            T & t
        ){
            typename
            boost::serialization::type_info_implementation<T>::type const
            & i = boost::serialization::type_info_implementation<T>::type
                    ::get_const_instance();

            boost::serialization::extended_type_info const * const this_type = & i;



            (__builtin_expect(!(__null != this_type), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp", 364, "NULL != this_type") : (void)0);

            const boost::serialization::extended_type_info * true_type =
                i.get_derived_extended_type_info(t);



            if(__null == true_type){
                boost::throw_exception(
                    archive_exception(archive_exception::unregistered_class)
                );
            }


            const void *vp = static_cast<const void *>(&t);
            if(*this_type == *true_type){
                const basic_pointer_oserializer * bpos = register_type(ar, t);
                ar.save_pointer(vp, bpos);
                return;
            }


            vp = serialization::void_downcast(
                *true_type,
                *this_type,
                static_cast<const void *>(&t)
            );
            if(__null == vp){
                boost::throw_exception(
                    archive_exception(archive_exception::unregistered_cast)
                );
            }




            const basic_pointer_oserializer * bpos
                = archive_pointer_oserializer<Archive>::find(* true_type);
            (__builtin_expect(!(__null != bpos), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp", 402, "NULL != bpos") : (void)0);
            if(__null == bpos)
                boost::throw_exception(
                    archive_exception(archive_exception::unregistered_class)
                );
            ar.save_pointer(vp, bpos);
        }
    };


    template<class T>
    struct conditional {
        typedef typename mpl::eval_if<
            is_polymorphic<T>,
            mpl::identity<polymorphic<T> >,
            mpl::identity<non_polymorphic<T> >
        >::type type;
    };


    template<class T>
    static void save(
        Archive & ar,
        const T & t
    ){
        conditional<T>::type::save(ar, const_cast<T &>(t));
    }

    template<class T>
    static void const_check(T & t){
        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((! boost::is_const<T>::value) == 0 ? false : true) >)> boost_static_assert_typedef_432;
    }

    static void invoke(Archive &ar, const TPtr t){
# 448 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/oserializer.hpp" 3
        register_type(ar, * t);
        if(__null == t){
            basic_oarchive & boa = boost::smart_cast_reference<basic_oarchive &>(ar);
            boa.save_null_pointer();
            save_access::end_preamble(ar);
            return;
        }
        save(ar, * t);
    };
};

template<class Archive, class T>
struct save_enum_type
{
    static void invoke(Archive &ar, const T &t){

        const int i = static_cast<int>(t);
        ar << boost::serialization::make_nvp(__null, i);
    }
};

template<class Archive, class T>
struct save_array_type
{
    static void invoke(Archive &ar, const T &t){
        typedef typename boost::remove_extent<T>::type value_type;

        save_access::end_preamble(ar);

        int count = sizeof(t) / (
            static_cast<const char *>(static_cast<const void *>(&t[1]))
            - static_cast<const char *>(static_cast<const void *>(&t[0]))
        );
        ar << boost::serialization::make_nvp("count", count);
        ar << serialization::make_array(static_cast<value_type const*>(&t[0]),count);
    }
};

}

template<class Archive, class T>
inline void save(Archive & ar, const T &t){
    typedef
        typename mpl::eval_if<is_pointer<T>,
            mpl::identity<detail::save_pointer_type<Archive, T> >,

        typename mpl::eval_if<is_enum<T>,
            mpl::identity<detail::save_enum_type<Archive, T> >,

        typename mpl::eval_if<is_array<T>,
            mpl::identity<detail::save_array_type<Archive, T> >,

            mpl::identity<detail::save_non_pointer_type<Archive, T> >
        >
        >
        >::type typex;
    typex::invoke(ar, t);
}



template<class T>
struct check_tracking {
    typedef typename mpl::if_<

        typename mpl::equal_to<
            serialization::tracking_level<T>,
            mpl::int_<serialization::track_never>
        >,

        mpl::not_<is_pointer<T> >,



        is_const<T>
    >::type typex;
    static const bool value = typex::value;
};

template<class Archive, class T>
inline void save(Archive & ar, T &t){







    struct STATIC_WARNING536 { int f() { int STATIC_WARNING = 1; return STATIC_WARNING / boost::static_warning_impl<(bool)( check_tracking<T>::value )>::value; } };
        save(ar, const_cast<const T &>(t));
}


}
}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_oarchive.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_oarchive.hpp" 2 3



namespace boost {
namespace archive {
namespace detail {

class basic_pointer_oserializer;

template<class Archive>
class interface_oarchive
{
protected:
    interface_oarchive(){};
public:


    typedef mpl::bool_<false> is_loading;
    typedef mpl::bool_<true> is_saving;


    Archive * This(){
        return static_cast<Archive *>(this);
    }

    template<class T>
    const basic_pointer_oserializer *
    register_type(const T * = __null){
        const basic_pointer_oserializer & bpos =
            boost::serialization::singleton<
                pointer_oserializer<Archive, T>
            >::get_const_instance();
        this->This()->register_basic_serializer(bpos.get_basic_serializer());
        return & bpos;
    }

    template<class T>
    Archive & operator<<(T & t){
        this->This()->save_override(t, 0);
        return * this->This();
    }


    template<class T>
    Archive & operator&(T & t){

            return * this->This() << const_cast<const T &>(t);



    }
};

}
}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 84 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_oarchive.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/common_oarchive.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/register_archive.hpp" 1 3






namespace boost { namespace archive { namespace detail {







struct adl_tag {};

template <class Archive, class Serializable>
struct ptr_serialization_support;





template <class Archive, class Serializable>
struct _ptr_serialization_support
  : ptr_serialization_support<Archive,Serializable>
{
    typedef int type;
};




template <class Serializable>
void instantiate_ptr_serialization(Serializable*, int, adl_tag ) {}
# 51 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/register_archive.hpp" 3
}}}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/common_oarchive.hpp" 2 3

namespace boost {
namespace archive {
namespace detail {


template<class Archive>
class common_oarchive :
    public basic_oarchive,
    public interface_oarchive<Archive>
{
    friend class interface_oarchive<Archive>;
private:
    virtual void vsave(const version_type t){
        * this->This() << t;
    }
    virtual void vsave(const object_id_type t){
        * this->This() << t;
    }
    virtual void vsave(const object_reference_type t){
        * this->This() << t;
    }
    virtual void vsave(const class_id_type t){
        * this->This() << t;
    }
    virtual void vsave(const class_id_reference_type t){
        * this->This() << t;
    }
    virtual void vsave(const class_id_optional_type t){
        * this->This() << t;
    }
    virtual void vsave(const class_name_type & t){
        * this->This() << t;
    }
    virtual void vsave(const tracking_type t){
        * this->This() << t;
    }
protected:

    template<class T>
    void save_override(T & t, int){
        archive::save(* this->This(), t);
    }
    void save_start(const char * ){}
    void save_end(const char * ){}
    common_oarchive(unsigned int flags = 0) :
        basic_oarchive(flags),
        interface_oarchive<Archive>()
    {}
};

}
}
}
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oarchive.hpp" 2 3



namespace boost {
namespace archive {
# 45 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_oarchive.hpp" 3
template<class Archive>
class basic_binary_oarchive :
    public archive::detail::common_oarchive<Archive>
{
protected:







    friend class detail::interface_oarchive<Archive>;


    typedef detail::common_oarchive<Archive> detail_common_oarchive;
    template<class T>
    void save_override(const T & t, int version){
      this->detail_common_oarchive::save_override(t, static_cast<int>(version));
    }


    void save_override(const class_id_optional_type & , int){}

    void save_override(const version_type & t, int){


        const unsigned char x = t.t;
        * this->This() << x;
    }
    void save_override(const class_id_type & t, int){

        const int_least16_t x = t.t;
        * this->This() << x;
    }
    void save_override(const class_id_reference_type & t, int){

        const int_least16_t x = t.t;
        * this->This() << x;
    }
    void save_override(const object_id_type & t, int){

        const uint_least32_t x = t.t;
        * this->This() << x;
    }
    void save_override(const object_reference_type & t, int){

        uint_least32_t x = t.t;
        * this->This() << x;
    }
    void save_override(const tracking_type & t, int){
        const char x = t.t;
        * this->This() << x;
    }


    void save_override(const class_name_type & t, int){
        const std::string s(t);
        * this->This() << s;
    }

    void save_override(const serialization::collection_size_type & t, int){

        unsigned int x = t.t;
        * this->This() << x;
   }

    void
    init();

    basic_binary_oarchive(unsigned int flags) :
        detail::common_oarchive<Archive>(flags)
    {}
};

}
}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_oarchive_impl.hpp" 2 3

namespace boost {
namespace archive {

template<class Archive, class Elem, class Tr>
class binary_oarchive_impl :
    public basic_binary_oprimitive<Archive, Elem, Tr>,
    public basic_binary_oarchive<Archive>
{



    friend class detail::interface_oarchive<Archive>;
    friend class basic_binary_oarchive<Archive>;
    friend class save_access;
protected:




    template<class T>
    void save_override(T & t, int){
        this->basic_binary_oarchive<Archive>::save_override(t, 0L);
    }
    void init(unsigned int flags) {
        if(0 != (flags & no_header))
            return;

            this->basic_binary_oarchive<Archive>::init();
            this->basic_binary_oprimitive<Archive, Elem, Tr>::init();




    }
    binary_oarchive_impl(
        std::basic_streambuf<Elem, Tr> & bsb,
        unsigned int flags
    ) :
        basic_binary_oprimitive<Archive, Elem, Tr>(
            bsb,
            0 != (flags & no_codecvt)
        ),
        basic_binary_oarchive<Archive>(flags)
    {
        init(flags);
    }
    binary_oarchive_impl(
        std::basic_ostream<Elem, Tr> & os,
        unsigned int flags
    ) :
        basic_binary_oprimitive<Archive, Elem, Tr>(
            * os.rdbuf(),
            0 != (flags & no_codecvt)
        ),
        basic_binary_oarchive<Archive>(flags)
    {
        init(flags);
    }
};

}
}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_oarchive.hpp" 2 3

namespace boost {
namespace archive {




class binary_oarchive :
    public binary_oarchive_impl<
        binary_oarchive, std::ostream::char_type, std::ostream::traits_type
    >
{
public:
    binary_oarchive(std::ostream & os, unsigned int flags = 0) :
        binary_oarchive_impl<
            binary_oarchive, std::ostream::char_type, std::ostream::traits_type
        >(os, flags)
    {}
    binary_oarchive(std::streambuf & bsb, unsigned int flags = 0) :
        binary_oarchive_impl<
            binary_oarchive, std::ostream::char_type, std::ostream::traits_type
        >(bsb, flags)
    {}
};

typedef binary_oarchive naked_binary_oarchive;

}
}


namespace boost { namespace archive { namespace detail { template <class Serializable> typename _ptr_serialization_support<boost::archive::binary_oarchive, Serializable>::type instantiate_ptr_serialization( Serializable*, boost::archive::binary_oarchive*, adl_tag ); }}}
namespace boost { namespace serialization { template <> struct use_array_optimization<boost::archive::binary_oarchive> { template <class ValueType> struct apply : boost::mpl::apply1<boost::archive::binary_oarchive::use_array_optimization , typename boost::remove_const<ValueType>::type >::type {}; }; }}
# 25 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericData.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_iarchive.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_iarchive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_iarchive_impl.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_iarchive_impl.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iprimitive.hpp" 1 3
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iprimitive.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iprimitive.hpp" 2 3
# 46 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iprimitive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 47 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iprimitive.hpp" 2 3
# 55 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iprimitive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/placeholders.hpp" 1 3
# 56 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iprimitive.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 59 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iprimitive.hpp" 2 3

namespace boost {
namespace archive {



template<class Archive, class Elem, class Tr>
class basic_binary_iprimitive
{

    friend class load_access;
protected:



    std::basic_streambuf<Elem, Tr> & m_sb;

    Archive * This(){
        return static_cast<Archive *>(this);
    }


    boost::scoped_ptr<std::locale> archive_locale;
    basic_streambuf_locale_saver<Elem, Tr> locale_saver;



    template<class T>
    void load(T & t){
        load_binary(& t, sizeof(T));
    }





    void load(bool & t){
        load_binary(& t, sizeof(t));
        int i = t;
        (__builtin_expect(!(0 == i || 1 == i), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iprimitive.hpp", 98, "0 == i || 1 == i") : (void)0);
        (void)i;
    }
    void
    load(std::string &s);

    void
    load(std::wstring &ws);

    void
    load(char * t);
    void
    load(wchar_t * t);

    void
    init();
   
    basic_binary_iprimitive(
        std::basic_streambuf<Elem, Tr> & sb,
        bool no_codecvt
    );
   
    ~basic_binary_iprimitive();
public:



    struct use_array_optimization {
        template <class T>
        struct apply : public serialization::is_bitwise_serializable<T> {};
    };


    template <class ValueType>
    void load_array(serialization::array<ValueType>& a, unsigned int)
    {
      load_binary(a.address(),a.count()*sizeof(ValueType));
    }

    void
    load_binary(void *address, std::size_t count);
};

template<class Archive, class Elem, class Tr>
inline void
basic_binary_iprimitive<Archive, Elem, Tr>::load_binary(
    void *address,
    std::size_t count
){

    std::streamsize s = count / sizeof(Elem);
    std::streamsize scount = m_sb.sgetn(
        static_cast<Elem *>(address),
        s
    );
    if(scount != static_cast<std::streamsize>(s))
        boost::throw_exception(
            archive_exception(archive_exception::stream_error)
        );

    s = count % sizeof(Elem);
    if(0 < s){


        Elem t;
        scount = m_sb.sgetn(& t, 1);
        if(scount != 1)
            boost::throw_exception(
                archive_exception(archive_exception::stream_error)
            );
        std::memcpy(static_cast<char*>(address) + (count - s), &t, s);
    }
}

}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 176 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iprimitive.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_iarchive_impl.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iarchive.hpp" 1 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iarchive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/common_iarchive.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/common_iarchive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_iarchive.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_iarchive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_iarchive.hpp" 2 3

namespace boost {
namespace serialization {
    class extended_type_info;
}

namespace archive {
namespace detail {

class basic_iarchive_impl;
class basic_iserializer;
class basic_pointer_iserializer;


class basic_iarchive
{
    friend class basic_iarchive_impl;



    basic_iarchive_impl * pimpl;

    virtual void vload(version_type &t) = 0;
    virtual void vload(object_id_type &t) = 0;
    virtual void vload(class_id_type &t) = 0;
    virtual void vload(class_id_optional_type &t) = 0;
    virtual void vload(class_name_type &t) = 0;
    virtual void vload(tracking_type &t) = 0;
protected:
    basic_iarchive(unsigned int flags);


    virtual

    ~basic_iarchive();
public:

    void next_object_pointer(void *t);
    void register_basic_serializer(
        const basic_iserializer & bis
    );
    void load_object(
        void *t,
        const basic_iserializer & bis
    );
    const basic_pointer_iserializer *
    load_pointer(
        void * & t,
        const
            basic_pointer_iserializer * bpis_ptr,
        const
        basic_pointer_iserializer * (*finder)(
            const boost::serialization::extended_type_info & eti
        )
    );

    void
    set_library_version(unsigned int archive_library_version);
    unsigned int
    get_library_version() const;
    unsigned int
    get_flags() const;
    void
    reset_object_address(const void * new_address, const void * old_address);
    void
    delete_created_pointers();
};

}
}
}







# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 107 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_iarchive.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/common_iarchive.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_iarchive.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_iarchive.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_iarchive.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 1 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/no_exceptions_support.hpp" 1 3
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 2 3
# 55 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/less.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/less.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply_wrap.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/numeric_op.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 2 3







# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/less.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/less.hpp" 3
namespace boost { namespace mpl {

template<
      typename Tag1
    , typename Tag2
    >
struct less_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )

        , aux::cast2nd_impl< less_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< less_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};


template<> struct less_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename Tag > struct less_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};

template< typename T > struct less_tag
{
    typedef typename T::tag type;
};

template<
      typename N1 = na
    , typename N2 = na
    >
struct less

    : less_impl<
          typename less_tag<N1>::type
        , typename less_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   

};

template<> struct less< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : less< T1 , T2 > { }; }; template< typename Tag > struct lambda< less< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef less< na , na > result_; typedef less< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< less< T1 , T2 > > : int_<2> { }; template<> struct template_arity< less< na , na > > : int_<-1> { }; }

}}

namespace boost { namespace mpl {

template<>
struct less_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply

        : bool_< ( N2::value > N1::value ) >
    {
    };
};

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/comparison_op.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/less.hpp" 2 3
# 56 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/limits/list.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list.hpp" 2 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list20.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list20.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list10.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list10.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/long.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/long.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/long_fwd.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/long_fwd.hpp" 3
namespace mpl_ {

template< long N > struct long_;

}
namespace boost { namespace mpl { using ::mpl_::long_; } }
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/long.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 3
namespace mpl_ {

template< long N >
struct long_
{
    static const long value = N;





    typedef long_ type;

    typedef long value_type;
    typedef integral_c_tag tag;
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/integral_wrapper.hpp" 3
    typedef mpl_::long_< static_cast<long>((value + 1)) > next;
    typedef mpl_::long_< static_cast<long>((value - 1)) > prior;






    operator long() const { return static_cast<long>(this->value); }
};


template< long N >
long const mpl_::long_< N >::value;


}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/long.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/push_front.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/push_front.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/push_front_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/push_front_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct push_front_impl;
template< typename Sequence, typename T > struct push_front;

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/push_front.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/item.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/item.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/tag.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/tag.hpp" 3
namespace boost { namespace mpl { namespace aux {

struct list_tag;
struct l_iter_tag;

}}}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/item.hpp" 2 3



namespace boost { namespace mpl {

template<
      typename Size
    , typename T
    , typename Next
    >
struct l_item
{




    typedef aux::list_tag tag;
    typedef l_item type;

    typedef Size size;
    typedef T item;
    typedef Next next;
};

struct l_end
{



    typedef aux::list_tag tag;
    typedef l_end type;
    typedef long_<0> size;
};

}}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/push_front.hpp" 2 3


namespace boost { namespace mpl {

template<>
struct push_front_impl< aux::list_tag >
{
    template< typename List, typename T > struct apply
    {
        typedef l_item<
              typename next<typename List::size>::type
            , T
            , typename List::type
            > type;
    };
};

}}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/pop_front.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/pop_front.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/pop_front_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/pop_front_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct pop_front_impl;
template< typename Sequence > struct pop_front;

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/pop_front.hpp" 2 3



namespace boost { namespace mpl {

template<>
struct pop_front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename mpl::next<List>::type type;
    };
};

}}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/push_back.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/push_back.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/push_back_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/push_back_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct push_back_impl;
template< typename Sequence, typename T > struct push_back;

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/push_back.hpp" 2 3



namespace boost { namespace mpl {

template< typename Tag > struct has_push_back_impl;

template<>
struct has_push_back_impl< aux::list_tag >
{
    template< typename Seq > struct apply
        : false_
    {
    };
};

}}
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/front.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/front.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/front_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/front_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct front_impl;
template< typename Sequence > struct front;

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/front.hpp" 2 3


namespace boost { namespace mpl {

template<>
struct front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename List::item type;
    };
};

}}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/clear.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/clear.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/clear_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/clear_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct clear_impl;
template< typename Sequence > struct clear;

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/clear.hpp" 2 3



namespace boost { namespace mpl {

template<>
struct clear_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_end type;
    };
};

}}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/O1_size.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/O1_size.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/O1_size_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/O1_size_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct O1_size_impl;
template< typename Sequence > struct O1_size;

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/O1_size.hpp" 2 3


namespace boost { namespace mpl {

template<>
struct O1_size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/size.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/size.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/size_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/size_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct size_impl;
template< typename Sequence > struct size;

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/size.hpp" 2 3


namespace boost { namespace mpl {

template<>
struct size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/empty.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/empty.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/empty_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/empty_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct empty_impl;
template< typename Sequence > struct empty;

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/empty.hpp" 2 3



namespace boost { namespace mpl {

template<>
struct empty_impl< aux::list_tag >
{
    template< typename List > struct apply
        : not_<typename List::size>
    {
    };
};

}}
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/begin_end.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/begin_end.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/begin_end_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/begin_end_fwd.hpp" 3
namespace boost { namespace mpl {

template< typename Tag > struct begin_impl;
template< typename Tag > struct end_impl;

template< typename Sequence > struct begin;
template< typename Sequence > struct end;

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/begin_end.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/iterator.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/iterator.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/iterator_tags.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/iterator_tags.hpp" 3
namespace boost { namespace mpl {

struct forward_iterator_tag : int_<0> { typedef forward_iterator_tag type; };
struct bidirectional_iterator_tag : int_<1> { typedef bidirectional_iterator_tag type; };
struct random_access_iterator_tag : int_<2> { typedef random_access_iterator_tag type; };

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/iterator.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/deref.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/deref.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/msvc_type.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/msvc_type.hpp" 3
namespace boost { namespace mpl { namespace aux {
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/msvc_type.hpp" 3
template< typename T > struct msvc_type
{
    typedef typename T::type type;
};

template<> struct msvc_type<int>
{
    typedef int type;
};



}}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/deref.hpp" 2 3




namespace boost { namespace mpl {

template<
      typename Iterator = na
    >
struct deref
{

    typedef typename Iterator::type type;



   
};

template<> struct deref< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : deref< T1 > { }; }; template< typename Tag > struct lambda< deref< na > , Tag , int_<-1> > { typedef false_ is_le; typedef deref< na > result_; typedef deref< na > type; }; namespace aux { template< typename T1 > struct template_arity< deref< T1 > > : int_<1> { }; template<> struct template_arity< deref< na > > : int_<-1> { }; }

}}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/iterator.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/lambda_spec.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/iterator.hpp" 2 3


namespace boost { namespace mpl {



template< typename Node >
struct l_iter
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;
};

template< typename Node >
struct deref< l_iter<Node> >
{
    typedef typename Node::item type;
};

template< typename Node >
struct next< l_iter<Node> >
{
    typedef l_iter< typename Node::next > type;
};
# 62 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/iterator.hpp" 3
template<> struct l_iter<l_end>
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;




};

template< typename T1 , typename Tag > struct lambda< l_iter< T1 > , Tag , int_<1> > { typedef false_ is_le; typedef l_iter< T1 > result_; typedef result_ type; };

}}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/begin_end.hpp" 2 3



namespace boost { namespace mpl {

template<>
struct begin_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_iter<typename List::type> type;
    };
};

template<>
struct end_impl< aux::list_tag >
{
    template< typename > struct apply
    {
        typedef l_iter<l_end> type;
    };
};

}}
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list0.hpp" 2 3


namespace boost { namespace mpl {

template< typename Dummy = na > struct list0;

template<> struct list0<na>
    : l_end
{
    typedef l_end type;
};

}}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list10.hpp" 2 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list10.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/include_preprocessed.hpp" 1 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpp" 3
namespace boost { namespace mpl {

template<
      typename T0
    >
struct list1
    : l_item<
          long_<1>
        , T0
        , l_end
        >
{
    typedef list1 type;
};

template<
      typename T0, typename T1
    >
struct list2
    : l_item<
          long_<2>
        , T0
        , list1<T1>
        >
{
    typedef list2 type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list3
    : l_item<
          long_<3>
        , T0
        , list2< T1,T2 >
        >
{
    typedef list3 type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list4
    : l_item<
          long_<4>
        , T0
        , list3< T1,T2,T3 >
        >
{
    typedef list4 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list5
    : l_item<
          long_<5>
        , T0
        , list4< T1,T2,T3,T4 >
        >
{
    typedef list5 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list6
    : l_item<
          long_<6>
        , T0
        , list5< T1,T2,T3,T4,T5 >
        >
{
    typedef list6 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list7
    : l_item<
          long_<7>
        , T0
        , list6< T1,T2,T3,T4,T5,T6 >
        >
{
    typedef list7 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list8
    : l_item<
          long_<8>
        , T0
        , list7< T1,T2,T3,T4,T5,T6,T7 >
        >
{
    typedef list8 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list9
    : l_item<
          long_<9>
        , T0
        , list8< T1,T2,T3,T4,T5,T6,T7,T8 >
        >
{
    typedef list9 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list10
    : l_item<
          long_<10>
        , T0
        , list9< T1,T2,T3,T4,T5,T6,T7,T8,T9 >
        >
{
    typedef list10 type;
};

}}
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/include_preprocessed.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list10.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list20.hpp" 2 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list20.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/include_preprocessed.hpp" 1 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpp" 3
namespace boost { namespace mpl {

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list11
    : l_item<
          long_<11>
        , T0
        , list10< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
        >
{
    typedef list11 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list12
    : l_item<
          long_<12>
        , T0
        , list11< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
        >
{
    typedef list12 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list13
    : l_item<
          long_<13>
        , T0
        , list12< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
        >
{
    typedef list13 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list14
    : l_item<
          long_<14>
        , T0
        , list13< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
        >
{
    typedef list14 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list15
    : l_item<
          long_<15>
        , T0
        , list14< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >
        >
{
    typedef list15 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list16
    : l_item<
          long_<16>
        , T0
        , list15< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >
        >
{
    typedef list16 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list17
    : l_item<
          long_<17>
        , T0
        , list16< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >
        >
{
    typedef list17 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list18
    : l_item<
          long_<18>
        , T0
        , list17< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >
        >
{
    typedef list18 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list19
    : l_item<
          long_<19>
        , T0
        , list18< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >
        >
{
    typedef list19 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list20
    : l_item<
          long_<20>
        , T0
        , list19< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >
        >
{
    typedef list20 type;
};

}}
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/aux_/include_preprocessed.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list/list20.hpp" 2 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list.hpp" 2 3
# 46 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/list.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/preprocessed/gcc/list.hpp" 3
namespace boost { namespace mpl {

template<
      typename T0 = na, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na, typename T6 = na, typename T7 = na
    , typename T8 = na, typename T9 = na, typename T10 = na, typename T11 = na
    , typename T12 = na, typename T13 = na, typename T14 = na
    , typename T15 = na, typename T16 = na, typename T17 = na
    , typename T18 = na, typename T19 = na
    >
struct list;

template<

    >
struct list<
          na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list0< >
{
    typedef list0< >::type type;
};

template<
      typename T0
    >
struct list<
          T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list1<T0>
{
    typedef typename list1<T0>::type type;
};

template<
      typename T0, typename T1
    >
struct list<
          T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list2< T0,T1 >
{
    typedef typename list2< T0,T1 >::type type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list<
          T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list3< T0,T1,T2 >
{
    typedef typename list3< T0,T1,T2 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list<
          T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list4< T0,T1,T2,T3 >
{
    typedef typename list4< T0,T1,T2,T3 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list<
          T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list5< T0,T1,T2,T3,T4 >
{
    typedef typename list5< T0,T1,T2,T3,T4 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list<
          T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list6< T0,T1,T2,T3,T4,T5 >
{
    typedef typename list6< T0,T1,T2,T3,T4,T5 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list7< T0,T1,T2,T3,T4,T5,T6 >
{
    typedef typename list7< T0,T1,T2,T3,T4,T5,T6 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list8< T0,T1,T2,T3,T4,T5,T6,T7 >
{
    typedef typename list8< T0,T1,T2,T3,T4,T5,T6,T7 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
{
    typedef typename list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na
        , na, na, na
        >
    : list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
{
    typedef typename list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na
        , na, na, na
        >
    : list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
{
    typedef typename list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na
        , na, na, na, na
        >
    : list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
{
    typedef typename list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na
        , na, na, na, na
        >
    : list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
{
    typedef typename list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na
        , na, na, na, na
        >
    : list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
{
    typedef typename list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na
        , na, na, na, na
        >
    : list15<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        >
{
    typedef typename list15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, na, na, na, na
        >
    : list16<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15
        >
{
    typedef typename list16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, na, na, na
        >
    : list17<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16
        >
{
    typedef typename list17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, na, na
        >
    : list18<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17
        >
{
    typedef typename list18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, na
        >
    : list19<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18
        >
{
    typedef typename list19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >::type type;
};



template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list
    : list20<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, T19
        >
{
    typedef typename list20< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >::type type;
};

}}
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3
# 47 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/list.hpp" 2 3
# 59 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/empty.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/empty.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/sequence_tag.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/sequence_tag.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/sequence_tag_fwd.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/sequence_tag_fwd.hpp" 3
namespace boost { namespace mpl {

struct nested_begin_end_tag;
struct non_sequence_tag;

template< typename Sequence > struct sequence_tag;

}}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/sequence_tag.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/has_begin.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/has_begin.hpp" 3
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_begin { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::begin>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/sequence_tag.hpp" 2 3






namespace boost { namespace mpl {
# 78 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/sequence_tag.hpp" 3
namespace aux {

template< bool has_tag_, bool has_begin_ >
struct sequence_tag_impl
{


    template< typename Sequence > struct result2_;
};
# 98 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/sequence_tag.hpp" 3
template<> struct sequence_tag_impl<true,true> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<true,false> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<false,true> { template< typename Sequence > struct result2_ { typedef nested_begin_end_tag type; }; };
template<> struct sequence_tag_impl<false,false> { template< typename Sequence > struct result2_ { typedef non_sequence_tag type; }; };



}

template<
      typename Sequence = na
    >
struct sequence_tag
    : aux::sequence_tag_impl<
          ::boost::mpl::aux::has_tag<Sequence>::value
        , ::boost::mpl::aux::has_begin<Sequence>::value
        >::template result2_<Sequence>
{
};



template<> struct sequence_tag< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : sequence_tag< T1 > { }; }; template< typename Tag > struct lambda< sequence_tag< na > , Tag , int_<-1> > { typedef false_ is_le; typedef sequence_tag< na > result_; typedef sequence_tag< na > type; }; namespace aux { template< typename T1 > struct template_arity< sequence_tag< T1 > > : int_<1> { }; template<> struct template_arity< sequence_tag< na > > : int_<-1> { }; }

}}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/empty.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/empty_impl.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/empty_impl.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/begin_end.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/begin_end.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/begin_end_impl.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/begin_end_impl.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/traits_lambda_spec.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/begin_end_impl.hpp" 2 3


namespace boost { namespace mpl {


namespace aux {

template< typename Sequence >
struct begin_type
{
    typedef typename Sequence::begin type;
};
template< typename Sequence >
struct end_type
{
    typedef typename Sequence::end type;
};

}





template< typename Tag >
struct begin_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::begin_type<Sequence>, void_>::type type;
    };
};

template< typename Tag >
struct end_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::end_type<Sequence>, void_>::type type;
    };
};
# 82 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/begin_end_impl.hpp" 3
template<> struct begin_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::begin type; }; };
template<> struct end_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::end type; }; };




template<> struct begin_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct begin_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };







}}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/begin_end.hpp" 2 3




namespace boost { namespace mpl {




template<
      typename Sequence = na
    >
struct begin
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename begin_impl< tag_ >
        ::template apply< Sequence >::type type;

   
};

template<
      typename Sequence = na
    >
struct end
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename end_impl< tag_ >
        ::template apply< Sequence >::type type;

   
};

template<> struct begin< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : begin< T1 > { }; }; template< typename Tag > struct lambda< begin< na > , Tag , int_<-1> > { typedef false_ is_le; typedef begin< na > result_; typedef begin< na > type; }; namespace aux { template< typename T1 > struct template_arity< begin< T1 > > : int_<1> { }; template<> struct template_arity< begin< na > > : int_<-1> { }; }
template<> struct end< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : end< T1 > { }; }; template< typename Tag > struct lambda< end< na > , Tag , int_<-1> > { typedef false_ is_le; typedef end< na > result_; typedef end< na > type; }; namespace aux { template< typename T1 > struct template_arity< end< T1 > > : int_<1> { }; template<> struct template_arity< end< na > > : int_<-1> { }; }

}}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/aux_/empty_impl.hpp" 2 3



namespace boost { namespace mpl {




template< typename Tag >
struct empty_impl
{
    template< typename Sequence > struct apply
        : is_same<
              typename begin<Sequence>::type
            , typename end<Sequence>::type
            >
    {
    };
};

 template<> struct empty_impl<non_sequence_tag> {};

}}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/empty.hpp" 2 3



namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct empty
    : empty_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct empty< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : empty< T1 > { }; }; template< typename Tag > struct lambda< empty< na > , Tag , int_<-1> > { typedef false_ is_le; typedef empty< na > result_; typedef empty< na > type; }; namespace aux { template< typename T1 > struct template_arity< empty< T1 > > : int_<1> { }; template<> struct template_arity< empty< na > > : int_<-1> { }; }

}}
# 60 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 2 3
# 68 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_iserializer.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_iserializer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_iserializer.hpp" 2 3

namespace boost {

namespace serialization {
    class extended_type_info;
}


namespace archive {
namespace detail {

class basic_iarchive;
class basic_pointer_iserializer;

class basic_iserializer :
    public basic_serializer
{
private:
    basic_pointer_iserializer *m_bpis;
protected:
    explicit basic_iserializer(
        const boost::serialization::extended_type_info & type
    );


    virtual

    ~basic_iserializer();
public:
    bool serialized_as_pointer() const {
        return m_bpis != __null;
    }
    void set_bpis(basic_pointer_iserializer *bpis){
        m_bpis = bpis;
    }
    const basic_pointer_iserializer * get_bpis_ptr() const {
        return m_bpis;
    }
    virtual void load_object_data(
        basic_iarchive & ar,
        void *x,
        const unsigned int file_version
    ) const = 0;

    virtual bool class_info() const = 0 ;

    virtual bool tracking(const unsigned int) const = 0 ;

    virtual unsigned int version() const = 0 ;

    virtual bool is_polymorphic() const = 0;
    virtual void destroy( void *address) const = 0 ;
};

}
}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 85 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_iserializer.hpp" 2 3
# 69 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_iserializer.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_iserializer.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_iserializer.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_pointer_iserializer.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_pointer_iserializer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_pointer_iserializer.hpp" 2 3

namespace boost {

namespace serialization {
    class extended_type_info;
}


namespace archive {
namespace detail {

class basic_iarchive;
class basic_iserializer;

class basic_pointer_iserializer
    : public basic_serializer {
protected:
    explicit basic_pointer_iserializer(
        const boost::serialization::extended_type_info & type_
    );


    virtual

    ~basic_pointer_iserializer();
public:
    virtual const basic_iserializer & get_basic_serializer() const = 0;
    virtual void load_object_ptr(
        basic_iarchive & ar,
        void * & x,
        const unsigned int file_version
    ) const = 0;
};

}
}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 63 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/basic_pointer_iserializer.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_iserializer.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_iserializer.hpp" 2 3

namespace boost {

namespace serialization {
    class extended_type_info;
}

namespace archive {
namespace detail {

template<class Archive>
class archive_pointer_iserializer :
    public basic_pointer_iserializer {
protected:
    explicit
    archive_pointer_iserializer(
        const boost::serialization::extended_type_info & eti
    );
   


    virtual

    ~archive_pointer_iserializer();
public:
    virtual const basic_iserializer & get_basic_serializer() const
# 62 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_iserializer.hpp" 3
    = 0;

    virtual void load_object_ptr(
        basic_iarchive & ar,
        void * & x,
        const unsigned int file_version
    ) const





    = 0;





    static const basic_pointer_iserializer *
    find(
        const boost::serialization::extended_type_info & eti
    );
};

}
}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 91 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/archive_pointer_iserializer.hpp" 2 3
# 70 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 2 3
# 83 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 3
namespace boost {

namespace serialization {
    class extended_type_info;
}

namespace archive {



class load_access {
public:
    template<class Archive, class T>
    static void load_primitive(Archive &ar, T &t){
        ar.load(t);
    }
};

namespace detail {

template<class Archive, class T>
class iserializer : public basic_iserializer
{
private:
    virtual void destroy( void *address) const {
        boost::serialization::access::destroy(static_cast<T *>(address));
    }


public:
    explicit iserializer() :
        basic_iserializer(
            boost::serialization::type_info_implementation<T>::type
                ::get_const_instance()
        )
    {}
    virtual void load_object_data(
        basic_iarchive & ar,
        void *x,
        const unsigned int file_version
    ) const __attribute__ ((used));
    virtual bool class_info() const {
        return boost::serialization::implementation_level<T>::value
            >= boost::serialization::object_class_info;
    }
    virtual bool tracking(const unsigned int ) const {
        return boost::serialization::tracking_level<T>::value
                == boost::serialization::track_always
            || ( boost::serialization::tracking_level<T>::value
                == boost::serialization::track_selectively
                && serialized_as_pointer());
    }
    virtual unsigned int version() const {
        return ::boost::serialization::version<T>::value;
    }
    virtual bool is_polymorphic() const {
        return boost::is_polymorphic<T>::value;
    }
    virtual ~iserializer(){};
};

template<class Archive, class T>
 void iserializer<Archive, T>::load_object_data(
    basic_iarchive & ar,
    void *x,
    const unsigned int file_version
) const {


    boost::serialization::serialize_adl(
        boost::smart_cast_reference<Archive &>(ar),
        * static_cast<T *>(x),
        file_version
    );
}

template<class Archive, class T>
class pointer_iserializer
  : public archive_pointer_iserializer<Archive>
{
private:
    virtual const basic_iserializer & get_basic_serializer() const {
        return boost::serialization::singleton<
            iserializer<Archive, T>
        >::get_const_instance();
    }
    virtual void load_object_ptr(
        basic_iarchive & ar,
        void * & x,
        const unsigned int file_version
    ) const __attribute__ ((used));
public:
    pointer_iserializer();
};
# 191 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 3
template<class T>
struct heap_allocator
{
# 217 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 3
        static T * invoke(){
            return static_cast<T *>(operator new(sizeof(T)));
        }

};


template <typename T>
class auto_ptr_with_deleter
{
public:
    explicit auto_ptr_with_deleter(T* p) :
        m_p(p)
    {}
    ~auto_ptr_with_deleter(){
        if (m_p)
            boost::serialization::access::destroy(m_p);
    }
    T* get() const {
        return m_p;
    }

    T* release() {
        T* p = m_p;
        m_p = __null;
        return p;
    }
private:
    T* m_p;
};

template<class Archive, class T>
 void pointer_iserializer<Archive, T>::load_object_ptr(
    basic_iarchive & ar,
    void * & x,
    const unsigned int file_version
) const
{
    Archive & ar_impl = boost::smart_cast_reference<Archive &>(ar);

    auto_ptr_with_deleter<T> ap(heap_allocator<T>::invoke());
    if(__null == ap.get())
        boost::throw_exception(std::bad_alloc()) ;

    T * t = ap.get();
    x = t;




    { try {


        ar.next_object_pointer(t);
        boost::serialization::load_construct_data_adl<Archive, T>(
            ar_impl,
            t,
            file_version
        );
    }
    catch(...){
        ap.release();
        throw;;
    }
    }

    ar_impl >> boost::serialization::make_nvp(__null, * t);
    ap.release();
}

template<class Archive, class T>
pointer_iserializer<Archive, T>::pointer_iserializer() :
    archive_pointer_iserializer<Archive>(
        boost::serialization::type_info_implementation<T>::type
            ::get_const_instance()
    )
{
    boost::serialization::singleton<
        iserializer<Archive, T>
    >::get_mutable_instance().set_bpis(this);
}

template<class Archive, class T>
struct load_non_pointer_type {


    struct load_primitive {
        static void invoke(Archive & ar, T & t){
            load_access::load_primitive(ar, t);
        }
    };


    struct load_only {
        static void invoke(Archive & ar, T & t){



            boost::serialization::serialize_adl(
                ar, t, boost::serialization::version<T>::value
            );
        }
    };



    struct load_standard {
        static void invoke(Archive &ar, T &t){



            typedef typename boost::remove_const<T>::type typex;
            void * x = & const_cast<typex &>(t);
            ar.load_object(
                x,
                boost::serialization::singleton<
                    iserializer<Archive, T>
                >::get_const_instance()
            );
        }
    };

    struct load_conditional {
        static void invoke(Archive &ar, T &t){

                load_standard::invoke(ar, t);


        }
    };

    typedef typename mpl::eval_if<

            mpl::equal_to<
                boost::serialization::implementation_level<T>,
                mpl::int_<boost::serialization::primitive_type>
            >,
            mpl::identity<load_primitive>,

        typename mpl::eval_if<

        mpl::greater_equal<
                    boost::serialization::implementation_level<T>,
                    mpl::int_<boost::serialization::object_class_info>
                >,

        mpl::identity<load_standard>,

    typename mpl::eval_if<

                mpl::equal_to<
                    boost::serialization::tracking_level<T>,
                    mpl::int_<boost::serialization::track_never>
            >,

            mpl::identity<load_only>,


        mpl::identity<load_conditional>
    > > >::type typex;

    static void invoke(Archive & ar, T &t){





        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( mpl::greater_equal< boost::serialization::implementation_level<T>, mpl::int_<boost::serialization::primitive_type> >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_389;





        typex::invoke(ar, t);
    }
};

template<class Archive, class Tptr>
struct load_pointer_type {
    template<class T>
    struct abstract
    {
        static const basic_pointer_iserializer * register_type(Archive & ){

            typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((boost::is_polymorphic<T>::value) == 0 ? false : true) >)> boost_static_assert_typedef_401;
            return static_cast<basic_pointer_iserializer *>(__null);
         }
    };

    template<class T>
    struct non_abstract
    {
        static const basic_pointer_iserializer * register_type(Archive & ar){
            return ar.register_type(static_cast<T *>(__null));
        }
    };

    template<class T>
    static const basic_pointer_iserializer * register_type(Archive &ar, T & ){




        typedef typename
            mpl::eval_if<
                boost::serialization::is_abstract<const T>,
                mpl::identity<abstract<T> >,
                mpl::identity<non_abstract<T> >
            >::type typex;
        return typex::register_type(ar);
    }

    template<class T>
    static T * pointer_tweak(
        const boost::serialization::extended_type_info & eti,
        void * t,
        T &
    ) {

        return static_cast<T *>(
            boost::serialization::void_upcast(
                eti,
                boost::serialization::type_info_implementation<T>::type
                    ::get_const_instance(),
                t
            )
        );
    }

    static void invoke(Archive & ar, Tptr & t){
        const basic_pointer_iserializer * bpis_ptr = register_type(ar, *t);
        const basic_pointer_iserializer * newbpis_ptr = ar.load_pointer(
            * reinterpret_cast<void **>(&t),
            bpis_ptr,
            archive_pointer_iserializer<Archive>::find
        );

        if(newbpis_ptr != bpis_ptr){
            t = pointer_tweak(newbpis_ptr->get_eti(), t, *t);
        }
    }
};

template<class Archive, class T>
struct load_enum_type {
    static void invoke(Archive &ar, T &t){

        int i;
        ar >> boost::serialization::make_nvp(__null, i);
        t = static_cast<T>(i);
    }
};

template<class Archive, class T>
struct load_array_type {
    static void invoke(Archive &ar, T &t){
        typedef typename remove_extent<T>::type value_type;


        int current_count = sizeof(t) / (
            static_cast<char *>(static_cast<void *>(&t[1]))
            - static_cast<char *>(static_cast<void *>(&t[0]))
        );
        int count;
        ar >> boost::serialization::make_nvp("count", count);
        if(count > current_count)
            boost::throw_exception(archive::archive_exception(
                boost::archive::archive_exception::array_size_too_short
            ));
        ar >> serialization::make_array(static_cast<value_type*>(&t[0]),count);
    }
};

}

template<class Archive, class T>
inline void load(Archive &ar, T &t){




    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((! boost::is_const<T>::value) == 0 ? false : true) >)> boost_static_assert_typedef_498;
    typedef
        typename mpl::eval_if<is_pointer<T>,
            mpl::identity<detail::load_pointer_type<Archive, T> >
        ,
        typename mpl::eval_if<is_array<T>,
            mpl::identity<detail::load_array_type<Archive, T> >
        ,
        typename mpl::eval_if<is_enum<T>,
            mpl::identity<detail::load_enum_type<Archive, T> >
        ,
            mpl::identity<detail::load_non_pointer_type<Archive, T> >
        >
        >
        >::type typex;
    typex::invoke(ar, t);
}
# 533 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/iserializer.hpp" 3
template<class Archive, class T>
inline void load_wrapper(Archive &ar, const T&t, mpl::true_){
    boost::archive::load(ar, const_cast<T&>(t));
}


template<class Archive, class T>
inline void load(Archive &ar, const T&t){
  load_wrapper(ar,t,serialization::is_wrapper<T>());
}



}
}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_iarchive.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_iarchive.hpp" 2 3

namespace boost {
namespace archive {
namespace detail {

class basic_pointer_iserializer;

template<class Archive>
class interface_iarchive
{
protected:
    interface_iarchive(){};
public:


    typedef mpl::bool_<true> is_loading;
    typedef mpl::bool_<false> is_saving;


    Archive * This(){
        return static_cast<Archive *>(this);
    }

    template<class T>
    const basic_pointer_iserializer *
    register_type(T * = __null){
        const basic_pointer_iserializer & bpis =
            boost::serialization::singleton<
                pointer_iserializer<Archive, T>
            >::get_const_instance();
        this->This()->register_basic_serializer(bpis.get_basic_serializer());
        return & bpis;
    }
    template<class T>
    Archive & operator>>(T & t){
        this->This()->load_override(t, 0);
        return * this->This();
    }


    template<class T>
    Archive & operator&(T & t){
        return *(this->This()) >> t;
    }
};

}
}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 77 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/interface_iarchive.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/common_iarchive.hpp" 2 3




namespace boost {
namespace archive {
namespace detail {


template<class Archive>
class common_iarchive :
    public basic_iarchive,
    public interface_iarchive<Archive>
{
    friend class interface_iarchive<Archive>;
private:
    virtual void vload(version_type & t){
        * this->This() >> t;
    }
    virtual void vload(object_id_type & t){
        * this->This() >> t;
    }
    virtual void vload(class_id_type & t){
        * this->This() >> t;
    }
    virtual void vload(class_id_optional_type & t){
        * this->This() >> t;
    }
    virtual void vload(tracking_type & t){
        * this->This() >> t;
    }
    virtual void vload(class_name_type &s){
        * this->This() >> s;
    }
protected:

    template<class T>
    void load_override(T & t, int){
        archive::load(* this->This(), t);
    }


    void load_start(const char * ){}
    void load_end(const char * ){}

    common_iarchive(unsigned int flags = 0) :
        basic_iarchive(flags),
        interface_iarchive<Archive>()
    {}
};

}
}
}
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iarchive.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_prefix.hpp" 2 3
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iarchive.hpp" 2 3

namespace boost {
namespace archive {



template<class Archive>
class basic_binary_iarchive :
    public detail::common_iarchive<Archive>
{
protected:







    friend class detail::interface_iarchive<Archive>;





    typedef detail::common_iarchive<Archive> detail_common_iarchive;
    template<class T>
    void load_override(T & t, int version){
      this->detail_common_iarchive::load_override(t, static_cast<int>(version));
    }

    void load_override(class_id_optional_type & , int){}



    void load_override(version_type & t, int){

        unsigned char x=0;
        * this->This() >> x;
        t = version_type(x);
    }
    void load_override(class_id_type & t, int){

        int_least16_t x=0;
        * this->This() >> x;
        t = class_id_type(x);
    }
    void load_override(class_id_reference_type & t, int){

        int_least16_t x=0;
        * this->This() >> x;
        t = class_id_reference_type(x);
    }
    void load_override(object_id_type & t, int){

        uint_least32_t x=0;
        * this->This() >> x;
        t = object_id_type(x);
    }
    void load_override(object_reference_type & t, int){

        uint_least32_t x=0;
        * this->This() >> x;
        t = object_reference_type(x);
    }
    void load_override(tracking_type & t, int){
        char x=0;
        * this->This() >> x;
        t = (0 != x);
    }
  void load_override(serialization::collection_size_type & t, int){
       unsigned int x=0;
       * this->This() >> x;
       t = serialization::collection_size_type(x);
   }

    void
    load_override(class_name_type & t, int);
    void
    init();

    basic_binary_iarchive(unsigned int flags) :
        detail::common_iarchive<Archive>(flags)
    {}
};

}
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/detail/abi_suffix.hpp" 2 3
# 124 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/basic_binary_iarchive.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_iarchive_impl.hpp" 2 3

namespace boost {
namespace archive {

template<class Archive, class Elem, class Tr>
class binary_iarchive_impl :
    public basic_binary_iprimitive<Archive, Elem, Tr>,
    public basic_binary_iarchive<Archive>
{



    friend class detail::interface_iarchive<Archive>;
    friend class basic_binary_iarchive<Archive>;
    friend class load_access;
protected:




    template<class T>
    void load_override(T & t, int){
        this->basic_binary_iarchive<Archive>::load_override(t, 0L);
    }
    void init(unsigned int flags){
        if(0 != (flags & no_header))
            return;

            this->basic_binary_iarchive<Archive>::init();
            this->basic_binary_iprimitive<Archive, Elem, Tr>::init();




    }
    binary_iarchive_impl(
        std::basic_streambuf<Elem, Tr> & bsb,
        unsigned int flags
    ) :
        basic_binary_iprimitive<Archive, Elem, Tr>(
            bsb,
            0 != (flags & no_codecvt)
        ),
        basic_binary_iarchive<Archive>(flags)
    {
        init(flags);
    }
    binary_iarchive_impl(
        std::basic_istream<Elem, Tr> & is,
        unsigned int flags
    ) :
        basic_binary_iprimitive<Archive, Elem, Tr>(
            * is.rdbuf(),
            0 != (flags & no_codecvt)
        ),
        basic_binary_iarchive<Archive>(flags)
    {
        init(flags);
    }
};

}
}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_iarchive.hpp" 2 3

namespace boost {
namespace archive {






class naked_binary_iarchive :
    public binary_iarchive_impl<
        boost::archive::naked_binary_iarchive,
        std::istream::char_type,
        std::istream::traits_type
    >
{
public:
    naked_binary_iarchive(std::istream & is, unsigned int flags = 0) :
        binary_iarchive_impl<
            naked_binary_iarchive, std::istream::char_type, std::istream::traits_type
        >(is, flags)
    {}
    naked_binary_iarchive(std::streambuf & bsb, unsigned int flags = 0) :
        binary_iarchive_impl<
            naked_binary_iarchive, std::istream::char_type, std::istream::traits_type
        >(bsb, flags)
    {}
};

}
}





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/shared_ptr_helper.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/shared_ptr_helper.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/shared_ptr_132.hpp" 1 3
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/shared_ptr_132.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_count_132.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_count_132.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/lightweight_mutex.hpp" 1 3
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/lightweight_mutex.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/lwm_pthreads.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/lwm_pthreads.hpp" 3
namespace boost
{

namespace detail
{

class lightweight_mutex
{
private:

    pthread_mutex_t m_;

    lightweight_mutex(lightweight_mutex const &);
    lightweight_mutex & operator=(lightweight_mutex const &);

public:

    lightweight_mutex()
    {






        pthread_mutex_init(&m_, 0);

    }

    ~lightweight_mutex()
    {
        pthread_mutex_destroy(&m_);
    }

    class scoped_lock;
    friend class scoped_lock;

    class scoped_lock
    {
    private:

        pthread_mutex_t & m_;

        scoped_lock(scoped_lock const &);
        scoped_lock & operator=(scoped_lock const &);

    public:

        scoped_lock(lightweight_mutex & m): m_(m.m_)
        {
            pthread_mutex_lock(&m_);
        }

        ~scoped_lock()
        {
            pthread_mutex_unlock(&m_);
        }
    };
};

}

}
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/lightweight_mutex.hpp" 2 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_count_132.hpp" 2 3
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_count_132.hpp" 3
namespace boost_132 {
# 78 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_count_132.hpp" 3
class bad_weak_ptr: public std::exception
{
public:

    virtual char const * what() const throw()
    {
        return "boost::bad_weak_ptr";
    }
};





namespace detail{

class sp_counted_base
{


    typedef boost::detail::lightweight_mutex mutex_type;

public:

    sp_counted_base(): use_count_(1), weak_count_(1)
    {
    }

    virtual ~sp_counted_base()
    {
    }




    virtual void dispose() = 0;



    virtual void destruct()
    {
        delete this;
    }

    virtual void * get_deleter(std::type_info const & ti) = 0;

    void add_ref_copy()
    {

        mutex_type::scoped_lock lock(mtx_);

        ++use_count_;
    }

    void add_ref_lock()
    {

        mutex_type::scoped_lock lock(mtx_);

        if(use_count_ == 0) boost::throw_exception(bad_weak_ptr());
        ++use_count_;
    }

    void release()
    {
        {

            mutex_type::scoped_lock lock(mtx_);

            long new_use_count = --use_count_;

            if(new_use_count != 0) return;
        }

        dispose();
        weak_release();
    }

    void weak_add_ref()
    {

        mutex_type::scoped_lock lock(mtx_);

        ++weak_count_;
    }

    void weak_release()
    {
        long new_weak_count;

        {

            mutex_type::scoped_lock lock(mtx_);

            new_weak_count = --weak_count_;
        }

        if(new_weak_count == 0)
        {
            destruct();
        }
    }

    long use_count() const
    {

        mutex_type::scoped_lock lock(mtx_);

        return use_count_;
    }


public:
    sp_counted_base(sp_counted_base const &);
    sp_counted_base & operator= (sp_counted_base const &);

    long use_count_;
    long weak_count_;


    mutable mutex_type mtx_;

};
# 241 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_count_132.hpp" 3
template<class P, class D> class sp_counted_base_impl: public sp_counted_base
{

public:
    P ptr;
    D del;

    sp_counted_base_impl(sp_counted_base_impl const &);
    sp_counted_base_impl & operator= (sp_counted_base_impl const &);

    typedef sp_counted_base_impl<P, D> this_type;

public:



    sp_counted_base_impl(P p, D d): ptr(p), del(d)
    {



    }

    virtual void dispose()
    {



        del(ptr);
    }

    virtual void * get_deleter(std::type_info const & ti)
    {
        return ti == typeid(D)? &del: 0;
    }
# 304 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_count_132.hpp" 3
};
# 313 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_count_132.hpp" 3
class weak_count;

class shared_count
{

public:
    sp_counted_base * pi_;





    friend class weak_count;

public:

    shared_count(): pi_(0)



    {
    }

    template<class P, class D> shared_count(P p, D d): pi_(0)



    {


        try
        {
            pi_ = new sp_counted_base_impl<P, D>(p, d);
        }
        catch(...)
        {
            d(p);
            throw;
        }
# 364 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_count_132.hpp" 3
    }





    template<class Y>
    explicit shared_count(std::auto_ptr<Y> & r): pi_(
        new sp_counted_base_impl<
            Y *,
            boost::checked_deleter<Y>
        >(r.get(), boost::checked_deleter<Y>()))



    {
        r.release();
    }



    ~shared_count()
    {
        if(pi_ != 0) pi_->release();



    }

    shared_count(shared_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->add_ref_copy();
    }

    explicit shared_count(weak_count const & r);

    shared_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if(tmp != pi_)
        {
            if(tmp != 0) tmp->add_ref_copy();
            if(pi_ != 0) pi_->release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(shared_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool unique() const
    {
        return use_count() == 1;
    }

    friend inline bool operator==(shared_count const & a, shared_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(shared_count const & a, shared_count const & b)
    {
        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
    }

    void * get_deleter(std::type_info const & ti) const
    {
        return pi_? pi_->get_deleter(ti): 0;
    }
};






class weak_count
{
private:

    sp_counted_base * pi_;





    friend class shared_count;

public:

    weak_count(): pi_(0)



    {
    }

    weak_count(shared_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }

    weak_count(weak_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }

    ~weak_count()
    {
        if(pi_ != 0) pi_->weak_release();



    }

    weak_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;
        if(tmp != 0) tmp->weak_add_ref();
        if(pi_ != 0) pi_->weak_release();
        pi_ = tmp;

        return *this;
    }

    weak_count & operator= (weak_count const & r)
    {
        sp_counted_base * tmp = r.pi_;
        if(tmp != 0) tmp->weak_add_ref();
        if(pi_ != 0) pi_->weak_release();
        pi_ = tmp;

        return *this;
    }

    void swap(weak_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    friend inline bool operator==(weak_count const & a, weak_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(weak_count const & a, weak_count const & b)
    {
        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
    }
};

inline shared_count::shared_count(weak_count const & r): pi_(r.pi_)



{
    if(pi_ != 0)
    {
        pi_->add_ref_lock();
    }
    else
    {
        boost::throw_exception(bad_weak_ptr());
    }
}

}

}


# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp" 2 3
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp" 3
namespace boost_132 {


using namespace boost;


template<class T> class weak_ptr;
template<class T> class enable_shared_from_this;

namespace detail
{

struct static_cast_tag {};
struct const_cast_tag {};
struct dynamic_cast_tag {};
struct polymorphic_cast_tag {};

template<class T> struct shared_ptr_traits
{
    typedef T & reference;
};

template<> struct shared_ptr_traits<void>
{
    typedef void reference;
};



template<> struct shared_ptr_traits<void const>
{
    typedef void reference;
};

template<> struct shared_ptr_traits<void volatile>
{
    typedef void reference;
};

template<> struct shared_ptr_traits<void const volatile>
{
    typedef void reference;
};





template<class T, class Y> void sp_enable_shared_from_this( shared_count const & pn, enable_shared_from_this<T> const * pe, Y const * px )
{
    if(pe != 0) pe->_internal_weak_this._internal_assign(const_cast<Y*>(px), pn);
}

inline void sp_enable_shared_from_this( shared_count const & , ... )
{
}

}
# 110 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp" 3
template<class T> class shared_ptr
{
private:

    typedef shared_ptr<T> this_type;

public:

    typedef T element_type;
    typedef T value_type;
    typedef T * pointer;
    typedef typename detail::shared_ptr_traits<T>::reference reference;

    shared_ptr(): px(0), pn()
    {
    }





    template<class Y>
    explicit shared_ptr(Y * p): px(p), pn(p, checked_deleter<Y>())

    {
        detail::sp_enable_shared_from_this( pn, p, p );
    }







    template<class Y, class D> shared_ptr(Y * p, D d): px(p), pn(p, d)
    {
        detail::sp_enable_shared_from_this( pn, p, p );
    }






    shared_ptr & operator=(shared_ptr const & r)
    {
        px = r.px;
        pn = r.pn;
        return *this;
    }



    template<class Y>
    explicit shared_ptr(weak_ptr<Y> const & r): pn(r.pn)
    {

        px = r.px;
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r): px(r.px), pn(r.pn)
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            pn = detail::shared_count();
        }
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            boost::throw_exception(std::bad_cast());
        }
    }



    template<class Y>
    explicit shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
    {
        Y * tmp = r.get();
        pn = detail::shared_count(r);
        detail::sp_enable_shared_from_this( pn, tmp, tmp );
    }





    template<class Y>
    shared_ptr & operator=(shared_ptr<Y> const & r)
    {
        px = r.px;
        pn = r.pn;
        return *this;
    }





    template<class Y>
    shared_ptr & operator=(std::auto_ptr<Y> & r)
    {
        this_type(r).swap(*this);
        return *this;
    }



    void reset()
    {
        this_type().swap(*this);
    }

    template<class Y> void reset(Y * p)
    {
        (__builtin_expect(!(p == 0 || p != px), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp", 245, "p == 0 || p != px") : (void)0);
        this_type(p).swap(*this);
    }

    template<class Y, class D> void reset(Y * p, D d)
    {
        this_type(p, d).swap(*this);
    }

    reference operator* () const
    {
        (__builtin_expect(!(px != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp", 256, "px != 0") : (void)0);
        return *px;
    }

    T * operator-> () const
    {
        (__builtin_expect(!(px != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp", 262, "px != 0") : (void)0);
        return px;
    }

    T * get() const
    {
        return px;
    }
# 290 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp" 3
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return px == 0? 0: &this_type::px;
    }





    bool operator! () const
    {
        return px == 0;
    }

    bool unique() const
    {
        return pn.unique();
    }

    long use_count() const
    {
        return pn.use_count();
    }

    void swap(shared_ptr<T> & other)
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

    template<class Y> bool _internal_less(shared_ptr<Y> const & rhs) const
    {
        return pn < rhs.pn;
    }

    void * _internal_get_deleter(std::type_info const & ti) const
    {
        return pn.get_deleter(ti);
    }






private:

    template<class Y> friend class shared_ptr;
    template<class Y> friend class weak_ptr;



public:
    T * px;
    detail::shared_count pn;

};

template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() == b.get();
}

template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() != b.get();
}
# 371 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp" 3
template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a._internal_less(b);
}

template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b)
{
    a.swap(b);
}

template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, detail::static_cast_tag());
}

template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, detail::const_cast_tag());
}

template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, detail::dynamic_cast_tag());
}



template<class T, class U> shared_ptr<T> shared_static_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, detail::static_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_dynamic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, detail::dynamic_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_polymorphic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, detail::polymorphic_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_polymorphic_downcast(shared_ptr<U> const & r)
{
    (__builtin_expect(!(dynamic_cast<T *>(r.get()) == r.get()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp", 415, "dynamic_cast<T *>(r.get()) == r.get()") : (void)0);
    return shared_static_cast<T>(r);
}



template<class T> inline T * get_pointer(shared_ptr<T> const & p)
{
    return p.get();
}
# 443 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp" 3
template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)

{
    os << p.get();
    return os;
}
# 467 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/detail/shared_ptr_132.hpp" 3
template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
{
    return static_cast<D *>(p._internal_get_deleter(typeid(D)));
}



}
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/shared_ptr_132.hpp" 2 3





namespace boost_132 {
namespace serialization {
namespace detail {

struct null_deleter {
    void operator()(void const *) const {}
};

}
}
}




namespace boost {
namespace serialization {

template<class Archive, class P, class D>
inline void serialize(
    Archive & ,
    boost_132::detail::sp_counted_base_impl<P, D> & ,
    const unsigned int
){


    boost::serialization::void_cast_register<
        boost_132::detail::sp_counted_base_impl<P, D>,
        boost_132::detail::sp_counted_base
    >(
        static_cast<boost_132::detail::sp_counted_base_impl<P, D> *>(__null),
        static_cast<boost_132::detail::sp_counted_base *>(__null)
    );
}

template<class Archive, class P, class D>
inline void save_construct_data(
    Archive & ar,
    const
    boost_132::detail::sp_counted_base_impl<P, D> *t,
    const unsigned int
){

    ar << boost::serialization::make_nvp("ptr", t->ptr);
}

template<class Archive, class P, class D>
inline void load_construct_data(
    Archive & ar,
    boost_132::detail::sp_counted_base_impl<P, D> * t,
    const unsigned int
){
    P ptr_;
    ar >> boost::serialization::make_nvp("ptr", ptr_);







    ::new(t)boost_132::detail::sp_counted_base_impl<
        P,
        boost_132::serialization::detail::null_deleter
    >(
        ptr_, boost_132::serialization::detail::null_deleter()
    );




    t->use_count_ = 0;
}

}
}




namespace boost {
namespace serialization {

template<class Archive>
inline void save(
    Archive & ar,
    const boost_132::detail::shared_count &t,
    const unsigned int
){
    ar << boost::serialization::make_nvp("pi", t.pi_);
}

template<class Archive>
inline void load(
    Archive & ar,
    boost_132::detail::shared_count &t,
    const unsigned int
){
    ar >> boost::serialization::make_nvp("pi", t.pi_);
    if(__null != t.pi_)
        t.pi_->add_ref_copy();
}

}
}

namespace boost { namespace serialization { template<class Archive> inline void serialize( Archive & ar, boost_132::detail::shared_count & t, const unsigned int file_version ){ split_free(ar, t, file_version); } }}




namespace boost {
namespace serialization {

template<class Archive, class T>
inline void save(
    Archive & ar,
    const boost_132::shared_ptr<T> &t,
    const unsigned int
){


    ar.register_type(static_cast<
        boost_132::detail::sp_counted_base_impl<T *, boost::checked_deleter<T> > *
    >(__null));
    ar << boost::serialization::make_nvp("px", t.px);
    ar << boost::serialization::make_nvp("pn", t.pn);
}

template<class Archive, class T>
inline void load(
    Archive & ar,
    boost_132::shared_ptr<T> &t,
    const unsigned int
){


    ar.register_type(static_cast<
        boost_132::detail::sp_counted_base_impl<T *, boost::checked_deleter<T> > *
    >(__null));
    ar >> boost::serialization::make_nvp("px", t.px);
    ar >> boost::serialization::make_nvp("pn", t.pn);
}

template<class Archive, class T>
inline void serialize(
    Archive & ar,
    boost_132::shared_ptr<T> &t,
    const unsigned int file_version
){


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((boost::serialization::tracking_level<T>::value != boost::serialization::track_never) == 0 ? false : true) >)> boost_static_assert_typedef_196;



    boost::serialization::split_free(ar, t, file_version);
}

}
}
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/shared_ptr_helper.hpp" 2 3




namespace boost_132 {
    template<class T> class shared_ptr;
}
namespace boost {
    template<class T> class shared_ptr;
    namespace serialization {
        class extended_type_info;
        template<class Archive, class T>
        inline void load(
            Archive & ar,
            boost::shared_ptr<T> &t,
            const unsigned int file_version
        );
    }

namespace archive{
namespace detail {

struct null_deleter {
    void operator()(void const *) const {}
};




class shared_ptr_helper {
    typedef std::map<const void *, shared_ptr<void> > collection_type;
    typedef collection_type::const_iterator iterator_type;





    collection_type * m_pointers;




    template<class Archive, class T>
    friend inline void boost::serialization::load(
        Archive & ar,
        boost::shared_ptr<T> &t,
        const unsigned int file_version
    );
# 85 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/shared_ptr_helper.hpp" 3
    std::list<boost_132::shared_ptr<void> > * m_pointers_132;


    template<class T>
    const void * object_identifier(T * t) const {
        const boost::serialization::extended_type_info * true_type
            = boost::serialization::type_info_implementation<T>::type
                ::get_const_instance().get_derived_extended_type_info(*t);


        if(__null == true_type)
            boost::throw_exception(
                boost::archive::archive_exception(
                    boost::archive::archive_exception::unregistered_class
                )
            );
        const boost::serialization::extended_type_info * this_type
            = & boost::serialization::type_info_implementation<T>::type
                    ::get_const_instance();
        const void * vp = void_downcast(
            *true_type,
            *this_type,
            static_cast<const void *>(t)
        );
        return vp;
    }
public:
    template<class T>
    void reset(shared_ptr<T> & s, T * r){
        if(__null == r){
            s.reset();
            return;
        }


        const void * od = object_identifier(r);

        if(__null == m_pointers)
            m_pointers = new collection_type;

        iterator_type it = m_pointers->find(od);

        if(it == m_pointers->end()){
            s.reset(r);
            m_pointers->insert(collection_type::value_type(od,s));
        }
        else{
            s = static_pointer_cast<T>((*it).second);
        }
    }
    void append(const boost_132::shared_ptr<void> & t){
        if(__null == m_pointers_132)
            m_pointers_132 = new std::list<boost_132::shared_ptr<void> >;
        m_pointers_132->push_back(t);
    }
public:
    shared_ptr_helper() :
        m_pointers(__null),
        m_pointers_132(__null)
    {}
    ~shared_ptr_helper(){
        if(__null != m_pointers)
            delete m_pointers;
        if(__null != m_pointers_132)
            delete m_pointers_132;
    }
};

}
}
}
# 58 "/Library/Application Support/MonkeyWorks/Developer/include/boost/archive/binary_iarchive.hpp" 2 3

namespace boost {
namespace archive {




class binary_iarchive :
    public binary_iarchive_impl<
        boost::archive::binary_iarchive,
        std::istream::char_type,
        std::istream::traits_type
    >,
    public detail::shared_ptr_helper
{
public:
    binary_iarchive(std::istream & is, unsigned int flags = 0) :
        binary_iarchive_impl<
            binary_iarchive, std::istream::char_type, std::istream::traits_type
        >(is, flags)
    {}
    binary_iarchive(std::streambuf & bsb, unsigned int flags = 0) :
        binary_iarchive_impl<
            binary_iarchive, std::istream::char_type, std::istream::traits_type
        >(bsb, flags)
    {}
};

}
}


namespace boost { namespace archive { namespace detail { template <class Serializable> typename _ptr_serialization_support<boost::archive::binary_iarchive, Serializable>::type instantiate_ptr_serialization( Serializable*, boost::archive::binary_iarchive*, adl_tag ); }}}
namespace boost { namespace serialization { template <> struct use_array_optimization<boost::archive::binary_iarchive> { template <class ValueType> struct apply : boost::mpl::apply1<boost::archive::binary_iarchive::use_array_optimization , typename boost::remove_const<ValueType>::type >::type {}; }; }}
# 26 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericData.h" 2 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Serialization.h" 1 3
# 18 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Serialization.h" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/shared_ptr.hpp" 1 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/shared_ptr.hpp" 3
    namespace boost {
    namespace serialization{
        template<class T>
        struct version< ::boost::shared_ptr<T> > {
            typedef mpl::integral_c_tag tag;



            typedef mpl::int_<1> type;




            static const unsigned int value = type::value;

        };

        template<class T>
        struct tracking_level< ::boost::shared_ptr<T> > {
            typedef mpl::integral_c_tag tag;



            typedef mpl::int_< ::boost::serialization::track_never> type;




            static const int value = type::value;

        };
    }}
# 87 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/shared_ptr.hpp" 3
namespace boost {
namespace serialization{




template<class Archive, class T>
inline void save(
    Archive & ar,
    const boost::shared_ptr<T> &t,
    const unsigned int
){



    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((tracking_level<T>::value != track_never)) == 0 ? false : true) >)> boost_static_assert_typedef_102;
    const T * t_ptr = t.get();
    ar << boost::serialization::make_nvp("px", t_ptr);
}

template<class Archive, class T>
inline void load(
    Archive & ar,
    boost::shared_ptr<T> &t,
    const unsigned int file_version
){



    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((tracking_level<T>::value != track_never)) == 0 ? false : true) >)> boost_static_assert_typedef_116;
    T* r;

    if(file_version < 1){



        ar.register_type(static_cast<
            boost_132::detail::sp_counted_base_impl<T *, boost::archive::detail::null_deleter > *
        >(__null));
        boost_132::shared_ptr<T> sp;
        ar >> boost::serialization::make_nvp("px", sp.px);
        ar >> boost::serialization::make_nvp("pn", sp.pn);

        ar.append(sp);
        r = sp.get();
    }
    else

    {
        ar >> boost::serialization::make_nvp("px", r);
    }
    ar.reset(t,r);
}

template<class Archive, class T>
inline void serialize(
    Archive & ar,
    boost::shared_ptr<T> &t,
    const unsigned int file_version
){


    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((boost::serialization::tracking_level<T>::value != boost::serialization::track_never) == 0 ? false : true) >)> boost_static_assert_typedef_152;



    boost::serialization::split_free(ar, t, file_version);
}

}
}
# 19 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Serialization.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/binary_object.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/binary_object.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/binary_object.hpp" 2 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/binary_object.hpp" 3
namespace boost {
namespace serialization {

struct binary_object {
                void * const m_t;
    const std::size_t m_size;
    template<class Archive>
    void save(Archive & ar, const unsigned int ) const {
        ar.save_binary(m_t, m_size);
    }
    template<class Archive>
    void load(Archive & ar, const unsigned int ) const {
        ar.load_binary(const_cast<void *>(m_t), m_size);
    }
    template<class Archive> void serialize( Archive &ar, const unsigned int file_version ){ boost::serialization::split_member(ar, *this, file_version); }
    binary_object( void * const t, std::size_t size) :
        m_t(t),
        m_size(size)
    {}
    binary_object(const binary_object & rhs) :
        m_t(rhs.m_t),
        m_size(rhs.m_size)
    {}
};



inline

const

binary_object
make_binary_object( void * t, std::size_t size){
    return binary_object(t, size);
}



template <>
struct is_wrapper<binary_object>
 : public mpl::true_
{};

}
}


namespace boost { namespace serialization { template <> struct implementation_level< binary_object > { typedef mpl::integral_c_tag tag; typedef mpl::int_< boost::serialization::object_serializable > type; static const int value = implementation_level::type::value; }; } }
# 94 "/Library/Application Support/MonkeyWorks/Developer/include/boost/serialization/binary_object.hpp" 3
namespace boost { namespace serialization { template<> struct tracking_level< binary_object > { typedef mpl::integral_c_tag tag; typedef mpl::int_< boost::serialization::track_never> type; static const int value = tracking_level::type::value; typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( mpl::greater< implementation_level< binary_object >, mpl::int_<primitive_type> >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_94; }; }}
# 20 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Serialization.h" 2 3





namespace boost {
    namespace serialization {
# 36 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Serialization.h" 3
        template<class Archive>
        void serialize(Archive & ar, ScarabDatum& d, const unsigned int version)
        {
            split_free(ar, d, version);
        }

        template<class Archive>
        void save(Archive & ar, const ScarabDatum& d, const unsigned int version)
        {
            ar << d.type;
            if(d.type == 5){
                ar << *(d.data.dict);
            } else if(d.type == 6){
                ar << *(d.data.list);
            } else if(d.type == 7){
                ar << d.data.opaque;
            } else if(d.type == 1){
                ar << (long long)(d.data.integer);
            } else if(d.type == 2){
                ar << (double)d.data.floatp;
            }
        }

        template<class Archive>
        void load(Archive & ar, ScarabDatum& d, const unsigned int version)
        {
            ar >> d.type;
            if(d.type == 5){
                ar >> *(d.data.dict);
            } else if(d.type == 6){
                ar >> *(d.data.list);
            } else if(d.type == 7){
                ar >> d.data.opaque;
            } else if(d.type == 1){
                long long val;
                ar >> val;
                d.data.integer = val;
            } else if(d.type == 2){
                double val;
                ar >> val;
                d.data.floatp = val;
            }
        }




        template<class Archive>
        void serialize(Archive & ar, ScarabDict& d, const unsigned int version){
            split_free(ar, d, version);
        }

        template<class Archive>
        void save(Archive & ar, const ScarabDict& d, const unsigned int version)
        {
            ar << d.size;
            ar << d.tablesize;

            for(int i = 0; i < d.size; i++){
                ar << d.keys[i];
                ar << d.values[i];
            }
        }

        template<class Archive>
        void load(Archive & ar, ScarabDict& d, const unsigned int version)
        {
            int dict_size, tablesize;
            shared_ptr< array<ScarabDatum *> > keys_array, values_array;
            ScarabDatum **keys, **values;

            ar >> dict_size;
            ar >> tablesize;

            keys = new ScarabDatum*[dict_size];
            values = new ScarabDatum*[dict_size];

            for(int i = 0; i < dict_size; i++){
                ScarabDatum *key;
                ScarabDatum *val;
                ar >> key;
                ar >> val;

                keys[i] = key;
                values[i] = val;
            }

            ScarabDatum *new_dict = scarab_dict_new(dict_size, &scarab_dict_times2);
            for(int i = 0; i < dict_size; i++){
                scarab_dict_put(new_dict, keys[i], values[i]);
            }

            d = *(new_dict->data.dict);
        }




        template<class Archive>
        void serialize(Archive & ar, ScarabList& d, const unsigned int version){
            split_free(ar, d, version);
        }

        template<class Archive>
        void save(Archive & ar, const ScarabList& d, const unsigned int version)
        {
            ar << d.size;
            for(int i = 0; i < d.size; i++){
                ar << d.values[i];
            }
        }

        template<class Archive>
        void load(Archive & ar, ScarabList& d, const unsigned int version)
        {
            int list_size;
            ScarabDatum **values;

            ar >> list_size;
            values = new ScarabDatum*[list_size];
            for(int i = 0; i < list_size; i++){
                ScarabDatum *value;
                ar >> value;
                values[i] = value;
            }

            ScarabDatum *new_list = scarab_list_new(list_size);
            for(int i = 0; i < list_size; i++){
                scarab_dict_put(new_list, scarab_new_integer(i), values[i]);
            }

            d = *(new_list->data.list);
        }



        template<class Archive>
        void serialize(Archive & ar, ScarabOpaque& d, const unsigned int version){
            split_free(ar, d, version);
        }

        template<class Archive>
        void save(Archive & ar, const ScarabOpaque& d, const unsigned int version)
        {
            ar << d.size;
            ar << make_binary_object(d.data, d.size);
        }

        template<class Archive>
        void load(Archive & ar, ScarabOpaque& d, const unsigned int version)
        {
            int data_size;


            ar >> data_size;
            unsigned char *value = new unsigned char[data_size];
            binary_object value_object(value, data_size);

            ar >> value_object;

            d.size = data_size;
            d.data = value;
        }



    }
}
# 29 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericData.h" 2 3
namespace mw {





 enum GenericDataType{M_UNDEFINED=0,M_INTEGER, M_FLOAT, M_BOOLEAN, M_STRING,
 M_LIST, M_DICTIONARY, M_MAX_DATA_TYPE};





  class Data{


  protected:
   GenericDataType datatype;
   ScarabDatum *data;



   void initScarabDatum();

   void createDictionary(const int intialsize);
   void createList(const int size);

   void lockDatum() const;
   void unlockDatum() const;

  public:




   Data();
   Data(GenericDataType type, const int arg);
   Data(GenericDataType type, const double arg);
   Data(const long value);
   Data(const MonkeyWorksTime value);
   Data(const double value);
   Data(const float value);
   Data(const bool value);
   Data(const char * string);
   Data(const std::string &string);
   Data(const stx::AnyScalar);





   Data(const Data& that);





   Data(ScarabDatum * datum);




   virtual ~Data();




   GenericDataType getDataType() const;
   void setDataType(const GenericDataType _type);




   ScarabDatum * getScarabDatum() const;
   ScarabDatum * getScarabDatumCopy() const;





   long getBool() const;
   double getFloat() const;
   long getInteger() const;





   const char *getString() const;
   int getStringLength() const;


   virtual void printToSTDERR();


   virtual void setBool(bool value);
   virtual void setFloat(double value);
   virtual void setInteger(long long value);
   virtual void setString(const char * string, int size);
   virtual void setString(std::string string);

   bool isInteger() const;
   bool isFloat() const;
   bool isBool() const;
   bool isString() const;
   bool isDictionary() const;
   bool isList() const;
   bool isUndefined() const;
   bool isNumber() const;


   Data& operator=(const Data& that);

   virtual operator long() const;
   virtual operator int() const;
   virtual operator short() const;
   virtual operator double() const;
   virtual operator float() const;
   virtual operator bool() const;
   virtual operator long long() const;
   virtual operator std::string() const;
   virtual operator stx::AnyScalar() const;


   virtual void operator=(long newdata);
   virtual void operator=(int newdata);
   virtual void operator=(short newdata);
   virtual void operator=(bool newdata);
   virtual void operator=(double newdata);
   virtual void operator=(float newdata);
   virtual void operator=(const char * newdata);
   virtual void operator=(std::string newdata);
   virtual void operator=(stx::AnyScalar newdata);



   virtual void operator++();
   virtual void operator--();

   virtual bool operator==(long newdata) const;
   virtual bool operator==(double newdata) const;
   virtual bool operator==(bool newdata) const;
   virtual bool operator==(const char * newdata) const;
   virtual bool operator!=(const char * newdata) const;


   virtual Data operator+(const Data&) const;
   virtual Data operator-(const Data&) const;
   virtual Data operator*(const Data&) const;
   virtual Data operator/(const Data&) const;
   virtual Data operator%(const Data&) const;
   virtual Data operator==(const Data&) const;
   virtual Data operator!=(const Data&) const;
   virtual Data operator>(const Data&) const;
   virtual Data operator>=(const Data&) const;
   virtual Data operator<(const Data&) const;
   virtual Data operator<=(const Data&) const;



   int getNElements() const;
   int getMaxElements() const;

   bool hasKey(const Data &key) const;
   Data getKey(const int n) const;
   std::vector<Data> getKeys() const;


   virtual void addElement(const Data &key, const Data &value);
   virtual void addElement(const Data &value);
   virtual void setElement(const int index, const Data &value);
   std::vector<Data> getElements() const;

   Data getElement(const Data &key) const;
   Data getElement(const int i) const;
# 213 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericData.h" 3
   virtual Data operator [](const int i);

   virtual std::string toString() const;

  private:

   friend class boost::serialization::access;
   template<class Archive>
   void serialize(Archive &ar, const unsigned int version){
    boost::serialization::split_member(ar, *this, version);
   }

   template<class Archive>
   void save(Archive &ar, const unsigned int version) const{

    long long ival;
    double fval;
    bool bval;
    std::string sval;

    ar << datatype;
    switch(datatype){
     case M_INTEGER:
      ival = getInteger();
      ar << ival;
      break;
     case M_FLOAT:
      fval = getFloat();
      ar << fval;
      break;
     case M_BOOLEAN:
      bval = getBool();
      ar << bval;
      break;
     case M_STRING:
      sval = getString();
      ar << sval;
     case M_LIST:
     case M_DICTIONARY:
     default:

      break;

    }
   }

   template<class Archive>
   void load(Archive &ar, const unsigned int version){

    long long ival;
    double fval;
    bool bval;
    std::string sval;

    ar >> datatype;
    switch(datatype){
     case M_INTEGER:
      ar >> ival;
      setInteger(ival);
      break;
     case M_FLOAT:
      ar >> fval;
      setFloat(fval);
      break;
     case M_BOOLEAN:
      ar >> bval;
      setBool(bval);
      break;
     case M_STRING:
      ar >> sval;
      setString(sval);
     case M_LIST:
     case M_DICTIONARY:
     default:

      break;

    }
   }
  };


  class ImmutableData : public Data {

  public:

   ImmutableData(const Data& d){
    setDataType(d.getDataType());
    data = d.getScarabDatumCopy();
   }


   virtual void setBool(bool value) { }
   virtual void setFloat(double value) { }
   virtual void setInteger(long long value) { }
   virtual void setString(const char * string, int size) { }
   virtual void setString(std::string string, int size) { }


   virtual void addElement(const char * key,Data value) { }
   virtual void addElement(Data value) { }
   virtual void setElement(int index, Data value) { }

   Data removeElement(const char * key) { return Data(); }

  };

 }
# 21 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Event.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/EventConstants.h" 1 3
# 31 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/EventConstants.h" 3
namespace mw {

typedef enum {
    M_SYSTEM_CONTROL_PACKAGE = 1000,
    M_SYSTEM_DATA_PACKAGE = 1001,
    M_SYSTEM_RESPONSE_PACKAGE = 1002,
} SystemEventType;


typedef enum {

    M_EXPERIMENT_PACKAGE = 2000,
    M_PROTOCOL_PACKAGE = 2001,
    M_DATAFILE_PACKAGE = 2004,



    M_PROTOCOL_SELECTION = 3001,
    M_START_EXPERIMENT = 3002,
    M_STOP_EXPERIMENT = 3003,
    M_PAUSE_EXPERIMENT = 3004,
    M_OPEN_DATA_FILE = 3005,
    M_CLOSE_DATA_FILE = 3006,
    M_CLOSE_EXPERIMENT = 3007,
    M_SAVE_VARIABLES = 3008,
    M_LOAD_VARIABLES = 3009,

    M_DATA_FILE_OPENED = 4007,
    M_DATA_FILE_CLOSED = 4008,
    M_CLIENT_CONNECTED_TO_SERVER = 4009,
    M_CLIENT_DISCONNECTED_FROM_SERVER = 4010,
    M_SERVER_CONNECTED_CLIENT = 4011,
    M_SERVER_DISCONNECTED_CLIENT = 4012,
 M_EXPERIMENT_STATE = 4013,

    M_USER_DEFINED = 6000,
} SystemPayloadType;


typedef enum {
    M_COMMAND_SUCCESS = 5001,
    M_COMMAND_FAILURE = 5002,
} SystemEventResponseCode;



enum MessageType { M_INVALID_MESSAGE = -1,
 M_GENERIC_MESSAGE = 0,
 M_WARNING_MESSAGE = 1,
 M_ERROR_MESSAGE = 2,
 M_FATAL_ERROR_MESSAGE = 3,
 M_MAX_MESSAGE_TYPE
};

enum MessageDomain { M_GENERIC_MESSAGE_DOMAIN = 0,
 M_NETWORK_MESSAGE_DOMAIN = 1,
 M_PARSER_MESSAGE_DOMAIN = 2,
 M_PARADIGM_MESSAGE_DOMAIN = 3,
 M_SCHEDULER_MESSAGE_DOMAIN = 4,
 M_STATE_SYSTEM_MESSAGE_DOMAIN = 5,
 M_DISPLAY_MESSAGE_DOMAIN = 6,
 M_IODEVICE_MESSAGE_DOMAIN = 7,
 M_FILE_MESSAGE_DOMAIN = 8,
 M_SYSTEM_MESSAGE_DOMAIN = 9,
 M_PLUGIN_MESSAGE_DOMAIN = 10,
 M_CLIENT_MESSAGE_DOMAIN = 11,
 M_SERVER_MESSAGE_DOMAIN = 12
};
# 129 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/EventConstants.h" 3
enum EventCode { M_UNDEFINED_EVENT_CODE = -999,
 M_TERMINATION_EVENT_CODE = 2,
 M_MAX_RESERVED_EVENT_CODE = 3
};

enum MessageOrigin {
 M_UNKNOWN_MESSAGE_ORIGIN = 0,
 M_SERVER_MESSAGE_ORIGIN = 1,
 M_CLIENT_MESSAGE_ORIGIN = 2,
};




}
# 22 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Event.h" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/mutex.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/mutex.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/platform.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/platform.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/requires_threads.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/platform.hpp" 2 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/mutex.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 1 3
# 9 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/addressof.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/addressof.hpp" 3
namespace boost
{

namespace detail
{

template<class T> struct addressof_impl
{
    static inline T * f( T & v, long )
    {
        return reinterpret_cast<T*>(
            &const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
    }

    static inline T * f( T * v, int )
    {
        return v;
    }
};

}

template<class T> T * addressof( T & v )
{
    return boost::detail::addressof_impl<T>::f( v, 0 );
}
# 61 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/addressof.hpp" 3
}
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/base_from_member.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/base_from_member.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/enum_binary_params.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/base_from_member.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/enum_params.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/base_from_member.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/repeat_from_to.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/repeat_from_to.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/base_from_member.hpp" 2 3
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/base_from_member.hpp" 3
namespace boost
{
# 65 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/base_from_member.hpp" 3
template < typename MemberType, int UniqueID = 0 >
class base_from_member
{
protected:
    MemberType member;

    base_from_member()
        : member()
        {}

    template < typename T0 > explicit base_from_member( T0 x0 ) : member( x0 ) {} template < typename T0 , typename T1 > explicit base_from_member( T0 x0 , T1 x1 ) : member( x0 , x1 ) {} template < typename T0 , typename T1 , typename T2 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 ) : member( x0 , x1 , x2 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 ) : member( x0 , x1 , x2 , x3 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 ) : member( x0 , x1 , x2 , x3 , x4 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 ) : member( x0 , x1 , x2 , x3 , x4 , x5 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 , T9 x9 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 ) {}


};

}
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/enable_if.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/enable_if.hpp" 3
namespace boost
{

  template <bool B, class T = void>
  struct enable_if_c {
    typedef T type;
  };

  template <class T>
  struct enable_if_c<false, T> {};

  template <class Cond, class T = void>
  struct enable_if : public enable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_enable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_enable_if_c<false, T> {};

  template <class Cond, class T>
  struct lazy_enable_if : public lazy_enable_if_c<Cond::value, T> {};


  template <bool B, class T = void>
  struct disable_if_c {
    typedef T type;
  };

  template <class T>
  struct disable_if_c<true, T> {};

  template <class Cond, class T = void>
  struct disable_if : public disable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_disable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_disable_if_c<true, T> {};

  template <class Cond, class T>
  struct lazy_disable_if : public lazy_disable_if_c<Cond::value, T> {};

}
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/next_prior.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/next_prior.hpp" 3
namespace boost {
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/next_prior.hpp" 3
template <class T>
inline T next(T x) { return ++x; }

template <class T, class Distance>
inline T next(T x, Distance n)
{
    std::advance(x, n);
    return x;
}

template <class T>
inline T prior(T x) { return --x; }

template <class T, class Distance>
inline T prior(T x, Distance n)
{
    std::advance(x, -n);
    return x;
}

}
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility.hpp" 2 3
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/exceptions.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/exceptions.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/config.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/platform.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/config.hpp" 2 3
# 85 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/auto_link.hpp" 1 3
# 86 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/config.hpp" 2 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/exceptions.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/exceptions.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/exceptions.hpp" 2 3

namespace boost
{

    class thread_interrupted
    {};

class thread_exception : public std::exception
{
protected:
    thread_exception();
    thread_exception(int sys_err_code);

public:
    ~thread_exception() throw();

    int native_error() const;

private:
    int m_sys_err;
};

    class condition_error:
        public std::exception
    {
    public:
        const char* what() const throw()
        {
            return "Condition error";
        }
    };


class lock_error : public thread_exception
{
public:
    lock_error();
    lock_error(int sys_err_code);
    ~lock_error() throw();

    virtual const char* what() const throw();
};

class thread_resource_error : public thread_exception
{
public:
    thread_resource_error();
    thread_resource_error(int sys_err_code);
    ~thread_resource_error() throw();

    virtual const char* what() const throw();
};

class unsupported_thread_option : public thread_exception
{
public:
    unsupported_thread_option();
    unsupported_thread_option(int sys_err_code);
    ~unsupported_thread_option() throw();

    virtual const char* what() const throw();
};

class invalid_thread_argument : public thread_exception
{
public:
    invalid_thread_argument();
    invalid_thread_argument(int sys_err_code);
    ~invalid_thread_argument() throw();

    virtual const char* what() const throw();
};

class thread_permission_error : public thread_exception
{
public:
    thread_permission_error();
    thread_permission_error(int sys_err_code);
    ~thread_permission_error() throw();

    virtual const char* what() const throw();
};

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 109 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/exceptions.hpp" 2 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 1 3
# 9 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/move.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/move.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/move.hpp" 2 3

namespace boost
{
    namespace detail
    {
        template<typename T>
        struct thread_move_t
        {
            T& t;
            explicit thread_move_t(T& t_):
                t(t_)
            {}

            T& operator*() const
            {
                return t;
            }

            T* operator->() const
            {
                return &t;
            }
        private:
            void operator=(thread_move_t&);
        };
    }


    template<typename T>
    typename enable_if<boost::is_convertible<T&,detail::thread_move_t<T> >, detail::thread_move_t<T> >::type move(T& t)
    {
        return t;
    }


    template<typename T>
    detail::thread_move_t<T> move(detail::thread_move_t<T> t)
    {
        return t;
    }

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 59 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/detail/move.hpp" 2 3
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/thread_time.hpp" 1 3
# 9 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/thread_time.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/microsec_time_clock.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/microsec_time_clock.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/c_time.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/c_time.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/compiler_config.hpp" 1 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/compiler_config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/locale_config.hpp" 1 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/compiler_config.hpp" 2 3
# 52 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/compiler_config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/compiler_config.hpp" 2 3
# 137 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/compiler_config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/auto_link.hpp" 1 3
# 138 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/compiler_config.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/c_time.hpp" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/c_time.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/time.h" 1 3 4
# 77 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/time.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/_structs.h" 1 3 4
# 78 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/time.h" 2 3 4
# 93 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/time.h" 3 4
struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};
# 144 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/time.h" 3 4
struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
# 187 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/time.h" 3 4
struct clockinfo {
 int hz;
 int tick;
 int tickadj;
 int stathz;
 int profhz;
};







extern "C" {


int adjtime(const struct timeval *, struct timeval *);
int futimes(int, const struct timeval *);
int lutimes(const char *, const struct timeval *);
int settimeofday(const struct timeval *, const struct timezone *);


int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval * , void * );



int setitimer(int, const struct itimerval * ,
  struct itimerval * );
int utimes(const char *, const struct timeval *);

}
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/c_time.hpp" 2 3






namespace boost {
namespace date_time {







  struct c_time {
    public:


      inline
      static std::tm* localtime(const std::time_t* t, std::tm* result)
      {

        result = localtime_r(t, result);
        return result;
      }

      inline
      static std::tm* gmtime(const std::time_t* t, std::tm* result)
      {

        result = gmtime_r(t, result);
        return result;
      }
# 88 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/c_time.hpp" 3
  };
}}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/microsec_time_clock.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_clock.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_clock.hpp" 3
namespace boost {
namespace date_time {





  template<class time_type>
  class second_clock
  {
  public:
    typedef typename time_type::date_type date_type;
    typedef typename time_type::time_duration_type time_duration_type;

    static time_type local_time()
    {
      ::std::time_t t;
      ::std::time(&t);
      ::std::tm curr, *curr_ptr;

      curr_ptr = c_time::localtime(&t, &curr);
      return create_time(curr_ptr);
    }



    static time_type universal_time()
    {

      ::std::time_t t;
      ::std::time(&t);
      ::std::tm curr, *curr_ptr;

      curr_ptr = c_time::gmtime(&t, &curr);
      return create_time(curr_ptr);
    }

    template<class time_zone_type>
    static time_type local_time(boost::shared_ptr<time_zone_type> tz_ptr)
    {
      typedef typename time_type::utc_time_type utc_time_type;
      utc_time_type utc_time = second_clock<utc_time_type>::universal_time();
      return time_type(utc_time, tz_ptr);
    }


  private:
    static time_type create_time(::std::tm* current)
    {
      date_type d(static_cast<unsigned short>(current->tm_year + 1900),
                  static_cast<unsigned short>(current->tm_mon + 1),
                  static_cast<unsigned short>(current->tm_mday));
      time_duration_type td(current->tm_hour,
                            current->tm_min,
                            current->tm_sec);
      return time_type(d,td);
    }

  };


} }
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/microsec_time_clock.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/microsec_time_clock.hpp" 2 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/microsec_time_clock.hpp" 3
namespace boost {
namespace date_time {
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/microsec_time_clock.hpp" 3
  template<class time_type>
  class microsec_clock
  {
  public:
    typedef typename time_type::date_type date_type;
    typedef typename time_type::time_duration_type time_duration_type;
    typedef typename time_duration_type::rep_type resolution_traits_type;



    template<class time_zone_type>
    static time_type local_time(shared_ptr<time_zone_type> tz_ptr) {
      typedef typename time_type::utc_time_type utc_time_type;
      typedef second_clock<utc_time_type> second_clock;


      utc_time_type utc_time = second_clock::universal_time();
      time_duration_type utc_offset = second_clock::local_time() - utc_time;


      utc_time = microsec_clock<utc_time_type>::local_time() - utc_offset;
      return time_type(utc_time, tz_ptr);
    }


  private:

    enum TZ_FOR_CREATE { LOCAL, GMT };

  public:



    static time_type local_time() {
      return create_time(LOCAL);
    }


    static time_type universal_time()
    {
      return create_time(GMT);
    }

  private:
    static time_type create_time(TZ_FOR_CREATE tz) {
      timeval tv;
      gettimeofday(&tv, 0);
      std::time_t t = tv.tv_sec;
      boost::uint32_t fs = tv.tv_usec;
      std::tm curr, *curr_ptr = 0;
      if (tz == LOCAL) {
        curr_ptr = c_time::localtime(&t, &curr);
      } else {
        curr_ptr = c_time::gmtime(&t, &curr);
      }
      date_type d(curr_ptr->tm_year + 1900,
                  curr_ptr->tm_mon + 1,
                  curr_ptr->tm_mday);




      int adjust = resolution_traits_type::res_adjust()/1000000;

      time_duration_type td(curr_ptr->tm_hour,
                            curr_ptr->tm_min,
                            curr_ptr->tm_sec,
                            fs*adjust);
      return time_type(d,td);

    }
# 196 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/microsec_time_clock.hpp" 3
  };


} }
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/thread_time.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_types.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_types.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/ptime.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/ptime.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_system.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_system.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_config.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_duration.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_duration.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_defs.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_defs.hpp" 3
namespace boost {
namespace date_time {


  enum time_resolutions {sec, tenth, hundreth, milli, ten_thousandth, micro, nano, NumResolutions };


  enum dst_flags {not_dst, is_dst, calculate};


} }
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_duration.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/special_defs.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/special_defs.hpp" 3
namespace boost {
namespace date_time {

    enum special_values {not_a_date_time,
                         neg_infin, pos_infin,
                         min_date_time, max_date_time,
                         not_special, NumSpecialValues};


} }
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_duration.hpp" 2 3


namespace boost {
namespace date_time {
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_duration.hpp" 3
  template<class T, typename rep_type>
  class time_duration : private
      boost::less_than_comparable<T
    , boost::equality_comparable<T
    > >





  {
  public:
    typedef T duration_type;
    typedef rep_type traits_type;
    typedef typename rep_type::day_type day_type;
    typedef typename rep_type::hour_type hour_type;
    typedef typename rep_type::min_type min_type;
    typedef typename rep_type::sec_type sec_type;
    typedef typename rep_type::fractional_seconds_type fractional_seconds_type;
    typedef typename rep_type::tick_type tick_type;
    typedef typename rep_type::impl_type impl_type;

    time_duration() : ticks_(0) {}
    time_duration(hour_type hours_in,
                  min_type minutes_in,
                  sec_type seconds_in=0,
                  fractional_seconds_type frac_sec_in = 0) :
      ticks_(rep_type::to_tick_count(hours_in,minutes_in,seconds_in,frac_sec_in))
    {}


    time_duration(const time_duration<T, rep_type>& other)
      : ticks_(other.ticks_)
    {}

    time_duration(special_values sv) : ticks_(impl_type::from_special(sv))
    {}

    static duration_type unit()
    {
      return duration_type(0,0,0,1);
    }

    static tick_type ticks_per_second()
    {
      return rep_type::res_adjust();
    }

    static time_resolutions resolution()
    {
      return rep_type::resolution();
    }

    hour_type hours() const
    {
      return static_cast<hour_type>(ticks() / (3600*ticks_per_second()));
    }

    min_type minutes() const
    {
      return static_cast<min_type>((ticks() / (60*ticks_per_second())) % 60);
    }

    sec_type seconds() const
    {
      return static_cast<sec_type>((ticks()/ticks_per_second()) % 60);
    }

    sec_type total_seconds() const
    {
      return static_cast<sec_type>(ticks() / ticks_per_second());
    }

    tick_type total_milliseconds() const
    {
      if (ticks_per_second() < 1000) {
        return ticks() * (static_cast<tick_type>(1000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000)) ;
    }

    tick_type total_nanoseconds() const
    {
      if (ticks_per_second() < 1000000000) {
        return ticks() * (static_cast<tick_type>(1000000000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000000000)) ;
    }

    tick_type total_microseconds() const
    {
      if (ticks_per_second() < 1000000) {
        return ticks() * (static_cast<tick_type>(1000000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000000)) ;
    }

    fractional_seconds_type fractional_seconds() const
    {
      return (ticks() % ticks_per_second());
    }

    static unsigned short num_fractional_digits()
    {
      return rep_type::num_fractional_digits();
    }
    duration_type invert_sign() const
    {
      return duration_type(ticks_ * (-1));
    }
    bool is_negative() const
    {
      return ticks_ < 0;
    }
    bool operator<(const time_duration& rhs) const
    {
      return ticks_ < rhs.ticks_;
    }
    bool operator==(const time_duration& rhs) const
    {
      return ticks_ == rhs.ticks_;
    }

    duration_type operator-()const
    {
      return duration_type(ticks_ * (-1));
    }
    duration_type operator-(const duration_type& d) const
    {
      return duration_type(ticks_ - d.ticks_);
    }
    duration_type operator+(const duration_type& d) const
    {
      return duration_type(ticks_ + d.ticks_);
    }
    duration_type operator/(int divisor) const
    {
      return duration_type(ticks_ / divisor);
    }
    duration_type operator-=(const duration_type& d)
    {
      ticks_ = ticks_ - d.ticks_;
      return duration_type(ticks_);
    }
    duration_type operator+=(const duration_type& d)
    {
      ticks_ = ticks_ + d.ticks_;
      return duration_type(ticks_);
    }

    duration_type operator/=(int divisor)
    {
      ticks_ = ticks_ / divisor;
      return duration_type(ticks_);
    }

    duration_type operator*(int rhs) const
    {
      return duration_type(ticks_ * rhs);
    }
    duration_type operator*=(int divisor)
    {
      ticks_ = ticks_ * divisor;
      return duration_type(ticks_);
    }
    tick_type ticks() const
    {
      return traits_type::as_number(ticks_);
    }


    bool is_special()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_special();
      }
      else{
        return false;
      }
    }

    bool is_pos_infinity()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_pos_infinity();
      }
      else{
        return false;
      }
    }

    bool is_neg_infinity()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_neg_infinity();
      }
      else{
        return false;
      }
    }

    bool is_not_a_date_time()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_nan();
      }
      else{
        return false;
      }
    }


    impl_type get_rep()const
    {
      return ticks_;
    }

  protected:
    explicit time_duration(impl_type in) : ticks_(in) {};
    impl_type ticks_;
  };







   template<class base_duration, boost::int64_t frac_of_second>
  class subsecond_duration : public base_duration
  {
  public:
    typedef typename base_duration::traits_type traits_type;
    explicit subsecond_duration(boost::int64_t ss) :
      base_duration(0,0,0,ss*traits_type::res_adjust()/frac_of_second)
    {}
  };



} }
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_config.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_resolution_traits.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_resolution_traits.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/int_adapter.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/int_adapter.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/limits.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/int_adapter.hpp" 2 3




namespace boost {
namespace date_time {
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/int_adapter.hpp" 3
template<typename int_type_>
class int_adapter {
public:
  typedef int_type_ int_type;
  int_adapter(int_type v) :
    value_(v)
  {}
  static bool has_infinity()
  {
    return true;
  }
  static const int_adapter pos_infinity()
  {
    return (::std::numeric_limits<int_type>::max)();
  }
  static const int_adapter neg_infinity()
  {
    return (::std::numeric_limits<int_type>::min)();
  }
  static const int_adapter not_a_number()
  {
    return (::std::numeric_limits<int_type>::max)()-1;
  }
  static int_adapter max ()
  {
    return (::std::numeric_limits<int_type>::max)()-2;
  }
  static int_adapter min ()
  {
    return (::std::numeric_limits<int_type>::min)()+1;
  }
  static int_adapter from_special(special_values sv)
  {
    switch (sv) {
    case not_a_date_time: return not_a_number();
    case neg_infin: return neg_infinity();
    case pos_infin: return pos_infinity();
    case max_date_time: return (max)();
    case min_date_time: return (min)();
    default: return not_a_number();
    }
  }
  static bool is_inf(int_type v)
  {
    return (v == neg_infinity().as_number() ||
            v == pos_infinity().as_number());
  }
  static bool is_neg_inf(int_type v)
  {
    return (v == neg_infinity().as_number());
  }
  static bool is_pos_inf(int_type v)
  {
    return (v == pos_infinity().as_number());
  }
  static bool is_not_a_number(int_type v)
  {
    return (v == not_a_number().as_number());
  }

  static special_values to_special(int_type v)
  {
    if (is_not_a_number(v)) return not_a_date_time;
    if (is_neg_inf(v)) return neg_infin;
    if (is_pos_inf(v)) return pos_infin;
    return not_special;
  }


  static int_type maxcount()
  {
    return (::std::numeric_limits<int_type>::max)()-3;
  }
  bool is_infinity() const
  {
    return (value_ == neg_infinity().as_number() ||
            value_ == pos_infinity().as_number());
  }
  bool is_pos_infinity()const
  {
    return(value_ == pos_infinity().as_number());
  }
  bool is_neg_infinity()const
  {
    return(value_ == neg_infinity().as_number());
  }
  bool is_nan() const
  {
    return (value_ == not_a_number().as_number());
  }
  bool is_special() const
  {
    return(is_infinity() || is_nan());
  }
  bool operator==(const int_adapter& rhs) const
  {
    return (compare(rhs) == 0);
  }
  bool operator==(const int& rhs) const
  {

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return false;
      }
    }
    return (compare(rhs) == 0);
  }
  bool operator!=(const int_adapter& rhs) const
  {
    return (compare(rhs) != 0);
  }
  bool operator!=(const int& rhs) const
  {

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return true;
      }
    }
    return (compare(rhs) != 0);
  }
  bool operator<(const int_adapter& rhs) const
  {
    return (compare(rhs) == -1);
  }
  bool operator<(const int& rhs) const
  {

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return true;
      }
    }
    return (compare(rhs) == -1);
  }
  bool operator>(const int_adapter& rhs) const
  {
    return (compare(rhs) == 1);
  }
  int_type as_number() const
  {
    return value_;
  }

  special_values as_special() const
  {
    return int_adapter::to_special(value_);
  }
# 203 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/int_adapter.hpp" 3
  template<class rhs_type>
  inline
  int_adapter operator+(const int_adapter<rhs_type>& rhs) const
  {
    if(is_special() || rhs.is_special())
    {
      if (is_nan() || rhs.is_nan())
      {
        return int_adapter::not_a_number();
      }
      if((is_pos_inf(value_) && rhs.is_neg_inf(rhs.as_number())) ||
      (is_neg_inf(value_) && rhs.is_pos_inf(rhs.as_number())) )
      {
        return int_adapter::not_a_number();
      }
      if (is_infinity())
      {
        return *this;
      }
      if (rhs.is_pos_inf(rhs.as_number()))
      {
        return int_adapter::pos_infinity();
      }
      if (rhs.is_neg_inf(rhs.as_number()))
      {
        return int_adapter::neg_infinity();
      }
    }
    return int_adapter<int_type>(value_ + rhs.as_number());
  }

  int_adapter operator+(const int_type rhs) const
  {
    if(is_special())
    {
      if (is_nan())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if (is_infinity())
      {
        return *this;
      }
    }
    return int_adapter<int_type>(value_ + rhs);
  }



  template<class rhs_type>
  inline
  int_adapter operator-(const int_adapter<rhs_type>& rhs)const
  {
    if(is_special() || rhs.is_special())
    {
      if (is_nan() || rhs.is_nan())
      {
        return int_adapter::not_a_number();
      }
      if((is_pos_inf(value_) && rhs.is_pos_inf(rhs.as_number())) ||
         (is_neg_inf(value_) && rhs.is_neg_inf(rhs.as_number())) )
      {
        return int_adapter::not_a_number();
      }
      if (is_infinity())
      {
        return *this;
      }
      if (rhs.is_pos_inf(rhs.as_number()))
      {
        return int_adapter::neg_infinity();
      }
      if (rhs.is_neg_inf(rhs.as_number()))
      {
        return int_adapter::pos_infinity();
      }
    }
    return int_adapter<int_type>(value_ - rhs.as_number());
  }
  int_adapter operator-(const int_type rhs) const
  {
    if(is_special())
    {
      if (is_nan())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if (is_infinity())
      {
        return *this;
      }
    }
    return int_adapter<int_type>(value_ - rhs);
  }


  int_adapter operator*(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ * rhs.value_);
  }


  int_adapter operator*(const int rhs) const
  {
    if(is_special())
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ * rhs);
  }


  int_adapter operator/(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(is_infinity() && rhs.is_infinity())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if(rhs != 0)
      {
        return mult_div_specials(rhs);
      }
      else {
        return int_adapter<int_type>(value_ / rhs.value_);
      }
    }
    return int_adapter<int_type>(value_ / rhs.value_);
  }


  int_adapter operator/(const int rhs) const
  {
    if(is_special() && rhs != 0)
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ / rhs);
  }


  int_adapter operator%(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(is_infinity() && rhs.is_infinity())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if(rhs != 0)
      {
        return mult_div_specials(rhs);
      }
      else {
        return int_adapter<int_type>(value_ % rhs.value_);
      }
    }
    return int_adapter<int_type>(value_ % rhs.value_);
  }


  int_adapter operator%(const int rhs) const
  {
    if(is_special() && rhs != 0)
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ % rhs);
  }
private:
  int_type value_;


  int compare(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(this->is_nan() || rhs.is_nan()) {
        if(this->is_nan() && rhs.is_nan()) {
          return 0;
        }
        else {
          return 2;
        }
      }
      if((is_neg_inf(value_) && !is_neg_inf(rhs.value_)) ||
         (is_pos_inf(rhs.value_) && !is_pos_inf(value_)) )
        {
          return -1;
        }
      if((is_pos_inf(value_) && !is_pos_inf(rhs.value_)) ||
         (is_neg_inf(rhs.value_) && !is_neg_inf(value_)) ) {
        return 1;
      }
    }
    if(value_ < rhs.value_) return -1;
    if(value_ > rhs.value_) return 1;

    return 0;
  }





  int_adapter mult_div_specials(const int_adapter& rhs)const
  {
    int min_value;

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(is_signed) {
      min_value = 0;
    }
    else {
      min_value = 1;
    }
    if(this->is_nan() || rhs.is_nan()) {
      return int_adapter<int_type>(not_a_number());
    }
    if((*this > 0 && rhs > 0) || (*this < min_value && rhs < min_value)) {
        return int_adapter<int_type>(pos_infinity());
    }
    if((*this > 0 && rhs < min_value) || (*this < min_value && rhs > 0)) {
        return int_adapter<int_type>(neg_infinity());
    }

    return int_adapter<int_type>(not_a_number());
  }






  int_adapter mult_div_specials(const int& rhs) const
  {
    int min_value;

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(is_signed) {
      min_value = 0;
    }
    else {
      min_value = 1;
    }
    if(this->is_nan()) {
      return int_adapter<int_type>(not_a_number());
    }
    if((*this > 0 && rhs > 0) || (*this < min_value && rhs < 0)) {
        return int_adapter<int_type>(pos_infinity());
    }
    if((*this > 0 && rhs < 0) || (*this < min_value && rhs > 0)) {
        return int_adapter<int_type>(neg_infinity());
    }

    return int_adapter<int_type>(not_a_number());
  }

};






  template<class charT, class traits, typename int_type>
  inline
  std::basic_ostream<charT, traits>&
  operator<<(std::basic_ostream<charT, traits>& os, const int_adapter<int_type>& ia)
  {
    if(ia.is_special()) {

      switch(ia.as_special())
        {
      case not_a_date_time:
        os << "not-a-number";
        break;
      case pos_infin:
        os << "+infinity";
        break;
      case neg_infin:
        os << "-infinity";
        break;
      default:
        os << "";
      }
    }
    else {
      os << ia.as_number();
    }
    return os;
  }



} }
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_resolution_traits.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_resolution_traits.hpp" 2 3

namespace boost {
namespace date_time {


  template <typename T>


  inline T absolute_value(T x)
  {
    return x < 0 ? -x : x;
  }


  struct time_resolution_traits_bi32_impl {
    typedef boost::int32_t int_type;
    typedef boost::int32_t impl_type;
    static int_type as_number(impl_type i){ return i;}

    static bool is_adapted() { return false;}
  };

  struct time_resolution_traits_adapted32_impl {
    typedef boost::int32_t int_type;
    typedef boost::date_time::int_adapter<boost::int32_t> impl_type;
    static int_type as_number(impl_type i){ return i.as_number();}

    static bool is_adapted() { return true;}
  };

  struct time_resolution_traits_bi64_impl {
    typedef boost::int64_t int_type;
    typedef boost::int64_t impl_type;
    static int_type as_number(impl_type i){ return i;}

    static bool is_adapted() { return false;}
  };

  struct time_resolution_traits_adapted64_impl {
    typedef boost::int64_t int_type;
    typedef boost::date_time::int_adapter<boost::int64_t> impl_type;
    static int_type as_number(impl_type i){ return i.as_number();}

    static bool is_adapted() { return true;}
  };

  template<typename frac_sec_type,
           time_resolutions res,



             typename frac_sec_type::int_type resolution_adjust,

             unsigned short frac_digits,
             typename v_type = boost::int32_t >
  class time_resolution_traits {
  public:
    typedef typename frac_sec_type::int_type fractional_seconds_type;
    typedef typename frac_sec_type::int_type tick_type;
    typedef typename frac_sec_type::impl_type impl_type;
    typedef v_type day_type;
    typedef v_type hour_type;
    typedef v_type min_type;
    typedef v_type sec_type;


    static typename frac_sec_type::int_type as_number(typename frac_sec_type::impl_type i)
    {
      return frac_sec_type::as_number(i);
    }
    static bool is_adapted()
    {
      return frac_sec_type::is_adapted();
    }


    static const int ticks_per_second = resolution_adjust;


    static time_resolutions resolution()
    {
      return res;
    }
    static unsigned short num_fractional_digits()
    {
      return frac_digits;
    }
    static fractional_seconds_type res_adjust()
    {
      return resolution_adjust;
    }

    static tick_type to_tick_count(hour_type hours,
                                   min_type minutes,
                                   sec_type seconds,
                                   fractional_seconds_type fs)
    {
      if(hours < 0 || minutes < 0 || seconds < 0 || fs < 0)
      {
        hours = absolute_value(hours);
        minutes = absolute_value(minutes);
        seconds = absolute_value(seconds);
        fs = absolute_value(fs);
        return (((((fractional_seconds_type(hours)*3600)
                   + (fractional_seconds_type(minutes)*60)
                   + seconds)*res_adjust()) + fs) * -1);
      }

      return (((fractional_seconds_type(hours)*3600)
               + (fractional_seconds_type(minutes)*60)
               + seconds)*res_adjust()) + fs;
    }

  };

  typedef time_resolution_traits<time_resolution_traits_adapted32_impl, milli, 1000, 3 > milli_res;
  typedef time_resolution_traits<time_resolution_traits_adapted64_impl, micro, 1000000, 6 > micro_res;
  typedef time_resolution_traits<time_resolution_traits_adapted64_impl, nano, 1000000000, 9 > nano_res;


} }
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_config.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_types.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_types.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/year_month_day.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/year_month_day.hpp" 3
namespace boost {
namespace date_time {


  template<typename YearType, typename MonthType, typename DayType>
  struct year_month_day_base {
    year_month_day_base(YearType year,
                        MonthType month,
                        DayType day);
    YearType year;
    MonthType month;
    DayType day;
    typedef YearType year_type;
    typedef MonthType month_type;
    typedef DayType day_type;
  };



  template<typename YearType, typename MonthType, typename DayType>
  inline
  year_month_day_base<YearType,MonthType,DayType>::year_month_day_base(YearType y,
                                                                       MonthType m,
                                                                       DayType d) :
    year(y),
    month(m),
    day(d)
  {}

} }
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date.hpp" 2 3



namespace boost {
namespace date_time {
# 52 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date.hpp" 3
  template<class T, class calendar, class duration_type_>
  class date : private
       boost::less_than_comparable<T
     , boost::equality_comparable<T
    > >
  {
  public:
    typedef T date_type;
    typedef calendar calendar_type;
    typedef typename calendar::date_traits_type traits_type;
    typedef duration_type_ duration_type;
    typedef typename calendar::year_type year_type;
    typedef typename calendar::month_type month_type;
    typedef typename calendar::day_type day_type;
    typedef typename calendar::ymd_type ymd_type;
    typedef typename calendar::date_rep_type date_rep_type;
    typedef typename calendar::date_int_type date_int_type;
    typedef typename calendar::day_of_week_type day_of_week_type;
    date(year_type y, month_type m, day_type d)
      : days_(calendar::day_number(ymd_type(y, m, d)))
    {}
    date(const ymd_type& ymd)
      : days_(calendar::day_number(ymd))
      {}

    year_type year() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.year;
    }
    month_type month() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.month;
    }
    day_type day() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.day;
    }
    day_of_week_type day_of_week() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return calendar::day_of_week(ymd);
    }
    ymd_type year_month_day() const
    {
      return calendar::from_day_number(days_);
    }
    bool operator<(const date_type& rhs) const
    {
      return days_ < rhs.days_;
    }
    bool operator==(const date_type& rhs) const
    {
      return days_ == rhs.days_;
    }

    bool is_special()const
    {
      return(is_not_a_date() || is_infinity());
    }

    bool is_not_a_date() const
    {
      return traits_type::is_not_a_number(days_);
    }

    bool is_infinity() const
    {
      return traits_type::is_inf(days_);
    }

    bool is_pos_infinity() const
    {
      return traits_type::is_pos_inf(days_);
    }

    bool is_neg_infinity() const
    {
      return traits_type::is_neg_inf(days_);
    }

    special_values as_special() const
    {
      return traits_type::to_special(days_);
    }
    duration_type operator-(const date_type& d) const
    {
      date_rep_type val = date_rep_type(days_) - date_rep_type(d.days_);
      return duration_type(val.as_number());
    }

    date_type operator-(const duration_type& dd) const
    {
      if(dd.is_special())
      {
        return date_type(date_rep_type(days_) - dd.get_rep());
      }
      return date_type(date_rep_type(days_) - dd.days());
    }
    date_type operator-=(const duration_type& dd)
    {
      *this = *this - dd;
      return date_type(days_);
    }
    date_rep_type day_count() const
    {
      return days_;
    };

    date_type operator+(const duration_type& dd) const
    {
      if(dd.is_special())
      {
        return date_type(date_rep_type(days_) + dd.get_rep());
      }
      return date_type(date_rep_type(days_) + dd.days());
    }
    date_type operator+=(const duration_type& dd)
    {
      *this = *this + dd;
      return date_type(days_);
    }


  protected:




    explicit date(date_int_type days) : days_(days) {};
    explicit date(date_rep_type days) : days_(days.as_number()) {};
    date_int_type days_;

  };




} }
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period.hpp" 3
namespace boost {
namespace date_time {
# 50 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period.hpp" 3
  template<class point_rep, class duration_rep>
  class period : private
      boost::less_than_comparable<period<point_rep, duration_rep>
    , boost::equality_comparable< period<point_rep, duration_rep>
    > >
  {
  public:
    typedef point_rep point_type;
    typedef duration_rep duration_type;

    period(point_rep first_point, point_rep end_point);
    period(point_rep first_point, duration_rep len);
    point_rep begin() const;
    point_rep end() const;
    point_rep last() const;
    duration_rep length() const;
    bool is_null() const;
    bool operator==(const period& rhs) const;
    bool operator<(const period& rhs) const;
    void shift(const duration_rep& d);
    void expand(const duration_rep& d);
    bool contains(const point_rep& point) const;
    bool contains(const period& other) const;
    bool intersects(const period& other) const;
    bool is_adjacent(const period& other) const;
    bool is_before(const point_rep& point) const;
    bool is_after(const point_rep& point) const;
    period intersection(const period& other) const;
    period merge(const period& other) const;
    period span(const period& other) const;
  private:
    point_rep begin_;
    point_rep last_;
  };




  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>::period(point_rep first_point,
                                         point_rep end_point) :
    begin_(first_point),
    last_(end_point - duration_rep::unit())
  {}




  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>::period(point_rep first_point, duration_rep len) :
    begin_(first_point),
    last_(first_point + len-duration_rep::unit())
  { }



  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::begin() const
  {
    return begin_;
  }


  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::end() const
  {
    return last_ + duration_rep::unit();
  }


  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::last() const
  {
    return last_;
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::is_null() const
  {
    return end() <= begin_;
  }


  template<class point_rep, class duration_rep>
  inline
  duration_rep period<point_rep,duration_rep>::length() const
  {
    if(last_ < begin_){
      return last_+duration_rep::unit() - begin_;
    }
    else{
      return end() - begin_;
    }
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::operator==(const period& rhs) const
  {
    return ((begin_ == rhs.begin_) &&
             (last_ == rhs.last_));
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::operator<(const period& rhs) const
  {
    return (last_ < rhs.begin_);
  }



  template<class point_rep, class duration_rep>
  inline
  void period<point_rep,duration_rep>::shift(const duration_rep& d)
  {
    begin_ = begin_ + d;
    last_ = last_ + d;
  }
# 198 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period.hpp" 3
  template<class point_rep, class duration_rep>
  inline
  void period<point_rep,duration_rep>::expand(const duration_rep& d)
  {
    begin_ = begin_ - d;
    last_ = last_ + d;
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::contains(const point_rep& point) const
  {
    return ((point >= begin_) &&
            (point <= last_));
  }



  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::contains(const period<point_rep,duration_rep>& other) const
  {
    return ((begin_ <= other.begin_) && (last_ >= other.last_));
  }
# 234 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period.hpp" 3
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_adjacent(const period<point_rep,duration_rep>& other) const
  {
    return (other.begin() == end() ||
            begin_ == other.end());
  }
# 253 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period.hpp" 3
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_after(const point_rep& t) const
  {
    if (is_null())
    {
      return false;
    }

    return t < begin_;
  }
# 275 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period.hpp" 3
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_before(const point_rep& t) const
  {
    if (is_null())
    {
      return false;
    }

    return last_ < t;
  }
# 300 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period.hpp" 3
  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::intersects(const period<point_rep,duration_rep>& other) const
  {
    return ( contains(other.begin_) ||
             other.contains(begin_) ||
             ((other.begin_ < begin_) && (other.last_ >= begin_)));
  }


  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::intersection(const period<point_rep,duration_rep>& other) const
  {
    if (begin_ > other.begin_) {
      if (last_ <= other.last_) {
        return *this;
      }

      return period<point_rep,duration_rep>(begin_, other.end());
    }
    else {
      if (last_ <= other.last_) {
        return period<point_rep,duration_rep>(other.begin_, this->end());
      }

      return other;
    }

  }




  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::merge(const period<point_rep,duration_rep>& other) const
  {
    if (this->intersects(other)) {
      if (begin_ < other.begin_) {
        return period<point_rep,duration_rep>(begin_, last_ > other.last_ ? this->end() : other.end());
      }

      return period<point_rep,duration_rep>(other.begin_, last_ > other.last_ ? this->end() : other.end());

    }
    return period<point_rep,duration_rep>(begin_,begin_);
  }
# 362 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period.hpp" 3
  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::span(const period<point_rep,duration_rep>& other) const
  {
    point_rep start((begin_ < other.begin_) ? begin() : other.begin());
    point_rep newend((last_ < other.last_) ? other.end() : this->end());
    return period<point_rep,duration_rep>(start, newend);
  }


} }
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_calendar.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_calendar.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_weekday.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_weekday.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/constrained_value.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/constrained_value.hpp" 3
namespace boost {


namespace CV {

  enum violation_enum {min_violation, max_violation};
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/constrained_value.hpp" 3
  template<class value_policies>
  class constrained_value {
  public:
    typedef typename value_policies::value_type value_type;

    constrained_value(value_type value)
    {
      assign(value);
    };
    constrained_value& operator=(value_type v)
    {
      assign(v);
      return *this;
    }

    static value_type max () {return (value_policies::max)();};

    static value_type min () {return (value_policies::min)();};

    operator value_type() const {return value_;};
  protected:
    value_type value_;
  private:
    void assign(value_type value)
    {


      if (value+1 < (min)()+1) {
        value_policies::on_error(value_, value, min_violation);
        return;
      }
      if (value > (max)()) {
        value_policies::on_error(value_, value, max_violation);
        return;
      }
      value_ = value;

    }
};


  template<typename rep_type, rep_type min_value,
           rep_type max_value, class exception_type>
  class simple_exception_policy
  {
  public:
    typedef rep_type value_type;
    static rep_type min () { return min_value; };
    static rep_type max () { return max_value;};
    static void on_error(rep_type, rep_type, violation_enum)
    {
      throw exception_type();
    }
  };



} }
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_weekday.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_defs.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_defs.hpp" 3
namespace boost {
namespace date_time {


  enum weekdays {Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday};


  enum months_of_year {Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec,NotAMonth,NumMonths};

} }
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_weekday.hpp" 2 3




namespace boost {
namespace gregorian {


  using date_time::Sunday;
  using date_time::Monday;
  using date_time::Tuesday;
  using date_time::Wednesday;
  using date_time::Thursday;
  using date_time::Friday;
  using date_time::Saturday;



  struct bad_weekday : public std::out_of_range
  {
    bad_weekday() : std::out_of_range(std::string("Weekday os out of range 0..6")) {}
  };
  typedef CV::simple_exception_policy<unsigned short, 0, 6, bad_weekday> greg_weekday_policies;
  typedef CV::constrained_value<greg_weekday_policies> greg_weekday_rep;



  class greg_weekday : public greg_weekday_rep {
  public:
    typedef boost::date_time::weekdays weekday_enum;
    greg_weekday(unsigned short day_of_week_num) :
      greg_weekday_rep(day_of_week_num)
    {}

    unsigned short as_number() const {return value_;}
    const char* as_short_string() const;
    const char* as_long_string() const;

    const wchar_t* as_short_wstring() const;
    const wchar_t* as_long_wstring() const;

    weekday_enum as_enum() const {return static_cast<weekday_enum>(value_);}


  };



} }
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_calendar.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_day_of_year.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_day_of_year.hpp" 3
namespace boost {
namespace gregorian {


  struct bad_day_of_year : public std::out_of_range
  {
    bad_day_of_year() :
      std::out_of_range(std::string("Day of year value is out of range 1..366"))
    {}
  };


  typedef CV::simple_exception_policy<unsigned short,1,366,bad_day_of_year> greg_day_of_year_policies;


  typedef CV::constrained_value<greg_day_of_year_policies> greg_day_of_year_rep;


} }
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_calendar.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian_calendar.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian_calendar.hpp" 3
namespace boost {
namespace date_time {
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian_calendar.hpp" 3
  template<typename ymd_type_, typename date_int_type_>
  class gregorian_calendar_base {
  public:

    typedef ymd_type_ ymd_type;

    typedef typename ymd_type::month_type month_type;

    typedef typename ymd_type::day_type day_type;

    typedef typename ymd_type::year_type year_type;

    typedef date_int_type_ date_int_type;


    static unsigned short day_of_week(const ymd_type& ymd);
    static int week_number(const ymd_type&ymd);

    static date_int_type day_number(const ymd_type& ymd);
    static date_int_type julian_day_number(const ymd_type& ymd);
    static long modjulian_day_number(const ymd_type& ymd);
    static ymd_type from_day_number(date_int_type);
    static ymd_type from_julian_day_number(date_int_type);
    static ymd_type from_modjulian_day_number(long);
    static bool is_leap_year(year_type);
    static unsigned short end_of_month_day(year_type y, month_type m);
    static ymd_type epoch();
    static unsigned short days_in_week();

  };



} }


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian_calendar.ipp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian_calendar.ipp" 3
namespace boost {
namespace date_time {



  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::day_of_week(const ymd_type& ymd) {
    unsigned short a = static_cast<unsigned short>((14-ymd.month)/12);
    unsigned short y = static_cast<unsigned short>(ymd.year - a);
    unsigned short m = static_cast<unsigned short>(ymd.month + 12*a - 2);
    unsigned short d = static_cast<unsigned short>((ymd.day + y + (y/4) - (y/100) + (y/400) + (31*m)/12) % 7);

    return d;
  }







  template<typename ymd_type_, typename date_int_type_>
  inline
  int
  gregorian_calendar_base<ymd_type_,date_int_type_>::week_number(const ymd_type& ymd) {
    unsigned long julianbegin = julian_day_number(ymd_type(ymd.year,1,1));
    unsigned long juliantoday = julian_day_number(ymd);
    unsigned long day = (julianbegin + 3) % 7;
    unsigned long week = (juliantoday + day - julianbegin + 4)/7;

    if ((week >= 1) && (week <= 52)) {
      return week;
    }

    if ((week == 53)) {
      if((day==6) ||(day == 5 && is_leap_year(ymd.year))) {
        return week;
      } else {
        return 1;
      }
    }

    else if (week == 0) {
      julianbegin = julian_day_number(ymd_type(static_cast<unsigned short>(ymd.year-1),1,1));
      juliantoday = julian_day_number(ymd);
      day = (julianbegin + 3) % 7;
      week = (juliantoday + day - julianbegin + 4)/7;
      return week;
    }

    return week;

  }




  template<typename ymd_type_, typename date_int_type_>
  inline
  date_int_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::day_number(const ymd_type& ymd)
  {
    unsigned short a = static_cast<unsigned short>((14-ymd.month)/12);
    unsigned short y = static_cast<unsigned short>(ymd.year + 4800 - a);
    unsigned short m = static_cast<unsigned short>(ymd.month + 12*a - 3);
    unsigned long d = ymd.day + ((153*m + 2)/5) + 365*y + (y/4) - (y/100) + (y/400) - 32045;
    return d;
  }




  template<typename ymd_type_, typename date_int_type_>
  inline
  date_int_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::julian_day_number(const ymd_type& ymd)
  {
    return day_number(ymd);
  }





  template<typename ymd_type_, typename date_int_type_>
  inline
  long
  gregorian_calendar_base<ymd_type_,date_int_type_>::modjulian_day_number(const ymd_type& ymd)
  {
    return julian_day_number(ymd)-2400001;
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_day_number(date_int_type dayNumber)
  {
    date_int_type a = dayNumber + 32044;
    date_int_type b = (4*a + 3)/146097;
    date_int_type c = a-((146097*b)/4);
    date_int_type d = (4*c + 3)/1461;
    date_int_type e = c - (1461*d)/4;
    date_int_type m = (5*e + 2)/153;
    unsigned short day = static_cast<unsigned short>(e - ((153*m + 2)/5) + 1);
    unsigned short month = static_cast<unsigned short>(m + 3 - 12 * (m/10));
    year_type year = static_cast<unsigned short>(100*b + d - 4800 + (m/10));


    return ymd_type(static_cast<unsigned short>(year),month,day);
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_julian_day_number(date_int_type dayNumber)
  {
    date_int_type a = dayNumber + 32044;
    date_int_type b = (4*a+3)/146097;
    date_int_type c = a - ((146097*b)/4);
    date_int_type d = (4*c + 3)/1461;
    date_int_type e = c - ((1461*d)/4);
    date_int_type m = (5*e + 2)/153;
    unsigned short day = static_cast<unsigned short>(e - ((153*m + 2)/5) + 1);
    unsigned short month = static_cast<unsigned short>(m + 3 - 12 * (m/10));
    year_type year = static_cast<year_type>(100*b + d - 4800 + (m/10));


    return ymd_type(year,month,day);
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_modjulian_day_number(long dayNumber) {
    date_int_type jd = dayNumber + 2400001;
    return from_julian_day_number(jd);
  }





  template<typename ymd_type_, typename date_int_type_>
  inline
  bool
  gregorian_calendar_base<ymd_type_,date_int_type_>::is_leap_year(year_type year)
  {

    return (!(year % 4)) && ((year % 100) || (!(year % 400)));
  }





  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::end_of_month_day(year_type year,
                                                                      month_type month)
  {
    switch (month) {
    case 2:
      if (is_leap_year(year)) {
        return 29;
      } else {
        return 28;
      };
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
    default:
      return 31;
    };

  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::epoch()
  {
    return ymd_type(1400,1,1);
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::days_in_week()
  {
    return 7;
  }


} }
# 64 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian_calendar.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_calendar.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_ymd.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_ymd.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_day.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_day.hpp" 3
namespace boost {
namespace gregorian {


  struct bad_day_of_month : public std::out_of_range
  {
    bad_day_of_month() :
      std::out_of_range(std::string("Day of month value is out of range 1..31"))
    {}

    bad_day_of_month(const std::string& s) :
      std::out_of_range(s)
    {}
  };

  typedef CV::simple_exception_policy<unsigned short, 1, 31, bad_day_of_month> greg_day_policies;


  typedef CV::constrained_value<greg_day_policies> greg_day_rep;







  class greg_day : public greg_day_rep {
  public:
    greg_day(unsigned short day_of_month) : greg_day_rep(day_of_month) {}
    unsigned short as_number() const {return value_;}
    operator unsigned short() const {return value_;}
  private:

  };



} }
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_ymd.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_year.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_year.hpp" 3
namespace boost {
namespace gregorian {


  struct bad_year : public std::out_of_range
  {
    bad_year() :
      std::out_of_range(std::string("Year is out of valid range: 1400..10000"))
    {}
  };

  typedef CV::simple_exception_policy<unsigned short, 1400, 10000, bad_year> greg_year_policies;


  typedef CV::constrained_value<greg_year_policies> greg_year_rep;
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_year.hpp" 3
  class greg_year : public greg_year_rep {
  public:
    greg_year(unsigned short year) : greg_year_rep(year) {}
    operator unsigned short() const {return value_;}
  private:

  };



} }
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_ymd.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_month.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_month.hpp" 3
namespace boost {
namespace gregorian {

  typedef date_time::months_of_year months_of_year;


  using date_time::Jan;
  using date_time::Feb;
  using date_time::Mar;
  using date_time::Apr;
  using date_time::May;
  using date_time::Jun;
  using date_time::Jul;
  using date_time::Aug;
  using date_time::Sep;
  using date_time::Oct;
  using date_time::Nov;
  using date_time::Dec;
  using date_time::NotAMonth;
  using date_time::NumMonths;


  struct bad_month : public std::out_of_range
  {
    bad_month() : std::out_of_range(std::string("Month number is out of range 1..12")) {}
  };

  typedef CV::simple_exception_policy<unsigned short, 1, 12, bad_month> greg_month_policies;

  typedef CV::constrained_value<greg_month_policies> greg_month_rep;



  class greg_month : public greg_month_rep {
  public:
    typedef date_time::months_of_year month_enum;
    typedef std::map<std::string, unsigned short> month_map_type;
    typedef boost::shared_ptr<month_map_type> month_map_ptr_type;

    greg_month(month_enum theMonth) :
      greg_month_rep(static_cast<greg_month_rep::value_type>(theMonth)) {}

    greg_month(unsigned short theMonth) : greg_month_rep(theMonth) {}

    operator unsigned short() const {return value_;}

    unsigned short as_number() const {return value_;}
    month_enum as_enum() const {return static_cast<month_enum>(value_);}
    const char* as_short_string() const;
    const char* as_long_string() const;

    const wchar_t* as_short_wstring() const;
    const wchar_t* as_long_wstring() const;


    static month_map_ptr_type get_month_map_ptr();



    const char* as_short_string(char) const
    {
      return as_short_string();
    }
    const char* as_long_string(char) const
    {
      return as_long_string();
    }

    const wchar_t* as_short_string(wchar_t) const
    {
      return as_short_wstring();
    }
    const wchar_t* as_long_string(wchar_t) const
    {
      return as_long_wstring();
    }

  };

} }
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_ymd.hpp" 2 3

namespace boost {
namespace gregorian {

  typedef date_time::year_month_day_base<greg_year,
                                         greg_month,
                                         greg_day> greg_year_month_day;



} }
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_calendar.hpp" 2 3


namespace boost {
namespace gregorian {


  typedef date_time::int_adapter<unsigned long> fancy_date_rep;


  class gregorian_calendar :
    public date_time::gregorian_calendar_base<greg_year_month_day, fancy_date_rep::int_type> {
  public:

    typedef greg_weekday day_of_week_type;

    typedef greg_day_of_year_rep day_of_year_type;

    typedef fancy_date_rep date_rep_type;

    typedef fancy_date_rep date_traits_type;


  private:
  };

} }
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_duration.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_duration.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_duration.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_duration.hpp" 3
namespace boost {
namespace date_time {



  template<class duration_rep_traits>
  class date_duration : private
              boost::less_than_comparable<date_duration< duration_rep_traits>
            , boost::equality_comparable< date_duration< duration_rep_traits>
            , boost::addable< date_duration< duration_rep_traits>
            , boost::subtractable< date_duration< duration_rep_traits>
            > > > >
  {
  public:
    typedef typename duration_rep_traits::int_type duration_rep_type;
    typedef typename duration_rep_traits::impl_type duration_rep;


    explicit date_duration(duration_rep day_count) : days_(day_count) {};



    date_duration(special_values sv) :
            days_(duration_rep::from_special(sv))
    {}



    date_duration(const date_duration<duration_rep_traits>& other) :
            days_(other.days_)
    {}


    duration_rep get_rep()const
    {
        return days_;
    }
    bool is_special()const
    {
        return days_.is_special();
    }

    duration_rep_type days() const
    {
        return duration_rep_traits::as_number(days_);
    }

    static date_duration unit()
    {
        return date_duration<duration_rep_traits>(1);
    }

    bool operator==(const date_duration& rhs) const
    {
        return days_ == rhs.days_;
    }

    bool operator<(const date_duration& rhs) const
    {
        return days_ < rhs.days_;
    }







    date_duration operator-=(const date_duration& rhs)
    {

        days_ = days_ - rhs.days_;
        return *this;
    }

    date_duration operator+=(const date_duration& rhs)
    {
        days_ = days_ + rhs.days_;
        return *this;
    }


    date_duration operator-()const
    {
        return date_duration<duration_rep_traits>(get_rep() * (-1));
    }

    date_duration<duration_rep_traits> operator/=(int divisor)
    {
        days_ = days_ / divisor;
        return *this;
    }
    date_duration<duration_rep_traits> operator/(int divisor)
    {
        return date_duration<duration_rep_traits>(days_ / divisor);
    }


    bool is_negative() const
    {
        return days_ < 0;
    }
  private:
    duration_rep days_;
  };





  struct duration_traits_long
  {
    typedef long int_type;
    typedef long impl_type;
    static int_type as_number(impl_type i) { return i; };
  };




  struct duration_traits_adapted
  {
    typedef long int_type;
    typedef boost::date_time::int_adapter<long> impl_type;
    static int_type as_number(impl_type i) { return i.as_number(); };
  };


} }
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_duration.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_duration_types.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_duration_types.hpp" 3
namespace boost {
namespace date_time {



  template <class duration_config>
  class weeks_duration : public date_duration<duration_config> {
  public:
    weeks_duration(typename duration_config::impl_type w)
      : date_duration<duration_config>(w * 7) {}
    weeks_duration(special_values sv)
      : date_duration<duration_config>(sv) {}
  };


  template<class t>
  class years_duration;






  template<class base_config>
  class months_duration
  {
    private:
      typedef typename base_config::int_rep int_rep;
      typedef typename int_rep::int_type int_type;
      typedef typename base_config::date_type date_type;
      typedef typename date_type::duration_type duration_type;
      typedef typename base_config::month_adjustor_type month_adjustor_type;
      typedef months_duration<base_config> months_type;
      typedef years_duration<base_config> years_type;
    public:
      months_duration(int_rep num) : _m(num) {}
      months_duration(special_values sv) : _m(sv)
      {
        _m = int_rep::from_special(sv);
      }
      int_rep number_of_months() const { return _m; }

      duration_type get_neg_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_m.as_number());
        return duration_type(m_adj.get_neg_offset(d));
      }
      duration_type get_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_m.as_number());
        return duration_type(m_adj.get_offset(d));
      }
      bool operator==(const months_type& rhs) const
      {
        return(_m == rhs._m);
      }
      bool operator!=(const months_type& rhs) const
      {
        return(_m != rhs._m);
      }
      months_type operator+(const months_type& rhs)const
      {
        return months_type(_m + rhs._m);
      }
      months_type& operator+=(const months_type& rhs)
      {
        _m = _m + rhs._m;
        return *this;
      }
      months_type operator-(const months_type& rhs)const
      {
        return months_type(_m - rhs._m);
      }
      months_type& operator-=(const months_type& rhs)
      {
        _m = _m - rhs._m;
        return *this;
      }
      months_type operator*(const int_type rhs)const
      {
        return months_type(_m * rhs);
      }
      months_type& operator*=(const int_type rhs)
      {
        _m = _m * rhs;
        return *this;
      }
      months_type operator/(const int_type rhs)const
      {
        return months_type(_m / rhs);
      }
      months_type& operator/=(const int_type rhs)
      {
        _m = _m / rhs;
        return *this;
      }
      months_type operator+(const years_type& y)const
      {
        return months_type(y.number_of_years() * 12 + _m);
      }
      months_type& operator+=(const years_type& y)
      {
        _m = y.number_of_years() * 12 + _m;
        return *this;
      }
      months_type operator-(const years_type& y) const
      {
        return months_type(_m - y.number_of_years() * 12);
      }
      months_type& operator-=(const years_type& y)
      {
        _m = _m - y.number_of_years() * 12;
        return *this;
      }


      friend date_type operator+(const date_type& d, const months_type& m)
      {
        return d + m.get_offset(d);
      }
      friend date_type operator+=(date_type& d, const months_type& m)
      {
        return d += m.get_offset(d);
      }
      friend date_type operator-(const date_type& d, const months_type& m)
      {

        return d + m.get_neg_offset(d);
      }
      friend date_type operator-=(date_type& d, const months_type& m)
      {

        return d += m.get_neg_offset(d);
      }

    private:
      int_rep _m;
  };







  template<class base_config>
  class years_duration
  {
    private:
      typedef typename base_config::int_rep int_rep;
      typedef typename int_rep::int_type int_type;
      typedef typename base_config::date_type date_type;
      typedef typename date_type::duration_type duration_type;
      typedef typename base_config::month_adjustor_type month_adjustor_type;
      typedef years_duration<base_config> years_type;
      typedef months_duration<base_config> months_type;
    public:
      years_duration(int_rep num) : _y(num) {}
      years_duration(special_values sv) : _y(sv)
      {
        _y = int_rep::from_special(sv);
      }
      int_rep number_of_years() const { return _y; }

      duration_type get_neg_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_y.as_number() * 12);
        return duration_type(m_adj.get_neg_offset(d));
      }
      duration_type get_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_y.as_number() * 12);
        return duration_type(m_adj.get_offset(d));
      }
      bool operator==(const years_type& rhs) const
      {
        return(_y == rhs._y);
      }
      bool operator!=(const years_type& rhs) const
      {
        return(_y != rhs._y);
      }
      years_type operator+(const years_type& rhs)const
      {
        return years_type(_y + rhs._y);
      }
      years_type& operator+=(const years_type& rhs)
      {
        _y = _y + rhs._y;
        return *this;
      }
      years_type operator-(const years_type& rhs)const
      {
        return years_type(_y - rhs._y);
      }
      years_type& operator-=(const years_type& rhs)
      {
        _y = _y - rhs._y;
        return *this;
      }
      years_type operator*(const int_type rhs)const
      {
        return years_type(_y * rhs);
      }
      years_type& operator*=(const int_type rhs)
      {
        _y = _y * rhs;
        return *this;
      }
      years_type operator/(const int_type rhs)const
      {
        return years_type(_y / rhs);
      }
      years_type& operator/=(const int_type rhs)
      {
        _y = _y / rhs;
        return *this;
      }
      months_type operator+(const months_type& m) const
      {
        return(months_type(_y * 12 + m.number_of_months()));
      }
      months_type operator-(const months_type& m) const
      {
        return(months_type(_y * 12 - m.number_of_months()));
      }


      friend date_type operator+(const date_type& d, const years_type& y)
      {
        return d + y.get_offset(d);
      }
      friend date_type operator+=(date_type& d, const years_type& y)
      {
        return d += y.get_offset(d);
      }
      friend date_type operator-(const date_type& d, const years_type& y)
      {

        return d + y.get_neg_offset(d);
      }
      friend date_type operator-=(date_type& d, const years_type& y)
      {

        return d += y.get_neg_offset(d);
      }

    private:
      int_rep _y;
  };

}}
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_duration.hpp" 2 3




namespace boost {
namespace gregorian {



  typedef boost::date_time::duration_traits_adapted date_duration_rep;




  typedef date_time::date_duration<date_duration_rep> date_duration;


  typedef date_duration days;

} }
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_duration_types.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_duration_types.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_date.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_date.hpp" 3
namespace boost {
namespace gregorian {


  using date_time::special_values;
  using date_time::not_special;
  using date_time::neg_infin;
  using date_time::pos_infin;
  using date_time::not_a_date_time;
  using date_time::max_date_time;
  using date_time::min_date_time;
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_date.hpp" 3
  class date : public date_time::date<date, gregorian_calendar, date_duration>
  {
   public:
    typedef gregorian_calendar::year_type year_type;
    typedef gregorian_calendar::month_type month_type;
    typedef gregorian_calendar::day_type day_type;
    typedef gregorian_calendar::day_of_year_type day_of_year_type;
    typedef gregorian_calendar::ymd_type ymd_type;
    typedef gregorian_calendar::date_rep_type date_rep_type;
    typedef gregorian_calendar::date_int_type date_int_type;
    typedef date_duration duration_type;


    date():
      date_time::date<date, gregorian_calendar, date_duration>(date_rep_type::from_special(not_a_date_time))
    {}


    date(year_type y, month_type m, day_type d)
      : date_time::date<date, gregorian_calendar, date_duration>(y, m, d)
    {
      if (gregorian_calendar::end_of_month_day(y, m) < d) {
        throw bad_day_of_month(std::string("Day of month is not valid for year"));
      }
    }

    explicit date(const ymd_type& ymd)
      : date_time::date<date, gregorian_calendar, date_duration>(ymd)
    {}

    explicit date(const date_int_type& rhs):
      date_time::date<date,gregorian_calendar, date_duration>(rhs)
    {}

    explicit date(date_rep_type rhs):
      date_time::date<date,gregorian_calendar, date_duration>(rhs)
    {}

    explicit date(special_values sv):
      date_time::date<date, gregorian_calendar, date_duration>(date_rep_type::from_special(sv))
    {
      if (sv == min_date_time)
      {
        *this = date(1400, 1, 1);
      }
      if (sv == max_date_time)
      {
        *this = date(9999, 12, 31);
      }

    }

    date_int_type julian_day() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::julian_day_number(ymd);
    }

    day_of_year_type day_of_year() const
    {
      date start_of_year(year(), 1, 1);
      unsigned short doy = static_cast<unsigned short>((*this-start_of_year).days() + 1);
      return day_of_year_type(doy);
    }

    long modjulian_day() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::modjulian_day_number(ymd);
    }

    int week_number() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::week_number(ymd);
    }

    date_int_type day_number() const
    {
      return days_;
    }

    date end_of_month() const
    {
      ymd_type ymd = year_month_day();
      short eom_day = gregorian_calendar::end_of_month_day(ymd.year, ymd.month);
      return date(ymd.year, ymd.month, eom_day);
    }

   private:

  };



} }
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_duration_types.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/adjust_functors.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/adjust_functors.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/wrapping_int.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/wrapping_int.hpp" 3
namespace boost {
namespace date_time {
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/wrapping_int.hpp" 3
template<typename int_type_, int_type_ wrap_val>
class wrapping_int {
public:
  typedef int_type_ int_type;

  static int_type wrap_value() {return wrap_val;}

  wrapping_int(int_type v) : value_(v) {};

  int_type as_int() const {return value_;}
  operator int_type() const {return value_;}





  int_type add(int_type v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_val));
    int_type overflow = static_cast<int_type>(v / (wrap_val));
    value_ = static_cast<int_type>(value_ + remainder);
    return calculate_wrap(overflow);
  }






  int_type subtract(int_type v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_val));
    int_type underflow = static_cast<int_type>(-(v / (wrap_val)));
    value_ = static_cast<int_type>(value_ - remainder);
    return calculate_wrap(underflow) * -1;
  }
private:
  int_type value_;

  int_type calculate_wrap(int_type wrap)
  {
    if ((value_) >= wrap_val)
    {
      wrap++;
      value_ -= (wrap_val);
    }
    else if(value_ < 0)
    {
      wrap--;
      value_ += (wrap_val);
    }
    return wrap;
  }

};






template<typename int_type_, int_type_ wrap_min, int_type_ wrap_max>
class wrapping_int2 {
public:
  typedef int_type_ int_type;
  static int_type wrap_value() {return wrap_max;}
  static int_type min_value() {return wrap_min;}


  wrapping_int2(int_type v) : value_(v) {
    if(value_ < wrap_min)
    {
      value_ = wrap_min;
    }
    if(value_ > wrap_max)
    {
      value_ = wrap_max;
    }
  }

  int_type as_int() const {return value_;}
  operator int_type() const {return value_;}





  int_type add(int_type v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_max - wrap_min + 1));
    int_type overflow = static_cast<int_type>(v / (wrap_max - wrap_min + 1));
    value_ = static_cast<int_type>(value_ + remainder);
    return calculate_wrap(overflow);
  }





  int_type subtract(int_type v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_max - wrap_min + 1));
    int_type underflow = static_cast<int_type>(-(v / (wrap_max - wrap_min + 1)));
    value_ = static_cast<int_type>(value_ - remainder);
    return calculate_wrap(underflow);
  }

private:
  int_type value_;

  int_type calculate_wrap(int_type wrap)
  {
    if ((value_) > wrap_max)
    {
      wrap++;
      value_ -= (wrap_max - wrap_min + 1);
    }
    else if((value_) < wrap_min)
    {
      wrap--;
      value_ += (wrap_max - wrap_min + 1);
    }
    return wrap;
  }
};



} }
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/adjust_functors.hpp" 2 3

namespace boost {
namespace date_time {



  template<class date_type>
  class day_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    day_functor(int f) : f_(f) {}
    duration_type get_offset(const date_type& d) const
    {


      d.year();
      return duration_type(f_);
    }
    duration_type get_neg_offset(const date_type& d) const
    {

      d.year();
      return duration_type(-f_);
    }
  private:
    int f_;
  };
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/adjust_functors.hpp" 3
  template<class date_type>
  class month_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    typedef typename date_type::calendar_type cal_type;
    typedef typename cal_type::ymd_type ymd_type;
    typedef typename cal_type::day_type day_type;

    month_functor(int f) : f_(f), origDayOfMonth_(0) {}
    duration_type get_offset(const date_type& d) const
    {
      ymd_type ymd(d.year_month_day());
      if (origDayOfMonth_ == 0) {
        origDayOfMonth_ = ymd.day;
        day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year,ymd.month));
        if (endOfMonthDay == ymd.day) {
          origDayOfMonth_ = -1;
        }
      }
      typedef date_time::wrapping_int2<short,1,12> wrap_int2;
      typedef typename wrap_int2::int_type int_type;
      wrap_int2 wi(ymd.month);

      int_type year = wi.add(static_cast<int_type>(f_));
      year = static_cast<int_type>(year + ymd.year);



      day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));

      if (origDayOfMonth_ == -1) {
        return date_type(year, wi.as_int(), resultingEndOfMonthDay) - d;
      }
      day_type dayOfMonth = origDayOfMonth_;
      if (dayOfMonth > resultingEndOfMonthDay) {
        dayOfMonth = resultingEndOfMonthDay;
      }
      return date_type(year, wi.as_int(), dayOfMonth) - d;
    }

    duration_type get_neg_offset(const date_type& d) const
    {
      ymd_type ymd(d.year_month_day());
      if (origDayOfMonth_ == 0) {
        origDayOfMonth_ = ymd.day;
        day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year,ymd.month));
        if (endOfMonthDay == ymd.day) {
          origDayOfMonth_ = -1;
        }
      }
      typedef date_time::wrapping_int2<short,1,12> wrap_int2;
      typedef typename wrap_int2::int_type int_type;
      wrap_int2 wi(ymd.month);

      int_type year = wi.subtract(static_cast<int_type>(f_));
      year = static_cast<int_type>(year + ymd.year);

      day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));

      if (origDayOfMonth_ == -1) {
        return date_type(year, wi.as_int(), resultingEndOfMonthDay) - d;
      }
      day_type dayOfMonth = origDayOfMonth_;
      if (dayOfMonth > resultingEndOfMonthDay) {
        dayOfMonth = resultingEndOfMonthDay;
      }
      return date_type(year, wi.as_int(), dayOfMonth) - d;
    }
  private:
    int f_;
    mutable short origDayOfMonth_;
  };



  template<class date_type>
  class week_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    typedef typename date_type::calendar_type calendar_type;
    week_functor(int f) : f_(f) {}
    duration_type get_offset(const date_type& d) const
    {


      d.year();
      return duration_type(f_*calendar_type::days_in_week());
    }
    duration_type get_neg_offset(const date_type& d) const
    {

      d.year();
      return duration_type(-f_*calendar_type::days_in_week());
    }
  private:
    int f_;
  };


  template<class date_type>
  class year_functor
  {
  public:

    typedef typename date_type::duration_type duration_type;
    year_functor(int f) : _mf(f * 12) {}
    duration_type get_offset(const date_type& d) const
    {
      return _mf.get_offset(d);
    }
    duration_type get_neg_offset(const date_type& d) const
    {
      return _mf.get_neg_offset(d);
    }
  private:
    month_functor<date_type> _mf;
  };


} }
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/greg_duration_types.hpp" 2 3



namespace boost {
namespace gregorian {


  struct greg_durations_config {
    typedef date date_type;
    typedef date_time::int_adapter<int> int_rep;
    typedef date_time::month_functor<date_type> month_adjustor_type;
  };

  typedef date_time::months_duration<greg_durations_config> months;
  typedef date_time::years_duration<greg_durations_config> years;
  typedef date_time::weeks_duration<date_time::duration_traits_adapted> weeks;

}}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generators.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generators.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 1 3
# 42 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
       
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3




namespace std
{
# 61 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:





      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 112 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 127 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      __string_type
      str() const
      {
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       return __string_type(this->pbase(), this->pptr());
     else
        return __string_type(this->pbase(), this->egptr());
   }
 else
   return _M_string;
      }
# 149 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(this->_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 this->_M_mode = __mode;

 __size_type __len = 0;
 if (this->_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 190 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.assign(__s, __n);


     _M_sync(__s, 0, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);







      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o)
      {
 const bool __testin = this->_M_mode & ios_base::in;
 const bool __testout = this->_M_mode & ios_base::out;
 char_type* __end = __base + _M_string.size();

 if (__testin)
   this->setg(__base, __base + __i, __end);
 if (__testout)
   {



     if (__base == _M_string.data())
       this->setp(__base, __base + _M_string.capacity());
     else
       this->setp(__base, __end);
     this->pbump(__o);



     if (!__testin)
       this->setg(__end, __end, __end);
   }
      }



      void
      _M_update_egptr()
      {
 const bool __testin = this->_M_mode & ios_base::in;

 if (this->pptr() && this->pptr() > this->egptr())
   if (__testin)
     this->setg(this->eback(), this->gptr(), this->pptr());
   else
     this->setg(this->pptr(), this->pptr(), this->pptr());
      }
    };
# 275 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 313 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 333 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 355 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 388 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 426 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 446 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 468 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 501 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 537 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 555 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 577 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
}


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/sstream.tcc" 1 3
# 43 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/sstream.tcc" 3
       
# 44 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/sstream.tcc" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/sstream.tcc" 2 3

namespace std
{
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      if (!__testput)
 {






   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      return this->sputc(traits_type::to_char_type(__c));
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->gbump((__beg + __newoffi) - this->gptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       this->pbump((__beg + __newoffo) - this->pptr());
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if (__beg && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = 0 <= __pos
                          && __pos <= this->egptr() - __beg;
   if (__testpos)
     {
       if (__testin)
  this->gbump((__beg + __pos) - this->gptr());
       if (__testout)
                this->pbump((__beg + __pos) - this->pptr());
       __ret = __sp;
     }
 }
      return __ret;
    }





  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;


}
# 603 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/sstream" 2 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generators.hpp" 2 3



namespace boost {
namespace date_time {







  template<class date_type>
  class year_based_generator
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::year_type year_type;
    year_based_generator() {};
    virtual ~year_based_generator() {};
    virtual date_type get_date(year_type y) const = 0;

    virtual std::string to_string() const =0;
  };
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generators.hpp" 3
  template<class date_type>
 class partial_date : public year_based_generator<date_type>
 {
 public:
   typedef typename date_type::calendar_type calendar_type;
   typedef typename calendar_type::day_type day_type;
   typedef typename calendar_type::month_type month_type;
   typedef typename calendar_type::year_type year_type;
   typedef typename date_type::duration_type duration_type;
   typedef typename duration_type::duration_rep duration_rep;
   partial_date(day_type d, month_type m) :
     day_(d),
     month_(m)
   {}





   partial_date(duration_rep days) :
     day_(1),
     month_(1)
   {
     date_type d1(2000,1,1);
     if(days > 1) {
       if(days > 366)
       {
         days = 366;
       }
       days = days - 1;
       duration_type dd(days);
       d1 = d1 + dd;
     }
     day_ = d1.day();
     month_ = d1.month();
   }
# 99 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generators.hpp" 3
   date_type get_date(year_type y) const
   {
     if((day_ == 29) && (month_ == 2) && !(calendar_type::is_leap_year(y))) {
       std::stringstream ss("");
       ss << "No Feb 29th in given year of " << y << ".";
       throw std::invalid_argument(ss.str());

     } else {
       return date_type(y, month_, day_);
     }
   }
   date_type operator()(year_type y) const
   {
     return get_date(y);

   }
   bool operator==(const partial_date& rhs) const
   {
     return (month_ == rhs.month_) && (day_ == rhs.day_);
   }
   bool operator<(const partial_date& rhs) const
   {
     if (month_ < rhs.month_) return true;
     if (month_ > rhs.month_) return false;

     return (day_ < rhs.day_);
   }


   month_type month() const
   {
     return month_;
   }
   day_type day() const
   {
     return day_;
   }






   virtual std::string to_string() const
   {
     std::stringstream ss;
     date_type d(2004, month_, day_);
     unsigned short c = d.day_of_year();
     c--;
     ss << c;
     return ss.str();
   }
 private:
   day_type day_;
   month_type month_;
 };
# 174 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generators.hpp" 3
  template<class date_type>
  class nth_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;
    enum week_num {first=1, second, third, fourth, fifth};
    nth_kday_of_month(week_num week_no,
                      day_of_week_type dow,
                      month_type m) :
      month_(m),
      wn_(week_no),
      dow_(dow)
    {}

    date_type get_date(year_type y) const
    {
      date_type d(y, month_, 1);
      duration_type one_day(1);
      duration_type one_week(7);
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      int week = 1;
      while (week < wn_) {
        d = d + one_week;
        week++;
      }

      if(d.month() != month_) {
        d = d - one_week;
      }
      return d;
    }

    month_type month() const
    {
      return month_;
    }
    week_num nth_week() const
    {
      return wn_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }
    const char* nth_week_as_str() const
    {
      return nth_as_str(wn_);
    }


    virtual std::string to_string() const
    {
     std::stringstream ss;
     ss << 'M'
       << static_cast<int>(month_) << '.'
       << static_cast<int>(wn_) << '.'
       << static_cast<int>(dow_);
     return ss.str();
    }
  private:
    month_type month_;
    week_num wn_;
    day_of_week_type dow_;
  };


  const char* nth_as_str(int n);





  template<class date_type>
  class first_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;




    first_kday_of_month(day_of_week_type dow, month_type m) :
      month_(m),
      dow_(dow)
    {}

    date_type get_date(year_type year) const
    {
      date_type d(year, month_,1);
      duration_type one_day(1);
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      return d;
        }

    month_type month() const
    {
      return month_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }


    virtual std::string to_string() const
    {
     std::stringstream ss;
     ss << 'M'
       << static_cast<int>(month_) << '.'
       << 1 << '.'
       << static_cast<int>(dow_);
     return ss.str();
    }
  private:
    month_type month_;
    day_of_week_type dow_;
  };
# 313 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generators.hpp" 3
  template<class date_type>
  class last_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;




    last_kday_of_month(day_of_week_type dow, month_type m) :
      month_(m),
      dow_(dow)
    {}

    date_type get_date(year_type year) const
    {
      date_type d(year, month_, calendar_type::end_of_month_day(year,month_));
      duration_type one_day(1);
      while (dow_ != d.day_of_week()) {
        d = d - one_day;
      }
      return d;
    }

    month_type month() const
    {
      return month_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }


    virtual std::string to_string() const
    {
      std::stringstream ss;
      ss << 'M'
         << static_cast<int>(month_) << '.'
         << 5 << '.'
         << static_cast<int>(dow_);
      return ss.str();
    }
  private:
    month_type month_;
    day_of_week_type dow_;
   };
# 375 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generators.hpp" 3
  template<class date_type>
  class first_kday_after
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename date_type::duration_type duration_type;
    first_kday_after(day_of_week_type dow) :
      dow_(dow)
    {}

    date_type get_date(date_type start_day) const
    {
      duration_type one_day(1);
      date_type d = start_day + one_day;
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      return d;
    }

    day_of_week_type day_of_week() const
    {
      return dow_;
    }
  private:
    day_of_week_type dow_;
  };
# 413 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generators.hpp" 3
  template<class date_type>
  class first_kday_before
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename date_type::duration_type duration_type;
    first_kday_before(day_of_week_type dow) :
      dow_(dow)
    {}

    date_type get_date(date_type start_day) const
    {
      duration_type one_day(1);
      date_type d = start_day - one_day;
      while (dow_ != d.day_of_week()) {
        d = d - one_day;
      }
      return d;
    }

    day_of_week_type day_of_week() const
    {
      return dow_;
    }
  private:
    day_of_week_type dow_;
  };





  template<typename date_type, class weekday_type>
  inline
  typename date_type::duration_type days_until_weekday(const date_type& d, const weekday_type& wd)
  {
    typedef typename date_type::duration_type duration_type;
    duration_type wks(0);
    duration_type dd(wd.as_number() - d.day_of_week().as_number());
    if(dd.is_negative()){
      wks = duration_type(7);
    }
    return dd + wks;
  }






  template<typename date_type, class weekday_type>
  inline
  typename date_type::duration_type days_before_weekday(const date_type& d, const weekday_type& wd)
  {
    typedef typename date_type::duration_type duration_type;
    duration_type wks(0);
    duration_type dd(wd.as_number() - d.day_of_week().as_number());
    if(dd.days() > 0){
      wks = duration_type(7);
    }


    return (-dd + wks);
  }






  template<class date_type, class weekday_type>
  inline
  date_type next_weekday(const date_type& d, const weekday_type& wd)
  {
    return d + days_until_weekday(d, wd);
  }






  template<class date_type, class weekday_type>
  inline
  date_type previous_weekday(const date_type& d, const weekday_type& wd)
  {
    return d - days_before_weekday(d, wd);
  }

} }
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_clock_device.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_clock_device.hpp" 3
namespace boost {
namespace date_time {







  template<class date_type>
  class day_clock
  {
  public:
    typedef typename date_type::ymd_type ymd_type;

    static date_type local_day()
    {
      return date_type(local_day_ymd());
    }

    static typename date_type::ymd_type local_day_ymd()
    {
      ::std::tm result;
      ::std::tm* curr = get_local_time(result);
      return ymd_type(curr->tm_year + 1900,
                      curr->tm_mon + 1,
                      curr->tm_mday);
    }

    static typename date_type::ymd_type universal_day_ymd()
    {
      ::std::tm result;
      ::std::tm* curr = get_universal_time(result);
      return ymd_type(curr->tm_year + 1900,
                      curr->tm_mon + 1,
                      curr->tm_mday);
    }

    static date_type universal_day()
    {
      return date_type(universal_day_ymd());
    }

  private:
    static ::std::tm* get_local_time(std::tm& result)
    {
      ::std::time_t t;
      ::std::time(&t);
      return c_time::localtime(&t, &result);
    }
    static ::std::tm* get_universal_time(std::tm& result)
    {
      ::std::time_t t;
      ::std::time(&t);
      return c_time::gmtime(&t, &result);
    }

  };

} }
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_iterator.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_iterator.hpp" 3
namespace boost {
namespace date_time {

  enum date_resolutions {day, week, months, year, decade, century, NumDateResolutions};
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_iterator.hpp" 3
  template<class date_type>
  class date_itr_base {



  public:
    typedef typename date_type::duration_type duration_type;
    typedef date_type value_type;
    typedef std::input_iterator_tag iterator_category;

    date_itr_base(date_type d) : current_(d) {}
    virtual ~date_itr_base() {};
    date_itr_base& operator++()
    {
      current_ = current_ + get_offset(current_);
      return *this;
    }
    date_itr_base& operator--()
    {
      current_ = current_ + get_neg_offset(current_);
      return *this;
    }
    virtual duration_type get_offset(const date_type& current) const=0;
    virtual duration_type get_neg_offset(const date_type& current) const=0;
    date_type operator*() {return current_;};
    date_type* operator->() {return &current_;};
    bool operator< (const date_type& d) {return current_ < d;}
    bool operator<= (const date_type& d) {return current_ <= d;}
    bool operator> (const date_type& d) {return current_ > d;}
    bool operator>= (const date_type& d) {return current_ >= d;}
    bool operator== (const date_type& d) {return current_ == d;}
    bool operator!= (const date_type& d) {return current_ != d;}
  private:
    date_type current_;
  };
# 76 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_iterator.hpp" 3
  template<class offset_functor, class date_type>
  class date_itr : public date_itr_base<date_type> {
  public:
    typedef typename date_type::duration_type duration_type;
    date_itr(date_type d, int factor=1) :
      date_itr_base<date_type>(d),
      of_(factor)
    {}
  private:
    virtual duration_type get_offset(const date_type& current) const
    {
      return of_.get_offset(current);
    }
    virtual duration_type get_neg_offset(const date_type& current) const
    {
      return of_.get_neg_offset(current);
    }
    offset_functor of_;
  };



} }
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3


namespace boost {






namespace gregorian {



  typedef date_time::period<date, date_duration> date_period;






  typedef date_time::year_based_generator<date> year_based_generator;


  typedef date_time::partial_date<date> partial_date;

  typedef date_time::nth_kday_of_month<date> nth_kday_of_month;
  typedef nth_kday_of_month nth_day_of_the_week_in_month;

  typedef date_time::first_kday_of_month<date> first_kday_of_month;
  typedef first_kday_of_month first_day_of_the_week_in_month;

  typedef date_time::last_kday_of_month<date> last_kday_of_month;
  typedef last_kday_of_month last_day_of_the_week_in_month;

  typedef date_time::first_kday_after<date> first_kday_after;
  typedef first_kday_after first_day_of_the_week_after;

  typedef date_time::first_kday_before<date> first_kday_before;
  typedef first_kday_before first_day_of_the_week_before;




  typedef date_time::day_clock<date> day_clock;




  typedef date_time::date_itr_base<date> date_iterator;




  typedef date_time::date_itr<date_time::day_functor<date>,
                              date> day_iterator;



  typedef date_time::date_itr<date_time::week_functor<date>,
                              date> week_iterator;



  typedef date_time::date_itr<date_time::month_functor<date>,
                              date> month_iterator;



  typedef date_time::date_itr<date_time::year_functor<date>,
                              date> year_iterator;


  using date_time::days_until_weekday;
  using date_time::days_before_weekday;
  using date_time::next_weekday;
  using date_time::previous_weekday;

} }
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_config.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_config.hpp" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cmath" 1 3
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cmath" 3
       
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cmath" 3




# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/math.h" 1 3 4
# 28 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/math.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 1 3 4
# 36 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
extern "C" {
# 49 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
 typedef float float_t;
 typedef double double_t;
# 83 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
enum {
 _FP_NAN = 1,
 _FP_INFINITE = 2,
 _FP_ZERO = 3,
 _FP_NORMAL = 4,
 _FP_SUBNORMAL = 5,
 _FP_SUPERNORMAL = 6
};
# 117 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
extern unsigned int __math_errhandling ( void );
# 137 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
extern int __fpclassifyf(float );
extern int __fpclassifyd(double );
extern int __fpclassify (long double);
# 172 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
 static __inline__ int __inline_isfinitef (float ) __attribute__ ((__always_inline__));
 static __inline__ int __inline_isfinited (double ) __attribute__ ((__always_inline__));
 static __inline__ int __inline_isfinite (long double) __attribute__ ((__always_inline__));
 static __inline__ int __inline_isinff (float ) __attribute__ ((__always_inline__));
 static __inline__ int __inline_isinfd (double ) __attribute__ ((__always_inline__));
 static __inline__ int __inline_isinf (long double) __attribute__ ((__always_inline__));
 static __inline__ int __inline_isnanf (float ) __attribute__ ((__always_inline__));
 static __inline__ int __inline_isnand (double ) __attribute__ ((__always_inline__));
 static __inline__ int __inline_isnan (long double) __attribute__ ((__always_inline__));
 static __inline__ int __inline_isnormalf (float ) __attribute__ ((__always_inline__));
 static __inline__ int __inline_isnormald (double ) __attribute__ ((__always_inline__));
 static __inline__ int __inline_isnormal (long double) __attribute__ ((__always_inline__));
 static __inline__ int __inline_signbitf (float ) __attribute__ ((__always_inline__));
 static __inline__ int __inline_signbitd (double ) __attribute__ ((__always_inline__));
 static __inline__ int __inline_signbit (long double) __attribute__ ((__always_inline__));

 static __inline__ int __inline_isinff( float __x ) { return __builtin_fabsf(__x) == __builtin_inff(); }
 static __inline__ int __inline_isinfd( double __x ) { return __builtin_fabs(__x) == __builtin_inf(); }
 static __inline__ int __inline_isinf( long double __x ) { return __builtin_fabsl(__x) == __builtin_infl(); }
 static __inline__ int __inline_isfinitef( float __x ) { return __x == __x && __builtin_fabsf(__x) != __builtin_inff(); }
 static __inline__ int __inline_isfinited( double __x ) { return __x == __x && __builtin_fabs(__x) != __builtin_inf(); }
 static __inline__ int __inline_isfinite( long double __x ) { return __x == __x && __builtin_fabsl(__x) != __builtin_infl(); }
 static __inline__ int __inline_isnanf( float __x ) { return __x != __x; }
 static __inline__ int __inline_isnand( double __x ) { return __x != __x; }
 static __inline__ int __inline_isnan( long double __x ) { return __x != __x; }
 static __inline__ int __inline_signbitf( float __x ) { union{ float __f; unsigned int __u; }__u; __u.__f = __x; return (int)(__u.__u >> 31); }
 static __inline__ int __inline_signbitd( double __x ) { union{ double __f; unsigned int __u[2]; }__u; __u.__f = __x; return (int)(__u.__u[1] >> 31); }
 static __inline__ int __inline_signbit( long double __x ){ union{ long double __ld; struct{ unsigned int __m[2]; short __sexp; }__p; }__u; __u.__ld = __x; return (int) (((unsigned short) __u.__p.__sexp) >> 15); }
 static __inline__ int __inline_isnormalf( float __x ) { float fabsf = __builtin_fabsf(__x); if( __x != __x ) return 0; return fabsf < __builtin_inff() && fabsf >= 1.17549435e-38F; }
 static __inline__ int __inline_isnormald( double __x ) { double fabsf = __builtin_fabs(__x); if( __x != __x ) return 0; return fabsf < __builtin_inf() && fabsf >= 2.2250738585072014e-308; }
 static __inline__ int __inline_isnormal( long double __x ) { long double fabsf = __builtin_fabsl(__x); if( __x != __x ) return 0; return fabsf < __builtin_infl() && fabsf >= 3.36210314311209350626e-4932L; }
# 262 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
extern double acos( double );
extern float acosf( float );

extern double asin( double );
extern float asinf( float );

extern double atan( double );
extern float atanf( float );

extern double atan2( double, double );
extern float atan2f( float, float );

extern double cos( double );
extern float cosf( float );

extern double sin( double );
extern float sinf( float );

extern double tan( double );
extern float tanf( float );

extern double acosh( double );
extern float acoshf( float );

extern double asinh( double );
extern float asinhf( float );

extern double atanh( double );
extern float atanhf( float );

extern double cosh( double );
extern float coshf( float );

extern double sinh( double );
extern float sinhf( float );

extern double tanh( double );
extern float tanhf( float );

extern double exp ( double );
extern float expf ( float );

extern double exp2 ( double );
extern float exp2f ( float );

extern double expm1 ( double );
extern float expm1f ( float );

extern double log ( double );
extern float logf ( float );

extern double log10 ( double );
extern float log10f ( float );

extern double log2 ( double );
extern float log2f ( float );

extern double log1p ( double );
extern float log1pf ( float );

extern double logb ( double );
extern float logbf ( float );

extern double modf ( double, double * );
extern float modff ( float, float * );

extern double ldexp ( double, int );
extern float ldexpf ( float, int );

extern double frexp ( double, int * );
extern float frexpf ( float, int * );

extern int ilogb ( double );
extern int ilogbf ( float );

extern double scalbn ( double, int );
extern float scalbnf ( float, int );

extern double scalbln ( double, long int );
extern float scalblnf ( float, long int );

extern double fabs( double );
extern float fabsf( float );

extern double cbrt( double );
extern float cbrtf( float );

extern double hypot ( double, double );
extern float hypotf ( float, float );

extern double pow ( double, double );
extern float powf ( float, float );

extern double sqrt( double );
extern float sqrtf( float );

extern double erf( double );
extern float erff( float );

extern double erfc( double );
extern float erfcf( float );

extern double lgamma( double );
extern float lgammaf( float );

extern double tgamma( double );
extern float tgammaf( float );

extern double ceil ( double );
extern float ceilf ( float );

extern double floor ( double );
extern float floorf ( float );

extern double nearbyint ( double );
extern float nearbyintf ( float );

extern double rint ( double );
extern float rintf ( float );

extern long int lrint ( double );
extern long int lrintf ( float );

extern double round ( double );
extern float roundf ( float );

extern long int lround ( double );
extern long int lroundf ( float );




    extern long long int llrint ( double );
    extern long long int llrintf ( float );

    extern long long int llround ( double );
    extern long long int llroundf ( float );



extern double trunc ( double );
extern float truncf ( float );

extern double fmod ( double, double );
extern float fmodf ( float, float );

extern double remainder ( double, double );
extern float remainderf ( float, float );

extern double remquo ( double, double, int * );
extern float remquof ( float, float, int * );

extern double copysign ( double, double );
extern float copysignf ( float, float );

extern double nan( const char * );
extern float nanf( const char * );

extern double nextafter ( double, double );
extern float nextafterf ( float, float );

extern double fdim ( double, double );
extern float fdimf ( float, float );

extern double fmax ( double, double );
extern float fmaxf ( float, float );

extern double fmin ( double, double );
extern float fminf ( float, float );

extern double fma ( double, double, double );
extern float fmaf ( float, float, float );

extern long double acosl(long double);
extern long double asinl(long double);
extern long double atanl(long double);
extern long double atan2l(long double, long double);
extern long double cosl(long double);
extern long double sinl(long double);
extern long double tanl(long double);
extern long double acoshl(long double);
extern long double asinhl(long double);
extern long double atanhl(long double);
extern long double coshl(long double);
extern long double sinhl(long double);
extern long double tanhl(long double);
extern long double expl(long double);
extern long double exp2l(long double);
extern long double expm1l(long double);
extern long double logl(long double);
extern long double log10l(long double);
extern long double log2l(long double);
extern long double log1pl(long double);
extern long double logbl(long double);
extern long double modfl(long double, long double *);
extern long double ldexpl(long double, int);
extern long double frexpl(long double, int *);
extern int ilogbl(long double);
extern long double scalbnl(long double, int);
extern long double scalblnl(long double, long int);
extern long double fabsl(long double);
extern long double cbrtl(long double);
extern long double hypotl(long double, long double);
extern long double powl(long double, long double);
extern long double sqrtl(long double);
extern long double erfl(long double);
extern long double erfcl(long double);
extern long double lgammal(long double);
extern long double tgammal(long double);
extern long double ceill(long double);
extern long double floorl(long double);
extern long double nearbyintl(long double);
extern long double rintl(long double);
extern long int lrintl(long double);
extern long double roundl(long double);
extern long int lroundl(long double);



    extern long long int llrintl(long double);
    extern long long int llroundl(long double);


extern long double truncl(long double);
extern long double fmodl(long double, long double);
extern long double remainderl(long double, long double);
extern long double remquol(long double, long double, int *);
extern long double copysignl(long double, long double);
extern long double nanl(const char *);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern long double fdiml(long double, long double);
extern long double fmaxl(long double, long double);
extern long double fminl(long double, long double);
extern long double fmal(long double, long double, long double);
# 507 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
extern double __inf( void );
extern float __inff( void );
extern long double __infl( void );
extern float __nan( void );


extern double j0 ( double );

extern double j1 ( double );

extern double jn ( int, double );

extern double y0 ( double );

extern double y1 ( double );

extern double yn ( int, double );

extern double scalb ( double, double );
# 543 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
extern int signgam;
# 557 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
extern long int rinttol ( double );

extern long int roundtol ( double );
# 597 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
extern int finite ( double );

extern double gamma ( double );
# 610 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/architecture/i386/math.h" 3 4
extern double significand ( double );




extern double drem ( double, double );







}
# 29 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/math.h" 2 3 4
# 53 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cmath" 2 3
# 81 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cmath" 3
namespace std
{


  template<typename _Tp> _Tp __cmath_power(_Tp, unsigned int);

  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

  using ::acos;

  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    acos(_Tp __x)
    {
      return __builtin_acos(__x);
    }

  using ::asin;

  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;

  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;

  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }

  template<typename _Tp, typename _Up>
    inline typename __enable_if<double, __is_integer<_Tp>::__value
                                        && __is_integer<_Up>::__value>::__type
    atan2(_Tp __y, _Up __x)
    { return __builtin_atan2(__y, __x); }

  using ::ceil;

  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;

  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;

  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;

  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;

  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }

  using ::frexp;

  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;

  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }

  template<typename _Tp>
  inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  using ::log;

  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;

  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;

  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }

  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }

  using ::pow;

  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }

  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;

  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;

  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;

  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }

  template<typename _Tp>
    inline typename __enable_if<double, __is_integer<_Tp>::__value>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
}






namespace __gnu_cxx
{
  template<typename _Tp>
    int
    __capture_fpclassify(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __fpclassifyf((float)(__f)) : sizeof (__f) == sizeof(double) ? __fpclassifyd((double)(__f)) : __fpclassify ((long double)(__f))); }

  template<typename _Tp>
    int
    __capture_isfinite(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __inline_isfinitef((float)(__f)) : sizeof (__f) == sizeof(double) ? __inline_isfinited((double)(__f)) : __inline_isfinite ((long double)(__f))); }

  template<typename _Tp>
    int
    __capture_isinf(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __inline_isinff((float)(__f)) : sizeof (__f) == sizeof(double) ? __inline_isinfd((double)(__f)) : __inline_isinf ((long double)(__f))); }

  template<typename _Tp>
    int
    __capture_isnan(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __inline_isnanf((float)(__f)) : sizeof (__f) == sizeof(double) ? __inline_isnand((double)(__f)) : __inline_isnan ((long double)(__f))); }

  template<typename _Tp>
    int
    __capture_isnormal(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __inline_isnormalf((float)(__f)) : sizeof (__f) == sizeof(double) ? __inline_isnormald((double)(__f)) : __inline_isnormal ((long double)(__f))); }

  template<typename _Tp>
    int
    __capture_signbit(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __inline_signbitf((float)(__f)) : sizeof (__f) == sizeof(double) ? __inline_signbitd((double)(__f)) : __inline_signbit((long double)(__f))); }

  template<typename _Tp>
    int
    __capture_isgreater(_Tp __f1, _Tp __f2)
    { return __builtin_isgreater ((__f1),(__f2)); }

  template<typename _Tp>
     int
     __capture_isgreaterequal(_Tp __f1, _Tp __f2)
     { return __builtin_isgreaterequal ((__f1),(__f2)); }

  template<typename _Tp>
     int
     __capture_isless(_Tp __f1, _Tp __f2) { return __builtin_isless ((__f1),(__f2)); }

  template<typename _Tp>
     int
     __capture_islessequal(_Tp __f1, _Tp __f2)
     { return __builtin_islessequal ((__f1),(__f2)); }

  template<typename _Tp>
     int
     __capture_islessgreater(_Tp __f1, _Tp __f2)
     { return __builtin_islessgreater ((__f1),(__f2)); }

  template<typename _Tp>
     int
     __capture_isunordered(_Tp __f1, _Tp __f2)
     { return __builtin_isunordered ((__f1),(__f2)); }
}
# 514 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cmath" 3
namespace std
{
  template<typename _Tp>
    int
    fpclassify(_Tp __f) { return __gnu_cxx::__capture_fpclassify(__f); }

  template<typename _Tp>
    int
    isfinite(_Tp __f) { return __gnu_cxx::__capture_isfinite(__f); }

  template<typename _Tp>
    int
    isinf(_Tp __f) { return __gnu_cxx::__capture_isinf(__f); }

  template<typename _Tp>
    int
    isnan(_Tp __f) { return __gnu_cxx::__capture_isnan(__f); }

  template<typename _Tp>
    int
    isnormal(_Tp __f) { return __gnu_cxx::__capture_isnormal(__f); }

  template<typename _Tp>
    int
    signbit(_Tp __f) { return __gnu_cxx::__capture_signbit(__f); }

  template<typename _Tp>
    int
    isgreater(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_isgreater(__f1, __f2); }

  template<typename _Tp>
    int
    isgreaterequal(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_isgreaterequal(__f1, __f2); }

  template<typename _Tp>
    int
    isless(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_isless(__f1, __f2); }

  template<typename _Tp>
    int
    islessequal(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_islessequal(__f1, __f2); }

  template<typename _Tp>
    int
    islessgreater(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_islessgreater(__f1, __f2); }

  template<typename _Tp>
    int
    isunordered(_Tp __f1, _Tp __f2)
    { return __gnu_cxx::__capture_isunordered(__f1, __f2); }
}




# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/cmath.tcc" 1 3
# 35 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/cmath.tcc" 3
namespace std
{
  template<typename _Tp>
    inline _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : 1;

      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }

      return __y;
    }
}
# 575 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cmath" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_config.hpp" 2 3


namespace boost {
namespace posix_time {
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_config.hpp" 3
  typedef date_time::time_resolution_traits<
    boost::date_time::time_resolution_traits_adapted64_impl, boost::date_time::micro,
                                            1000000, 6 > time_res_traits;
# 57 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_config.hpp" 3
  class time_duration :
    public date_time::time_duration<time_duration, time_res_traits>
  {
  public:
    typedef time_res_traits rep_type;
    typedef time_res_traits::day_type day_type;
    typedef time_res_traits::hour_type hour_type;
    typedef time_res_traits::min_type min_type;
    typedef time_res_traits::sec_type sec_type;
    typedef time_res_traits::fractional_seconds_type fractional_seconds_type;
    typedef time_res_traits::tick_type tick_type;
    typedef time_res_traits::impl_type impl_type;
    time_duration(hour_type hour,
                  min_type min,
                  sec_type sec,
                  fractional_seconds_type fs=0) :
      date_time::time_duration<time_duration, time_res_traits>(hour,min,sec,fs)
    {}
    time_duration() :
      date_time::time_duration<time_duration, time_res_traits>(0,0,0)
    {}

    time_duration(boost::date_time::special_values sv) :
      date_time::time_duration<time_duration, time_res_traits>(sv)
    {}

    friend class date_time::time_duration<time_duration, time_res_traits>;
  private:
    explicit time_duration(impl_type ticks) :
      date_time::time_duration<time_duration, time_res_traits>(ticks)
    {}
  };
# 154 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_config.hpp" 3
  class millisec_posix_time_system_config
  {
   public:
    typedef boost::int64_t time_rep_type;

    typedef gregorian::date date_type;
    typedef gregorian::date_duration date_duration_type;
    typedef time_duration time_duration_type;
    typedef time_res_traits::tick_type int_type;
    typedef time_res_traits::impl_type impl_type;
    typedef time_res_traits resolution_traits;


    static const boost::int64_t tick_per_second = 1000000;

  };



} }
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_system.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_system_split.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_system_split.hpp" 3
namespace boost {
namespace date_time {





  template<typename config>

  class split_timedate_system
  {
   public:
    typedef typename config::time_rep_type time_rep_type;
    typedef typename config::date_type date_type;
    typedef typename config::time_duration_type time_duration_type;
    typedef typename config::date_duration_type date_duration_type;
    typedef typename config::int_type int_type;
    typedef typename config::resolution_traits resolution_traits;





   private:
     static const int_type ticks_per_day = int64_t(86400) * config::tick_per_second;
   public:



    typedef date_time::wrapping_int<int_type, ticks_per_day> wrap_int_type;



    static time_rep_type get_time_rep(special_values sv)
    {
      switch (sv) {
      case not_a_date_time:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));
      case pos_infin:
        return time_rep_type(date_type(pos_infin),
                             time_duration_type(pos_infin));
      case neg_infin:
        return time_rep_type(date_type(neg_infin),
                             time_duration_type(neg_infin));
      case max_date_time: {
        time_duration_type td = time_duration_type(24,0,0,0) - time_duration_type(0,0,0,1);
        return time_rep_type(date_type(max_date_time), td);
      }
      case min_date_time:
        return time_rep_type(date_type(min_date_time), time_duration_type(0,0,0,0));

      default:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));

      }

    }

    static time_rep_type get_time_rep(const date_type& day,
                                      const time_duration_type& tod,
                                      date_time::dst_flags dst=not_dst)
    {
      if(day.is_special() || tod.is_special()) {
        if(day.is_not_a_date() || tod.is_not_a_date_time()) {
          return time_rep_type(date_type(not_a_date_time),
                               time_duration_type(not_a_date_time));
        }
        else if(day.is_pos_infinity()) {
          if(tod.is_neg_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(day, time_duration_type(pos_infin));
          }
        }
        else if(day.is_neg_infinity()) {
          if(tod.is_pos_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(day, time_duration_type(neg_infin));
          }
        }
        else if(tod.is_pos_infinity()) {
          if(day.is_neg_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(date_type(pos_infin), tod);
          }
        }
        else if(tod.is_neg_infinity()) {
          if(day.is_pos_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(date_type(neg_infin), tod);
          }
        }
      }
      return time_rep_type(day, tod);
    }
    static date_type get_date(const time_rep_type& val)
    {
      return date_type(val.day);
    }
    static time_duration_type get_time_of_day(const time_rep_type& val)
    {
      return time_duration_type(val.time_of_day);
    }
    static std::string zone_name(const time_rep_type&)
    {
      return "";
    }
    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return ((lhs.day == rhs.day) && (lhs.time_of_day == rhs.time_of_day));
    }
    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      if (lhs.day < rhs.day) return true;
      if (lhs.day > rhs.day) return false;
      return (lhs.time_of_day < rhs.time_of_day);
    }
    static time_rep_type add_days(const time_rep_type& base,
                                  const date_duration_type& dd)
    {
      return time_rep_type(base.day+dd, base.time_of_day);
    }
    static time_rep_type subtract_days(const time_rep_type& base,
                                       const date_duration_type& dd)
    {
      return split_timedate_system::get_time_rep(base.day-dd, base.time_of_day);
    }
    static time_rep_type subtract_time_duration(const time_rep_type& base,
                                                const time_duration_type& td)
    {
      if(base.day.is_special() || td.is_special())
      {
        return split_timedate_system::get_time_rep(base.day, -td);
      }
      if (td.is_negative()) {
        time_duration_type td1 = td.invert_sign();
        return add_time_duration(base,td1);
      }


      wrap_int_type day_offset(base.time_of_day.ticks());
      date_duration_type day_overflow(static_cast<typename date_duration_type::duration_rep_type>(day_offset.subtract(td.ticks())));



      return time_rep_type(base.day-day_overflow,
                           time_duration_type(0,0,0,day_offset.as_int()));
    }
    static time_rep_type add_time_duration(const time_rep_type& base,
                                           time_duration_type td)
    {
      if(base.day.is_special() || td.is_special()) {
        return split_timedate_system::get_time_rep(base.day, td);
      }
      if (td.is_negative()) {
        time_duration_type td1 = td.invert_sign();
        return subtract_time_duration(base,td1);
      }
      wrap_int_type day_offset(base.time_of_day.ticks());
      typename date_duration_type::duration_rep_type doff = day_offset.add(td.ticks());


      date_duration_type day_overflow(doff);


      return time_rep_type(base.day+day_overflow,
                           time_duration_type(0,0,0,day_offset.as_int()));
    }
    static time_duration_type subtract_times(const time_rep_type& lhs,
                                             const time_rep_type& rhs)
    {
      date_duration_type dd = lhs.day - rhs.day;
      time_duration_type td(dd.days()*24,0,0);
      time_duration_type td2 = lhs.time_of_day - rhs.time_of_day;
      return td+td2;

    }

  };

} }
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_system.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_system_counted.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_system_counted.hpp" 3
namespace boost {
namespace date_time {


  template<class config>
  struct counted_time_rep
  {
    typedef typename config::int_type int_type;
    typedef typename config::date_type date_type;
    typedef typename config::impl_type impl_type;
    typedef typename date_type::duration_type date_duration_type;
    typedef typename date_type::calendar_type calendar_type;
    typedef typename date_type::ymd_type ymd_type;
    typedef typename config::time_duration_type time_duration_type;
    typedef typename config::resolution_traits resolution_traits;

    counted_time_rep(const date_type& d, const time_duration_type& time_of_day)
      : time_count_(1)
    {
      if(d.is_infinity() || d.is_not_a_date() || time_of_day.is_special()) {
        time_count_ = time_of_day.get_rep() + d.day_count();

      }
      else {
        time_count_ = (d.day_number() * frac_sec_per_day()) + time_of_day.ticks();
      }
    }
    explicit counted_time_rep(int_type count) :
      time_count_(count)
    {}
    explicit counted_time_rep(impl_type count) :
      time_count_(count)
    {}
    date_type date() const
    {
      if(time_count_.is_special()) {
        return date_type(time_count_.as_special());
      }
      else {
        typename calendar_type::date_int_type dc = day_count();

        ymd_type ymd = calendar_type::from_day_number(dc);
        return date_type(ymd);
      }
    }

    unsigned long day_count() const
    {
# 78 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_system_counted.hpp" 3
      return static_cast<unsigned long>(resolution_traits::as_number(time_count_) / frac_sec_per_day());
    }
    int_type time_count() const
    {
      return resolution_traits::as_number(time_count_);
    }
    int_type tod() const
    {
      return resolution_traits::as_number(time_count_) % frac_sec_per_day();
    }
    static int_type frac_sec_per_day()
    {
      int_type seconds_per_day = 60*60*24;
      int_type fractional_sec_per_sec(resolution_traits::res_adjust());
      return seconds_per_day*fractional_sec_per_sec;
    }
    bool is_pos_infinity()const
    {
      return impl_type::is_pos_inf(time_count_.as_number());
    }
    bool is_neg_infinity()const
    {
      return impl_type::is_neg_inf(time_count_.as_number());
    }
    bool is_not_a_date_time()const
    {
      return impl_type::is_not_a_number(time_count_.as_number());
    }
    bool is_special()const
    {
      return time_count_.is_special();
    }
    impl_type get_rep()const
    {
      return time_count_;
    }
  private:
    impl_type time_count_;
  };


  template<class time_rep>
  class counted_time_system
  {
   public:
    typedef time_rep time_rep_type;
    typedef typename time_rep_type::impl_type impl_type;
    typedef typename time_rep_type::time_duration_type time_duration_type;
    typedef typename time_duration_type::fractional_seconds_type fractional_seconds_type;
    typedef typename time_rep_type::date_type date_type;
    typedef typename time_rep_type::date_duration_type date_duration_type;


    template<class T> static void unused_var(const T&) {}

    static time_rep_type get_time_rep(const date_type& day,
                                      const time_duration_type& tod,
                                      date_time::dst_flags dst=not_dst)
    {
      unused_var(dst);
      return time_rep_type(day, tod);
    }

    static time_rep_type get_time_rep(special_values sv)
    {
      switch (sv) {
      case not_a_date_time:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));
      case pos_infin:
        return time_rep_type(date_type(pos_infin),
                             time_duration_type(pos_infin));
      case neg_infin:
        return time_rep_type(date_type(neg_infin),
                             time_duration_type(neg_infin));
      case max_date_time: {
        time_duration_type td = time_duration_type(24,0,0,0) - time_duration_type(0,0,0,1);
        return time_rep_type(date_type(max_date_time), td);
      }
      case min_date_time:
        return time_rep_type(date_type(min_date_time), time_duration_type(0,0,0,0));

      default:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));

      }

    }

    static date_type get_date(const time_rep_type& val)
    {
      return val.date();
    }
    static time_duration_type get_time_of_day(const time_rep_type& val)
    {
      if(val.is_special()) {
        return time_duration_type(val.get_rep().as_special());
      }
      else{
        return time_duration_type(0,0,0,val.tod());
      }
    }
    static std::string zone_name(const time_rep_type&)
    {
      return "";
    }
    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return (lhs.time_count() == rhs.time_count());
    }
    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return (lhs.time_count() < rhs.time_count());
    }
    static time_rep_type add_days(const time_rep_type& base,
                                  const date_duration_type& dd)
    {
      if(base.is_special() || dd.is_special()) {
        return(time_rep_type(base.get_rep() + dd.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() + (dd.days() * time_rep_type::frac_sec_per_day()));
      }
    }
    static time_rep_type subtract_days(const time_rep_type& base,
                                       const date_duration_type& dd)
    {
      if(base.is_special() || dd.is_special()) {
        return(time_rep_type(base.get_rep() - dd.get_rep()));
      }
      else{
        return time_rep_type(base.time_count() - (dd.days() * time_rep_type::frac_sec_per_day()));
      }
    }
    static time_rep_type subtract_time_duration(const time_rep_type& base,
                                                const time_duration_type& td)
    {
      if(base.is_special() || td.is_special()) {
        return(time_rep_type(base.get_rep() - td.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() - td.ticks());
      }
    }
    static time_rep_type add_time_duration(const time_rep_type& base,
                                           time_duration_type td)
    {
      if(base.is_special() || td.is_special()) {
        return(time_rep_type(base.get_rep() + td.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() + td.ticks());
      }
    }
    static time_duration_type subtract_times(const time_rep_type& lhs,
                                             const time_rep_type& rhs)
    {
      if(lhs.is_special() || rhs.is_special()) {
        return(time_duration_type(
          impl_type::to_special((lhs.get_rep() - rhs.get_rep()).as_number())));
      }
      else {
        fractional_seconds_type fs = lhs.time_count() - rhs.time_count();
        return time_duration_type(0,0,0,fs);
      }
    }

  };


} }
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_system.hpp" 2 3



namespace boost {
namespace posix_time {
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_system.hpp" 3
  typedef date_time::counted_time_rep<millisec_posix_time_system_config> int64_time_rep;
  typedef date_time::counted_time_system<int64_time_rep> posix_time_system;



} }
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/ptime.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time.hpp" 3
namespace boost {
namespace date_time {
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time.hpp" 3
  template <class T, class time_system>
  class base_time : private
      boost::less_than_comparable<T
    , boost::equality_comparable<T
      > >
  {
  public:
    typedef T time_type;
    typedef typename time_system::time_rep_type time_rep_type;
    typedef typename time_system::date_type date_type;
    typedef typename time_system::date_duration_type date_duration_type;
    typedef typename time_system::time_duration_type time_duration_type;


    base_time(const date_type& day,
              const time_duration_type& td,
              dst_flags dst=not_dst) :
      time_(time_system::get_time_rep(day, td, dst))
    {}
    base_time(special_values sv) :
      time_(time_system::get_time_rep(sv))
    {}
    base_time(const time_rep_type& rhs) :
      time_(rhs)
    {}
    date_type date() const
    {
      return time_system::get_date(time_);
    }
    time_duration_type time_of_day() const
    {
      return time_system::get_time_of_day(time_);
    }



    std::string zone_name(bool as_offset=false) const
    {
      return time_system::zone_name(time_);
    }



    std::string zone_abbrev(bool as_offset=false) const
    {
      return time_system::zone_name(time_);
    }

    std::string zone_as_posix_string() const
    {
      return std::string("");
    }


    bool is_not_a_date_time() const
    {
      return time_.is_not_a_date_time();
    }

    bool is_infinity() const
    {
      return (is_pos_infinity() || is_neg_infinity());
    }

    bool is_pos_infinity() const
    {
      return time_.is_pos_infinity();
    }

    bool is_neg_infinity() const
    {
      return time_.is_neg_infinity();
    }

    bool is_special() const
    {
      return(is_not_a_date_time() || is_infinity());
    }

    bool operator==(const time_type& rhs) const
    {
      return time_system::is_equal(time_,rhs.time_);
    }

    bool operator<(const time_type& rhs) const
    {
      return time_system::is_less(time_,rhs.time_);
    }

    time_duration_type operator-(const time_type& rhs) const
    {
      return time_system::subtract_times(time_, rhs.time_);
    }

    time_type operator+(const date_duration_type& dd) const
    {
      return time_system::add_days(time_, dd);
    }
    time_type operator+=(const date_duration_type& dd)
    {
      time_ = (time_system::get_time_rep(date() + dd, time_of_day()));
      return time_type(time_);
    }

    time_type operator-(const date_duration_type& dd) const
    {
      return time_system::subtract_days(time_, dd);
    }
    time_type operator-=(const date_duration_type& dd)
    {
      time_ = (time_system::get_time_rep(date() - dd, time_of_day()));
      return time_type(time_);
    }

    time_type operator+(const time_duration_type& td) const
    {
      return time_type(time_system::add_time_duration(time_, td));
    }
    time_type operator+=(const time_duration_type& td)
    {
      time_ = (time_system::get_time_rep(date(), time_of_day() + td));
      return time_type(time_);
    }

    time_type operator-(const time_duration_type& rhs) const
    {
      return time_system::subtract_time_duration(time_, rhs);
    }
    time_type operator-=(const time_duration_type& td)
    {
      time_ = (time_system::get_time_rep(date(), time_of_day() - td));
      return time_type(time_);
    }

  protected:
    time_rep_type time_;
  };





} }
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/ptime.hpp" 2 3

namespace boost {

namespace posix_time {


  using date_time::special_values;
  using date_time::not_special;
  using date_time::neg_infin;
  using date_time::pos_infin;
  using date_time::not_a_date_time;
  using date_time::max_date_time;
  using date_time::min_date_time;




  class ptime : public date_time::base_time<ptime, posix_time_system>
  {
  public:
    typedef posix_time_system time_system_type;
    typedef time_system_type::time_rep_type time_rep_type;
    typedef time_system_type::time_duration_type time_duration_type;
    typedef ptime time_type;

    ptime(gregorian::date d,time_duration_type td) : date_time::base_time<time_type,time_system_type>(d,td)
    {}

    explicit ptime(gregorian::date d) : date_time::base_time<time_type,time_system_type>(d,time_duration_type(0,0,0))
    {}

    ptime(const time_rep_type& rhs):
      date_time::base_time<time_type,time_system_type>(rhs)
    {}

    ptime(const special_values sv) : date_time::base_time<time_type,time_system_type>(sv)
    {}


    ptime() : date_time::base_time<time_type,time_system_type>(gregorian::date(not_a_date_time), time_duration_type(not_a_date_time))
    {}


  };



} }
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/date_duration_operators.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/date_duration_operators.hpp" 3
namespace boost {
namespace posix_time {
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/date_duration_operators.hpp" 3
  inline
  ptime
  operator+(const ptime& t, const boost::gregorian::months& m)
  {
    return t + m.get_offset(t.date());
  }




  inline
  ptime
  operator+=(ptime& t, const boost::gregorian::months& m)
  {

    return t += m.get_offset(t.date());
  }




  inline
  ptime
  operator-(const ptime& t, const boost::gregorian::months& m)
  {

    return t + m.get_neg_offset(t.date());
  }




  inline
  ptime
  operator-=(ptime& t, const boost::gregorian::months& m)
  {
    return t += m.get_neg_offset(t.date());
  }






  inline
  ptime
  operator+(const ptime& t, const boost::gregorian::years& y)
  {
    return t + y.get_offset(t.date());
  }




  inline
  ptime
  operator+=(ptime& t, const boost::gregorian::years& y)
  {
    return t += y.get_offset(t.date());
  }




  inline
  ptime
  operator-(const ptime& t, const boost::gregorian::years& y)
  {

    return t + y.get_neg_offset(t.date());
  }




  inline
  ptime
  operator-=(ptime& t, const boost::gregorian::years& y)
  {

    return t += y.get_neg_offset(t.date());
  }

}}
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_duration.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_duration.hpp" 3
namespace boost {
namespace posix_time {




  class hours : public time_duration
  {
  public:
    explicit hours(long h) :
      time_duration(h,0,0)
    {}
  };




  class minutes : public time_duration
  {
  public:
    explicit minutes(long m) :
      time_duration(0,m,0)
    {}
  };




  class seconds : public time_duration
  {
  public:
    explicit seconds(long s) :
      time_duration(0,0,s)
    {}
  };





  typedef date_time::subsecond_duration<time_duration,1000> millisec;
  typedef date_time::subsecond_duration<time_duration,1000> milliseconds;




  typedef date_time::subsecond_duration<time_duration,1000000> microsec;
  typedef date_time::subsecond_duration<time_duration,1000000> microseconds;
# 78 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_duration.hpp" 3
} }
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/time_period.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/time_period.hpp" 3
namespace boost {
namespace posix_time {




  typedef date_time::period<ptime, time_duration> time_period;


} }
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_iterator.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/time_iterator.hpp" 3
namespace boost {
namespace date_time {



  template<class time_type>
  class time_itr {
  public:
    typedef typename time_type::time_duration_type time_duration_type;
    time_itr(time_type t, time_duration_type d) : current_(t), offset_(d) {};
    time_itr& operator++()
    {
      current_ = current_ + offset_;
      return *this;
    }
    time_itr& operator--()
    {
      current_ = current_ - offset_;
      return *this;
    }
    time_type operator*() {return current_;};
    time_type* operator->() {return &current_;};
    bool operator< (const time_type& t) {return current_ < t;};
    bool operator<= (const time_type& t) {return current_ <= t;};
    bool operator!= (const time_type& t) {return current_ != t;};
    bool operator== (const time_type& t) {return current_ == t;};
    bool operator> (const time_type& t) {return current_ > t;};
    bool operator>= (const time_type& t) {return current_ >= t;};

  private:
    time_type current_;
    time_duration_type offset_;
  };



} }
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/dst_rules.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/dst_rules.hpp" 3
namespace boost {
  namespace date_time {

    enum time_is_dst_result {is_not_in_dst, is_in_dst,
                             ambiguous, invalid_time_label};



    template<class date_type_,
             class time_duration_type_>
    class dst_calculator
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;
# 47 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/dst_rules.hpp" 3
      static time_is_dst_result
      process_local_dst_start_day(const time_duration_type& time_of_day,
                                  unsigned int dst_start_offset_minutes,
                                  long dst_length_minutes)
      {

        if (time_of_day < time_duration_type(0,dst_start_offset_minutes,0)) {
          return is_not_in_dst;
        }
        long offset = dst_start_offset_minutes + dst_length_minutes;
        if (time_of_day >= time_duration_type(0,offset,0)) {
          return is_in_dst;
        }
        return invalid_time_label;
      }
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/dst_rules.hpp" 3
      static time_is_dst_result
      process_local_dst_end_day(const time_duration_type& time_of_day,
                                unsigned int dst_end_offset_minutes,
                                long dst_length_minutes)
      {

        int offset = dst_end_offset_minutes-dst_length_minutes;
        if (time_of_day < time_duration_type(0,offset,0)) {
          return is_in_dst;
        }
        if (time_of_day >= time_duration_type(0,dst_end_offset_minutes,0)) {
          return is_not_in_dst;
        }
        return ambiguous;
      }
# 100 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/dst_rules.hpp" 3
      static time_is_dst_result
      local_is_dst(const date_type& current_day,
                   const time_duration_type& time_of_day,
                   const date_type& dst_start_day,
                   const time_duration_type& dst_start_offset,
                   const date_type& dst_end_day,
                   const time_duration_type& dst_end_offset,
                   const time_duration_type& dst_length_minutes)
      {
        unsigned int start_minutes =
          dst_start_offset.hours() * 60 + dst_start_offset.minutes();
        unsigned int end_minutes =
          dst_end_offset.hours() * 60 + dst_end_offset.minutes();
        long length_minutes =
          dst_length_minutes.hours() * 60 + dst_length_minutes.minutes();

        return local_is_dst(current_day, time_of_day,
                            dst_start_day, start_minutes,
                            dst_end_day, end_minutes,
                            length_minutes);
      }
# 136 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/dst_rules.hpp" 3
      static time_is_dst_result
      local_is_dst(const date_type& current_day,
                   const time_duration_type& time_of_day,
                   const date_type& dst_start_day,
                   unsigned int dst_start_offset_minutes,
                   const date_type& dst_end_day,
                   unsigned int dst_end_offset_minutes,
                   long dst_length_minutes)
      {

        if (dst_start_day < dst_end_day) {
          if ((current_day > dst_start_day) && (current_day < dst_end_day)) {
            return is_in_dst;
          }
          if ((current_day < dst_start_day) || (current_day > dst_end_day)) {
            return is_not_in_dst;
          }
        }
        else {
          if ((current_day < dst_start_day) && (current_day > dst_end_day)) {
            return is_not_in_dst;
          }
          if ((current_day > dst_start_day) || (current_day < dst_end_day)) {
            return is_in_dst;
          }
        }

        if (current_day == dst_start_day) {
          return process_local_dst_start_day(time_of_day,
                                             dst_start_offset_minutes,
                                             dst_length_minutes);
        }

        if (current_day == dst_end_day) {
          return process_local_dst_end_day(time_of_day,
                                           dst_end_offset_minutes,
                                           dst_length_minutes);
        }

        return invalid_time_label;
      }

    };
# 208 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/dst_rules.hpp" 3
    template<class date_type,
             class time_duration_type,
             class dst_traits>
    class dst_calc_engine
    {
    public:
      typedef typename date_type::year_type year_type;
      typedef typename date_type::calendar_type calendar_type;
      typedef dst_calculator<date_type, time_duration_type> dstcalc;






      static time_is_dst_result local_is_dst(const date_type& d,
                                             const time_duration_type& td)
      {

        year_type y = d.year();
        date_type dst_start = local_dst_start_day(y);
        date_type dst_end = local_dst_end_day(y);
        return dstcalc::local_is_dst(d,td,
                                     dst_start,
                                     dst_traits::dst_start_offset_minutes(),
                                     dst_end,
                                     dst_traits::dst_end_offset_minutes(),
                                     dst_traits::dst_shift_length_minutes());

      }

      static bool is_dst_boundary_day(date_type d)
      {
        year_type y = d.year();
        return ((d == local_dst_start_day(y)) ||
                (d == local_dst_end_day(y)));
      }


      static time_duration_type dst_offset()
      {
        return time_duration_type(0,dst_traits::dst_shift_length_minutes(),0);
      }

      static date_type local_dst_start_day(year_type year)
      {
        return dst_traits::local_dst_start_day(year);
      }

      static date_type local_dst_end_day(year_type year)
      {
        return dst_traits::local_dst_end_day(year);
      }


    };






    template<class date_type_,
             class time_duration_type_,
             unsigned int dst_start_offset_minutes=120,
             short dst_length_minutes=60>
    class us_dst_rules
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;
      typedef typename date_type::year_type year_type;
      typedef typename date_type::calendar_type calendar_type;
      typedef date_time::last_kday_of_month<date_type> lkday;
      typedef date_time::first_kday_of_month<date_type> fkday;
      typedef date_time::nth_kday_of_month<date_type> nkday;
      typedef dst_calculator<date_type, time_duration_type> dstcalc;






      static time_is_dst_result local_is_dst(const date_type& d,
                                             const time_duration_type& td)
      {

        year_type y = d.year();
        date_type dst_start = local_dst_start_day(y);
        date_type dst_end = local_dst_end_day(y);
        return dstcalc::local_is_dst(d,td,
                                     dst_start,dst_start_offset_minutes,
                                     dst_end, dst_start_offset_minutes,
                                     dst_length_minutes);

      }


      static bool is_dst_boundary_day(date_type d)
      {
        year_type y = d.year();
        return ((d == local_dst_start_day(y)) ||
                (d == local_dst_end_day(y)));
      }

      static date_type local_dst_start_day(year_type year)
      {
        if (year >= year_type(2007)) {

          nkday ssim(nkday::second, Sunday, gregorian::Mar);
          return ssim.get_date(year);
        } else {

          fkday fsia(Sunday, gregorian::Apr);
          return fsia.get_date(year);
        }
      }

      static date_type local_dst_end_day(year_type year)
      {
        if (year >= year_type(2007)) {

          fkday fsin(Sunday, gregorian::Nov);
          return fsin.get_date(year);
        } else {

          lkday lsio(Sunday, gregorian::Oct);
          return lsio.get_date(year);
        }
      }

      static time_duration_type dst_offset()
      {
        return time_duration_type(0,dst_length_minutes,0);
      }

     private:


    };


    template<class date_type_, class time_duration_type_>
    class null_dst_rules
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;





      static time_is_dst_result local_is_dst(const date_type&,
                                             const time_duration_type&)
      {
        return is_not_in_dst;
      }


      static time_is_dst_result utc_is_dst(const date_type&,
                                           const time_duration_type&)
      {
        return is_not_in_dst;
      }

      static bool is_dst_boundary_day(date_type d)
      {
        return false;
      }

      static time_duration_type dst_offset()
      {
        return time_duration_type(0,0,0);
      }

    };


  } }
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3

namespace boost {


namespace posix_time {




  typedef date_time::time_itr<ptime> time_iterator;



  typedef date_time::second_clock<ptime> second_clock;





  typedef date_time::microsec_clock<ptime> microsec_clock;



  typedef date_time::null_dst_rules<ptime::date_type, time_duration> no_dst;

  typedef date_time::us_dst_rules<ptime::date_type, time_duration> us_dst;


} }
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/thread_time.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/thread_time.hpp" 2 3

namespace boost
{
    typedef boost::posix_time::ptime system_time;

    inline system_time get_system_time()
    {
        return boost::date_time::microsec_clock<system_time>::universal_time();
    }

    namespace detail
    {
        inline system_time get_system_time_sentinel()
        {
            return system_time(boost::posix_time::pos_infin);
        }

        inline unsigned long get_milliseconds_until(system_time const& target_time)
        {
            if(target_time.is_pos_infinity())
            {
                return ~(unsigned long)0;
            }
            system_time const now=get_system_time();
            if(target_time<=now)
            {
                return 0;
            }
            return static_cast<unsigned long>((target_time-now).total_milliseconds()+1);
        }

    }

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/thread_time.hpp" 2 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 2 3

namespace boost
{
    struct xtime;
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 3
    namespace detail
    {
        template<typename T>
        struct has_member_lock
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };

            template<typename U>
            static true_type has_member(U*,void (U::*dummy)()=&U::lock);
            static false_type has_member(void*);

            static const bool value=sizeof(has_member_lock<T>::has_member((T*)__null))==sizeof(true_type);
        };

        template<typename T>
        struct has_member_unlock
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };

            template<typename U>
            static true_type has_member(U*,void (U::*dummy)()=&U::unlock);
            static false_type has_member(void*);

            static const bool value=sizeof(has_member_unlock<T>::has_member((T*)__null))==sizeof(true_type);
        };

        template<typename T>
        struct has_member_try_lock
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };

            template<typename U>
            static true_type has_member(U*,bool (U::*dummy)()=&U::try_lock);
            static false_type has_member(void*);

            static const bool value=sizeof(has_member_try_lock<T>::has_member((T*)__null))==sizeof(true_type);
        };

    }


    template<typename T>
    struct is_mutex_type
    {
        static const bool value = detail::has_member_lock<T>::value && detail::has_member_unlock<T>::value && detail::has_member_try_lock<T>::value;



    };
# 97 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 3
    struct defer_lock_t
    {};
    struct try_to_lock_t
    {};
    struct adopt_lock_t
    {};

    const defer_lock_t defer_lock={};
    const try_to_lock_t try_to_lock={};
    const adopt_lock_t adopt_lock={};

    template<typename Mutex>
    class shared_lock;

    template<typename Mutex>
    class upgrade_lock;

    template<typename Mutex>
    class unique_lock;

    namespace detail
    {
        template<typename Mutex>
        class try_lock_wrapper;
    }
# 182 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 3
    template<typename Mutex>
    class lock_guard
    {
    private:
        Mutex& m;

        explicit lock_guard(lock_guard&);
        lock_guard& operator=(lock_guard&);
    public:
        explicit lock_guard(Mutex& m_):
            m(m_)
        {
            m.lock();
        }
        lock_guard(Mutex& m_,adopt_lock_t):
            m(m_)
        {}
        ~lock_guard()
        {
            m.unlock();
        }
    };


    template<typename Mutex>
    class unique_lock
    {
    private:
        Mutex* m;
        bool is_locked;
        unique_lock(unique_lock&);
        explicit unique_lock(upgrade_lock<Mutex>&);
        unique_lock& operator=(unique_lock&);
        unique_lock& operator=(upgrade_lock<Mutex>& other);
    public:
        unique_lock():
            m(0),is_locked(false)
        {}

        explicit unique_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        unique_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        unique_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        unique_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
        unique_lock(Mutex& m_,system_time const& target_time):
            m(&m_),is_locked(false)
        {
            timed_lock(target_time);
        }
# 276 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 3
        unique_lock(detail::thread_move_t<unique_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            other->is_locked=false;
            other->m=0;
        }
        unique_lock(detail::thread_move_t<upgrade_lock<Mutex> > other);

        operator detail::thread_move_t<unique_lock<Mutex> >()
        {
            return move();
        }

        detail::thread_move_t<unique_lock<Mutex> > move()
        {
            return detail::thread_move_t<unique_lock<Mutex> >(*this);
        }

        unique_lock& operator=(detail::thread_move_t<unique_lock<Mutex> > other)
        {
            unique_lock temp(other);
            swap(temp);
            return *this;
        }

        unique_lock& operator=(detail::thread_move_t<upgrade_lock<Mutex> > other)
        {
            unique_lock temp(other);
            swap(temp);
            return *this;
        }
        void swap(unique_lock& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }
        void swap(detail::thread_move_t<unique_lock<Mutex> > other)
        {
            std::swap(m,other->m);
            std::swap(is_locked,other->is_locked);
        }


        ~unique_lock()
        {
            if(owns_lock())
            {
                m->unlock();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            m->lock();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            is_locked=m->try_lock();
            return is_locked;
        }
        template<typename TimeDuration>
        bool timed_lock(TimeDuration const& relative_time)
        {
            is_locked=m->timed_lock(relative_time);
            return is_locked;
        }

        bool timed_lock(::boost::system_time const& absolute_time)
        {
            is_locked=m->timed_lock(absolute_time);
            return is_locked;
        }
        bool timed_lock(::boost::xtime const& absolute_time)
        {
            is_locked=m->timed_lock(absolute_time);
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                throw boost::lock_error();
            }
            m->unlock();
            is_locked=false;
        }

        typedef void (unique_lock::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&unique_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }

        Mutex* mutex() const
        {
            return m;
        }

        Mutex* release()
        {
            Mutex* const res=m;
            m=0;
            is_locked=false;
            return res;
        }

        friend class shared_lock<Mutex>;
        friend class upgrade_lock<Mutex>;
    };
# 409 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 3
    template<typename Mutex>
    void swap(unique_lock<Mutex>& lhs,unique_lock<Mutex>& rhs)
    {
        lhs.swap(rhs);
    }
# 424 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 3
    template<typename Mutex>
    class shared_lock
    {
    protected:
        Mutex* m;
        bool is_locked;
    private:
        explicit shared_lock(shared_lock&);
        shared_lock& operator=(shared_lock&);
    public:
        shared_lock():
            m(0),is_locked(false)
        {}

        explicit shared_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        shared_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        shared_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        shared_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
        shared_lock(Mutex& m_,system_time const& target_time):
            m(&m_),is_locked(false)
        {
            timed_lock(target_time);
        }

        shared_lock(detail::thread_move_t<shared_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            other->is_locked=false;
            other->m=0;
        }

        shared_lock(detail::thread_move_t<unique_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            if(is_locked)
            {
                m->unlock_and_lock_shared();
            }
            other->is_locked=false;
            other->m=0;
        }

        shared_lock(detail::thread_move_t<upgrade_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            if(is_locked)
            {
                m->unlock_upgrade_and_lock_shared();
            }
            other->is_locked=false;
            other->m=0;
        }

        operator detail::thread_move_t<shared_lock<Mutex> >()
        {
            return move();
        }

        detail::thread_move_t<shared_lock<Mutex> > move()
        {
            return detail::thread_move_t<shared_lock<Mutex> >(*this);
        }


        shared_lock& operator=(detail::thread_move_t<shared_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }

        shared_lock& operator=(detail::thread_move_t<unique_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }

        shared_lock& operator=(detail::thread_move_t<upgrade_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }
# 528 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 3
        void swap(shared_lock& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }
        void swap(boost::detail::thread_move_t<shared_lock<Mutex> > other)
        {
            std::swap(m,other->m);
            std::swap(is_locked,other->is_locked);
        }


        Mutex* mutex() const
        {
            return m;
        }

        ~shared_lock()
        {
            if(owns_lock())
            {
                m->unlock_shared();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            m->lock_shared();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            is_locked=m->try_lock_shared();
            return is_locked;
        }
        bool timed_lock(boost::system_time const& target_time)
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            is_locked=m->timed_lock_shared(target_time);
            return is_locked;
        }
        template<typename Duration>
        bool timed_lock(Duration const& target_time)
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            is_locked=m->timed_lock_shared(target_time);
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                throw boost::lock_error();
            }
            m->unlock_shared();
            is_locked=false;
        }

        typedef void (shared_lock<Mutex>::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&shared_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }

    };
# 622 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 3
    template<typename Mutex>
    void swap(shared_lock<Mutex>& lhs,shared_lock<Mutex>& rhs)
    {
        lhs.swap(rhs);
    }


    template<typename Mutex>
    class upgrade_lock
    {
    protected:
        Mutex* m;
        bool is_locked;
    private:
        explicit upgrade_lock(upgrade_lock&);
        upgrade_lock& operator=(upgrade_lock&);
    public:
        upgrade_lock():
            m(0),is_locked(false)
        {}

        explicit upgrade_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        upgrade_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        upgrade_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        upgrade_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
        upgrade_lock(detail::thread_move_t<upgrade_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            other->is_locked=false;
            other->m=0;
        }

        upgrade_lock(detail::thread_move_t<unique_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            if(is_locked)
            {
                m->unlock_and_lock_upgrade();
            }
            other->is_locked=false;
            other->m=0;
        }

        operator detail::thread_move_t<upgrade_lock<Mutex> >()
        {
            return move();
        }

        detail::thread_move_t<upgrade_lock<Mutex> > move()
        {
            return detail::thread_move_t<upgrade_lock<Mutex> >(*this);
        }


        upgrade_lock& operator=(detail::thread_move_t<upgrade_lock<Mutex> > other)
        {
            upgrade_lock temp(other);
            swap(temp);
            return *this;
        }

        upgrade_lock& operator=(detail::thread_move_t<unique_lock<Mutex> > other)
        {
            upgrade_lock temp(other);
            swap(temp);
            return *this;
        }

        void swap(upgrade_lock& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }

        ~upgrade_lock()
        {
            if(owns_lock())
            {
                m->unlock_upgrade();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            m->lock_upgrade();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            is_locked=m->try_lock_upgrade();
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                throw boost::lock_error();
            }
            m->unlock_upgrade();
            is_locked=false;
        }

        typedef void (upgrade_lock::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&upgrade_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }
        friend class shared_lock<Mutex>;
        friend class unique_lock<Mutex>;
    };
# 773 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 3
    template<typename Mutex>
    unique_lock<Mutex>::unique_lock(detail::thread_move_t<upgrade_lock<Mutex> > other):
        m(other->m),is_locked(other->is_locked)
    {
        other->is_locked=false;
        if(is_locked)
        {
            m->unlock_upgrade_and_lock();
        }
    }

    template <class Mutex>
    class upgrade_to_unique_lock
    {
    private:
        upgrade_lock<Mutex>* source;
        unique_lock<Mutex> exclusive;

        explicit upgrade_to_unique_lock(upgrade_to_unique_lock&);
        upgrade_to_unique_lock& operator=(upgrade_to_unique_lock&);
    public:
        explicit upgrade_to_unique_lock(upgrade_lock<Mutex>& m_):
            source(&m_),exclusive(move(*source))
        {}
        ~upgrade_to_unique_lock()
        {
            if(source)
            {
                *source=move(exclusive);
            }
        }

        upgrade_to_unique_lock(detail::thread_move_t<upgrade_to_unique_lock<Mutex> > other):
            source(other->source),exclusive(move(other->exclusive))
        {
            other->source=0;
        }

        upgrade_to_unique_lock& operator=(detail::thread_move_t<upgrade_to_unique_lock<Mutex> > other)
        {
            upgrade_to_unique_lock temp(other);
            swap(temp);
            return *this;
        }
        void swap(upgrade_to_unique_lock& other)
        {
            std::swap(source,other.source);
            exclusive.swap(other.exclusive);
        }
        typedef void (upgrade_to_unique_lock::*bool_type)(upgrade_to_unique_lock&);
        operator bool_type() const
        {
            return exclusive.owns_lock()?&upgrade_to_unique_lock::swap:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return exclusive.owns_lock();
        }
    };

    namespace detail
    {
        template<typename Mutex>
        class try_lock_wrapper:
            private unique_lock<Mutex>
        {
            typedef unique_lock<Mutex> base;
        public:
            try_lock_wrapper()
            {}

            explicit try_lock_wrapper(Mutex& m):
                base(m,try_to_lock)
            {}

            try_lock_wrapper(Mutex& m_,adopt_lock_t):
                base(m_,adopt_lock)
            {}
            try_lock_wrapper(Mutex& m_,defer_lock_t):
                base(m_,defer_lock)
            {}
            try_lock_wrapper(Mutex& m_,try_to_lock_t):
                base(m_,try_to_lock)
            {}
            try_lock_wrapper(detail::thread_move_t<try_lock_wrapper<Mutex> > other):
                base(detail::thread_move_t<base>(*other))
            {}

            operator detail::thread_move_t<try_lock_wrapper<Mutex> >()
            {
                return move();
            }

            detail::thread_move_t<try_lock_wrapper<Mutex> > move()
            {
                return detail::thread_move_t<try_lock_wrapper<Mutex> >(*this);
            }

            try_lock_wrapper& operator=(detail::thread_move_t<try_lock_wrapper<Mutex> > other)
            {
                try_lock_wrapper temp(other);
                swap(temp);
                return *this;
            }







            void swap(try_lock_wrapper& other)
            {
                base::swap(other);
            }
            void swap(detail::thread_move_t<try_lock_wrapper<Mutex> > other)
            {
                base::swap(*other);
            }


            void lock()
            {
                base::lock();
            }
            bool try_lock()
            {
                return base::try_lock();
            }
            void unlock()
            {
                base::unlock();
            }
            bool owns_lock() const
            {
                return base::owns_lock();
            }
            Mutex* mutex() const
            {
                return base::mutex();
            }
            Mutex* release()
            {
                return base::release();
            }
            bool operator!() const
            {
                return !this->owns_lock();
            }

            typedef typename base::bool_type bool_type;
            operator bool_type() const
            {
                return base::operator bool_type();
            }
        };
# 941 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 3
        template<typename Mutex>
        void swap(try_lock_wrapper<Mutex>& lhs,try_lock_wrapper<Mutex>& rhs)
        {
            lhs.swap(rhs);
        }


        template<typename MutexType1,typename MutexType2>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(!m2.try_lock())
            {
                return 2;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }


        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                                   MutexType4& m4)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4,typename MutexType5>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                                   MutexType4& m4,MutexType5& m5)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4,m5))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }


        template<typename MutexType1,typename MutexType2>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(!m2.try_lock())
            {
                return 1;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                             MutexType4& m4)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4,typename MutexType5>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                             MutexType4& m4,MutexType5& m5)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4,m5))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }
    }

    namespace detail
    {
        template<bool x>
        struct is_mutex_type_wrapper
        {};

        template<typename MutexType1,typename MutexType2>
        void lock_impl(MutexType1& m1,MutexType2& m2,is_mutex_type_wrapper<true>)
        {
            unsigned const lock_count=2;
            unsigned lock_first=0;
            while(true)
            {
                switch(lock_first)
                {
                case 0:
                    lock_first=detail::lock_helper(m1,m2);
                    if(!lock_first)
                        return;
                    break;
                case 1:
                    lock_first=detail::lock_helper(m2,m1);
                    if(!lock_first)
                        return;
                    lock_first=(lock_first+1)%lock_count;
                    break;
                }
            }
        }

        template<typename Iterator>
        void lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>);
    }


    template<typename MutexType1,typename MutexType2>
    void lock(MutexType1& m1,MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    void lock(const MutexType1& m1,MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    void lock(MutexType1& m1,const MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    void lock(const MutexType1& m1,const MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3)
    {
        unsigned const lock_count=3;
        unsigned lock_first=0;
        while(true)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            }
        }
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,
             typename MutexType4>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,
              MutexType4& m4)
    {
        unsigned const lock_count=4;
        unsigned lock_first=0;
        while(true)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3,m4);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m4,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m4,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            case 3:
                lock_first=detail::lock_helper(m4,m1,m2,m3);
                if(!lock_first)
                    return;
                lock_first=(lock_first+3)%lock_count;
                break;
            }
        }
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,
             typename MutexType4,typename MutexType5>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,
              MutexType4& m4,MutexType5& m5)
    {
        unsigned const lock_count=5;
        unsigned lock_first=0;
        while(true)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3,m4,m5);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m4,m5,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m4,m5,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            case 3:
                lock_first=detail::lock_helper(m4,m5,m1,m2,m3);
                if(!lock_first)
                    return;
                lock_first=(lock_first+3)%lock_count;
                break;
            case 4:
                lock_first=detail::lock_helper(m5,m1,m2,m3,m4);
                if(!lock_first)
                    return;
                lock_first=(lock_first+4)%lock_count;
                break;
            }
        }
    }

    namespace detail
    {
        template<typename Mutex,bool x=is_mutex_type<Mutex>::value>
        struct try_lock_impl_return
        {
            typedef int type;
        };

        template<typename Iterator>
        struct try_lock_impl_return<Iterator,false>
        {
            typedef Iterator type;
        };

        template<typename MutexType1,typename MutexType2>
        int try_lock_impl(MutexType1& m1,MutexType2& m2,is_mutex_type_wrapper<true>)
        {
            return ((int)detail::try_lock_internal(m1,m2))-1;
        }

        template<typename Iterator>
        Iterator try_lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>);
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(MutexType1& m1,MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(const MutexType1& m1,MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(MutexType1& m1,const MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(const MutexType1& m1,const MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3))-1;
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,typename MutexType4>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,MutexType4& m4)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3,m4))-1;
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,typename MutexType4,typename MutexType5>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,MutexType4& m4,MutexType5& m5)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3,m4,m5))-1;
    }


    namespace detail
    {
        template<typename Iterator>
        struct range_lock_guard
        {
            Iterator begin;
            Iterator end;

            range_lock_guard(Iterator begin_,Iterator end_):
                begin(begin_),end(end_)
            {
                lock(begin,end);
            }

            void release()
            {
                begin=end;
            }

            ~range_lock_guard()
            {
                for(;begin!=end;++begin)
                {
                    begin->unlock();
                }
            }
        };

        template<typename Iterator>
        Iterator try_lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>)

        {
            if(begin==end)
            {
                return end;
            }
            typedef typename std::iterator_traits<Iterator>::value_type lock_type;
            unique_lock<lock_type> guard(*begin,try_to_lock);

            if(!guard.owns_lock())
            {
                return begin;
            }
            Iterator const failed=try_lock(++begin,end);
            if(failed==end)
            {
                guard.release();
            }

            return failed;
        }
    }


    namespace detail
    {
        template<typename Iterator>
        void lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>)
        {
            typedef typename std::iterator_traits<Iterator>::value_type lock_type;

            if(begin==end)
            {
                return;
            }
            bool start_with_begin=true;
            Iterator second=begin;
            ++second;
            Iterator next=second;

            for(;;)
            {
                unique_lock<lock_type> begin_lock(*begin,defer_lock);
                if(start_with_begin)
                {
                    begin_lock.lock();
                    Iterator const failed_lock=try_lock(next,end);
                    if(failed_lock==end)
                    {
                        begin_lock.release();
                        return;
                    }
                    start_with_begin=false;
                    next=failed_lock;
                }
                else
                {
                    detail::range_lock_guard<Iterator> guard(next,end);
                    if(begin_lock.try_lock())
                    {
                        Iterator const failed_lock=try_lock(second,next);
                        if(failed_lock==next)
                        {
                            begin_lock.release();
                            guard.release();
                            return;
                        }
                        start_with_begin=false;
                        next=failed_lock;
                    }
                    else
                    {
                        start_with_begin=true;
                        next=second;
                    }
                }
            }
        }

    }

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 1423 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/locks.hpp" 2 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/xtime.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/xtime.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/xtime.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/conversion.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/conversion.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/filetime_functions.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/conversion.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/conversion.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/conversion.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_io.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_io.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_facet.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_facet.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/config.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 1 3
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_traits.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_traits.hpp" 3
namespace boost {
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_traits.hpp" 3
template <class Iterator>
struct iterator_value
{
    typedef typename boost::detail::iterator_traits<Iterator>::value_type type;
};

template <class Iterator>
struct iterator_reference
{
    typedef typename boost::detail::iterator_traits<Iterator>::reference type;
};


template <class Iterator>
struct iterator_pointer
{
    typedef typename boost::detail::iterator_traits<Iterator>::pointer type;
};

template <class Iterator>
struct iterator_difference
{
    typedef typename boost::detail::iterator_traits<Iterator>::difference_type type;
};

template <class Iterator>
struct iterator_category
{
    typedef typename boost::detail::iterator_traits<Iterator>::iterator_category type;
};
# 90 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_traits.hpp" 3
}
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/functions.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/functions.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/begin.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/begin.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/config.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/begin.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/mutable_iterator.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/mutable_iterator.hpp" 3
namespace boost
{




    template< typename C >
    struct range_mutable_iterator
    {
        typedef typename C::iterator type;
    };





    template< typename Iterator >
    struct range_mutable_iterator< std::pair<Iterator,Iterator> >
    {
        typedef Iterator type;
    };





    template< typename T, std::size_t sz >
    struct range_mutable_iterator< T[sz] >
    {
        typedef T* type;
    };

}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/const_iterator.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/const_iterator.hpp" 3
namespace boost
{




    template< typename C >
    struct range_const_iterator
    {
        typedef typename C::const_iterator type;
    };





    template< typename Iterator >
    struct range_const_iterator< std::pair<Iterator,Iterator> >
    {
        typedef Iterator type;
    };





    template< typename T, std::size_t sz >
    struct range_const_iterator< T[sz] >
    {
        typedef const T* type;
    };

}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator.hpp" 2 3




namespace boost
{
# 50 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator.hpp" 3
    template< typename C >
    struct range_iterator
    {







        typedef typename
            mpl::eval_if_c< is_const<C>::value,
                            range_const_iterator< typename remove_const<C>::type >,
                            range_mutable_iterator<C> >::type type;


    };

}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/begin.hpp" 2 3

namespace boost
{




namespace range_detail
{






    template< typename C >
    inline typename range_iterator<C>::type
    range_begin( C& c )
    {





        return c.begin();
    }





    template< typename Iterator >
    inline Iterator range_begin( const std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }

    template< typename Iterator >
    inline Iterator range_begin( std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }
# 75 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/begin.hpp" 3
    template< typename T, std::size_t sz >
    inline const T* range_begin( const T (&a)[sz] )
    {
        return a;
    }

    template< typename T, std::size_t sz >
    inline T* range_begin( T (&a)[sz] )
    {
        return a;
    }





}



template< class T >
inline typename range_iterator<T>::type begin( T& r )
{



    using namespace range_detail;

    return range_begin( r );
}

template< class T >
inline typename range_iterator<const T>::type begin( const T& r )
{



    using namespace range_detail;

    return range_begin( r );
}

}



namespace boost
{
    template< class T >
    inline typename range_iterator<const T>::type
    const_begin( const T& r )
    {
        return boost::begin( r );
    }
}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/functions.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/end.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/end.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/implementation_help.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/implementation_help.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/common.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/common.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/sfinae.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/sfinae.hpp" 3
namespace boost
{
    namespace range_detail
    {
        using type_traits::yes_type;
        using type_traits::no_type;





        yes_type is_string_impl( const char* const );
        yes_type is_string_impl( const wchar_t* const );
        no_type is_string_impl( ... );

        template< std::size_t sz >
        yes_type is_char_array_impl( char (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_char_array_impl( const char (&boost_range_array)[sz] );
        no_type is_char_array_impl( ... );

        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( wchar_t (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( const wchar_t (&boost_range_array)[sz] );
        no_type is_wchar_t_array_impl( ... );

        yes_type is_char_ptr_impl( char* const );
        no_type is_char_ptr_impl( ... );

        yes_type is_const_char_ptr_impl( const char* const );
        no_type is_const_char_ptr_impl( ... );

        yes_type is_wchar_t_ptr_impl( wchar_t* const );
        no_type is_wchar_t_ptr_impl( ... );

        yes_type is_const_wchar_t_ptr_impl( const wchar_t* const );
        no_type is_const_wchar_t_ptr_impl( ... );





        template< typename Iterator >
        yes_type is_pair_impl( const std::pair<Iterator,Iterator>* );
        no_type is_pair_impl( ... );





        struct char_or_wchar_t_array_tag {};

    }

}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/common.hpp" 2 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/common.hpp" 3
namespace boost
{
    namespace range_detail
    {
# 47 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/common.hpp" 3
        typedef mpl::int_<1>::type std_container_;
        typedef mpl::int_<2>::type std_pair_;
        typedef mpl::int_<3>::type const_std_pair_;
        typedef mpl::int_<4>::type array_;
        typedef mpl::int_<5>::type const_array_;
        typedef mpl::int_<6>::type char_array_;
        typedef mpl::int_<7>::type wchar_t_array_;
        typedef mpl::int_<8>::type char_ptr_;
        typedef mpl::int_<9>::type const_char_ptr_;
        typedef mpl::int_<10>::type wchar_t_ptr_;
        typedef mpl::int_<11>::type const_wchar_t_ptr_;
        typedef mpl::int_<12>::type string_;

        template< typename C >
        struct range_helper
        {
            static C* c;
            static C ptr;

            static const bool is_pair_ = sizeof( boost::range_detail::is_pair_impl( c ) ) == sizeof( yes_type );
            static const bool is_char_ptr_ = sizeof( boost::range_detail::is_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_char_ptr_ = sizeof( boost::range_detail::is_const_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_ptr_ = sizeof( boost::range_detail::is_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_wchar_t_ptr_ = sizeof( boost::range_detail::is_const_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_char_array_ = sizeof( boost::range_detail::is_char_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_array_ = sizeof( boost::range_detail::is_wchar_t_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_string_ = (boost::type_traits::ice_or<is_const_char_ptr_, is_const_wchar_t_ptr_>::value );
            static const bool is_array_ = boost::is_array<C>::value;

        };

        template< typename C >
        class range
        {
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_pair_,
                                                                  boost::range_detail::std_pair_,
                                                                  void >::type pair_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_array_,
                                                                    boost::range_detail::array_,
                                                                    pair_t >::type array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_string_,
                                                                    boost::range_detail::string_,
                                                                    array_t >::type string_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_char_ptr_,
                                                                    boost::range_detail::const_char_ptr_,
                                                                    string_t >::type const_char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_ptr_,
                                                                    boost::range_detail::char_ptr_,
                                                                    const_char_ptr_t >::type char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_wchar_t_ptr_,
                                                                    boost::range_detail::const_wchar_t_ptr_,
                                                                    char_ptr_t >::type const_wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_ptr_,
                                                                    boost::range_detail::wchar_t_ptr_,
                                                                    const_wchar_ptr_t >::type wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_array_,
                                                                    boost::range_detail::wchar_t_array_,
                                                                    wchar_ptr_t >::type wchar_array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_array_,
                                                                    boost::range_detail::char_array_,
                                                                    wchar_array_t >::type char_array_t;
        public:
            typedef typename boost::mpl::if_c< ::boost::is_void<char_array_t>::value,
                                                                    boost::range_detail::std_container_,
                                                                    char_array_t >::type type;
        };
    }
}
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/implementation_help.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/implementation_help.hpp" 3
namespace boost
{
    namespace range_detail
    {
        template <typename T>
        inline void boost_range_silence_warning( const T& ) { }





        inline const char* str_end( const char* s, const char* )
        {
            return s + strlen( s );
        }


        inline const wchar_t* str_end( const wchar_t* s, const wchar_t* )
        {
            return s + wcslen( s );
        }
# 56 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/implementation_help.hpp" 3
        template< class Char >
        inline Char* str_end( Char* s )
        {
            return const_cast<Char*>( str_end( s, s ) );
        }

        template< class T, std::size_t sz >
        inline T* array_end( T (&boost_range_array)[sz] )
        {
            return boost_range_array + sz;
        }

        template< class T, std::size_t sz >
        inline const T* array_end( const T (&boost_range_array)[sz] )
        {
            return boost_range_array + sz;
        }





        template< class Char >
        inline std::size_t str_size( const Char* const& s )
        {
            return str_end( s ) - s;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }

        template< class T, std::size_t sz >
        inline std::size_t array_size( const T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }

    }

}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/end.hpp" 2 3



namespace boost
{




namespace range_detail
{





        template< typename C >
        inline typename range_iterator<C>::type
        range_end( C& c )
        {





            return c.end();
        }





        template< typename Iterator >
        inline Iterator range_end( const std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }

        template< typename Iterator >
        inline Iterator range_end( std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }





        template< typename T, std::size_t sz >
        inline const T* range_end( const T (&a)[sz] )
        {
            return range_detail::array_end<T,sz>( a );
        }

        template< typename T, std::size_t sz >
        inline T* range_end( T (&a)[sz] )
        {
            return range_detail::array_end<T,sz>( a );
        }




}


template< class T >
inline typename range_iterator<T>::type end( T& r )
{



    using namespace range_detail;

    return range_end( r );
}

template< class T >
inline typename range_iterator<const T>::type end( const T& r )
{



    using namespace range_detail;

    return range_end( r );
}

}






namespace boost
{
    template< class T >
    inline typename range_iterator<const T>::type
    const_end( const T& r )
    {
        return boost::end( r );
    }
}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/functions.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/size.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/size.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/difference_type.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/difference_type.hpp" 3
namespace boost
{
    template< class T >
    struct range_difference : iterator_difference< typename range_iterator<T>::type >
    { };
}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/size.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/size.hpp" 2 3

namespace boost
{

    template< class T >
    inline typename range_difference<T>::type size( const T& r )
    {
        (__builtin_expect(!((boost::end( r ) - boost::begin( r )) >= 0 && "reachability invariant broken!"), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/size.hpp", 30, "(boost::end( r ) - boost::begin( r )) >= 0 && \"reachability invariant broken!\"") : (void)0);

        return boost::end( r ) - boost::begin( r );
    }

}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/functions.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/distance.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/distance.hpp" 3
namespace boost
{

    template< class T >
    inline typename range_difference<T>::type
    distance( const T& r )
    {
        return std::distance( boost::begin( r ), boost::end( r ) );
    }

}
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/functions.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/empty.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/empty.hpp" 3
namespace boost
{

    template< class T >
    inline bool empty( const T& r )
    {
        return boost::begin( r ) == boost::end( r );
    }

}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/functions.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/rbegin.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/rbegin.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/reverse_iterator.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/reverse_iterator.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/reverse_iterator.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/reverse_iterator.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_adaptor.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_adaptor.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_categories.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_categories.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_def.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_categories.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/placeholders.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_categories.hpp" 2 3






namespace boost {





struct no_traversal_tag {};

struct incrementable_traversal_tag
  : no_traversal_tag
{


};

struct single_pass_traversal_tag
  : incrementable_traversal_tag
{


};

struct forward_traversal_tag
  : single_pass_traversal_tag
{


};

struct bidirectional_traversal_tag
  : forward_traversal_tag
{


};

struct random_access_traversal_tag
  : bidirectional_traversal_tag
{


};

namespace detail
{






  template <class Cat>
  struct old_category_to_traversal
    : mpl::eval_if<
          is_convertible<Cat,std::random_access_iterator_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Cat,std::bidirectional_iterator_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Cat,std::forward_iterator_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Cat,std::input_iterator_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Cat,std::output_iterator_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {};
# 108 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_categories.hpp" 3
  template <class Traversal>
  struct pure_traversal_tag
    : mpl::eval_if<
          is_convertible<Traversal,random_access_traversal_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Traversal,bidirectional_traversal_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Traversal,forward_traversal_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Traversal,single_pass_traversal_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Traversal,incrementable_traversal_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {
  };
# 142 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_categories.hpp" 3
}





template <class Cat>
struct iterator_category_to_traversal
  : mpl::eval_if<
        is_convertible<Cat,incrementable_traversal_tag>
      , mpl::identity<Cat>
      , boost::detail::old_category_to_traversal<Cat>
    >
{};


template <class Iterator = mpl::_1>
struct iterator_traversal
  : iterator_category_to_traversal<
        typename boost::detail::iterator_traits<Iterator>::iterator_category
    >
{};
# 184 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_categories.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_undef.hpp" 1 3
# 187 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_categories.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_adaptor.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 1 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/interoperable.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/interoperable.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_def.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/interoperable.hpp" 2 3

namespace boost
{
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/interoperable.hpp" 3
  template <typename A, typename B>
  struct is_interoperable



    : mpl::or_<
          is_convertible< A, B >
        , is_convertible< B, A > >

  {
  };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_undef.hpp" 1 3
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/interoperable.hpp" 2 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/facade_iterator_category.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/facade_iterator_category.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_def.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/indirect_traits.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/indirect_traits.hpp" 3
namespace boost { namespace detail {

namespace indirect_traits {


template <class T>
struct is_reference_to_const : mpl::false_
{
};

template <class T>
struct is_reference_to_const<T const&> : mpl::true_
{
};
# 55 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/indirect_traits.hpp" 3
template <class T>
struct is_reference_to_function : mpl::false_
{
};

template <class T>
struct is_reference_to_function<T&> : is_function<T>
{
};

template <class T>
struct is_pointer_to_function : mpl::false_
{
};



template <class T>
struct is_pointer_to_function<T*> : is_function<T>
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl : mpl::false_
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl<T&>
    : is_member_function_pointer<typename remove_cv<T>::type>
{
};


template <class T>
struct is_reference_to_member_function_pointer
    : is_reference_to_member_function_pointer_impl<T>
{
   
};

template <class T>
struct is_reference_to_function_pointer_aux
    : mpl::and_<
          is_reference<T>
        , is_pointer_to_function<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >
      >
{

};

template <class T>
struct is_reference_to_function_pointer
    : mpl::if_<
          is_reference_to_function<T>
        , mpl::false_
        , is_reference_to_function_pointer_aux<T>
     >::type
{
};

template <class T>
struct is_reference_to_non_const
    : mpl::and_<
          is_reference<T>
        , mpl::not_<
             is_reference_to_const<T>
          >
      >
{
};

template <class T>
struct is_reference_to_volatile : mpl::false_
{
};

template <class T>
struct is_reference_to_volatile<T volatile&> : mpl::true_
{
};
# 149 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/indirect_traits.hpp" 3
template <class T>
struct is_reference_to_pointer : mpl::false_
{
};

template <class T>
struct is_reference_to_pointer<T*&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* const&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* volatile&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* const volatile&> : mpl::true_
{
};

template <class T>
struct is_reference_to_class
    : mpl::and_<
          is_reference<T>
        , is_class<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >
      >
{
   
};

template <class T>
struct is_pointer_to_class
    : mpl::and_<
          is_pointer<T>
        , is_class<
              typename remove_cv<
                  typename remove_pointer<T>::type
              >::type
          >
      >
{
   
};
# 481 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/indirect_traits.hpp" 3
}

using namespace indirect_traits;

}}
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3







namespace boost { struct use_default; }

namespace boost { namespace detail {

struct input_output_iterator_tag
  : std::input_iterator_tag
{






    operator std::output_iterator_tag() const
    {
        return std::output_iterator_tag();
    }
};






template <class ValueParam, class Reference>
struct iterator_writability_disabled

  : mpl::or_<
        is_const<Reference>
      , boost::detail::indirect_traits::is_reference_to_const<Reference>
      , is_const<ValueParam>
    >



{};
# 86 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/facade_iterator_category.hpp" 3
template <class Traversal, class ValueParam, class Reference>
struct iterator_facade_default_category
  : mpl::eval_if<
        mpl::and_<
            is_reference<Reference>
          , is_convertible<Traversal,forward_traversal_tag>
        >
      , mpl::eval_if<
            is_convertible<Traversal,random_access_traversal_tag>
          , mpl::identity<std::random_access_iterator_tag>
          , mpl::if_<
                is_convertible<Traversal,bidirectional_traversal_tag>
              , std::bidirectional_iterator_tag
              , std::forward_iterator_tag
            >
        >
      , typename mpl::eval_if<
            mpl::and_<
                is_convertible<Traversal, single_pass_traversal_tag>


              , is_convertible<Reference, ValueParam>
            >
          , mpl::identity<std::input_iterator_tag>
          , mpl::identity<Traversal>
        >
    >
{
};


template <class T>
struct is_iterator_category
  : mpl::or_<
        is_convertible<T,std::input_iterator_tag>
      , is_convertible<T,std::output_iterator_tag>
    >
{
};

template <class T>
struct is_iterator_traversal
  : is_convertible<T,incrementable_traversal_tag>
{};







template <class Category, class Traversal>
struct iterator_category_with_traversal
  : Category, Traversal
{




    enum { mpl_assertion_in_line_149 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) ( is_convertible< typename iterator_category_to_traversal<Category>::type , Traversal >))0, 1 ) ) ) };





    enum { mpl_assertion_in_line_151 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_category<Category>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_152 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_153 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_traversal<Category>))0, 1 ) ) ) };

    enum { mpl_assertion_in_line_155 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_traversal<Traversal>))0, 1 ) ) ) };


};



template <class Traversal, class ValueParam, class Reference>
struct facade_iterator_category_impl
{

    enum { mpl_assertion_in_line_166 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };


    typedef typename iterator_facade_default_category<
        Traversal,ValueParam,Reference
    >::type category;

    typedef typename mpl::if_<
        is_same<
            Traversal
          , typename iterator_category_to_traversal<category>::type
        >
      , category
      , iterator_category_with_traversal<category,Traversal>
    >::type type;
};




template <class CategoryOrTraversal, class ValueParam, class Reference>
struct facade_iterator_category
  : mpl::eval_if<
        is_iterator_category<CategoryOrTraversal>
      , mpl::identity<CategoryOrTraversal>
      , facade_iterator_category_impl<CategoryOrTraversal,ValueParam,Reference>
    >
{
};

}}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_undef.hpp" 1 3
# 199 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/enable_if.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/enable_if.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/enable_if.hpp" 2 3







namespace boost
{

  namespace iterators
  {



    template<bool>
    struct enabled
    {
      template<typename T>
      struct base
      {
        typedef T type;
      };
    };






    template<>
    struct enabled<false>
    {
      template<typename T>
      struct base
      {
# 62 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/enable_if.hpp" 3
      };
    };


    template <class Cond,
              class Return>
    struct enable_if

      : enabled<(Cond::value)>::template base<Return>



    {



    };

  }

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_undef.hpp" 1 3
# 85 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/enable_if.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/implicit_cast.hpp" 1 3
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/implicit_cast.hpp" 3
namespace boost {






template <typename T>
inline T implicit_cast (typename mpl::identity<T>::type x) {
    return x;
}





}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_const.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_const.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_const.hpp" 2 3

namespace boost {
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_const.hpp" 3
template< typename T > struct add_const { typedef T const type; };






template< typename T > struct add_const<T&> { typedef T& type; };


}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 46 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_const.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_pointer.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_pointer.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_def.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_pointer.hpp" 2 3

namespace boost {

namespace detail {
# 55 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_pointer.hpp" 3
template <typename T>
struct add_pointer_impl
{
    typedef typename remove_reference<T>::type no_ref_type;
    typedef no_ref_type* type;
};



}

template< typename T > struct add_pointer { typedef typename boost::detail::add_pointer_impl<T>::type type; };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3
# 71 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/add_pointer.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 2 3
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/apply.hpp" 1 3
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_def.hpp" 1 3
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 2 3

namespace boost
{


  template <class I, class V, class TC, class R, class D> class iterator_facade;

  namespace detail
  {



    struct always_bool2
    {
        template <class T, class U>
        struct apply
        {
            typedef bool type;
        };
    };




    template <
        class Facade1
      , class Facade2
      , class Return
    >
    struct enable_if_interoperable
# 80 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
      : ::boost::iterators::enable_if<
           mpl::or_<
               is_convertible<Facade1, Facade2>
             , is_convertible<Facade2, Facade1>
           >
         , Return
        >
    {};






    template <
        class ValueParam
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    struct iterator_facade_types
    {
        typedef typename facade_iterator_category<
            CategoryOrTraversal, ValueParam, Reference
        >::type iterator_category;

        typedef typename remove_const<ValueParam>::type value_type;

        typedef typename mpl::eval_if<
            boost::detail::iterator_writability_disabled<ValueParam,Reference>
          , add_pointer<const value_type>
          , add_pointer<value_type>
        >::type pointer;
# 130 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
    };







    template <class Iterator>
    class postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
        {}





        value_type&
        operator*() const
        {
            return this->stored_value;
        }
     private:
        mutable value_type stored_value;
    };





    template <class Iterator>
    class writable_postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit writable_postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
          , stored_iterator(x)
        {}





        writable_postfix_increment_proxy const&
        operator*() const
        {
            return *this;
        }


        operator value_type&() const
        {
            return stored_value;
        }


        template <class T>
        T const& operator=(T const& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        template <class T>
        T& operator=(T& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        operator Iterator const&() const
        {
            return stored_iterator;
        }

     private:
        mutable value_type stored_value;
        Iterator stored_iterator;
    };
# 244 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
    template <class Reference, class Value>
    struct is_non_proxy_reference
      : is_convertible<
            typename remove_reference<Reference>::type
            const volatile*
          , Value const volatile*
        >
    {};
# 269 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
    template <class Iterator, class Value, class Reference, class CategoryOrTraversal>
    struct postfix_increment_result
      : mpl::eval_if<
            mpl::and_<

                is_convertible<Reference,Value const&>



              , mpl::not_<
                    is_convertible<
                        typename iterator_category_to_traversal<CategoryOrTraversal>::type
                      , forward_traversal_tag
                    >
                >
            >
          , mpl::if_<
                is_non_proxy_reference<Reference,Value>
              , postfix_increment_proxy<Iterator>
              , writable_postfix_increment_proxy<Iterator>
            >
          , mpl::identity<Iterator>
        >
    {};





    template <class T>
    struct operator_arrow_proxy
    {
        operator_arrow_proxy(T const* px) : m_value(*px) {}
        T* operator->() const { return &m_value; }


        operator T*() const { return &m_value; }
        mutable T m_value;
    };




    template <class ValueType, class Reference, class Pointer>
    struct operator_arrow_result
    {



        typedef typename mpl::if_<
            is_reference<Reference>
          , Pointer
          , operator_arrow_proxy<ValueType>
        >::type type;

        static type make(Reference x)
        {
            return implicit_cast<type>(&x);
        }
    };
# 342 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
    template <class Iterator>
    class operator_brackets_proxy
    {


        typedef typename Iterator::reference reference;
        typedef typename Iterator::value_type value_type;

     public:
        operator_brackets_proxy(Iterator const& iter)
          : m_iter(iter)
        {}

        operator reference() const
        {
            return *m_iter;
        }

        operator_brackets_proxy& operator=(value_type const& val)
        {
            *m_iter = val;
            return *this;
        }

     private:
        Iterator m_iter;
    };



    template <class ValueType, class Reference>
    struct use_operator_brackets_proxy
      : mpl::not_<
            mpl::and_<


                boost::is_POD<ValueType>
              , iterator_writability_disabled<ValueType,Reference>
            >
        >
    {};

    template <class Iterator, class Value, class Reference>
    struct operator_brackets_result
    {
        typedef typename mpl::if_<
            use_operator_brackets_proxy<Value,Reference>
          , operator_brackets_proxy<Iterator>
          , Value
        >::type type;
    };

    template <class Iterator>
    operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const& iter, mpl::true_)
    {
        return operator_brackets_proxy<Iterator>(iter);
    }

    template <class Iterator>
    typename Iterator::value_type make_operator_brackets_result(Iterator const& iter, mpl::false_)
    {
      return *iter;
    }

    struct choose_difference_type
    {
        template <class I1, class I2>
        struct apply
          :
# 420 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
          mpl::eval_if<
              is_convertible<I2,I1>
            , iterator_difference<I1>
            , iterator_difference<I2>
          >

        {};

    };
  }
# 471 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
  class iterator_core_access
  {







      template <class I, class V, class TC, class R, class D> friend class iterator_facade;




      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);

      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);


      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)

      ;

      template <class Derived, class V, class TC, class R, class D> friend inline Derived operator+ (iterator_facade<Derived, V, TC, R, D> const& , typename Derived::difference_type)




      ;

      template <class Derived, class V, class TC, class R, class D> friend inline Derived operator+ (typename Derived::difference_type , iterator_facade<Derived, V, TC, R, D> const&)




      ;



      template <class Facade>
      static typename Facade::reference dereference(Facade const& f)
      {
          return f.dereference();
      }

      template <class Facade>
      static void increment(Facade& f)
      {
          f.increment();
      }

      template <class Facade>
      static void decrement(Facade& f)
      {
          f.decrement();
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return f1.equal(f2);
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.equal(f1);
      }

      template <class Facade>
      static void advance(Facade& f, typename Facade::difference_type n)
      {
          f.advance(n);
      }

      template <class Facade1, class Facade2>
      static typename Facade1::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return -f1.distance_to(f2);
      }

      template <class Facade1, class Facade2>
      static typename Facade2::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.distance_to(f1);
      }




      template <class I, class V, class TC, class R, class D>
      static I& derived(iterator_facade<I,V,TC,R,D>& facade)
      {
          return *static_cast<I*>(&facade);
      }

      template <class I, class V, class TC, class R, class D>
      static I const& derived(iterator_facade<I,V,TC,R,D> const& facade)
      {
          return *static_cast<I const*>(&facade);
      }

   private:

      iterator_core_access();
  };





  template <
      class Derived
    , class Value
    , class CategoryOrTraversal
    , class Reference = Value&
    , class Difference = std::ptrdiff_t
  >
  class iterator_facade






  {
   private:



      Derived& derived()
      {
          return *static_cast<Derived*>(this);
      }

      Derived const& derived() const
      {
          return *static_cast<Derived const*>(this);
      }

      typedef boost::detail::iterator_facade_types<
         Value, CategoryOrTraversal, Reference, Difference
      > associated_types;

   protected:

      typedef iterator_facade<Derived,Value,CategoryOrTraversal,Reference,Difference> iterator_facade_;

   public:

      typedef typename associated_types::value_type value_type;
      typedef Reference reference;
      typedef Difference difference_type;
      typedef typename associated_types::pointer pointer;
      typedef typename associated_types::iterator_category iterator_category;

      reference operator*() const
      {
          return iterator_core_access::dereference(this->derived());
      }

      typename boost::detail::operator_arrow_result<
          value_type
        , reference
        , pointer
      >::type
      operator->() const
      {
          return boost::detail::operator_arrow_result<
              value_type
            , reference
            , pointer
          >::make(*this->derived());
      }

      typename boost::detail::operator_brackets_result<Derived,Value,reference>::type
      operator[](difference_type n) const
      {
          typedef boost::detail::use_operator_brackets_proxy<Value,Reference> use_proxy;

          return boost::detail::make_operator_brackets_result<Derived>(
              this->derived() + n
            , use_proxy()
          );
      }

      Derived& operator++()
      {
          iterator_core_access::increment(this->derived());
          return this->derived();
      }
# 680 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
      Derived& operator--()
      {
          iterator_core_access::decrement(this->derived());
          return this->derived();
      }

      Derived operator--(int)
      {
          Derived tmp(this->derived());
          --*this;
          return tmp;
      }

      Derived& operator+=(difference_type n)
      {
          iterator_core_access::advance(this->derived(), n);
          return this->derived();
      }

      Derived& operator-=(difference_type n)
      {
          iterator_core_access::advance(this->derived(), -n);
          return this->derived();
      }

      Derived operator-(difference_type x) const
      {
          Derived result(this->derived());
          return result -= x;
      }
# 722 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
  };


  template <class I, class V, class TC, class R, class D>
  inline typename boost::detail::postfix_increment_result<I,V,R,TC>::type
  operator++(
      iterator_facade<I,V,TC,R,D>& i
    , int
  )
  {
      typename boost::detail::postfix_increment_result<I,V,R,TC>::type
          tmp(*static_cast<I*>(&i));

      ++i;

      return tmp;
  }
# 837 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_837; return iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_838; return ! iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }

  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_840; return 0 > iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_841; return 0 < iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_842; return 0 >= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_843; return 0 <= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }



  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( is_interoperable< Derived1, Derived2 >::value )) == 0 ? false : true) >)> boost_static_assert_typedef_852; return iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
# 863 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 3
template <class Derived, class V, class TC, class R, class D> inline Derived operator+ ( iterator_facade<Derived, V, TC, R, D> const& i , typename Derived::difference_type n ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }




template <class Derived, class V, class TC, class R, class D> inline Derived operator+ ( typename Derived::difference_type n , iterator_facade<Derived, V, TC, R, D> const& i ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }






}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_undef.hpp" 1 3
# 878 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_facade.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_adaptor.hpp" 2 3
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_adaptor.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_def.hpp" 1 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_adaptor.hpp" 2 3



namespace boost
{



  struct use_default;





  template<class To>
  struct is_convertible<use_default,To>
    : mpl::false_ {};


  namespace detail
  {
# 61 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_adaptor.hpp" 3
    struct enable_type;
  }
# 143 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_adaptor.hpp" 3
  template<typename From, typename To>
  struct enable_if_convertible
    : iterators::enable_if<
          is_convertible<From, To>
        , boost::detail::enable_type
      >
  {};






  namespace detail
  {


    template <class T, class DefaultNullaryFn>
    struct ia_dflt_help
      : mpl::eval_if<
            is_same<T, use_default>
          , DefaultNullaryFn
          , mpl::identity<T>
        >
    {
    };



    template <
        class Derived
      , class Base
      , class Value
      , class Traversal
      , class Reference
      , class Difference
    >
    struct iterator_adaptor_base
    {
        typedef iterator_facade<
            Derived


          , typename boost::detail::ia_dflt_help<
                Value
              , mpl::eval_if<
                    is_same<Reference,use_default>
                  , iterator_value<Base>
                  , remove_reference<Reference>
                >
            >::type






          , typename boost::detail::ia_dflt_help<
                Traversal
              , iterator_traversal<Base>
            >::type

          , typename boost::detail::ia_dflt_help<
                Reference
              , mpl::eval_if<
                    is_same<Value,use_default>
                  , iterator_reference<Base>
                  , add_reference<Value>
                >
            >::type

          , typename boost::detail::ia_dflt_help<
                Difference, iterator_difference<Base>
            >::type
        >
        type;
    };


    template <class Tr1, class Tr2>
    inline void iterator_adaptor_assert_traversal ()
    {
      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((is_convertible<Tr1, Tr2>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_225;
    }
  }
# 254 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_adaptor.hpp" 3
  template <
      class Derived
    , class Base
    , class Value = use_default
    , class Traversal = use_default
    , class Reference = use_default
    , class Difference = use_default
  >
  class iterator_adaptor
    : public boost::detail::iterator_adaptor_base<
        Derived, Base, Value, Traversal, Reference, Difference
      >::type
  {
      friend class iterator_core_access;

   protected:
      typedef typename boost::detail::iterator_adaptor_base<
          Derived, Base, Value, Traversal, Reference, Difference
      >::type super_t;
   public:
      iterator_adaptor() {}

      explicit iterator_adaptor(Base const &iter)
          : m_iterator(iter)
      {
      }

      typedef Base base_type;

      Base const& base() const
        { return m_iterator; }

   protected:

      typedef iterator_adaptor<Derived,Base,Value,Traversal,Reference,Difference> iterator_adaptor_;




      Base const& base_reference() const
        { return m_iterator; }

      Base& base_reference()
        { return m_iterator; }

   private:






      typename super_t::reference dereference() const
        { return *m_iterator; }

      template <
      class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const
      {




          return m_iterator == x.base();
      }

      typedef typename iterator_category_to_traversal<
          typename super_t::iterator_category
      >::type my_traversal;




      void advance(typename super_t::difference_type n)
      {
          boost::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
          m_iterator += n;
      }

      void increment() { ++m_iterator; }

      void decrement()
      {
          boost::detail::iterator_adaptor_assert_traversal<my_traversal, bidirectional_traversal_tag>();
           --m_iterator;
      }

      template <
          class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      typename super_t::difference_type distance_to(
          iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const
      {
          boost::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();




          return y.base() - m_iterator;
      }



   private:
      Base m_iterator;
  };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_undef.hpp" 1 3
# 365 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/iterator_adaptor.hpp" 2 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/reverse_iterator.hpp" 2 3

namespace boost
{




  template <class Iterator>
  class reverse_iterator
      : public iterator_adaptor< reverse_iterator<Iterator>, Iterator >
  {
      typedef iterator_adaptor< reverse_iterator<Iterator>, Iterator > super_t;

      friend class iterator_core_access;

   public:
      reverse_iterator() {}

      explicit reverse_iterator(Iterator x)
          : super_t(x) {}

      template<class OtherIterator>
      reverse_iterator(
          reverse_iterator<OtherIterator> const& r
          , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0
          )
          : super_t(r.base())
      {}

   private:
      typename super_t::reference dereference() const { return *boost::prior(this->base()); }

      void increment() { --this->base_reference(); }
      void decrement() { ++this->base_reference(); }

      void advance(typename super_t::difference_type n)
      {
          this->base_reference() += -n;
      }

      template <class OtherIterator>
      typename super_t::difference_type
      distance_to(reverse_iterator<OtherIterator> const& y) const
      {
          return this->base_reference() - y.base();
      }
  };

  template <class BidirectionalIterator>
  reverse_iterator<BidirectionalIterator> make_reverse_iterator(BidirectionalIterator x)
  {
      return reverse_iterator<BidirectionalIterator>(x);
  }

}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/reverse_iterator.hpp" 2 3


namespace boost
{




    template< typename C >
    struct range_reverse_iterator
    {
        typedef reverse_iterator<
            typename range_iterator<C>::type > type;
    };


}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/rbegin.hpp" 2 3

namespace boost
{
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/rbegin.hpp" 3
template< class C >
inline typename range_reverse_iterator<C>::type
rbegin( C& c )
{
    typedef typename range_reverse_iterator<C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}

template< class C >
inline typename range_reverse_iterator<const C>::type
rbegin( const C& c )
{
    typedef typename range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}



template< class T >
inline typename range_reverse_iterator<const T>::type
const_rbegin( const T& r )
{
    return boost::rbegin( r );
}

}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/functions.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/rend.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/rend.hpp" 3
namespace boost
{
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/rend.hpp" 3
template< class C >
inline typename range_reverse_iterator<C>::type
rend( C& c )
{
    typedef typename range_reverse_iterator<C>::type
               iter_type;
    return iter_type( boost::begin( c ) );
}

template< class C >
inline typename range_reverse_iterator<const C>::type
rend( const C& c )
{
    typedef typename range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::begin( c ) );
}



template< class T >
inline typename range_reverse_iterator<const T>::type
const_rend( const T& r )
{
    return boost::rend( r );
}

}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/functions.hpp" 2 3
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 2 3
# 56 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 3
namespace boost
{
    namespace iterator_range_detail
    {




        template<typename IteratorT>
        struct iterator_range_impl {
            template< class ForwardRange >
            static IteratorT adl_begin( ForwardRange& r )
            {
                return IteratorT( boost::begin( r ) );
            }

            template< class ForwardRange >
            static IteratorT adl_end( ForwardRange& r )
            {
                return IteratorT( boost::end( r ) );
            }
        };

        template< class Left, class Right >
        inline bool equal( const Left& l, const Right& r )
        {
            typedef typename boost::range_difference<Left>::type sz_type;

            sz_type l_size = boost::distance( l ),
                    r_size = boost::distance( r );

            if( l_size != r_size )
                return false;

            return std::equal( boost::begin(l), boost::end(l),
                               boost::begin(r) );
        }

        template< class Left, class Right >
        inline bool less_than( const Left& l, const Right& r )
        {
            return std::lexicographical_compare( boost::begin(l),
                                                 boost::end(l),
                                                 boost::begin(r),
                                                 boost::end(r) );
        }

        struct range_tag { };
        struct const_range_tag { };

    }
# 127 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 3
        template<typename IteratorT>
        class iterator_range
        {
        protected:

            typedef iterator_range_detail::iterator_range_impl<IteratorT> impl;
        public:


            typedef iterator_range<IteratorT> type;



            typedef typename
                iterator_value<IteratorT>::type value_type;


            typedef typename
                iterator_difference<IteratorT>::type difference_type;


            typedef std::size_t size_type;


            typedef iterator_range<IteratorT> this_type;






            typedef typename
                iterator_reference<IteratorT>::type reference;






            typedef IteratorT const_iterator;

            typedef IteratorT iterator;

        private:
            typedef typename
                boost::mpl::if_< boost::is_abstract<value_type>,
                                 reference, value_type >::type abstract_value_type;

        public:
            iterator_range() : m_Begin( iterator() ), m_End( iterator() )

            , singular( true )

            { }


            template< class Iterator >
            iterator_range( Iterator Begin, Iterator End ) :
                m_Begin(Begin), m_End(End)

            , singular(false)

            {}


            template< class Range >
            iterator_range( const Range& r ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )

            , singular(false)

            {}


            template< class Range >
            iterator_range( Range& r ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )

            , singular(false)

            {}


            template< class Range >
            iterator_range( const Range& r, iterator_range_detail::const_range_tag ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )

            , singular(false)

            {}


            template< class Range >
            iterator_range( Range& r, iterator_range_detail::range_tag ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )

            , singular(false)

            {}


            this_type& operator=( const this_type& r )
            {
                m_Begin = r.begin();
                m_End = r.end();


                singular = r.singular;

                return *this;
            }


            template< class Iterator >
            iterator_range& operator=( const iterator_range<Iterator>& r )
            {
                m_Begin = r.begin();
                m_End = r.end();

                singular = r.is_singular();

                return *this;
            }

            template< class ForwardRange >
            iterator_range& operator=( ForwardRange& r )
            {
                m_Begin = impl::adl_begin( r );
                m_End = impl::adl_end( r );

                singular = false;

                return *this;
            }

            template< class ForwardRange >
            iterator_range& operator=( const ForwardRange& r )
            {
                m_Begin = impl::adl_begin( r );
                m_End = impl::adl_end( r );

                singular = false;

                return *this;
            }

            IteratorT begin() const
            {
                (__builtin_expect(!(!is_singular()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp", 275, "!is_singular()") : (void)0);
                return m_Begin;
            }

            IteratorT end() const
            {
                (__builtin_expect(!(!is_singular()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp", 281, "!is_singular()") : (void)0);
                return m_End;
            }

            difference_type size() const
            {
                (__builtin_expect(!(!is_singular()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp", 287, "!is_singular()") : (void)0);
                return m_End - m_Begin;
            }

            bool empty() const
            {
                (__builtin_expect(!(!is_singular()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp", 293, "!is_singular()") : (void)0);
                return m_Begin == m_End;
            }







            typedef iterator (iterator_range::*unspecified_bool_type) () const;
            operator unspecified_bool_type() const
            {
                return empty() ? 0: &iterator_range::end;
            }


            bool equal( const iterator_range& r ) const
            {
                (__builtin_expect(!(!is_singular()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp", 312, "!is_singular()") : (void)0);
                return m_Begin == r.m_Begin && m_End == r.m_End;
            }
# 339 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 3
        public:
           reference front() const
           {
               (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp", 342, "!empty()") : (void)0);
               return *m_Begin;
           }

           reference back() const
           {
               (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp", 348, "!empty()") : (void)0);
               IteratorT last( m_End );
               return *--last;
           }

           reference operator[]( difference_type at ) const
           {
               (__builtin_expect(!(at >= 0 && at < size()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp", 355, "at >= 0 && at < size()") : (void)0);
               return m_Begin[at];
           }






           abstract_value_type operator()( difference_type at ) const
           {
               (__builtin_expect(!(at >= 0 && at < size()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp", 366, "at >= 0 && at < size()") : (void)0);
               return m_Begin[at];
           }

           iterator_range& advance_begin( difference_type n )
           {
               (__builtin_expect(!(!is_singular()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp", 372, "!is_singular()") : (void)0);
               std::advance( m_Begin, n );
               return *this;
           }

           iterator_range& advance_end( difference_type n )
           {
               (__builtin_expect(!(!is_singular()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp", 379, "!is_singular()") : (void)0);
               std::advance( m_End, n );
               return *this;
           }

        private:

            IteratorT m_Begin;
            IteratorT m_End;


            bool singular;


        public:
            bool is_singular() const
            {

                 return singular;



            }

        protected:




            typedef iterator_range iterator_range_;
        };
# 421 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 3
        template< typename IteratorT, typename Elem, typename Traits >
        inline std::basic_ostream<Elem,Traits>& operator<<(
                    std::basic_ostream<Elem, Traits>& Os,
                    const iterator_range<IteratorT>& r )
        {
            std::copy( r.begin(), r.end(),
                       std::ostream_iterator< typename
                                              iterator_value<IteratorT>::type,
                                              Elem, Traits>(Os) );
            return Os;
        }
# 456 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 3
        template< class IteratorT, class ForwardRange >
        inline bool operator==( const ForwardRange& l,
                                const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline bool operator!=( const ForwardRange& l,
                                const iterator_range<IteratorT>& r )
        {
            return !iterator_range_detail::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline bool operator<( const ForwardRange& l,
                               const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }



        template< class Iterator1T, class Iterator2T >
        inline bool operator==( const iterator_range<Iterator1T>& l,
                                const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline bool operator==( const iterator_range<IteratorT>& l,
                                const ForwardRange& r )
        {
            return iterator_range_detail::equal( l, r );
        }


        template< class Iterator1T, class Iterator2T >
        inline bool operator!=( const iterator_range<Iterator1T>& l,
                                const iterator_range<Iterator2T>& r )
        {
            return !iterator_range_detail::equal( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline bool operator!=( const iterator_range<IteratorT>& l,
                                const ForwardRange& r )
        {
            return !iterator_range_detail::equal( l, r );
        }


        template< class Iterator1T, class Iterator2T >
        inline bool operator<( const iterator_range<Iterator1T>& l,
                               const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }

        template< class IteratorT, class ForwardRange >
        inline bool operator<( const iterator_range<IteratorT>& l,
                               const ForwardRange& r )
        {
            return iterator_range_detail::less_than( l, r );
        }
# 535 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 3
        template< typename IteratorT >
        inline iterator_range< IteratorT >
        make_iterator_range( IteratorT Begin, IteratorT End )
        {
            return iterator_range<IteratorT>( Begin, End );
        }
# 558 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 3
        template< class ForwardRange >
        inline iterator_range< typename range_iterator<ForwardRange>::type >
        make_iterator_range( ForwardRange& r )
        {
           return iterator_range< typename range_iterator<ForwardRange>::type >
                ( r, iterator_range_detail::range_tag() );
        }

        template< class ForwardRange >
        inline iterator_range< typename range_iterator<const ForwardRange>::type >
        make_iterator_range( const ForwardRange& r )
        {
           return iterator_range< typename range_iterator<const ForwardRange>::type >
                ( r, iterator_range_detail::const_range_tag() );
        }



        namespace iterator_range_detail
        {
            template< class Range >
            inline iterator_range< typename range_iterator<Range>::type >
            make_range_impl( Range& r,
                             typename range_difference<Range>::type advance_begin,
                             typename range_difference<Range>::type advance_end )
            {







                typename range_iterator<Range>::type
                    new_begin = boost::begin( r ),
                    new_end = boost::end( r );
                std::advance( new_begin, advance_begin );
                std::advance( new_end, advance_end );
                return make_iterator_range( new_begin, new_end );
            }
        }
# 614 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 3
        template< class Range >
        inline iterator_range< typename range_iterator<Range>::type >
        make_iterator_range( Range& r,
                    typename range_difference<Range>::type advance_begin,
                    typename range_difference<Range>::type advance_end )
        {

            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }

        template< class Range >
        inline iterator_range< typename range_iterator<const Range>::type >
        make_iterator_range( const Range& r,
                    typename range_difference<Range>::type advance_begin,
                    typename range_difference<Range>::type advance_end )
        {

            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }
# 644 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/iterator_range.hpp" 3
        template< typename SeqT, typename Range >
        inline SeqT copy_range( const Range& r )
        {
            return SeqT( boost::begin( r ), boost::end( r ) );
        }

}
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_format.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_format.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/deque" 1 3
# 63 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/deque" 3
       
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/deque" 3






# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 1 3
# 68 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
namespace std
{
# 82 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
  inline size_t
  __deque_buf_size(size_t __size)
  { return __size < 512 ? size_t(512 / __size) : size_t(1); }
# 100 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;

      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) {}

      _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}

      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) {}

      reference
      operator*() const
      { return *_M_cur; }

      pointer
      operator->() const
      { return _M_cur; }

      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }







      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }





  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }
# 353 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return *static_cast<const _Alloc*>(&this->_M_impl); }

      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }

      ~_Deque_base();

    protected:



      struct _Deque_impl
      : public _Alloc
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl(const _Alloc& __a)
 : _Alloc(__a), _M_map(0), _M_map_size(0), _M_start(), _M_finish()
 { }
      };

      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;
      _Map_alloc_type _M_get_map_allocator() const
      { return _Map_alloc_type(this->get_allocator()); }

      _Tp*
      _M_allocate_node()
      { return _M_impl._Alloc::allocate(__deque_buf_size(sizeof(_Tp))); }

      void
      _M_deallocate_node(_Tp* __p)
      { _M_impl._Alloc::deallocate(__p, __deque_buf_size(sizeof(_Tp))); }

      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }

      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 444 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 594 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

     

      typedef _Deque_base<_Tp, _Alloc> _Base;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef typename _Base::allocator_type allocator_type;

    protected:
      typedef pointer* _Map_pointer;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;






      using _Base::_M_impl;

    public:





      explicit
      deque(const allocator_type& __a = allocator_type())
      : _Base(__a, 0) {}
# 655 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      deque(size_type __n, const value_type& __value,
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 667 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      explicit
      deque(size_type __n)
      : _Base(allocator_type(), __n)
      { _M_fill_initialize(value_type()); }
# 679 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(__x.get_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        this->get_allocator()); }
# 699 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }






      ~deque()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        this->get_allocator()); }
# 725 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 738 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 754 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const
      { return this->_M_impl._M_start; }






      iterator
      end()
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend() { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }



      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const
      { return size_type(-1); }
# 859 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 const size_type __len = size();
 if (__new_size < __len)
   erase(this->_M_impl._M_start + __new_size, this->_M_impl._M_finish);
 else
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
      }
# 878 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      void
      resize(size_type new_size)
      { resize(new_size, value_type()); }





      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 902 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
# 917 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }

    public:
# 942 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 960 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1017 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }
# 1038 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }
# 1059 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1080 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1102 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      iterator
      insert(iterator position, const value_type& __x);
# 1114 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1128 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1151 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      iterator
      erase(iterator __position);
# 1170 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1182 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      void
      swap(deque& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);
      }







      void clear();

    protected:



      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(__n);
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
# 1236 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       forward_iterator_tag);
# 1260 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);





      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     erase(std::copy(__first, __last, begin()), end());
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     erase(begin() + __n, end());
     std::fill(begin(), end(), __val);
   }
      }







      void _M_push_back_aux(const value_type&);
      void _M_push_front_aux(const value_type&);
      void _M_pop_back_aux();
      void _M_pop_front_aux();






      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__x));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename iterator_traits<_InputIterator>::iterator_category
     _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


      iterator
      _M_insert_aux(iterator __pos, const value_type& __x);


      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);
# 1404 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 1442 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back (size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front (size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);

    };
# 1474 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 1492 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return lexicographical_compare(__x.begin(), __x.end(),
         __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }
}
# 71 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/deque" 2 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/deque.tcc" 1 3
# 64 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/bits/deque.tcc" 3
namespace std
{
  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     erase(std::copy(__x.begin(), __x.end(), this->_M_impl._M_start),
    this->_M_impl._M_finish);
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator position, const value_type& __x)
    {
      if (position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(position, __x);
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const size_type __index = __position - this->_M_impl._M_start;
      if (__index < (size() >> 1))
 {
   std::copy_backward(this->_M_impl._M_start, __position, __next);
   pop_front();
 }
      else
 {
   std::copy(__next, this->_M_impl._M_finish, __position);
   pop_back();
 }
      return this->_M_impl._M_start + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == this->_M_impl._M_start
   && __last == this->_M_impl._M_finish)
 {
   clear();
   return this->_M_impl._M_finish;
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = (__first
        - this->_M_impl._M_start);
   if (static_cast<size_type>(__elems_before) < (size() - __n) / 2)
     {
       std::copy_backward(this->_M_impl._M_start, __first, __last);
       iterator __new_start = this->_M_impl._M_start + __n;
       std::_Destroy(this->_M_impl._M_start, __new_start,
       this->get_allocator());
       _M_destroy_nodes(this->_M_impl._M_start._M_node,
          __new_start._M_node);
       this->_M_impl._M_start = __new_start;
     }
   else
     {
       std::copy(__last, this->_M_impl._M_finish, __first);
       iterator __new_finish = this->_M_impl._M_finish - __n;
       std::_Destroy(__new_finish, this->_M_impl._M_finish,
       this->get_allocator());
       _M_destroy_nodes(__new_finish._M_node + 1,
          this->_M_impl._M_finish._M_node + 1);
       this->_M_impl._M_finish = __new_finish;
     }
   return this->_M_impl._M_start + __elems_before;
 }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    clear()
    {
      for (_Map_pointer __node = this->_M_impl._M_start._M_node + 1;
           __node < this->_M_impl._M_finish._M_node;
           ++__node)
 {
   std::_Destroy(*__node, *__node + _S_buffer_size(),
   this->get_allocator());
   _M_deallocate_node(*__node);
 }

      if (this->_M_impl._M_start._M_node != this->_M_impl._M_finish._M_node)
 {
   std::_Destroy(this->_M_impl._M_start._M_cur,
   this->_M_impl._M_start._M_last,
   this->get_allocator());
   std::_Destroy(this->_M_impl._M_finish._M_first,
   this->_M_impl._M_finish._M_cur,
   this->get_allocator());
   _M_deallocate_node(this->_M_impl._M_finish._M_first);
 }
      else
        std::_Destroy(this->_M_impl._M_start._M_cur,
        this->_M_impl._M_finish._M_cur,
        this->get_allocator());

      this->_M_impl._M_finish = this->_M_impl._M_start;
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>
      ::_M_assign_aux(_InputIterator __first, _InputIterator __last,
        input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          erase(__cur, end());
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x,
       this->get_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       this->get_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, this->get_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, this->get_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   this->get_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
            {
              _ForwardIterator __mid = __first;
              std::advance(__mid, _S_buffer_size());
              std::__uninitialized_copy_a(__first, __mid, *__cur_node,
       this->get_allocator());
              __first = __mid;
            }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     this->get_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     this->get_allocator());
            throw;
          }
      }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_push_back_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_back();
      *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
      try
        {
          this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t_copy);
          this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
           + 1);
          this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
        }
      catch(...)
        {
          _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_push_front_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_front();
      *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
      try
        {
          this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
          - 1);
          this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
          this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t_copy);
        }
      catch(...)
        {
          ++this->_M_impl._M_start;
          _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         this->get_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         this->get_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, const value_type& __x)
    {
      difference_type __index = __pos - this->_M_impl._M_start;
      value_type __x_copy = __x;
      if (static_cast<size_type>(__index) < size() / 2)
 {
   push_front(front());
   iterator __front1 = this->_M_impl._M_start;
   ++__front1;
   iterator __front2 = __front1;
   ++__front2;
   __pos = this->_M_impl._M_start + __index;
   iterator __pos1 = __pos;
   ++__pos1;
   std::copy(__front2, __pos1, __front1);
 }
      else
 {
   push_back(back());
   iterator __back1 = this->_M_impl._M_finish;
   --__back1;
   iterator __back2 = __back1;
   --__back2;
   __pos = this->_M_impl._M_start + __index;
   std::copy_backward(__pos, __back2, __back1);
 }
      *__pos = __x_copy;
      return __pos;
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_copy_a(this->_M_impl._M_start,
           __start_n, __new_start,
           this->get_allocator());
    this->_M_impl._M_start = __new_start;
    std::copy(__start_n, __pos, __old_start);
    fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_copy_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       this->get_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_copy_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           this->get_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_copy(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       this->get_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_copy_a(this->_M_impl._M_start,
      __start_n, __new_start,
      this->get_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_copy_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         this->get_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_copy_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           this->get_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_copy(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       this->get_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      const size_type __new_nodes
 = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      const size_type __new_nodes
 = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }
}
# 74 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/deque" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_format.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/as_literal.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/as_literal.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/str_types.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/str_types.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/size_type.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/size_type.hpp" 3
namespace boost
{
    namespace detail
    {





        template< typename C >
        struct range_size
        {
            typedef typename C::size_type type;
        };





        template< typename Iterator >
        struct range_size< std::pair<Iterator,Iterator> >
        {
            typedef std::size_t type;
        };





        template< typename T, std::size_t sz >
        struct range_size< T[sz] >
        {
            typedef std::size_t type;
        };
    }

    template< class T >
    struct range_size :
        detail::range_size<T>
    { };

    template< class T >
    struct range_size<const T > : range_size<T>
    { };

}
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/detail/str_types.hpp" 2 3


namespace boost
{
    template< class T >
    struct range_mutable_iterator<T*>
    {
        typedef T* type;
    };

    template< class T >
    struct range_const_iterator<T*>
    {
        typedef const T* type;
    };

    template< class T >
    struct range_size<T*>
    {
       typedef std::size_t type;
    };
}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/as_literal.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/as_literal.hpp" 3
namespace boost
{
    namespace range_detail
    {
        inline std::size_t length( const char* s )
        {
            return strlen( s );
        }


        inline std::size_t length( const wchar_t* s )
        {
            return wcslen( s );
        }
# 54 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/as_literal.hpp" 3
        inline bool is_char_ptr( char* )
        {
            return true;
        }

        inline bool is_char_ptr( const char* )
        {
            return true;
        }


        inline bool is_char_ptr( wchar_t* )
        {
            return true;
        }

        inline bool is_char_ptr( const wchar_t* )
        {
            return true;
        }


        template< class T >
        inline long is_char_ptr( T )
        {
            return 0L;
        }

        template< class T >
        inline iterator_range<T*>
        make_range( T* const r, bool )
        {
            return iterator_range<T*>( r, r + length(r) );
        }

        template< class T >
        inline iterator_range<typename range_iterator<T>::type>
        make_range( T& r, long )
        {
            return boost::make_iterator_range( r );
        }

    }

    template< class Range >
    inline iterator_range<typename range_iterator<Range>::type>
    as_literal( Range& r )
    {
        return range_detail::make_range( r, range_detail::is_char_ptr(r) );
    }

    template< class Range >
    inline iterator_range<typename range_iterator<const Range>::type>
    as_literal( const Range& r )
    {
        return range_detail::make_range( r, range_detail::is_char_ptr(r) );
    }

    template< class Char, std::size_t sz >
    inline iterator_range<Char*> as_literal( Char (&arr)[sz] )
    {
        return range_detail::make_range( arr, range_detail::is_char_ptr(arr) );
    }

    template< class Char, std::size_t sz >
    inline iterator_range<const Char*> as_literal( const Char (&arr)[sz] )
    {
        return range_detail::make_range( arr, range_detail::is_char_ptr(arr) );
    }
}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_format.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/concept.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/concept.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept_check.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept_check.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/assert.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/detail/general.hpp" 1 3
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/detail/general.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/detail/has_constraints.hpp" 1 3
# 9 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/detail/has_constraints.hpp" 3
namespace boost { namespace concept {

namespace detail
{



  typedef char yes;
  typedef char (&no)[2];

  template <class Model, void (Model::*)()>
  struct wrap_constraints {};
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/detail/has_constraints.hpp" 3
  template <class Model>
  inline yes has_constraints_(Model*, wrap_constraints<Model,&Model::constraints>* = 0);
  inline no has_constraints_(...);

}



template <class Model>
struct not_satisfied
{
    static const bool value = sizeof( detail::has_constraints_((Model*)0) ) == sizeof(detail::yes);


    typedef mpl::bool_<value> type;
};

}}
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/detail/general.hpp" 2 3





namespace boost { namespace concept {

template <class ModelFn>
struct requirement_;

namespace detail
{
  template <void(*)()> struct instantiate {};
}

template <class Model>
struct requirement
{
    static void failed() { ((Model*)0)->~Model(); }
};



template <class Model>
struct constraint
{
    static void failed() { ((Model*)0)->constraints(); }
};

template <class Model>
struct requirement_<void(*)(Model)>
  : mpl::if_<
        concept::not_satisfied<Model>
      , constraint<Model>
      , requirement<Model>
    >::type
{};
# 64 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/detail/general.hpp" 3
}}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/assert.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept_check.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/conversion_traits.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept_check.hpp" 2 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept_check.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/usage.hpp" 1 3
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/usage.hpp" 3
namespace boost { namespace concept {







template <class Model>
struct usage_requirements
{
    ~usage_requirements() { ((Model*)0)->~Model(); }
};
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/usage.hpp" 3
}}
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept_check.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/detail/concept_def.hpp" 1 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/seq/for_each_i.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/seq/for_each_i.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/seq/seq.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/seq/seq.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/seq/elem.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/seq/seq.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/seq/for_each_i.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/seq/size.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/seq/for_each_i.hpp" 2 3
# 7 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/detail/concept_def.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/seq/enum.hpp" 1 3
# 8 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/detail/concept_def.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept_check.hpp" 2 3

namespace boost
{





  template <class Model>
  inline void function_requires(Model* = 0)
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Model)>::failed> boost_concept_check43;
  }
  template <class T> inline void ignore_unused_variable_warning(T const&) {}
# 63 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept_check.hpp" 3
  template < typename T > struct Integer; template < typename T > struct IntegerConcept : Integer< T > { }; template < typename T > struct Integer
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Integer>)>::failed> boost_concept_check65; ~Integer()
        {
            x.error_type_must_be_an_integer_type();
        }
   private:
      T x;
  };

  template <> struct Integer<signed char> {};
  template <> struct Integer<unsigned char> {};
  template <> struct Integer<short> {};
  template <> struct Integer<unsigned short> {};
  template <> struct Integer<int> {};
  template <> struct Integer<unsigned int> {};
  template <> struct Integer<long> {};
  template <> struct Integer<unsigned long> {};

  template <> struct Integer< ::boost::long_long_type> {};
  template <> struct Integer< ::boost::ulong_long_type> {};





  template < typename T > struct SignedInteger; template < typename T > struct SignedIntegerConcept : SignedInteger< T > { }; template < typename T > struct SignedInteger {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<SignedInteger>)>::failed> boost_concept_check90; ~SignedInteger() {
      x.error_type_must_be_a_signed_integer_type();
    }
   private:
    T x;
  };
  template <> struct SignedInteger<signed char> { };
  template <> struct SignedInteger<short> {};
  template <> struct SignedInteger<int> {};
  template <> struct SignedInteger<long> {};

  template <> struct SignedInteger< ::boost::long_long_type> {};




  template < typename T > struct UnsignedInteger; template < typename T > struct UnsignedIntegerConcept : UnsignedInteger< T > { }; template < typename T > struct UnsignedInteger {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<UnsignedInteger>)>::failed> boost_concept_check107; ~UnsignedInteger() {
      x.error_type_must_be_an_unsigned_integer_type();
    }
   private:
    T x;
  };

  template <> struct UnsignedInteger<unsigned char> {};
  template <> struct UnsignedInteger<unsigned short> {};
  template <> struct UnsignedInteger<unsigned int> {};
  template <> struct UnsignedInteger<unsigned long> {};

  template <> struct UnsignedInteger< ::boost::ulong_long_type> {};







  template < typename TT > struct DefaultConstructible; template < typename TT > struct DefaultConstructibleConcept : DefaultConstructible< TT > { }; template < typename TT > struct DefaultConstructible
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<DefaultConstructible>)>::failed> boost_concept_check129; ~DefaultConstructible() {
      TT a;
      ignore_unused_variable_warning(a);
    }
  };

  template < typename TT > struct Assignable; template < typename TT > struct AssignableConcept : Assignable< TT > { }; template < typename TT > struct Assignable
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Assignable>)>::failed> boost_concept_check137; ~Assignable() {

      a = a;

      const_constraints(a);
    }
   private:
    void const_constraints(const TT& b) {

      a = b;

    }
   private:
    TT a;
  };


  template < typename TT > struct CopyConstructible; template < typename TT > struct CopyConstructibleConcept : CopyConstructible< TT > { }; template < typename TT > struct CopyConstructible
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<CopyConstructible>)>::failed> boost_concept_check156; ~CopyConstructible() {
      TT a(b);
      TT* ptr = &a;
      const_constraints(a);
      ignore_unused_variable_warning(ptr);
    }
   private:
    void const_constraints(const TT& a) {
      TT c(a);
      const TT* ptr = &a;
      ignore_unused_variable_warning(c);
      ignore_unused_variable_warning(ptr);
    }
    TT b;
  };


  template < typename TT > struct SGIAssignable; template < typename TT > struct SGIAssignableConcept : SGIAssignable< TT > { }; template < typename TT > struct SGIAssignable
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<SGIAssignable>)>::failed> boost_concept_check175; ~SGIAssignable() {
      TT b(a);

      a = a;

      const_constraints(a);
      ignore_unused_variable_warning(b);
    }
   private:
    void const_constraints(const TT& b) {
      TT c(b);

      a = b;

      ignore_unused_variable_warning(c);
    }
    TT a;
  };

  template < typename X , typename Y > struct Convertible; template < typename X , typename Y > struct ConvertibleConcept : Convertible< X, Y > { }; template < typename X , typename Y > struct Convertible
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Convertible>)>::failed> boost_concept_check196; ~Convertible() {
      Y y = x;
      ignore_unused_variable_warning(y);
    }
   private:
    X x;
  };
# 213 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept_check.hpp" 3
  template <class TT>
  void require_boolean_expr(const TT& t) {
    bool x = t;
    ignore_unused_variable_warning(x);
  }

  template < typename TT > struct EqualityComparable; template < typename TT > struct EqualityComparableConcept : EqualityComparable< TT > { }; template < typename TT > struct EqualityComparable
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<EqualityComparable>)>::failed> boost_concept_check221; ~EqualityComparable() {
      require_boolean_expr(a == b);
      require_boolean_expr(a != b);
    }
   private:
    TT a, b;
  };

  template < typename TT > struct LessThanComparable; template < typename TT > struct LessThanComparableConcept : LessThanComparable< TT > { }; template < typename TT > struct LessThanComparable
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<LessThanComparable>)>::failed> boost_concept_check231; ~LessThanComparable() {
      require_boolean_expr(a < b);
    }
   private:
    TT a, b;
  };


  template < typename TT > struct Comparable; template < typename TT > struct ComparableConcept : Comparable< TT > { }; template < typename TT > struct Comparable
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Comparable>)>::failed> boost_concept_check241; ~Comparable() {
      require_boolean_expr(a < b);
      require_boolean_expr(a > b);
      require_boolean_expr(a <= b);
      require_boolean_expr(a >= b);
    }
   private:
    TT a, b;
  };
# 271 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept_check.hpp" 3
  template < typename First , typename Second > struct EqualOp; template < typename First , typename Second > struct EqualOpConcept : EqualOp< First, Second > { }; template < typename First , typename Second > struct EqualOp { typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<EqualOp>)>::failed> boost_concept_check271; ~EqualOp() { (void)constraints_(); } private: bool constraints_() { return a == b; } First a; Second b; };
  template < typename First , typename Second > struct NotEqualOp; template < typename First , typename Second > struct NotEqualOpConcept : NotEqualOp< First, Second > { }; template < typename First , typename Second > struct NotEqualOp { typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<NotEqualOp>)>::failed> boost_concept_check272; ~NotEqualOp() { (void)constraints_(); } private: bool constraints_() { return a != b; } First a; Second b; };
  template < typename First , typename Second > struct LessThanOp; template < typename First , typename Second > struct LessThanOpConcept : LessThanOp< First, Second > { }; template < typename First , typename Second > struct LessThanOp { typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<LessThanOp>)>::failed> boost_concept_check273; ~LessThanOp() { (void)constraints_(); } private: bool constraints_() { return a < b; } First a; Second b; };
  template < typename First , typename Second > struct LessEqualOp; template < typename First , typename Second > struct LessEqualOpConcept : LessEqualOp< First, Second > { }; template < typename First , typename Second > struct LessEqualOp { typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<LessEqualOp>)>::failed> boost_concept_check274; ~LessEqualOp() { (void)constraints_(); } private: bool constraints_() { return a <= b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterThanOp; template < typename First , typename Second > struct GreaterThanOpConcept : GreaterThanOp< First, Second > { }; template < typename First , typename Second > struct GreaterThanOp { typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<GreaterThanOp>)>::failed> boost_concept_check275; ~GreaterThanOp() { (void)constraints_(); } private: bool constraints_() { return a > b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterEqualOp; template < typename First , typename Second > struct GreaterEqualOpConcept : GreaterEqualOp< First, Second > { }; template < typename First , typename Second > struct GreaterEqualOp { typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<GreaterEqualOp>)>::failed> boost_concept_check276; ~GreaterEqualOp() { (void)constraints_(); } private: bool constraints_() { return a >= b; } First a; Second b; };

  template < typename Ret , typename First , typename Second > struct PlusOp; template < typename Ret , typename First , typename Second > struct PlusOpConcept : PlusOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct PlusOp { typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<PlusOp>)>::failed> boost_concept_check278; ~PlusOp() { (void)constraints_(); } private: Ret constraints_() { return a + b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct TimesOp; template < typename Ret , typename First , typename Second > struct TimesOpConcept : TimesOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct TimesOp { typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<TimesOp>)>::failed> boost_concept_check279; ~TimesOp() { (void)constraints_(); } private: Ret constraints_() { return a * b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct DivideOp; template < typename Ret , typename First , typename Second > struct DivideOpConcept : DivideOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct DivideOp { typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<DivideOp>)>::failed> boost_concept_check280; ~DivideOp() { (void)constraints_(); } private: Ret constraints_() { return a / b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct SubtractOp; template < typename Ret , typename First , typename Second > struct SubtractOpConcept : SubtractOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct SubtractOp { typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<SubtractOp>)>::failed> boost_concept_check281; ~SubtractOp() { (void)constraints_(); } private: Ret constraints_() { return a - b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct ModOp; template < typename Ret , typename First , typename Second > struct ModOpConcept : ModOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct ModOp { typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<ModOp>)>::failed> boost_concept_check282; ~ModOp() { (void)constraints_(); } private: Ret constraints_() { return a % b; } First a; Second b; };




  template < typename Func , typename Return > struct Generator; template < typename Func , typename Return > struct GeneratorConcept : Generator< Func, Return > { }; template < typename Func , typename Return > struct Generator
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Generator>)>::failed> boost_concept_check289; ~Generator() { test(is_void<Return>()); }

   private:
      void test(boost::mpl::false_)
      {

          const Return& r = f();
          ignore_unused_variable_warning(r);
      }

      void test(boost::mpl::true_)
      {
          f();
      }

      Func f;
  };

  template < typename Func , typename Return , typename Arg > struct UnaryFunction; template < typename Func , typename Return , typename Arg > struct UnaryFunctionConcept : UnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct UnaryFunction
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<UnaryFunction>)>::failed> boost_concept_check309; ~UnaryFunction() { test(is_void<Return>()); }

   private:
      void test(boost::mpl::false_)
      {
          f(arg);
          Return r = f(arg);
          ignore_unused_variable_warning(r);
      }

      void test(boost::mpl::true_)
      {
          f(arg);
      }

      Func f;
      Arg arg;
  };

  template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunctionConcept : BinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<BinaryFunction>)>::failed> boost_concept_check330; ~BinaryFunction() { test(is_void<Return>()); }
   private:
      void test(boost::mpl::false_)
      {
          f(first,second);
          Return r = f(first, second);
          (void)r;
      }

      void test(boost::mpl::true_)
      {
          f(first,second);
      }

      Func f;
      First first;
      Second second;
  };

  template < typename Func , typename Arg > struct UnaryPredicate; template < typename Func , typename Arg > struct UnaryPredicateConcept : UnaryPredicate< Func, Arg > { }; template < typename Func , typename Arg > struct UnaryPredicate
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<UnaryPredicate>)>::failed> boost_concept_check351; ~UnaryPredicate() {
      require_boolean_expr(f(arg));
    }
   private:
    Func f;
    Arg arg;
  };

  template < typename Func , typename First , typename Second > struct BinaryPredicate; template < typename Func , typename First , typename Second > struct BinaryPredicateConcept : BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct BinaryPredicate
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<BinaryPredicate>)>::failed> boost_concept_check361; ~BinaryPredicate() {
      require_boolean_expr(f(a, b));
    }
   private:
    Func f;
    First a;
    Second b;
  };


  template < typename Func , typename First , typename Second > struct Const_BinaryPredicate; template < typename Func , typename First , typename Second > struct Const_BinaryPredicateConcept : Const_BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct Const_BinaryPredicate
    : BinaryPredicate<Func, First, Second>
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Const_BinaryPredicate>)>::failed> boost_concept_check374; ~Const_BinaryPredicate() {
      const_constraints(f);
    }
   private:
    void const_constraints(const Func& fun) {

      require_boolean_expr(fun(a, b));
    }
    Func f;
    First a;
    Second b;
  };

  template < typename Func , typename Return > struct AdaptableGenerator; template < typename Func , typename Return > struct AdaptableGeneratorConcept : AdaptableGenerator< Func, Return > { }; template < typename Func , typename Return > struct AdaptableGenerator
    : Generator<Func, typename Func::result_type>
  {
      typedef typename Func::result_type result_type;

      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<AdaptableGenerator>)>::failed> boost_concept_check392; ~AdaptableGenerator()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check394;
      }
  };

  template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunctionConcept : AdaptableUnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction
    : UnaryFunction<Func, typename Func::result_type, typename Func::argument_type>
  {
      typedef typename Func::argument_type argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableUnaryFunction()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check406;
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Convertible<Arg, argument_type>)>::failed> boost_concept_check407;
      }
  };

  template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunctionConcept : AdaptableBinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction
    : BinaryFunction<
          Func
        , typename Func::result_type
        , typename Func::first_argument_type
        , typename Func::second_argument_type
      >
  {
      typedef typename Func::first_argument_type first_argument_type;
      typedef typename Func::second_argument_type second_argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableBinaryFunction()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check425;
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Convertible<First, first_argument_type>)>::failed> boost_concept_check426;
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Convertible<Second, second_argument_type>)>::failed> boost_concept_check427;
      }
  };

  template < typename Func , typename Arg > struct AdaptablePredicate; template < typename Func , typename Arg > struct AdaptablePredicateConcept : AdaptablePredicate< Func, Arg > { }; template < typename Func , typename Arg > struct AdaptablePredicate
    : UnaryPredicate<Func, Arg>
    , AdaptableUnaryFunction<Func, bool, Arg>
  {
  };

  template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicateConcept : AdaptableBinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate
    : BinaryPredicate<Func, First, Second>
    , AdaptableBinaryFunction<Func, bool, First, Second>
  {
  };




  template < typename TT > struct InputIterator; template < typename TT > struct InputIteratorConcept : InputIterator< TT > { }; template < typename TT > struct InputIterator
    : Assignable<TT>
    , EqualityComparable<TT>
  {
      typedef typename boost::detail::iterator_traits<TT>::value_type value_type;
      typedef typename boost::detail::iterator_traits<TT>::difference_type difference_type;
      typedef typename boost::detail::iterator_traits<TT>::reference reference;
      typedef typename boost::detail::iterator_traits<TT>::pointer pointer;
      typedef typename boost::detail::iterator_traits<TT>::iterator_category iterator_category;

      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<InputIterator>)>::failed> boost_concept_check456; ~InputIterator()
      {
        typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(SignedInteger<difference_type>)>::failed> boost_concept_check458;
        typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Convertible<iterator_category, std::input_iterator_tag>)>::failed> boost_concept_check459;

        TT j(i);
        (void)*i;
        ++j;
        i++;
      }
   private:
    TT i;
  };

  template < typename TT , typename ValueT > struct OutputIterator; template < typename TT , typename ValueT > struct OutputIteratorConcept : OutputIterator< TT, ValueT > { }; template < typename TT , typename ValueT > struct OutputIterator
    : Assignable<TT>
  {
    typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<OutputIterator>)>::failed> boost_concept_check473; ~OutputIterator() {

      ++i;
      i++;
      *i++ = t;
    }
   private:
    TT i, j;
    ValueT t;
  };

  template < typename TT > struct ForwardIterator; template < typename TT > struct ForwardIteratorConcept : ForwardIterator< TT > { }; template < typename TT > struct ForwardIterator
    : InputIterator<TT>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<ForwardIterator>)>::failed> boost_concept_check487; ~ForwardIterator()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Convertible< typename ForwardIterator::iterator_category , std::forward_iterator_tag >)>::failed> boost_concept_check492;




          typename InputIterator<TT>::reference r = *i;
          ignore_unused_variable_warning(r);
      }

   private:
      TT i;
  };

  template < typename TT > struct Mutable_ForwardIterator; template < typename TT > struct Mutable_ForwardIteratorConcept : Mutable_ForwardIterator< TT > { }; template < typename TT > struct Mutable_ForwardIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Mutable_ForwardIterator>)>::failed> boost_concept_check505; ~Mutable_ForwardIterator() {
        *i++ = *i;
      }
   private:
      TT i;
  };

  template < typename TT > struct BidirectionalIterator; template < typename TT > struct BidirectionalIteratorConcept : BidirectionalIterator< TT > { }; template < typename TT > struct BidirectionalIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<BidirectionalIterator>)>::failed> boost_concept_check515; ~BidirectionalIterator()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Convertible< typename BidirectionalIterator::iterator_category , std::bidirectional_iterator_tag >)>::failed> boost_concept_check520;




          --i;
          i--;
      }
   private:
      TT i;
  };

  template < typename TT > struct Mutable_BidirectionalIterator; template < typename TT > struct Mutable_BidirectionalIteratorConcept : Mutable_BidirectionalIterator< TT > { }; template < typename TT > struct Mutable_BidirectionalIterator
    : BidirectionalIterator<TT>
    , Mutable_ForwardIterator<TT>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Mutable_BidirectionalIterator>)>::failed> boost_concept_check533; ~Mutable_BidirectionalIterator()
      {
          *i-- = *i;
      }
   private:
      TT i;
  };

  template < typename TT > struct RandomAccessIterator; template < typename TT > struct RandomAccessIteratorConcept : RandomAccessIterator< TT > { }; template < typename TT > struct RandomAccessIterator
    : BidirectionalIterator<TT>
    , Comparable<TT>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<RandomAccessIterator>)>::failed> boost_concept_check545; ~RandomAccessIterator()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Convertible< typename BidirectionalIterator<TT>::iterator_category , std::random_access_iterator_tag >)>::failed> boost_concept_check550;




          i += n;
          i = i + n; i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
          (void)i[n];
      }

   private:
    TT a, b;
    TT i, j;
      typename boost::detail::iterator_traits<TT>::difference_type n;
  };

  template < typename TT > struct Mutable_RandomAccessIterator; template < typename TT > struct Mutable_RandomAccessIteratorConcept : Mutable_RandomAccessIterator< TT > { }; template < typename TT > struct Mutable_RandomAccessIterator
    : RandomAccessIterator<TT>
    , Mutable_BidirectionalIterator<TT>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Mutable_RandomAccessIterator>)>::failed> boost_concept_check570; ~Mutable_RandomAccessIterator()
      {
          i[n] = *i;
      }
   private:
    TT i;
    typename boost::detail::iterator_traits<TT>::difference_type n;
  };




  template < typename C > struct Container; template < typename C > struct ContainerConcept : Container< C > { }; template < typename C > struct Container
    : Assignable<C>
  {
    typedef typename C::value_type value_type;
    typedef typename C::difference_type difference_type;
    typedef typename C::size_type size_type;
    typedef typename C::const_reference const_reference;
    typedef typename C::const_pointer const_pointer;
    typedef typename C::const_iterator const_iterator;

      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Container>)>::failed> boost_concept_check592; ~Container()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(InputIterator<const_iterator>)>::failed> boost_concept_check594;
          const_constraints(c);
      }

   private:
      void const_constraints(const C& cc) {
          i = cc.begin();
          i = cc.end();
          n = cc.size();
          n = cc.max_size();
          b = cc.empty();
      }
      C c;
      bool b;
      const_iterator i;
      size_type n;
  };

  template < typename C > struct Mutable_Container; template < typename C > struct Mutable_ContainerConcept : Mutable_Container< C > { }; template < typename C > struct Mutable_Container
    : Container<C>
  {
      typedef typename C::reference reference;
      typedef typename C::iterator iterator;
      typedef typename C::pointer pointer;

      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Mutable_Container>)>::failed> boost_concept_check619; ~Mutable_Container()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)( Assignable<typename Mutable_Container::value_type>)>::failed> boost_concept_check622;


          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(InputIterator<iterator>)>::failed> boost_concept_check624;

          i = c.begin();
          i = c.end();
          c.swap(c2);
      }

   private:
      iterator i;
      C c, c2;
  };

  template < typename C > struct ForwardContainer; template < typename C > struct ForwardContainerConcept : ForwardContainer< C > { }; template < typename C > struct ForwardContainer
    : Container<C>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<ForwardContainer>)>::failed> boost_concept_check639; ~ForwardContainer()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)( ForwardIterator< typename ForwardContainer::const_iterator >)>::failed> boost_concept_check644;



      }
  };

  template < typename C > struct Mutable_ForwardContainer; template < typename C > struct Mutable_ForwardContainerConcept : Mutable_ForwardContainer< C > { }; template < typename C > struct Mutable_ForwardContainer
    : ForwardContainer<C>
    , Mutable_Container<C>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Mutable_ForwardContainer>)>::failed> boost_concept_check652; ~Mutable_ForwardContainer()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)( Mutable_ForwardIterator< typename Mutable_ForwardContainer::iterator >)>::failed> boost_concept_check657;



      }
  };

  template < typename C > struct ReversibleContainer; template < typename C > struct ReversibleContainerConcept : ReversibleContainer< C > { }; template < typename C > struct ReversibleContainer
    : ForwardContainer<C>
  {
      typedef typename
        C::const_reverse_iterator
      const_reverse_iterator;

      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<ReversibleContainer>)>::failed> boost_concept_check668; ~ReversibleContainer()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)( BidirectionalIterator< typename ReversibleContainer::const_iterator>)>::failed> boost_concept_check672;



          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(BidirectionalIterator<const_reverse_iterator>)>::failed> boost_concept_check674;

          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reverse_iterator i = cc.rbegin();
          i = cc.rend();
      }
      C c;
  };

  template < typename C > struct Mutable_ReversibleContainer; template < typename C > struct Mutable_ReversibleContainerConcept : Mutable_ReversibleContainer< C > { }; template < typename C > struct Mutable_ReversibleContainer
    : Mutable_ForwardContainer<C>
    , ReversibleContainer<C>
  {
      typedef typename C::reverse_iterator reverse_iterator;

      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Mutable_ReversibleContainer>)>::failed> boost_concept_check693; ~Mutable_ReversibleContainer()
      {
          typedef typename Mutable_ForwardContainer<C>::iterator iterator;
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Mutable_BidirectionalIterator<iterator>)>::failed> boost_concept_check696;
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Mutable_BidirectionalIterator<reverse_iterator>)>::failed> boost_concept_check697;

          reverse_iterator i = c.rbegin();
          i = c.rend();
      }
   private:
      C c;
  };

  template < typename C > struct RandomAccessContainer; template < typename C > struct RandomAccessContainerConcept : RandomAccessContainer< C > { }; template < typename C > struct RandomAccessContainer
    : ReversibleContainer<C>
  {
      typedef typename C::size_type size_type;
      typedef typename C::const_reference const_reference;

      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<RandomAccessContainer>)>::failed> boost_concept_check712; ~RandomAccessContainer()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)( RandomAccessIterator< typename RandomAccessContainer::const_iterator >)>::failed> boost_concept_check717;




          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reference r = cc[n];
          ignore_unused_variable_warning(r);
      }

      C c;
      size_type n;
  };

  template < typename C > struct Mutable_RandomAccessContainer; template < typename C > struct Mutable_RandomAccessContainerConcept : Mutable_RandomAccessContainer< C > { }; template < typename C > struct Mutable_RandomAccessContainer
    : Mutable_ReversibleContainer<C>
    , RandomAccessContainer<C>
  {
   private:
      typedef Mutable_RandomAccessContainer self;
   public:
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Mutable_RandomAccessContainer>)>::failed> boost_concept_check739; ~Mutable_RandomAccessContainer()
      {
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::iterator>)>::failed> boost_concept_check741;
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::reverse_iterator>)>::failed> boost_concept_check742;

          typename self::reference r = c[i];
          ignore_unused_variable_warning(r);
      }

   private:
      typename Mutable_ReversibleContainer<C>::size_type i;
      C c;
  };


  template < typename S > struct Sequence; template < typename S > struct SequenceConcept : Sequence< S > { }; template < typename S > struct Sequence
    : Mutable_ForwardContainer<S>



    , DefaultConstructible<S>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<Sequence>)>::failed> boost_concept_check761; ~Sequence()
      {
          S
              c(n),
              c2(n, t),
              c3(first, last);

          c.insert(p, t);
          c.insert(p, n, t);
          c.insert(p, first, last);

          c.erase(p);
          c.erase(p, q);

          typename Sequence::reference r = c.front();

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(c3);
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& c) {
          typename Sequence::const_reference r = c.front();
          ignore_unused_variable_warning(r);
      }

      typename S::value_type t;
      typename S::size_type n;
      typename S::value_type* first, *last;
      typename S::iterator p, q;
  };

  template < typename S > struct FrontInsertionSequence; template < typename S > struct FrontInsertionSequenceConcept : FrontInsertionSequence< S > { }; template < typename S > struct FrontInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<FrontInsertionSequence>)>::failed> boost_concept_check798; ~FrontInsertionSequence()
      {
          c.push_front(t);
          c.pop_front();
      }
   private:
      S c;
      typename S::value_type t;
  };

  template < typename S > struct BackInsertionSequence; template < typename S > struct BackInsertionSequenceConcept : BackInsertionSequence< S > { }; template < typename S > struct BackInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<BackInsertionSequence>)>::failed> boost_concept_check811; ~BackInsertionSequence()
      {
          c.push_back(t);
          c.pop_back();
          typename BackInsertionSequence::reference r = c.back();
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& cc) {
          typename BackInsertionSequence::const_reference
              r = cc.back();
          ignore_unused_variable_warning(r);
      };
      S c;
      typename S::value_type t;
  };

  template < typename C > struct AssociativeContainer; template < typename C > struct AssociativeContainerConcept : AssociativeContainer< C > { }; template < typename C > struct AssociativeContainer
    : ForwardContainer<C>
    , DefaultConstructible<C>
  {
      typedef typename C::key_type key_type;
      typedef typename C::key_compare key_compare;
      typedef typename C::value_compare value_compare;
      typedef typename C::iterator iterator;

      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<AssociativeContainer>)>::failed> boost_concept_check838; ~AssociativeContainer()
      {
          i = c.find(k);
          r = c.equal_range(k);
          c.erase(k);
          c.erase(i);
          c.erase(r.first, r.second);
          const_constraints(c);
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(BinaryPredicate<key_compare,key_type,key_type>)>::failed> boost_concept_check846;

          typedef typename AssociativeContainer::value_type value_type_;
          typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(BinaryPredicate<value_compare,value_type_,value_type_>)>::failed> boost_concept_check849;
      }


      typedef typename C::const_iterator const_iterator;
   private:
      void const_constraints(const C& cc)
      {
          ci = cc.find(k);
          n = cc.count(k);
          cr = cc.equal_range(k);
      }

      C c;
      iterator i;
      std::pair<iterator,iterator> r;
      const_iterator ci;
      std::pair<const_iterator,const_iterator> cr;
      typename C::key_type k;
      typename C::size_type n;
  };

  template < typename C > struct UniqueAssociativeContainer; template < typename C > struct UniqueAssociativeContainerConcept : UniqueAssociativeContainer< C > { }; template < typename C > struct UniqueAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<UniqueAssociativeContainer>)>::failed> boost_concept_check874; ~UniqueAssociativeContainer()
      {
          C c(first, last);

          pos_flag = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
      }
   private:
      std::pair<typename C::iterator, bool> pos_flag;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct MultipleAssociativeContainer; template < typename C > struct MultipleAssociativeContainerConcept : MultipleAssociativeContainer< C > { }; template < typename C > struct MultipleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<MultipleAssociativeContainer>)>::failed> boost_concept_check892; ~MultipleAssociativeContainer()
      {
          C c(first, last);

          pos = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(pos);
      }
   private:
      typename C::iterator pos;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct SimpleAssociativeContainer; template < typename C > struct SimpleAssociativeContainerConcept : SimpleAssociativeContainer< C > { }; template < typename C > struct SimpleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<SimpleAssociativeContainer>)>::failed> boost_concept_check911; ~SimpleAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          enum { mpl_assertion_in_line_915 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_same<key_type,value_type>))0, 1 ) ) ) };
      }
  };

  template < typename C > struct PairAssociativeContainer; template < typename C > struct PairAssociativeContainerConcept : PairAssociativeContainer< C > { }; template < typename C > struct PairAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<PairAssociativeContainer>)>::failed> boost_concept_check922; ~PairAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          typedef typename C::mapped_type mapped_type;
          typedef std::pair<const key_type, mapped_type> required_value_type;
          enum { mpl_assertion_in_line_928 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_same<value_type,required_value_type>))0, 1 ) ) ) };
      }
  };

  template < typename C > struct SortedAssociativeContainer; template < typename C > struct SortedAssociativeContainerConcept : SortedAssociativeContainer< C > { }; template < typename C > struct SortedAssociativeContainer
    : AssociativeContainer<C>
    , ReversibleContainer<C>
  {
      typedef ::boost::concept::detail::instantiate< &::boost::concept::requirement_<void(*)(boost::concept::usage_requirements<SortedAssociativeContainer>)>::failed> boost_concept_check936; ~SortedAssociativeContainer()
      {
          C
              c(kc),
              c2(first, last),
              c3(first, last, kc);

          p = c.upper_bound(k);
          p = c.lower_bound(k);
          r = c.equal_range(k);

          c.insert(p, t);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(c3);
          const_constraints(c);
      }

      void const_constraints(const C& c)
      {
          kc = c.key_comp();
          vc = c.value_comp();

          cp = c.upper_bound(k);
          cp = c.lower_bound(k);
          cr = c.equal_range(k);
      }

   private:
      typename C::key_compare kc;
      typename C::value_compare vc;
      typename C::value_type t;
      typename C::key_type k;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;

      typedef SortedAssociativeContainer self;
      iterator p;
      const_iterator cp;
      std::pair<typename self::iterator,typename self::iterator> r;
      std::pair<typename self::const_iterator,typename self::const_iterator> cr;
      typename C::value_type* first, *last;
  };



}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept/detail/concept_undef.hpp" 1 3
# 986 "/Library/Application Support/MonkeyWorks/Developer/include/boost/concept_check.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/concept.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/concept.hpp" 3
namespace boost {
    namespace algorithm {
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/concept.hpp" 3
        template<typename FinderT, typename IteratorT>
        struct FinderConcept
        {
        private:
            typedef iterator_range<IteratorT> range;
        public:
            void constraints()
            {

                r=(*pF)(i,i);
            }
        private:
            range r;
            IteratorT i;
            FinderT* pF;
        };
# 61 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/concept.hpp" 3
        template<typename FormatterT, typename FinderT, typename IteratorT>
        struct FormatterConcept
        {
        public:
            void constraints()
            {

                ::boost::begin((*pFo)( (*pF)(i,i) ));
                ::boost::end((*pFo)( (*pF)(i,i) ));
            }
        private:
            IteratorT i;
            FinderT* pF;
            FormatterT *pFo;
        };

    }
}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_format.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_format.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_format.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_format_store.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_format_store.hpp" 3
namespace boost {
    namespace algorithm {
        namespace detail {







            template<
                typename ForwardIteratorT,
                typename FormatterT,
                typename FormatResultT >
            class find_format_store :
                public iterator_range<ForwardIteratorT>
            {
            public:

                typedef iterator_range<ForwardIteratorT> base_type;
                typedef FormatterT formatter_type;
                typedef FormatResultT format_result_type;

            public:

                find_format_store(
                        const base_type& FindResult,
                        const format_result_type& FormatResult,
                        const formatter_type& Formatter ) :
                    base_type(FindResult),
                    m_FormatResult(FormatResult),
                    m_Formatter(Formatter) {}


                template< typename FindResultT >
                find_format_store& operator=( FindResultT FindResult )
                {
                    iterator_range<ForwardIteratorT>::operator=(FindResult);
                    m_FormatResult=m_Formatter(FindResult);

                    return *this;
                }


                const format_result_type& format_result()
                {
                    return m_FormatResult;
                }

            private:
                format_result_type m_FormatResult;
                const formatter_type& m_Formatter;
            };




        }
    }
}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_format.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/replace_storage.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/replace_storage.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/sequence_traits.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/sequence_traits.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/yes_no_type.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/yes_no_type.hpp" 3
namespace boost {
    namespace algorithm {





        template<int I> struct size_descriptor
        {
            typedef char (& type)[I];
        };

        typedef size_descriptor<1>::type yes_type;
        typedef size_descriptor<2>::type no_type;

    }
}
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/sequence_traits.hpp" 2 3
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/sequence_traits.hpp" 3
namespace boost {
    namespace algorithm {
# 85 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/sequence_traits.hpp" 3
        template< typename T >
        class has_native_replace
        {
# 96 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/sequence_traits.hpp" 3
        public:



            static const bool value=false;




            typedef mpl::bool_<has_native_replace<T>::value> type;
        };







        template< typename T >
        class has_stable_iterators
        {







        public:



            static const bool value=false;



            typedef mpl::bool_<has_stable_iterators<T>::value> type;
        };







        template< typename T >
        class has_const_time_insert
        {







        public:



            static const bool value=false;



            typedef mpl::bool_<has_const_time_insert<T>::value> type;
        };







        template< typename T >
        class has_const_time_erase
        {







        public:



            static const bool value=false;



            typedef mpl::bool_<has_const_time_erase<T>::value> type;
        };

    }
}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/replace_storage.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/sequence.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/sequence.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mpl/logical.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/sequence.hpp" 2 3





namespace boost {
    namespace algorithm {
        namespace detail {



            template< typename InputT, typename ForwardIteratorT >
            inline void insert(
                InputT& Input,
                typename InputT::iterator At,
                ForwardIteratorT Begin,
                ForwardIteratorT End )
            {
                Input.insert( At, Begin, End );
            }

            template< typename InputT, typename InsertT >
            inline void insert(
                InputT& Input,
                typename InputT::iterator At,
                const InsertT& Insert )
            {
                insert( Input, At, ::boost::begin(Insert), ::boost::end(Insert) );
            }







            template< typename InputT >
            inline typename InputT::iterator erase(
                InputT& Input,
                typename InputT::iterator From,
                typename InputT::iterator To )
            {
                return Input.erase( From, To );
            }





            template< bool HasConstTimeOperations >
            struct replace_const_time_helper
            {
                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {

                    ForwardIteratorT InsertIt=Begin;
                    typename InputT::iterator InputIt=From;
                    for(; InsertIt!=End && InputIt!=To; InsertIt++, InputIt++ )
                    {
                        *InputIt=*InsertIt;
                    }

                    if ( InsertIt!=End )
                    {

                        Input.insert( InputIt, InsertIt, End );
                    }
                    else
                    {
                        if ( InputIt!=To )
                        {

                            Input.erase( InputIt, To );
                        }
                    }
                }
            };

            template<>
            struct replace_const_time_helper< true >
            {

                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {
                    typename InputT::iterator At=Input.erase( From, To );
                    if ( Begin!=End )
                    {
                        if(!Input.empty())
                        {
                            Input.insert( At, Begin, End );
                        }
                        else
                        {
                            Input.insert( Input.begin(), Begin, End );
                        }
                    }
                }
            };


            template< bool HasNative >
            struct replace_native_helper
            {
                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {
                    replace_const_time_helper<
                        boost::mpl::and_<
                            has_const_time_insert<InputT>,
                            has_const_time_erase<InputT> >::value >()(
                        Input, From, To, Begin, End );
                }
            };


            template<>
            struct replace_native_helper< true >
            {
                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {
                    Input.replace( From, To, Begin, End );
                }
            };



            template< typename InputT, typename ForwardIteratorT >
            inline void replace(
                InputT& Input,
                typename InputT::iterator From,
                typename InputT::iterator To,
                ForwardIteratorT Begin,
                ForwardIteratorT End )
            {
                replace_native_helper< has_native_replace<InputT>::value >()(
                    Input, From, To, Begin, End );
            }

            template< typename InputT, typename InsertT >
            inline void replace(
                InputT& Input,
                typename InputT::iterator From,
                typename InputT::iterator To,
                const InsertT& Insert )
            {
                if(From!=To)
                {
                    replace( Input, From, To, ::boost::begin(Insert), ::boost::end(Insert) );
                }
                else
                {
                    insert( Input, From, ::boost::begin(Insert), ::boost::end(Insert) );
                }
            }

        }
    }
}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/replace_storage.hpp" 2 3

namespace boost {
    namespace algorithm {
        namespace detail {



            template< typename StorageT, typename OutputIteratorT >
            inline OutputIteratorT move_from_storage(
                StorageT& Storage,
                OutputIteratorT DestBegin,
                OutputIteratorT DestEnd )
            {
                OutputIteratorT OutputIt=DestBegin;

                while( !Storage.empty() && OutputIt!=DestEnd )
                {
                    *OutputIt=Storage.front();
                    Storage.pop_front();
                    ++OutputIt;
                }

                return OutputIt;
            }

            template< typename StorageT, typename WhatT >
            inline void copy_to_storage(
                StorageT& Storage,
                const WhatT& What )
            {
                Storage.insert( Storage.end(), ::boost::begin(What), ::boost::end(What) );
            }




            template< bool HasStableIterators >
            struct process_segment_helper
            {

                template<
                    typename StorageT,
                    typename InputT,
                    typename ForwardIteratorT >
                ForwardIteratorT operator()(
                    StorageT& Storage,
                    InputT& ,
                    ForwardIteratorT InsertIt,
                    ForwardIteratorT SegmentBegin,
                    ForwardIteratorT SegmentEnd )
                {

                    ForwardIteratorT It=move_from_storage( Storage, InsertIt, SegmentBegin );






                    if( Storage.empty() )
                    {
                        if( It==SegmentBegin )
                        {

                            return SegmentEnd;
                        }
                        else
                        {

                            return std::copy( SegmentBegin, SegmentEnd, It );
                        }
                    }
                    else
                    {

                        while( It!=SegmentEnd )
                        {

                            Storage.push_back( *It );

                            *It=Storage.front();
                            Storage.pop_front();


                            ++It;
                        }

                        return It;
                    }
                }
            };

            template<>
            struct process_segment_helper< true >
            {

                template<
                    typename StorageT,
                    typename InputT,
                    typename ForwardIteratorT >
                ForwardIteratorT operator()(
                    StorageT& Storage,
                    InputT& Input,
                    ForwardIteratorT InsertIt,
                    ForwardIteratorT SegmentBegin,
                    ForwardIteratorT SegmentEnd )

                {

                    replace( Input, InsertIt, SegmentBegin, Storage );

                    Storage.clear();

                    return SegmentEnd;
                }
            };


            template<
                typename StorageT,
                typename InputT,
                typename ForwardIteratorT >
            inline ForwardIteratorT process_segment(
                StorageT& Storage,
                InputT& Input,
                ForwardIteratorT InsertIt,
                ForwardIteratorT SegmentBegin,
                ForwardIteratorT SegmentEnd )
            {
                return
                    process_segment_helper<
                        has_stable_iterators<InputT>::value>()(
                                Storage, Input, InsertIt, SegmentBegin, SegmentEnd );
            }


        }
    }
}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_format.hpp" 2 3

namespace boost {
    namespace algorithm {
        namespace detail {



            template<
                typename OutputIteratorT,
                typename InputT,
                typename FormatterT,
                typename FindResultT >
            inline OutputIteratorT find_format_copy_impl(
                OutputIteratorT Output,
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult )
            {
                return find_format_copy_impl2(
                    Output,
                    Input,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
            }

            template<
                typename OutputIteratorT,
                typename InputT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline OutputIteratorT find_format_copy_impl2(
                OutputIteratorT Output,
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult )
            {
                typedef find_format_store<
                    typename
                        range_const_iterator<InputT>::type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );

                if ( !M )
                {

                    std::copy( ::boost::begin(Input), ::boost::end(Input), Output );
                    return Output;
                }


                std::copy( ::boost::begin(Input), ::boost::begin(M), Output );


                std::copy( ::boost::begin(M.format_result()), ::boost::end(M.format_result()), Output );

                std::copy( M.end(), ::boost::end(Input), Output );

                return Output;
            }



            template<
                typename InputT,
                typename FormatterT,
                typename FindResultT >
            inline InputT find_format_copy_impl(
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult)
            {
                return find_format_copy_impl2(
                    Input,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
            }

            template<
                typename InputT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline InputT find_format_copy_impl2(
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult)
            {
                typedef find_format_store<
                    typename
                        range_const_iterator<InputT>::type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );

                if ( !M )
                {

                    return InputT( Input );
                }

                InputT Output;

                insert( Output, ::boost::end(Output), ::boost::begin(Input), M.begin() );

                insert( Output, ::boost::end(Output), M.format_result() );

                insert( Output, ::boost::end(Output), M.end(), ::boost::end(Input) );

                return Output;
            }



            template<
                typename InputT,
                typename FormatterT,
                typename FindResultT >
            inline void find_format_impl(
                InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult)
            {
                find_format_impl2(
                    Input,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
            }

            template<
                typename InputT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline void find_format_impl2(
                InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult)
            {
                typedef find_format_store<
                    typename
                        range_iterator<InputT>::type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );

                if ( !M )
                {

                    return;
                }


                replace( Input, M.begin(), M.end(), M.format_result() );
            }

        }
    }
}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_format.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_format_all.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_format_all.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/value_type.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/range/value_type.hpp" 3
namespace boost
{
    template< class T >
    struct range_value : iterator_value< typename range_iterator<T>::type >
    { };
}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_format_all.hpp" 2 3



namespace boost {
    namespace algorithm {
        namespace detail {



            template<
                typename OutputIteratorT,
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT >
            inline OutputIteratorT find_format_all_copy_impl(
                OutputIteratorT Output,
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult )
            {
                return find_format_all_copy_impl2(
                    Output,
                    Input,
                    Finder,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
            }

            template<
                typename OutputIteratorT,
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline OutputIteratorT find_format_all_copy_impl2(
                OutputIteratorT Output,
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult )
            {
                typedef typename
                    range_const_iterator<InputT>::type input_iterator_type;

                typedef find_format_store<
                        input_iterator_type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );


                input_iterator_type LastMatch=::boost::begin(Input);


                while( M )
                {

                    std::copy( LastMatch, M.begin(), Output );

                    std::copy( ::boost::begin(M.format_result()), ::boost::end(M.format_result()), Output );


                    LastMatch=M.end();
                    M=Finder( LastMatch, ::boost::end(Input) );
                }


                std::copy( LastMatch, ::boost::end(Input), Output );

                return Output;
            }



            template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT >
            inline InputT find_format_all_copy_impl(
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult)
            {
                return find_format_all_copy_impl2(
                    Input,
                    Finder,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
            }

            template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline InputT find_format_all_copy_impl2(
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult)
            {
                typedef typename
                    range_const_iterator<InputT>::type input_iterator_type;

                typedef find_format_store<
                        input_iterator_type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );


                input_iterator_type LastMatch=::boost::begin(Input);


                InputT Output;


                while( M )
                {

                    insert( Output, ::boost::end(Output), LastMatch, M.begin() );

                    insert( Output, ::boost::end(Output), M.format_result() );


                    LastMatch=M.end();
                    M=Finder( LastMatch, ::boost::end(Input) );
                }


                insert( Output, ::boost::end(Output), LastMatch, ::boost::end(Input) );

                return Output;
            }



            template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT >
            inline void find_format_all_impl(
                InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                FindResultT FindResult)
            {
                find_format_all_impl2(
                    Input,
                    Finder,
                    Formatter,
                    FindResult,
                    Formatter(FindResult) );
            }

            template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline void find_format_all_impl2(
                InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                FindResultT FindResult,
                FormatResultT FormatResult)
            {
                typedef typename
                    range_iterator<InputT>::type input_iterator_type;
                typedef find_format_store<
                        input_iterator_type,
                        FormatterT,
                        FormatResultT > store_type;


                store_type M( FindResult, FormatResult, Formatter );


                std::deque<
                    typename range_value<InputT>::type> Storage;


                input_iterator_type InsertIt=::boost::begin(Input);
                input_iterator_type SearchIt=::boost::begin(Input);

                while( M )
                {

                    InsertIt=process_segment(
                        Storage,
                        Input,
                        InsertIt,
                        SearchIt,
                        M.begin() );


                    SearchIt=M.end();


                    copy_to_storage( Storage, M.format_result() );


                    M=Finder( SearchIt, ::boost::end(Input) );
                }


                InsertIt=process_segment(
                    Storage,
                    Input,
                    InsertIt,
                    SearchIt,
                    ::boost::end(Input) );

                if ( Storage.empty() )
                {

                    erase( Input, InsertIt, ::boost::end(Input) );
                }
                else
                {

                    insert( Input, ::boost::end(Input), Storage.begin(), Storage.end() );
                }
            }

        }
    }
}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_format.hpp" 2 3







namespace boost {
    namespace algorithm {
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_format.hpp" 3
        template<
            typename OutputIteratorT,
            typename RangeT,
            typename FinderT,
            typename FormatterT>
        inline OutputIteratorT find_format_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {

            function_requires<
                FinderConcept<FinderT,
                typename range_const_iterator<RangeT>::type> >();
            function_requires<
                FormatterConcept<
                    FormatterT,
                    FinderT,typename range_const_iterator<RangeT>::type> >();

            iterator_range<typename range_const_iterator<RangeT>::type> lit_input(as_literal(Input));

            return detail::find_format_copy_impl(
                Output,
                lit_input,
                Formatter,
                Finder( ::boost::begin(lit_input), ::boost::end(lit_input) ) );
        }





        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT>
        inline SequenceT find_format_copy(
            const SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {

            function_requires<
                FinderConcept<FinderT,
                typename range_const_iterator<SequenceT>::type> >();
            function_requires<
                FormatterConcept<
                    FormatterT,
                    FinderT,typename range_const_iterator<SequenceT>::type> >();

            return detail::find_format_copy_impl(
                Input,
                Formatter,
                Finder(::boost::begin(Input), ::boost::end(Input)));
        }
# 119 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_format.hpp" 3
        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT>
        inline void find_format(
            SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter)
        {

            function_requires<
                FinderConcept<FinderT,
                typename range_const_iterator<SequenceT>::type> >();
            function_requires<
                FormatterConcept<
                    FormatterT,
                    FinderT,typename range_const_iterator<SequenceT>::type> >();

            detail::find_format_impl(
                Input,
                Formatter,
                Finder(::boost::begin(Input), ::boost::end(Input)));
        }
# 163 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_format.hpp" 3
        template<
            typename OutputIteratorT,
            typename RangeT,
            typename FinderT,
            typename FormatterT>
        inline OutputIteratorT find_format_all_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            FinderT Finder,
            FormatterT Formatter)
        {

            function_requires<
                FinderConcept<FinderT,
                typename range_const_iterator<RangeT>::type> >();
            function_requires<
                FormatterConcept<
                    FormatterT,
                    FinderT,typename range_const_iterator<RangeT>::type> >();

            iterator_range<typename range_const_iterator<RangeT>::type> lit_input(as_literal(Input));

            return detail::find_format_all_copy_impl(
                Output,
                lit_input,
                Finder,
                Formatter,
                Finder(::boost::begin(lit_input), ::boost::end(lit_input)));
        }





        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT >
        inline SequenceT find_format_all_copy(
            const SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {

            function_requires<
                FinderConcept<FinderT,
                typename range_const_iterator<SequenceT>::type> >();
            function_requires<
                FormatterConcept<
                    FormatterT,
                    FinderT,typename range_const_iterator<SequenceT>::type> >();

            return detail::find_format_all_copy_impl(
                Input,
                Finder,
                Formatter,
                Finder( ::boost::begin(Input), ::boost::end(Input) ) );
        }
# 232 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_format.hpp" 3
        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT >
        inline void find_format_all(
            SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {

            function_requires<
                FinderConcept<FinderT,
                typename range_const_iterator<SequenceT>::type> >();
            function_requires<
                FormatterConcept<
                    FormatterT,
                    FinderT,typename range_const_iterator<SequenceT>::type> >();

            detail::find_format_all_impl(
                Input,
                Finder,
                Formatter,
                Finder(::boost::begin(Input), ::boost::end(Input)));

        }

    }


    using algorithm::find_format_copy;
    using algorithm::find_format;
    using algorithm::find_format_all_copy;
    using algorithm::find_format_all;

}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/constants.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/constants.hpp" 3
namespace boost {
    namespace algorithm {





    enum token_compress_mode_type
    {
        token_compress_on,
        token_compress_off
    };

    }


    using algorithm::token_compress_on;
    using algorithm::token_compress_off;

}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/finder.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/finder.hpp" 3
namespace boost {
    namespace algorithm {
        namespace detail {
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/finder.hpp" 3
            template<typename SearchIteratorT,typename PredicateT>
            struct first_finderF
            {
                typedef SearchIteratorT search_iterator_type;


                template< typename SearchT >
                first_finderF( const SearchT& Search, PredicateT Comp ) :
                    m_Search(::boost::begin(Search), ::boost::end(Search)), m_Comp(Comp) {}
                first_finderF(
                        search_iterator_type SearchBegin,
                        search_iterator_type SearchEnd,
                        PredicateT Comp ) :
                    m_Search(SearchBegin, SearchEnd), m_Comp(Comp) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;
                    typedef ForwardIteratorT input_iterator_type;


                    for(input_iterator_type OuterIt=Begin;
                        OuterIt!=End;
                        ++OuterIt)
                    {

                        if( boost::empty(m_Search) )
                            return result_type( End, End );

                        input_iterator_type InnerIt=OuterIt;
                        search_iterator_type SubstrIt=m_Search.begin();
                        for(;
                            InnerIt!=End && SubstrIt!=m_Search.end();
                            ++InnerIt,++SubstrIt)
                        {
                            if( !( m_Comp(*InnerIt,*SubstrIt) ) )
                                break;
                        }


                        if ( SubstrIt==m_Search.end() )
                            return result_type( OuterIt, InnerIt );
                    }

                    return result_type( End, End );
                }

            private:
                iterator_range<search_iterator_type> m_Search;
                PredicateT m_Comp;
            };
# 100 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/finder.hpp" 3
            template<typename SearchIteratorT, typename PredicateT>
            struct last_finderF
            {
                typedef SearchIteratorT search_iterator_type;
                typedef first_finderF<
                    search_iterator_type,
                    PredicateT> first_finder_type;


                template< typename SearchT >
                last_finderF( const SearchT& Search, PredicateT Comp ) :
                    m_Search(::boost::begin(Search), ::boost::end(Search)), m_Comp(Comp) {}
                last_finderF(
                        search_iterator_type SearchBegin,
                        search_iterator_type SearchEnd,
                        PredicateT Comp ) :
                    m_Search(SearchBegin, SearchEnd), m_Comp(Comp) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;

                    if( boost::empty(m_Search) )
                        return result_type( End, End );

                    typedef typename boost::detail::
                        iterator_traits<ForwardIteratorT>::iterator_category category;

                    return findit( Begin, End, category() );
                }

            private:

                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                findit(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    std::forward_iterator_tag ) const
                {
                    typedef ForwardIteratorT input_iterator_type;
                    typedef iterator_range<ForwardIteratorT> result_type;

                    first_finder_type first_finder(
                        m_Search.begin(), m_Search.end(), m_Comp );

                    result_type M=first_finder( Begin, End );
                    result_type Last=M;

                    while( M )
                    {
                        Last=M;
                        M=first_finder( ::boost::end(M), End );
                    }

                    return Last;
                }


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                findit(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    std::bidirectional_iterator_tag ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;
                    typedef ForwardIteratorT input_iterator_type;


                    for(input_iterator_type OuterIt=End;
                        OuterIt!=Begin; )
                    {
                        input_iterator_type OuterIt2=--OuterIt;

                        input_iterator_type InnerIt=OuterIt2;
                        search_iterator_type SubstrIt=m_Search.begin();
                        for(;
                            InnerIt!=End && SubstrIt!=m_Search.end();
                            ++InnerIt,++SubstrIt)
                        {
                            if( !( m_Comp(*InnerIt,*SubstrIt) ) )
                                break;
                        }


                        if( SubstrIt==m_Search.end() )
                            return result_type( OuterIt2, InnerIt );
                    }

                    return result_type( End, End );
                }

            private:
                iterator_range<search_iterator_type> m_Search;
                PredicateT m_Comp;
            };
# 210 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/finder.hpp" 3
            template<typename SearchIteratorT, typename PredicateT>
            struct nth_finderF
            {
                typedef SearchIteratorT search_iterator_type;
                typedef first_finderF<
                    search_iterator_type,
                    PredicateT> first_finder_type;
                typedef last_finderF<
                    search_iterator_type,
                    PredicateT> last_finder_type;


                template< typename SearchT >
                nth_finderF(
                        const SearchT& Search,
                        int Nth,
                        PredicateT Comp) :
                    m_Search(::boost::begin(Search), ::boost::end(Search)),
                    m_Nth(Nth),
                    m_Comp(Comp) {}
                nth_finderF(
                        search_iterator_type SearchBegin,
                        search_iterator_type SearchEnd,
                        int Nth,
                        PredicateT Comp) :
                    m_Search(SearchBegin, SearchEnd),
                    m_Nth(Nth),
                    m_Comp(Comp) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    if(m_Nth>=0)
                    {
                        return find_forward(Begin, End, m_Nth);
                    }
                    else
                    {
                        return find_backward(Begin, End, -m_Nth);
                    }

                }

            private:

                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                find_forward(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    unsigned int N) const
                {
                    typedef ForwardIteratorT input_iterator_type;
                    typedef iterator_range<ForwardIteratorT> result_type;


                    if( boost::empty(m_Search) )
                        return result_type( End, End );


                    first_finder_type first_finder(
                        m_Search.begin(), m_Search.end(), m_Comp );

                    result_type M( Begin, Begin );

                    for( unsigned int n=0; n<=N; ++n )
                    {

                        M=first_finder( ::boost::end(M), End );

                        if ( !M )
                        {

                            return M;
                        }
                    }

                    return M;
                }

                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                find_backward(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    unsigned int N) const
                {
                    typedef ForwardIteratorT input_iterator_type;
                    typedef iterator_range<ForwardIteratorT> result_type;


                    if( boost::empty(m_Search) )
                        return result_type( End, End );


                    last_finder_type last_finder(
                        m_Search.begin(), m_Search.end(), m_Comp );

                    result_type M( End, End );

                    for( unsigned int n=1; n<=N; ++n )
                    {

                        M=last_finder( Begin, ::boost::begin(M) );

                        if ( !M )
                        {

                            return M;
                        }
                    }

                    return M;
                }


            private:
                iterator_range<search_iterator_type> m_Search;
                int m_Nth;
                PredicateT m_Comp;
            };



            template<typename ForwardIteratorT>
                iterator_range<ForwardIteratorT>
            find_head_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::forward_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;

                input_iterator_type It=Begin;
                for(
                    unsigned int Index=0;
                    Index<N && It!=End; ++Index,++It ) {};

                return result_type( Begin, It );
            }

            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_head_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::random_access_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;

                if ( (End<=Begin) || ( static_cast<unsigned int>(End-Begin) < N ) )
                    return result_type( Begin, End );

                return result_type(Begin,Begin+N);
            }


            template<typename ForwardIteratorT>
                iterator_range<ForwardIteratorT>
            find_head_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N )
            {
                typedef typename boost::detail::
                    iterator_traits<ForwardIteratorT>::iterator_category category;

                return find_head_impl( Begin, End, N, category() );
            }

            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::forward_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;

                unsigned int Index=0;
                input_iterator_type It=Begin;
                input_iterator_type It2=Begin;


                for( Index=0; Index<N && It2!=End; ++Index,++It2 ) {};


                for(; It2!=End; ++It,++It2 ) {};

                return result_type( It, It2 );
            }

            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::bidirectional_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;

                input_iterator_type It=End;
                for(
                    unsigned int Index=0;
                    Index<N && It!=Begin; ++Index,--It ) {};

                return result_type( It, End );
            }

            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::random_access_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;

                if ( (End<=Begin) || ( static_cast<unsigned int>(End-Begin) < N ) )
                    return result_type( Begin, End );

                return result_type( End-N, End );
            }


            template< typename ForwardIteratorT >
            iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N )
            {
                typedef typename boost::detail::
                    iterator_traits<ForwardIteratorT>::iterator_category category;

                return find_tail_impl( Begin, End, N, category() );
            }
# 473 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/finder.hpp" 3
            struct head_finderF
            {

                head_finderF( int N ) : m_N(N) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    if(m_N>=0)
                    {
                        return find_head_impl( Begin, End, m_N );
                    }
                    else
                    {
                        iterator_range<ForwardIteratorT> Res=
                            find_tail_impl( Begin, End, -m_N );

                        return make_iterator_range(Begin, Res.begin());
                    }
                }

            private:
                int m_N;
            };
# 511 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/finder.hpp" 3
            struct tail_finderF
            {

                tail_finderF( int N ) : m_N(N) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    if(m_N>=0)
                    {
                        return find_tail_impl( Begin, End, m_N );
                    }
                    else
                    {
                        iterator_range<ForwardIteratorT> Res=
                            find_head_impl( Begin, End, -m_N );

                        return make_iterator_range(Res.end(), End);
                    }
                }

            private:
                int m_N;
            };
# 552 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/finder.hpp" 3
            template< typename PredicateT >
            struct token_finderF
            {

                token_finderF(
                    PredicateT Pred,
                    token_compress_mode_type eCompress=token_compress_off ) :
                        m_Pred(Pred), m_eCompress(eCompress) {}


                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;

                    ForwardIteratorT It=std::find_if( Begin, End, m_Pred );

                    if( It==End )
                    {
                        return result_type( End, End );
                    }
                    else
                    {
                        ForwardIteratorT It2=It;

                        if( m_eCompress==token_compress_on )
                        {

                            while( It2!=End && m_Pred(*It2) ) ++It2;
                        }
                        else
                        {

                            ++It2;
                        }

                        return result_type( It, It2 );
                    }
                }

            private:
                PredicateT m_Pred;
                token_compress_mode_type m_eCompress;
            };
# 607 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/finder.hpp" 3
            template<typename ForwardIterator1T>
            struct range_finderF
            {
                typedef ForwardIterator1T input_iterator_type;
                typedef iterator_range<input_iterator_type> result_type;


                range_finderF(
                    input_iterator_type Begin,
                    input_iterator_type End ) : m_Range(Begin, End) {}

                range_finderF(const iterator_range<input_iterator_type>& Range) :
                    m_Range(Range) {}


                template< typename ForwardIterator2T >
                iterator_range<ForwardIterator2T>
                operator()(
                    ForwardIterator2T,
                    ForwardIterator2T ) const
                {





                    return m_Range;

                }

            private:
                iterator_range<input_iterator_type> m_Range;
            };


        }
    }
}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/compare.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/compare.hpp" 3
namespace boost {
    namespace algorithm {
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/compare.hpp" 3
        struct is_equal
        {




            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                return Arg1==Arg2;
            }
        };






        struct is_iequal
        {




            is_iequal( const std::locale& Loc=std::locale() ) :
                m_Loc( Loc ) {}





            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {



                    return std::toupper<T1>(Arg1,m_Loc)==std::toupper<T2>(Arg2,m_Loc);

            }

        private:
            std::locale m_Loc;
        };
# 86 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/compare.hpp" 3
        struct is_less
        {




            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                return Arg1<Arg2;
            }
        };







        struct is_iless
        {




            is_iless( const std::locale& Loc=std::locale() ) :
                m_Loc( Loc ) {}





            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {



                    return std::toupper<T1>(Arg1,m_Loc)<std::toupper<T2>(Arg2,m_Loc);

            }

        private:
            std::locale m_Loc;
        };
# 139 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/compare.hpp" 3
        struct is_not_greater
        {




            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                return Arg1<=Arg2;
            }
        };







        struct is_not_igreater
        {




            is_not_igreater( const std::locale& Loc=std::locale() ) :
                m_Loc( Loc ) {}





            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {



                    return std::toupper<T1>(Arg1,m_Loc)<=std::toupper<T2>(Arg2,m_Loc);

            }

        private:
            std::locale m_Loc;
        };


    }


    using algorithm::is_equal;
    using algorithm::is_iequal;
    using algorithm::is_less;
    using algorithm::is_iless;
    using algorithm::is_not_greater;
    using algorithm::is_not_igreater;

}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 2 3
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 3
namespace boost {
    namespace algorithm {
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 3
        template<typename RangeT>
        inline detail::first_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>
        first_finder( const RangeT& Search )
        {
            return
                detail::first_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    is_equal>( as_literal(Search), is_equal() ) ;
        }





        template<typename RangeT,typename PredicateT>
        inline detail::first_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>
        first_finder(
            const RangeT& Search, PredicateT Comp )
        {
            return
                detail::first_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    PredicateT>( as_literal(Search), Comp );
        }
# 90 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 3
        template<typename RangeT>
        inline detail::last_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>
        last_finder( const RangeT& Search )
        {
            return
                detail::last_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    is_equal>( as_literal(Search), is_equal() );
        }




        template<typename RangeT, typename PredicateT>
        inline detail::last_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>
        last_finder( const RangeT& Search, PredicateT Comp )
        {
            return
                detail::last_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    PredicateT>( as_literal(Search), Comp ) ;
        }
# 130 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 3
        template<typename RangeT>
        inline detail::nth_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>
        nth_finder(
            const RangeT& Search,
            int Nth)
        {
            return
                detail::nth_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    is_equal>( as_literal(Search), Nth, is_equal() ) ;
        }




        template<typename RangeT, typename PredicateT>
        inline detail::nth_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>
        nth_finder(
            const RangeT& Search,
            int Nth,
            PredicateT Comp )
        {
            return
                detail::nth_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    PredicateT>( as_literal(Search), Nth, Comp );
        }
# 175 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 3
        inline detail::head_finderF
        head_finder( int N )
        {
            return detail::head_finderF(N);
        }
# 192 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 3
        inline detail::tail_finderF
        tail_finder( int N )
        {
            return detail::tail_finderF(N);
        }
# 216 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 3
        template< typename PredicateT >
        inline detail::token_finderF<PredicateT>
        token_finder(
            PredicateT Pred,
            token_compress_mode_type eCompress=token_compress_off )
        {
            return detail::token_finderF<PredicateT>( Pred, eCompress );
        }
# 236 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/finder.hpp" 3
        template< typename ForwardIteratorT >
        inline detail::range_finderF<ForwardIteratorT>
        range_finder(
            ForwardIteratorT Begin,
            ForwardIteratorT End )
        {
            return detail::range_finderF<ForwardIteratorT>( Begin, End );
        }





        template< typename ForwardIteratorT >
        inline detail::range_finderF<ForwardIteratorT>
        range_finder( iterator_range<ForwardIteratorT> Range )
        {
            return detail::range_finderF<ForwardIteratorT>( Range );
        }

    }


    using algorithm::first_finder;
    using algorithm::last_finder;
    using algorithm::nth_finder;
    using algorithm::head_finder;
    using algorithm::tail_finder;
    using algorithm::token_finder;
    using algorithm::range_finder;

}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/formatter.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/formatter.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/formatter.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/formatter.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/util.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/util.hpp" 3
namespace boost {
    namespace algorithm {
        namespace detail {
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/util.hpp" 3
            template< typename CharT >
            struct empty_container
            {
                typedef empty_container<CharT> type;
                typedef CharT value_type;
                typedef std::size_t size_type;
                typedef std::ptrdiff_t difference_type;
                typedef const value_type& reference;
                typedef const value_type& const_reference;
                typedef const value_type* iterator;
                typedef const value_type* const_iterator;



                const_iterator begin() const
                {
                    return reinterpret_cast<const_iterator>(0);
                }

                const_iterator end() const
                {
                    return reinterpret_cast<const_iterator>(0);
                }

                bool empty() const
                {
                    return false;
                }

                size_type size() const
                {
                    return 0;
                }
            };




            template<typename InputIteratorT, typename OutputIteratorT>
            inline OutputIteratorT bounded_copy(
                InputIteratorT First,
                InputIteratorT Last,
                OutputIteratorT DestFirst,
                OutputIteratorT DestLast )
            {
                InputIteratorT InputIt=First;
                OutputIteratorT OutputIt=DestFirst;
                for(; InputIt!=Last && OutputIt!=DestLast; InputIt++, OutputIt++ )
                {
                    *OutputIt=*InputIt;
                }

                return OutputIt;
            }




            template<
                typename SeqT,
                typename IteratorT=typename SeqT::const_iterator >
            struct copy_iterator_rangeF :
                public std::unary_function< iterator_range<IteratorT>, SeqT >
            {
                SeqT operator()( const iterator_range<IteratorT>& Range ) const
                {
                    return copy_range<SeqT>(Range);
                }
            };

        }
    }
}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/formatter.hpp" 2 3



namespace boost {
    namespace algorithm {
        namespace detail {




            template<typename RangeT>
            struct const_formatF
            {
            private:
                typedef typename
                    range_const_iterator<RangeT>::type format_iterator;
                typedef iterator_range<format_iterator> result_type;

            public:

                const_formatF(const RangeT& Format) :
                    m_Format(::boost::begin(Format), ::boost::end(Format)) {}
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/formatter.hpp" 3
                template<typename Range2T>
                const result_type& operator()(const Range2T&) const
                {
                    return m_Format;
                }

            private:
                result_type m_Format;
            };




            template<typename RangeT>
            struct identity_formatF
            {

                template< typename Range2T >
                const RangeT& operator()(const Range2T& Replace) const
                {
                    return RangeT(::boost::begin(Replace), ::boost::end(Replace));
                }
            };




            template< typename CharT >
            struct empty_formatF
            {
                template< typename ReplaceT >
                empty_container<CharT> operator()(const ReplaceT&) const
                {
                    return empty_container<CharT>();
                }
            };

        }
    }
}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/formatter.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/formatter.hpp" 3
namespace boost {
    namespace algorithm {
# 45 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/formatter.hpp" 3
        template<typename RangeT>
        inline detail::const_formatF<
            iterator_range<
                typename range_const_iterator<RangeT>::type> >
        const_formatter(const RangeT& Format)
        {
            return detail::const_formatF<
                iterator_range<
                    typename range_const_iterator<RangeT>::type> >(as_literal(Format));
        }
# 63 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/formatter.hpp" 3
        template<typename RangeT>
        inline detail::identity_formatF<
            iterator_range<
                typename range_const_iterator<RangeT>::type> >
        identity_formatter()
        {
            return detail::identity_formatF<
                iterator_range<
                    typename range_const_iterator<RangeT>::type> >();
        }
# 83 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/formatter.hpp" 3
        template<typename RangeT>
        inline detail::empty_formatF<
            typename range_value<RangeT>::type>
        empty_formatter(const RangeT&)
        {
            return detail::empty_formatF<
                typename range_value<RangeT>::type>();
        }


    }


    using algorithm::const_formatter;
    using algorithm::identity_formatter;
    using algorithm::empty_formatter;

}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 2 3







namespace boost {
    namespace algorithm {
# 52 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT replace_range_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const iterator_range<
                typename
                    range_const_iterator<Range1T>::type>& SearchRange,
            const Range2T& Format)
        {
            return find_format_copy(
                Output,
                Input,
                range_finder(SearchRange),
                const_formatter(Format));
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT replace_range_copy(
            const SequenceT& Input,
            const iterator_range<
                typename
                    range_const_iterator<SequenceT>::type>& SearchRange,
            const RangeT& Format)
        {
            return find_format_copy(
                Input,
                range_finder(SearchRange),
                const_formatter(Format));
        }
# 98 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void replace_range(
            SequenceT& Input,
            const iterator_range<
                typename
                    range_iterator<SequenceT>::type>& SearchRange,
            const RangeT& Format)
        {
            find_format(
                Input,
                range_finder(SearchRange),
                const_formatter(Format));
        }
# 130 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_first_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format)
        {
            return find_format_copy(
                Output,
                Input,
                first_finder(Search),
                const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_first_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            return find_format_copy(
                Input,
                first_finder(Search),
                const_formatter(Format) );
        }
# 173 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_first(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            find_format(
                Input,
                first_finder(Search),
                const_formatter(Format) );
        }
# 205 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_first_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Output,
                Input,
                first_finder(Search, is_iequal(Loc)),
                const_formatter(Format) );
        }





        template<typename SequenceT, typename Range2T, typename Range1T>
        inline SequenceT ireplace_first_copy(
            const SequenceT& Input,
            const Range2T& Search,
            const Range1T& Format,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Input,
                first_finder(Search, is_iequal(Loc)),
                const_formatter(Format) );
        }
# 252 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_first(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            find_format(
                Input,
                first_finder(Search, is_iequal(Loc)),
                const_formatter(Format) );
        }
# 283 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_last_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format )
        {
            return find_format_copy(
                Output,
                Input,
                last_finder(Search),
                const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_last_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            return find_format_copy(
                Input,
                last_finder(Search),
                const_formatter(Format) );
        }
# 326 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_last(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            find_format(
                Input,
                last_finder(Search),
                const_formatter(Format) );
        }
# 358 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_last_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Output,
                Input,
                last_finder(Search, is_iequal(Loc)),
                const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT ireplace_last_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Input,
                last_finder(Search, is_iequal(Loc)),
                const_formatter(Format) );
        }
# 406 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_last(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            find_format(
                Input,
                last_finder(Search, is_iequal(Loc)),
                const_formatter(Format) );
        }
# 439 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_nth_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            int Nth,
            const Range3T& Format )
        {
            return find_format_copy(
                Output,
                Input,
                nth_finder(Search, Nth),
                const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_nth_copy(
            const SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format )
        {
            return find_format_copy(
                Input,
                nth_finder(Search, Nth),
                const_formatter(Format) );
        }
# 486 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_nth(
            SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format )
        {
            find_format(
                Input,
                nth_finder(Search, Nth),
                const_formatter(Format) );
        }
# 521 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_nth_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            int Nth,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Output,
                Input,
                nth_finder(Search, Nth, is_iequal(Loc) ),
                const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT ireplace_nth_copy(
            const SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Input,
                nth_finder(Search, Nth, is_iequal(Loc)),
                const_formatter(Format) );
        }
# 572 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_nth(
            SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            find_format(
                Input,
                nth_finder(Search, Nth, is_iequal(Loc)),
                const_formatter(Format) );
        }
# 604 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_all_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format )
        {
            return find_format_all_copy(
                Output,
                Input,
                first_finder(Search),
                const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_all_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            return find_format_all_copy(
                Input,
                first_finder(Search),
                const_formatter(Format) );
        }
# 648 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_all(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            find_format_all(
                Input,
                first_finder(Search),
                const_formatter(Format) );
        }
# 680 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_all_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return find_format_all_copy(
                Output,
                Input,
                first_finder(Search, is_iequal(Loc)),
                const_formatter(Format) );
        }





        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT ireplace_all_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            return find_format_all_copy(
                Input,
                first_finder(Search, is_iequal(Loc)),
                const_formatter(Format) );
        }
# 727 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_all(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            find_format_all(
                Input,
                first_finder(Search, is_iequal(Loc)),
                const_formatter(Format) );
        }
# 762 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT replace_head_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            int N,
            const Range2T& Format )
        {
            return find_format_copy(
                Output,
                Input,
                head_finder(N),
                const_formatter(Format) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT replace_head_copy(
            const SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            return find_format_copy(
                Input,
                head_finder(N),
                const_formatter(Format) );
        }
# 808 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void replace_head(
            SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            find_format(
                Input,
                head_finder(N),
                const_formatter(Format) );
        }
# 842 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT replace_tail_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            int N,
            const Range2T& Format )
        {
            return find_format_copy(
                Output,
                Input,
                tail_finder(N),
                const_formatter(Format) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT replace_tail_copy(
            const SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            return find_format_copy(
                Input,
                tail_finder(N),
                const_formatter(Format) );
        }
# 888 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/replace.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void replace_tail(
            SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            find_format(
                Input,
                tail_finder(N),
                const_formatter(Format) );
        }

    }


    using algorithm::replace_range_copy;
    using algorithm::replace_range;
    using algorithm::replace_first_copy;
    using algorithm::replace_first;
    using algorithm::ireplace_first_copy;
    using algorithm::ireplace_first;
    using algorithm::replace_last_copy;
    using algorithm::replace_last;
    using algorithm::ireplace_last_copy;
    using algorithm::ireplace_last;
    using algorithm::replace_nth_copy;
    using algorithm::replace_nth;
    using algorithm::ireplace_nth_copy;
    using algorithm::ireplace_nth;
    using algorithm::replace_all_copy;
    using algorithm::replace_all;
    using algorithm::ireplace_all_copy;
    using algorithm::ireplace_all;
    using algorithm::replace_head_copy;
    using algorithm::replace_head;
    using algorithm::replace_tail_copy;
    using algorithm::replace_tail;

}
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_facet.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/special_values_formatter.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/special_values_formatter.hpp" 3
namespace boost { namespace date_time {
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/special_values_formatter.hpp" 3
  template <class CharT, class OutItrT = std::ostreambuf_iterator<CharT, std::char_traits<CharT> > >
  class special_values_formatter
  {
  public:
    typedef std::basic_string<CharT> string_type;
    typedef CharT char_type;
    typedef std::vector<string_type> collection_type;
    static const char_type default_special_value_names[3][17];




    special_values_formatter()
    {
      std::copy(&default_special_value_names[0],
                &default_special_value_names[3],
                std::back_inserter(m_special_value_names));
    }
# 58 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/special_values_formatter.hpp" 3
    special_values_formatter(const char_type* const* begin, const char_type* const* end)
    {
      std::copy(begin, end, std::back_inserter(m_special_value_names));
    }
    special_values_formatter(typename collection_type::iterator beg, typename collection_type::iterator end)
    {
      std::copy(beg, end, std::back_inserter(m_special_value_names));
    }

    OutItrT put_special(OutItrT next,
                        const boost::date_time::special_values& value) const
    {

      unsigned int index = value;
      if (index < m_special_value_names.size()) {
        std::copy(m_special_value_names[index].begin(),
                  m_special_value_names[index].end(),
                  next);
      }
      return next;
    }
  protected:
    collection_type m_special_value_names;
  };






  template <class CharT, class OutItrT>
  const typename special_values_formatter<CharT, OutItrT>::char_type special_values_formatter<CharT, OutItrT>::default_special_value_names[3][17] = {
    {'n','o','t','-','a','-','d','a','t','e','-','t','i','m','e'},
    {'-','i','n','f','i','n','i','t','y'},
    {'+','i','n','f','i','n','i','t','y'} };

 } }
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_facet.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period_formatter.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period_formatter.hpp" 3
namespace boost { namespace date_time {
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period_formatter.hpp" 3
  template <class CharT, class OutItrT = std::ostreambuf_iterator<CharT, std::char_traits<CharT> > >
  class period_formatter {
  public:
    typedef std::basic_string<CharT> string_type;
    typedef CharT char_type;
    typedef typename std::basic_string<char_type>::const_iterator const_itr_type;
    typedef std::vector<std::basic_string<CharT> > collection_type;

    static const char_type default_period_separator[2];
    static const char_type default_period_start_delimeter[2];
    static const char_type default_period_open_range_end_delimeter[2];
    static const char_type default_period_closed_range_end_delimeter[2];

    enum range_display_options { AS_OPEN_RANGE, AS_CLOSED_RANGE };


    period_formatter(range_display_options range_option_in = AS_CLOSED_RANGE,
                     const char_type* const period_separator = default_period_separator,
                     const char_type* const period_start_delimeter = default_period_start_delimeter,
                     const char_type* const period_open_range_end_delimeter = default_period_open_range_end_delimeter,
                     const char_type* const period_closed_range_end_delimeter = default_period_closed_range_end_delimeter) :
      m_range_option(range_option_in),
      m_period_separator(period_separator),
      m_period_start_delimeter(period_start_delimeter),
      m_open_range_end_delimeter(period_open_range_end_delimeter),
      m_closed_range_end_delimeter(period_closed_range_end_delimeter)
    {}


    OutItrT put_period_separator(OutItrT& oitr) const
    {
      const_itr_type ci = m_period_separator.begin();
      while (ci != m_period_separator.end()) {
        *oitr = *ci;
        ci++;
      }
      return oitr;
    }


    OutItrT put_period_start_delimeter(OutItrT& oitr) const
    {
      const_itr_type ci = m_period_start_delimeter.begin();
      while (ci != m_period_start_delimeter.end()) {
        *oitr = *ci;
        ci++;
      }
      return oitr;
    }


    OutItrT put_period_end_delimeter(OutItrT& oitr) const
    {

      const_itr_type ci, end;
      if (m_range_option == AS_OPEN_RANGE) {
        ci = m_open_range_end_delimeter.begin();
        end = m_open_range_end_delimeter.end();
      }
      else {
        ci = m_closed_range_end_delimeter.begin();
        end = m_closed_range_end_delimeter.end();
      }
      while (ci != end) {
        *oitr = *ci;
        ci++;
      }
      return oitr;
    }

    range_display_options range_option() const
    {
      return m_range_option;
    }


    void
    range_option(range_display_options option) const
    {
      m_range_option = option;
    }
    void delimiter_strings(const string_type& separator,
                           const string_type& start_delim,
                           const string_type& open_end_delim,
                           const string_type& closed_end_delim)
    {
      m_period_separator;
      m_period_start_delimeter;
      m_open_range_end_delimeter;
      m_closed_range_end_delimeter;
    }
# 150 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period_formatter.hpp" 3
    template<class period_type, class facet_type>
    OutItrT put_period(OutItrT next,
                       std::ios_base& a_ios,
                       char_type a_fill,
                       const period_type& p,
                       const facet_type& facet) const {
      put_period_start_delimeter(next);
      next = facet.put(next, a_ios, a_fill, p.begin());
      put_period_separator(next);
      if (m_range_option == AS_CLOSED_RANGE) {
        facet.put(next, a_ios, a_fill, p.last());
      }
      else {
        facet.put(next, a_ios, a_fill, p.end());
      }
      put_period_end_delimeter(next);
      return next;
    }


  private:
    range_display_options m_range_option;
    string_type m_period_separator;
    string_type m_period_start_delimeter;
    string_type m_open_range_end_delimeter;
    string_type m_closed_range_end_delimeter;
  };

  template <class CharT, class OutItrT>
  const typename period_formatter<CharT, OutItrT>::char_type
  period_formatter<CharT, OutItrT>::default_period_separator[2] = {'/'};

  template <class CharT, class OutItrT>
  const typename period_formatter<CharT, OutItrT>::char_type
  period_formatter<CharT, OutItrT>::default_period_start_delimeter[2] = {'['};

  template <class CharT, class OutItrT>
  const typename period_formatter<CharT, OutItrT>::char_type
  period_formatter<CharT, OutItrT>::default_period_open_range_end_delimeter[2] = {')'};

  template <class CharT, class OutItrT>
  const typename period_formatter<CharT, OutItrT>::char_type
  period_formatter<CharT, OutItrT>::default_period_closed_range_end_delimeter[2] = {']'};

 } }
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_facet.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period_parser.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period_parser.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/string_parse_tree.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/string_parse_tree.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/call_traits.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/call_traits.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/call_traits.hpp" 1 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/call_traits.hpp" 3
namespace boost{

namespace detail{

template <typename T, bool small_>
struct ct_imp2
{
   typedef const T& param_type;
};

template <typename T>
struct ct_imp2<T, true>
{
   typedef const T param_type;
};

template <typename T, bool isp, bool b1>
struct ct_imp
{
   typedef const T& param_type;
};

template <typename T, bool isp>
struct ct_imp<T, isp, true>
{
   typedef typename ct_imp2<T, sizeof(T) <= sizeof(void*)>::param_type param_type;
};

template <typename T, bool b1>
struct ct_imp<T, true, b1>
{
   typedef const T param_type;
};

}

template <typename T>
struct call_traits
{
public:
   typedef T value_type;
   typedef T& reference;
   typedef const T& const_reference;






   typedef typename boost::detail::ct_imp<
      T,
      ::boost::is_pointer<T>::value,
      ::boost::is_arithmetic<T>::value
   >::param_type param_type;
};

template <typename T>
struct call_traits<T&>
{
   typedef T& value_type;
   typedef T& reference;
   typedef const T& const_reference;
   typedef T& param_type;
};
# 135 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/call_traits.hpp" 3
template <typename T, std::size_t N>
struct call_traits<T [N]>
{
private:
   typedef T array_type[N];
public:

   typedef const T* value_type;
   typedef array_type& reference;
   typedef const array_type& const_reference;
   typedef const T* const param_type;
};

template <typename T, std::size_t N>
struct call_traits<const T [N]>
{
private:
   typedef const T array_type[N];
public:

   typedef const T* value_type;
   typedef array_type& reference;
   typedef const array_type& const_reference;
   typedef const T* const param_type;
};


}
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/call_traits.hpp" 2 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/lcast_precision.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/lcast_precision.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/integer_traits.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/integer_traits.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/limits.h" 1 3 4






# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/syslimits.h" 1 3 4
# 8 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/limits.h" 2 3 4
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/integer_traits.hpp" 2 3







namespace boost {
template<class T>
class integer_traits : public std::numeric_limits<T>
{
public:
  static const bool is_integral = false;
};

namespace detail {
template<class T, T min_val, T max_val>
class integer_traits_base
{
public:
  static const bool is_integral = true;
  static const T const_min = min_val;
  static const T const_max = max_val;
};



template<class T, T min_val, T max_val>
const bool integer_traits_base<T, min_val, max_val>::is_integral;

template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_min;

template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_max;


}

template<>
class integer_traits<bool>
  : public std::numeric_limits<bool>,
    public detail::integer_traits_base<bool, false, true>
{ };

template<>
class integer_traits<char>
  : public std::numeric_limits<char>,
    public detail::integer_traits_base<char, (-127 - 1), 127>
{ };

template<>
class integer_traits<signed char>
  : public std::numeric_limits<signed char>,
    public detail::integer_traits_base<signed char, (-127 - 1), 127>
{ };

template<>
class integer_traits<unsigned char>
  : public std::numeric_limits<unsigned char>,
    public detail::integer_traits_base<unsigned char, 0, (127 * 2 + 1)>
{ };


template<>
class integer_traits<wchar_t>
  : public std::numeric_limits<wchar_t>,
# 110 "/Library/Application Support/MonkeyWorks/Developer/include/boost/integer_traits.hpp" 3
    public detail::integer_traits_base<wchar_t, (-2147483647 - 1), 2147483647>
# 119 "/Library/Application Support/MonkeyWorks/Developer/include/boost/integer_traits.hpp" 3
{ };


template<>
class integer_traits<short>
  : public std::numeric_limits<short>,
    public detail::integer_traits_base<short, (-32767 - 1), 32767>
{ };

template<>
class integer_traits<unsigned short>
  : public std::numeric_limits<unsigned short>,
    public detail::integer_traits_base<unsigned short, 0, (32767 * 2 + 1)>
{ };

template<>
class integer_traits<int>
  : public std::numeric_limits<int>,
    public detail::integer_traits_base<int, (-2147483647 - 1), 2147483647>
{ };

template<>
class integer_traits<unsigned int>
  : public std::numeric_limits<unsigned int>,
    public detail::integer_traits_base<unsigned int, 0, (2147483647 * 2U + 1U)>
{ };

template<>
class integer_traits<long>
  : public std::numeric_limits<long>,
    public detail::integer_traits_base<long, (-2147483647L - 1L), 2147483647L>
{ };

template<>
class integer_traits<unsigned long>
  : public std::numeric_limits<unsigned long>,
    public detail::integer_traits_base<unsigned long, 0, (2147483647L * 2UL + 1UL)>
{ };




template<>
class integer_traits< ::boost::long_long_type>
  : public std::numeric_limits< ::boost::long_long_type>,
    public detail::integer_traits_base< ::boost::long_long_type, (-0x7fffffffffffffffLL-1), 0x7fffffffffffffffLL>
{ };

template<>
class integer_traits< ::boost::ulong_long_type>
  : public std::numeric_limits< ::boost::ulong_long_type>,
    public detail::integer_traits_base< ::boost::ulong_long_type, 0, 0xffffffffffffffffULL>
{ };
# 231 "/Library/Application Support/MonkeyWorks/Developer/include/boost/integer_traits.hpp" 3
}
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/lcast_precision.hpp" 2 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/lcast_precision.hpp" 3
namespace boost { namespace detail {

class lcast_abstract_stub {};





template<class T>
struct lcast_precision
{



    typedef typename boost::mpl::if_<
        boost::is_abstract<T>
      , std::numeric_limits<lcast_abstract_stub>
      , std::numeric_limits<T>
      >::type limits;


    static const bool use_default_precision = !limits::is_specialized || limits::is_exact;



    static const bool is_specialized_bin = !use_default_precision && limits::radix == 2 && limits::digits > 0;




    static const bool is_specialized_dec = !use_default_precision && limits::radix == 10 && limits::digits10 > 0;




    static const std::streamsize streamsize_max = boost::integer_traits<std::streamsize>::const_max;



    static const unsigned int precision_dec = limits::digits10 + 1U;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!is_specialized_dec || precision_dec <= streamsize_max + 0UL) == 0 ? false : true) >)> boost_static_assert_typedef_79;



    static const unsigned long precision_bin = 2UL + limits::digits * 30103UL / 100000UL;



    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!is_specialized_bin || (limits::digits + 0UL < (2147483647L * 2UL + 1UL) / 30103UL && precision_bin > limits::digits10 + 0UL && precision_bin <= streamsize_max + 0UL)) == 0 ? false : true) >)> boost_static_assert_typedef_89;





    static const std::streamsize value = is_specialized_bin ? precision_bin : is_specialized_dec ? precision_dec : 6;



};


template<class T>
inline std::streamsize lcast_get_precision(T* = 0)
{

    return lcast_precision<T>::value;
# 165 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/lcast_precision.hpp" 3
}

template<class T>
inline void lcast_set_precision(std::ios_base& stream, T*)
{
    stream.precision(lcast_get_precision<T>());
}

template<class Source, class Target>
inline void lcast_set_precision(std::ios_base& stream, Source*, Target*)
{
    std::streamsize const s = lcast_get_precision((Source*)0);
    std::streamsize const t = lcast_get_precision((Target*)0);
    stream.precision(s > t ? s : t);
}

}}
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 2 3
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
namespace boost
{

    class bad_lexical_cast : public std::bad_cast
    {
    public:
        bad_lexical_cast() :
        source(&typeid(void)), target(&typeid(void))
        {
        }
        bad_lexical_cast(
            const std::type_info &source_type_arg,
            const std::type_info &target_type_arg) :
            source(&source_type_arg), target(&target_type_arg)
        {
        }
        const std::type_info &source_type() const
        {
            return *source;
        }
        const std::type_info &target_type() const
        {
            return *target;
        }
        virtual const char *what() const throw()
        {
            return "bad lexical cast: "
                   "source type value could not be interpreted as target";
        }
        virtual ~bad_lexical_cast() throw()
        {
        }
    private:
        const std::type_info *source;
        const std::type_info *target;
    };

    namespace detail
    {
        template<typename Type>
        struct stream_char
        {
            typedef char type;
        };


        template<class CharT, class Traits, class Alloc>
        struct stream_char< std::basic_string<CharT,Traits,Alloc> >
        {
            typedef CharT type;
        };




        template<>
        struct stream_char<wchar_t>
        {
            typedef wchar_t type;
        };


        template<>
        struct stream_char<wchar_t *>
        {
            typedef wchar_t type;
        };

        template<>
        struct stream_char<const wchar_t *>
        {
            typedef wchar_t type;
        };
# 127 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
        template<typename TargetChar, typename SourceChar>
        struct widest_char
        {
            typedef TargetChar type;
        };

        template<>
        struct widest_char<char, wchar_t>
        {
            typedef wchar_t type;
        };
    }

    namespace detail
    {

        template<class CharT, class Target, class Source>
        struct deduce_char_traits
        {
            typedef std::char_traits<CharT> type;
        };

        template<class CharT, class Traits, class Alloc, class Source>
        struct deduce_char_traits< CharT
                                 , std::basic_string<CharT,Traits,Alloc>
                                 , Source
                                 >
        {
            typedef Traits type;
        };

        template<class CharT, class Target, class Traits, class Alloc>
        struct deduce_char_traits< CharT
                                 , Target
                                 , std::basic_string<CharT,Traits,Alloc>
                                 >
        {
            typedef Traits type;
        };

        template<class CharT, class Traits, class Alloc1, class Alloc2>
        struct deduce_char_traits< CharT
                                 , std::basic_string<CharT,Traits,Alloc1>
                                 , std::basic_string<CharT,Traits,Alloc2>
                                 >
        {
            typedef Traits type;
        };

    }

    namespace detail
    {
# 189 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
        template< class CharT
                , class Source
                >
        struct lcast_src_length
        {
            static const std::size_t value = 0;


            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<char, bool>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<char, char>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
# 223 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
        template<>
        struct lcast_src_length<wchar_t, bool>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<wchar_t, char>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };


        template<>
        struct lcast_src_length<wchar_t, wchar_t>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };



        template<>
        struct lcast_src_length<char, char const*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<char, char*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };


        template<>
        struct lcast_src_length<wchar_t, wchar_t const*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<wchar_t, wchar_t*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };



        template<class CharT, class Traits, class Alloc>
        struct lcast_src_length< CharT, std::basic_string<CharT,Traits,Alloc> >
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
# 315 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
        template<class Source>
        struct lcast_src_length_integral
        {

            static const std::size_t value = std::numeric_limits<Source>::is_signed + std::numeric_limits<Source>::is_specialized + std::numeric_limits<Source>::digits10 * 2;
# 328 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
        };
# 342 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
        template<> struct lcast_src_length<char, short> : lcast_src_length_integral<short> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, short> : lcast_src_length_integral<short> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, unsigned short> : lcast_src_length_integral<unsigned short> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, unsigned short> : lcast_src_length_integral<unsigned short> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, int> : lcast_src_length_integral<int> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, int> : lcast_src_length_integral<int> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, unsigned int> : lcast_src_length_integral<unsigned int> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, unsigned int> : lcast_src_length_integral<unsigned int> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, long> : lcast_src_length_integral<long> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, long> : lcast_src_length_integral<long> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, unsigned long> : lcast_src_length_integral<unsigned long> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, unsigned long> : lcast_src_length_integral<unsigned long> { static void check_coverage() {} };

        template<> struct lcast_src_length<char, boost::ulong_long_type> : lcast_src_length_integral<boost::ulong_long_type> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, boost::ulong_long_type> : lcast_src_length_integral<boost::ulong_long_type> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, boost::long_long_type> : lcast_src_length_integral<boost::long_long_type> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, boost::long_long_type> : lcast_src_length_integral<boost::long_long_type> { static void check_coverage() {} };
# 370 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
        template<class Source>
        struct lcast_src_length_floating
        {
            typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<Source>::max_exponent10 <= 999999L && std::numeric_limits<Source>::min_exponent10 >= -999999L) == 0 ? false : true) >)> boost_static_assert_typedef_376;



            static const std::size_t value = 5 + lcast_precision<Source>::value + 6;


        };

        template<>
        struct lcast_src_length<char,float>
          : lcast_src_length_floating<float>
        {
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<char,double>
          : lcast_src_length_floating<double>
        {
            static void check_coverage() {}
        };

        template<>
        struct lcast_src_length<char,long double>
          : lcast_src_length_floating<long double>
        {
            static void check_coverage() {}
        };


    template<>
    struct lcast_src_length<wchar_t,float>
      : lcast_src_length_floating<float>
    {
        static void check_coverage() {}
    };

    template<>
    struct lcast_src_length<wchar_t,double>
      : lcast_src_length_floating<double>
    {
        static void check_coverage() {}
    };

    template<>
    struct lcast_src_length<wchar_t,long double>
      : lcast_src_length_floating<long double>
    {
        static void check_coverage() {}
    };



    }

    namespace detail
    {
        template<typename CharT> struct lcast_char_constants;

        template<>
        struct lcast_char_constants<char>
        {
            static const char zero = '0';
            static const char minus = '-';
        };


        template<>
        struct lcast_char_constants<wchar_t>
        {
            static const wchar_t zero = L'0';
            static const wchar_t minus = L'-';
        };

    }

    namespace detail
    {
        struct lexical_streambuf_fake
        {
        };
    }

    namespace detail
    {






        inline unsigned int lcast_to_unsigned(int value)
        {
            unsigned int uval = value;
            return value < 0 ? -uval : uval;
        }

        inline unsigned long lcast_to_unsigned(long value)
        {
            unsigned long uval = value;
            return value < 0 ? -uval : uval;
        }


        inline boost::ulong_long_type lcast_to_unsigned(boost::long_long_type v)
        {
            boost::ulong_long_type uval = v;
            return v < 0 ? -uval : uval;
        }
# 495 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
    }

    namespace detail
    {
        template<class Traits, class T, class CharT>
        CharT* lcast_put_unsigned(T n, CharT* finish)
        {

            typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!std::numeric_limits<T>::is_signed) == 0 ? false : true) >)> boost_static_assert_typedef_503;

            CharT thousands_sep = 0;





            std::locale loc;
            typedef std::numpunct<CharT> numpunct;
            numpunct const& np = std::use_facet< numpunct >(loc);
            std::string const& grouping = np.grouping();
            std::string::size_type const grouping_size = grouping.size();

            if(grouping_size)
                thousands_sep = np.thousands_sep();


            std::string::size_type group = 0;
            char last_grp_size = grouping[0] <= 0 ? 127 : grouping[0];




            typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((std::numeric_limits<T>::digits10 < 127) == 0 ? false : true) >)> boost_static_assert_typedef_527;

            typedef typename Traits::int_type int_type;
            CharT const czero = lcast_char_constants<CharT>::zero;
            int_type const zero = Traits::to_int_type(czero);

            char left = last_grp_size;

            do
            {
                if(left == 0)
                {
                    ++group;
                    if(group < grouping_size)
                    {
                        char const grp_size = grouping[group];
                        last_grp_size = grp_size <= 0 ? 127 : grp_size;
                    }

                    left = last_grp_size;
                    --finish;
                    Traits::assign(*finish, thousands_sep);
                }

                --left;
                --finish;
                int_type const digit = static_cast<int_type>(n % 10U);
                Traits::assign(*finish, Traits::to_char_type(zero + digit));
                n /= 10;
            } while(n);

            return finish;
        }
    }

    namespace detail
    {
        template<typename Target, typename Source, typename Traits>
        class lexical_stream
        {
        private:
            typedef typename widest_char<
                typename stream_char<Target>::type,
                typename stream_char<Source>::type>::type char_type;

            typedef Traits traits_type;

        public:
            lexical_stream(char_type* = 0, char_type* = 0)
            {
                stream.unsetf(std::ios::skipws);
                lcast_set_precision(stream, (Source*)0, (Target*)0);
            }
            ~lexical_stream()
            {



            }
            bool operator<<(const Source &input)
            {
                return !(stream << input).fail();
            }
            template<typename InputStreamable>
            bool operator>>(InputStreamable &output)
            {
                return !is_pointer<InputStreamable>::value &&
                       stream >> output &&
                       stream.get() ==







                           traits_type::eof();

            }
# 626 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
            bool operator>>(std::basic_string<char_type,traits_type>& output)
            {
                stream.str().swap(output);
                return true;
            }

            template<class Alloc>
            bool operator>>(std::basic_string<char_type,traits_type,Alloc>& out)
            {
                std::basic_string<char_type,traits_type> str(stream.str());
                out.assign(str.begin(), str.end());
                return true;
            }

        private:





            std::basic_stringstream<char_type,traits_type> stream;

        };
    }

    namespace detail
    {

        template< class CharT
                , class Base
                , class Traits
                >
        class lexical_stream_limited_src : public Base
        {



            CharT* start;
            CharT* finish;

        private:

            static void widen_and_assign(char*p, char ch)
            {
                Traits::assign(*p, ch);
            }


            static void widen_and_assign(wchar_t* p, char ch)
            {
                std::locale loc;
                wchar_t w = std::use_facet< std::ctype<wchar_t> >(loc).widen(ch);
                Traits::assign(*p, w);
            }

            static void widen_and_assign(wchar_t* p, wchar_t ch)
            {
                Traits::assign(*p, ch);
            }

            static void widen_and_assign(char*, wchar_t ch);


            template<class OutputStreamable>
            bool lcast_put(const OutputStreamable& input)
            {
                this->setp(start, finish);
                std::basic_ostream<CharT> stream(static_cast<Base*>(this));
                lcast_set_precision(stream, (OutputStreamable*)0);
                bool const result = !(stream << input).fail();
                finish = this->pptr();
                return result;
            }


            lexical_stream_limited_src(lexical_stream_limited_src const&);
            void operator=(lexical_stream_limited_src const&);

        public:

            lexical_stream_limited_src(CharT* start, CharT* finish)
              : start(start)
              , finish(finish)
            {}

        public:

            template<class Alloc>
            bool operator<<(std::basic_string<CharT,Traits,Alloc> const& str)
            {
                start = const_cast<CharT*>(str.data());
                finish = start + str.length();
                return true;
            }

            bool operator<<(bool);
            bool operator<<(char);

            bool operator<<(wchar_t);

            bool operator<<(CharT const*);
            bool operator<<(short);
            bool operator<<(int);
            bool operator<<(long);
            bool operator<<(unsigned short);
            bool operator<<(unsigned int);
            bool operator<<(unsigned long);

            bool operator<<(boost::ulong_long_type);
            bool operator<<(boost::long_long_type );






            bool operator<<(float);
            bool operator<<(double);
            bool operator<<(long double);

        public:



            template<typename InputStreamable>
            bool operator>>(InputStreamable& output)
            {





                if(is_pointer<InputStreamable>::value)
                    return false;

                this->setg(start, start, finish);
                std::basic_istream<CharT> stream(static_cast<Base*>(this));
                stream.unsetf(std::ios::skipws);
                lcast_set_precision(stream, (InputStreamable*)0);



                return stream >> output &&
                    stream.get() ==







                Traits::eof();

            }

            bool operator>>(CharT&);
# 793 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
            template<class Alloc>
            bool operator>>(std::basic_string<CharT,Traits,Alloc>& str)
            {
                str.assign(start, finish);
                return true;
            }

        };

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                bool value)
        {
            typedef typename Traits::int_type int_type;
            CharT const czero = lcast_char_constants<CharT>::zero;
            int_type const zero = Traits::to_int_type(czero);
            Traits::assign(*start, Traits::to_char_type(zero + value));
            finish = start + 1;
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                char ch)
        {
            widen_and_assign(start, ch);
            finish = start + 1;
            return true;
        }


        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                wchar_t ch)
        {
            widen_and_assign(start, ch);
            finish = start + 1;
            return true;
        }


        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                short n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                int n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                long n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }


        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                boost::long_long_type n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }
# 906 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                unsigned short n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                unsigned int n)
        {
            start = lcast_put_unsigned<Traits>(n, finish);
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                unsigned long n)
        {
            start = lcast_put_unsigned<Traits>(n, finish);
            return true;
        }


        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                boost::ulong_long_type n)
        {
            start = lcast_put_unsigned<Traits>(n, finish);
            return true;
        }
# 948 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                float val)
        {
            return this->lcast_put(val);
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                double val)
        {
            return this->lcast_put(val);
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                long double val)
        {
            return this->lcast_put(val);
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                CharT const* str)
        {
            start = const_cast<CharT*>(str);
            finish = start + Traits::length(str);
            return true;
        }

        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator>>(
                CharT& output)
        {
            bool const ok = (finish - start == 1);
            if(ok)
                Traits::assign(output, *start);
            return ok;
        }
# 1007 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
    }

    namespace detail
    {

        template<class Source>
        struct lcast_streambuf_for_source
        {
            static const bool value = false;
        };

        template<>
        struct lcast_streambuf_for_source<float>
        {
            static const bool value = true;
        };

        template<>
        struct lcast_streambuf_for_source<double>
        {
            static const bool value = true;
        };

        template<>
        struct lcast_streambuf_for_source<long double>
        {
            static const bool value = true;
        };
    }

    namespace detail
    {

        template<class Target>
        struct lcast_streambuf_for_target
        {
            static const bool value = true;
        };

        template<>
        struct lcast_streambuf_for_target<char>
        {
            static const bool value = false;
        };


        template<>
        struct lcast_streambuf_for_target<wchar_t>
        {
            static const bool value = false;
        };



        template<class Traits, class Alloc>
        struct lcast_streambuf_for_target<
                    std::basic_string<char,Traits,Alloc> >
        {
            static const bool value = false;
        };


        template<class Traits, class Alloc>
        struct lcast_streambuf_for_target<
                    std::basic_string<wchar_t,Traits,Alloc> >
        {
            static const bool value = false;
        };
# 1091 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
    }





    namespace detail
    {
        template<class T>
        struct array_to_pointer_decay
        {
            typedef T type;
        };

        template<class T, std::size_t N>
        struct array_to_pointer_decay<T[N]>
        {
            typedef const T * type;
        };

        template< typename Target
                , typename Source
                , bool Unlimited
                , typename CharT
                >
        Target lexical_cast(
            typename boost::call_traits<Source>::param_type arg,
            CharT* buf, std::size_t src_len)
        {
            typedef typename
                deduce_char_traits<CharT,Target,Source>::type traits;

            typedef typename boost::mpl::if_c<
                lcast_streambuf_for_target<Target>::value ||
                lcast_streambuf_for_source<Source>::value
              , std::basic_streambuf<CharT>
              , lexical_streambuf_fake
              >::type base;

            typename boost::mpl::if_c<
                Unlimited
              , detail::lexical_stream<Target,Source,traits>
              , detail::lexical_stream_limited_src<CharT,base,traits>
              >::type interpreter(buf, buf + src_len);
# 1146 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
            if(interpreter << arg) {
                Target result;
                if (interpreter >> result)
                    return result;
            }
            throw_exception(bad_lexical_cast(typeid(Source), typeid(Target)));
            return Target();
        }
    }

    template<typename Target, typename Source>
    inline Target lexical_cast(const Source &arg)
    {
        typedef typename detail::array_to_pointer_decay<Source>::type src;

        typedef typename detail::widest_char<
            typename detail::stream_char<Target>::type
          , typename detail::stream_char<src>::type
          >::type char_type;

        typedef detail::lcast_src_length<char_type, src> lcast_src_length;
        std::size_t const src_len = lcast_src_length::value;
        char_type buf[src_len + 1];
        lcast_src_length::check_coverage();
        return detail::lexical_cast<Target, src, !src_len>(arg, buf, src_len);
    }
# 1195 "/Library/Application Support/MonkeyWorks/Developer/include/boost/lexical_cast.hpp" 3
}
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/string_parse_tree.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/case_conv.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/case_conv.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/transform_iterator.hpp" 1 3
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/transform_iterator.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iterate.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/iterate.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/array/elem.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/array/elem.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/array/data.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/array/elem.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/array/size.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/array/elem.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/iterate.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/slot/slot.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/slot/slot.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/slot/detail/def.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/slot/slot.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/iterate.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iterate.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/prologue.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/prologue.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/prologue.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_base.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_base.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_base.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/composite_traits.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_base.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/ref.hpp" 1 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/ref.hpp" 3
namespace boost
{

template<class T> class reference_wrapper
{
public:
    typedef T type;







    explicit reference_wrapper(T& t): t_(boost::addressof(t)) {}



    operator T& () const { return *t_; }

    T& get() const { return *t_; }

    T* get_pointer() const { return t_; }

private:

    T* t_;
};







template<class T> inline reference_wrapper<T> const ref(T & t)
{
    return reference_wrapper<T>(t);
}

template<class T> inline reference_wrapper<T const> const cref(T const & t)
{
    return reference_wrapper<T const>(t);
}





template<typename T>
class is_reference_wrapper
    : public mpl::false_
{
};

template<typename T>
class unwrap_reference
{
 public:
    typedef T type;
};
# 106 "/Library/Application Support/MonkeyWorks/Developer/include/boost/ref.hpp" 3
template<typename T> class is_reference_wrapper< reference_wrapper<T> > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> > { public: typedef T type; };

template<typename T> class is_reference_wrapper< reference_wrapper<T> const > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> volatile > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> const volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const volatile > { public: typedef T type; };
# 176 "/Library/Application Support/MonkeyWorks/Developer/include/boost/ref.hpp" 3
}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_base.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_base.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function_equal.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function_equal.hpp" 3
namespace boost {

template<typename F, typename G>
  bool function_equal_impl(const F& f, const G& g, long)
  { return f == g; }




template<typename F, typename G>
  bool function_equal(const F& f, const G& g)
  { return function_equal_impl(f, g, 0); }

}
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_base.hpp" 2 3
# 96 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_base.hpp" 3
namespace boost {

template<typename Signature>
class function;

template<typename Signature>
inline void swap(function<Signature>& f1,
                 function<Signature>& f2)
{
  f1.swap(f2);
}

}


namespace boost {
  namespace detail {
    namespace function {
      class X;







      union function_buffer
      {

        void* obj_ptr;



        const void* const_obj_ptr;


        mutable void (*func_ptr)();


        struct bound_memfunc_ptr_t {
          void (X::*memfunc_ptr)(int);
          void* obj_ptr;
        } bound_memfunc_ptr;


        mutable char data;
      };







      struct unusable
      {
        unusable() {}
        template<typename T> unusable(const T&) {}
      };





      template<typename T> struct function_return_type { typedef T type; };

      template<>
      struct function_return_type<void>
      {
        typedef unusable type;
      };


      enum functor_manager_operation_type {
        clone_functor_tag,
        destroy_functor_tag,
        check_functor_type_tag,
        get_functor_type_tag
      };


      struct function_ptr_tag {};
      struct function_obj_tag {};
      struct member_ptr_tag {};
      struct function_obj_ref_tag {};

      template<typename F>
      class get_function_tag
      {
        typedef typename mpl::if_c<(is_pointer<F>::value),
                                   function_ptr_tag,
                                   function_obj_tag>::type ptr_or_obj_tag;

        typedef typename mpl::if_c<(is_member_pointer<F>::value),
                                   member_ptr_tag,
                                   ptr_or_obj_tag>::type ptr_or_obj_or_mem_tag;

        typedef typename mpl::if_c<(is_reference_wrapper<F>::value),
                                   function_obj_ref_tag,
                                   ptr_or_obj_or_mem_tag>::type or_ref_tag;

      public:
        typedef or_ref_tag type;
      };



      template<typename F>
      struct reference_manager
      {
        static inline void
        get(const function_buffer& in_buffer, function_buffer& out_buffer,
            functor_manager_operation_type op)
        {
          switch (op) {
          case clone_functor_tag:
            out_buffer.obj_ptr = in_buffer.obj_ptr;
            return;

          case destroy_functor_tag:
            out_buffer.obj_ptr = 0;
            return;

          case check_functor_type_tag:
            {



              const std::type_info& check_type =
                *static_cast<const std::type_info*>(out_buffer.const_obj_ptr);
              if ((std::strcmp((check_type).name(),(typeid(F)).name()) == 0))
                out_buffer.obj_ptr = in_buffer.obj_ptr;
              else
                out_buffer.obj_ptr = 0;
            }
            return;

          case get_functor_type_tag:
            out_buffer.const_obj_ptr = &typeid(F);
            return;
          }
        }
      };





      template<typename F>
      struct function_allows_small_object_optimization
      {
        static const bool value = ((sizeof(F) <= sizeof(function_buffer) && (alignment_of<function_buffer>::value % alignment_of<F>::value == 0)));




      };

      template <typename F,typename A>
      struct functor_wrapper: public F, public A
      {
        functor_wrapper( F f, A a ):
          F(f),
          A(a)
        {
        }
      };





      template<typename Functor>
      struct functor_manager_common
      {
        typedef Functor functor_type;


        static inline void
        manage_ptr(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op)
        {
          if (op == clone_functor_tag)
            out_buffer.func_ptr = in_buffer.func_ptr;
          else if (op == destroy_functor_tag)
            out_buffer.func_ptr = 0;
          else {
            const std::type_info& check_type =
              *static_cast<const std::type_info*>(out_buffer.const_obj_ptr);
            if ((std::strcmp((check_type).name(),(typeid(Functor)).name()) == 0))
              out_buffer.obj_ptr = &in_buffer.func_ptr;
            else
              out_buffer.obj_ptr = 0;
          }
        }


        static inline void
        manage_small(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op)
        {
          if (op == clone_functor_tag) {
            const functor_type* in_functor =
              reinterpret_cast<const functor_type*>(&in_buffer.data);
            new ((void*)&out_buffer.data) functor_type(*in_functor);
          } else if (op == destroy_functor_tag) {

            reinterpret_cast<functor_type*>(&out_buffer.data)->~Functor();
          } else {
            const std::type_info& check_type =
              *static_cast<const std::type_info*>(out_buffer.const_obj_ptr);
            if ((std::strcmp((check_type).name(),(typeid(Functor)).name()) == 0))
              out_buffer.obj_ptr = &in_buffer.data;
            else
              out_buffer.obj_ptr = 0;
          }
        }
      };

      template<typename Functor>
      struct functor_manager
      {
      private:
        typedef Functor functor_type;


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_ptr_tag)
        {
          functor_manager_common<Functor>::manage_ptr(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, mpl::true_)
        {
          functor_manager_common<Functor>::manage_small(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, mpl::false_)
        {
          if (op == clone_functor_tag) {



            const functor_type* f =
              (const functor_type*)(in_buffer.obj_ptr);
            functor_type* new_f = new functor_type(*f);
            out_buffer.obj_ptr = new_f;
          } else if (op == destroy_functor_tag) {

            functor_type* f =
              static_cast<functor_type*>(out_buffer.obj_ptr);
            delete f;
            out_buffer.obj_ptr = 0;
          } else {
            const std::type_info& check_type =
              *static_cast<const std::type_info*>(out_buffer.const_obj_ptr);
            if ((std::strcmp((check_type).name(),(typeid(Functor)).name()) == 0))
              out_buffer.obj_ptr = in_buffer.obj_ptr;
            else
              out_buffer.obj_ptr = 0;
          }
        }




        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_obj_tag)
        {
          manager(in_buffer, out_buffer, op,
                  mpl::bool_<(function_allows_small_object_optimization<functor_type>::value)>());
        }

      public:


        static inline void
        manage(const function_buffer& in_buffer, function_buffer& out_buffer,
               functor_manager_operation_type op)
        {
          typedef typename get_function_tag<functor_type>::type tag_type;
          switch (op) {
          case get_functor_type_tag:
            out_buffer.const_obj_ptr = &typeid(functor_type);
            return;

          default:
            manager(in_buffer, out_buffer, op, tag_type());
            return;
          }
        }
      };

      template<typename Functor, typename Allocator>
      struct functor_manager_a
      {
      private:
        typedef Functor functor_type;


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_ptr_tag)
        {
          functor_manager_common<Functor>::manage_ptr(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, mpl::true_)
        {
          functor_manager_common<Functor>::manage_small(in_buffer,out_buffer,op);
        }


        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, mpl::false_)
        {
          typedef functor_wrapper<Functor,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;

          if (op == clone_functor_tag) {



            const functor_wrapper_type* f =
              (const functor_wrapper_type*)(in_buffer.obj_ptr);
            wrapper_allocator_type wrapper_allocator(static_cast<Allocator const &>(*f));
            wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
            wrapper_allocator.construct(copy, *f);


            functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
            out_buffer.obj_ptr = new_f;
          } else if (op == destroy_functor_tag) {

            functor_wrapper_type* victim =
              static_cast<functor_wrapper_type*>(in_buffer.obj_ptr);
            wrapper_allocator_type wrapper_allocator(static_cast<Allocator const &>(*victim));
            wrapper_allocator.destroy(victim);
            wrapper_allocator.deallocate(victim,1);
            out_buffer.obj_ptr = 0;
          } else {
            const std::type_info& check_type =
              *static_cast<const std::type_info*>(out_buffer.const_obj_ptr);
            if ((std::strcmp((check_type).name(),(typeid(Functor)).name()) == 0))
              out_buffer.obj_ptr = in_buffer.obj_ptr;
            else
              out_buffer.obj_ptr = 0;
          }
        }




        static inline void
        manager(const function_buffer& in_buffer, function_buffer& out_buffer,
                functor_manager_operation_type op, function_obj_tag)
        {
          manager(in_buffer, out_buffer, op,
                  mpl::bool_<(function_allows_small_object_optimization<functor_type>::value)>());
        }

      public:


        static inline void
        manage(const function_buffer& in_buffer, function_buffer& out_buffer,
               functor_manager_operation_type op)
        {
          typedef typename get_function_tag<functor_type>::type tag_type;
          switch (op) {
          case get_functor_type_tag:
            out_buffer.const_obj_ptr = &typeid(functor_type);
            return;

          default:
            manager(in_buffer, out_buffer, op, tag_type());
            return;
          }
        }
      };


      struct useless_clear_type {};
# 557 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_base.hpp" 3
      struct vtable_base
      {
        vtable_base() : manager(0) { }
        void (*manager)(const function_buffer& in_buffer,
                        function_buffer& out_buffer,
                        functor_manager_operation_type op);
      };
    }
  }







class function_base
{
public:
  function_base() : vtable(0) { }


  bool empty() const { return !vtable; }



  const std::type_info& target_type() const
  {
    if (!vtable) return typeid(void);

    detail::function::function_buffer type;
    vtable->manager(functor, type, detail::function::get_functor_type_tag);
    return *static_cast<const std::type_info*>(type.const_obj_ptr);
  }

  template<typename Functor>
    Functor* target()
    {
      if (!vtable) return 0;

      detail::function::function_buffer type_result;
      type_result.const_obj_ptr = &typeid(Functor);
      vtable->manager(functor, type_result,
                      detail::function::check_functor_type_tag);
      return static_cast<Functor*>(type_result.obj_ptr);
    }

  template<typename Functor>



    const Functor* target() const

    {
      if (!vtable) return 0;

      detail::function::function_buffer type_result;
      type_result.const_obj_ptr = &typeid(Functor);
      vtable->manager(functor, type_result,
                      detail::function::check_functor_type_tag);


      return (const Functor*)(type_result.obj_ptr);
    }

  template<typename F>
    bool contains(const F& f) const
    {



      if (const F* fp = this->template target<F>())

      {
        return function_equal(*fp, f);
      } else {
        return false;
      }
    }
# 660 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_base.hpp" 3
public:
  detail::function::vtable_base* vtable;
  mutable detail::function::function_buffer functor;
};





class bad_function_call : public std::runtime_error
{
public:
  bad_function_call() : std::runtime_error("call to empty boost::function") {}
};


inline bool operator==(const function_base& f,
                       detail::function::useless_clear_type*)
{
  return f.empty();
}

inline bool operator!=(const function_base& f,
                       detail::function::useless_clear_type*)
{
  return !f.empty();
}

inline bool operator==(detail::function::useless_clear_type*,
                       const function_base& f)
{
  return f.empty();
}

inline bool operator!=(detail::function::useless_clear_type*,
                       const function_base& f)
{
  return !f.empty();
}
# 736 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_base.hpp" 3
template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(const function_base& f, Functor g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return function_equal(*fp, g);
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(Functor g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return function_equal(g, *fp);
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(const function_base& f, Functor g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return !function_equal(*fp, g);
    else return true;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(Functor g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return !function_equal(g, *fp);
    else return true;
  }


template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(const function_base& f, reference_wrapper<Functor> g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return fp == g.get_pointer();
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator==(reference_wrapper<Functor> g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return g.get_pointer() == fp;
    else return false;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(const function_base& f, reference_wrapper<Functor> g)
  {
    if (const Functor* fp = f.template target<Functor>())
      return fp != g.get_pointer();
    else return true;
  }

template<typename Functor>
  typename ::boost::enable_if_c<(::boost::type_traits::ice_not< (::boost::is_integral<Functor>::value)>::value), bool>::type
  operator!=(reference_wrapper<Functor> g, const function_base& f)
  {
    if (const Functor* fp = f.template target<Functor>())
      return g.get_pointer() != fp;
    else return true;
  }



namespace detail {
  namespace function {
    inline bool has_empty_target(const function_base* f)
    {
      return f->empty();
    }







    inline bool has_empty_target(...)
    {
      return false;
    }

  }
}
}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mem_fn.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mem_fn.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/get_pointer.hpp" 1 3
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/get_pointer.hpp" 3
namespace boost {



template<class T> T * get_pointer(T * p)
{
    return p;
}



template<class T> T * get_pointer(std::auto_ptr<T> const& p)
{
    return p.get();
}


}
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mem_fn.hpp" 2 3


namespace boost
{
# 207 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mem_fn.hpp" 3
namespace _mfi
{






# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/bind/mem_fn_template.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/bind/mem_fn_template.hpp" 3
template<class R, class T > class mf0
{
public:

    typedef R result_type;
    typedef T * argument_type;

private:

    typedef R ( T::*F) ();
    F f_;

    template<class U> R call(U & u, T const *) const
    {
        return (u.*f_)();
    }

    template<class U> R call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_)();
    }

public:

    explicit mf0(F f): f_(f) {}

    R operator()(T * p) const
    {
        return (p->*f_)();
    }

    template<class U> R operator()(U & u) const
    {
        return call(u, &u);
    }



    template<class U> R operator()(U const & u) const
    {
        return call(u, &u);
    }



    R operator()(T & t) const
    {
        return (t.*f_)();
    }

    bool operator==(mf0 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf0 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T > class cmf0
{
public:

    typedef R result_type;
    typedef T const * argument_type;

private:

    typedef R ( T::*F) () const;
    F f_;

    template<class U> R call(U & u, T const *) const
    {
        return (u.*f_)();
    }

    template<class U> R call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_)();
    }

public:

    explicit cmf0(F f): f_(f) {}

    template<class U> R operator()(U const & u) const
    {
        return call(u, &u);
    }

    R operator()(T const & t) const
    {
        return (t.*f_)();
    }

    bool operator==(cmf0 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf0 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1 > class mf1
{
public:

    typedef R result_type;
    typedef T * first_argument_type;
    typedef A1 second_argument_type;

private:

    typedef R ( T::*F) (A1);
    F f_;

    template<class U, class B1> R call(U & u, T const *, B1 & b1) const
    {
        return (u.*f_)(b1);
    }

    template<class U, class B1> R call(U & u, void const *, B1 & b1) const
    {
        return (get_pointer(u)->*f_)(b1);
    }

public:

    explicit mf1(F f): f_(f) {}

    R operator()(T * p, A1 a1) const
    {
        return (p->*f_)(a1);
    }

    template<class U> R operator()(U & u, A1 a1) const
    {
        return call(u, &u, a1);
    }



    template<class U> R operator()(U const & u, A1 a1) const
    {
        return call(u, &u, a1);
    }



    R operator()(T & t, A1 a1) const
    {
        return (t.*f_)(a1);
    }

    bool operator==(mf1 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf1 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1 > class cmf1
{
public:

    typedef R result_type;
    typedef T const * first_argument_type;
    typedef A1 second_argument_type;

private:

    typedef R ( T::*F) (A1) const;
    F f_;

    template<class U, class B1> R call(U & u, T const *, B1 & b1) const
    {
        return (u.*f_)(b1);
    }

    template<class U, class B1> R call(U & u, void const *, B1 & b1) const
    {
        return (get_pointer(u)->*f_)(b1);
    }

public:

    explicit cmf1(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1) const
    {
        return call(u, &u, a1);
    }

    R operator()(T const & t, A1 a1) const
    {
        return (t.*f_)(a1);
    }

    bool operator==(cmf1 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf1 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2 > class mf2
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2);
    F f_;

    template<class U, class B1, class B2> R call(U & u, T const *, B1 & b1, B2 & b2) const
    {
        return (u.*f_)(b1, b2);
    }

    template<class U, class B1, class B2> R call(U & u, void const *, B1 & b1, B2 & b2) const
    {
        return (get_pointer(u)->*f_)(b1, b2);
    }

public:

    explicit mf2(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2) const
    {
        return (p->*f_)(a1, a2);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2) const
    {
        return call(u, &u, a1, a2);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2) const
    {
        return call(u, &u, a1, a2);
    }



    R operator()(T & t, A1 a1, A2 a2) const
    {
        return (t.*f_)(a1, a2);
    }

    bool operator==(mf2 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf2 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2 > class cmf2
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2) const;
    F f_;

    template<class U, class B1, class B2> R call(U & u, T const *, B1 & b1, B2 & b2) const
    {
        return (u.*f_)(b1, b2);
    }

    template<class U, class B1, class B2> R call(U & u, void const *, B1 & b1, B2 & b2) const
    {
        return (get_pointer(u)->*f_)(b1, b2);
    }

public:

    explicit cmf2(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2) const
    {
        return call(u, &u, a1, a2);
    }

    R operator()(T const & t, A1 a1, A2 a2) const
    {
        return (t.*f_)(a1, a2);
    }

    bool operator==(cmf2 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf2 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3 > class mf3
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3);
    F f_;

    template<class U, class B1, class B2, class B3> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (u.*f_)(b1, b2, b3);
    }

    template<class U, class B1, class B2, class B3> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3);
    }

public:

    explicit mf3(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3) const
    {
        return (p->*f_)(a1, a2, a3);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3) const
    {
        return call(u, &u, a1, a2, a3);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3) const
    {
        return call(u, &u, a1, a2, a3);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3) const
    {
        return (t.*f_)(a1, a2, a3);
    }

    bool operator==(mf3 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf3 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3 > class cmf3
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3) const;
    F f_;

    template<class U, class B1, class B2, class B3> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (u.*f_)(b1, b2, b3);
    }

    template<class U, class B1, class B2, class B3> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3);
    }

public:

    explicit cmf3(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3) const
    {
        return call(u, &u, a1, a2, a3);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3) const
    {
        return (t.*f_)(a1, a2, a3);
    }

    bool operator==(cmf3 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf3 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4 > class mf4
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4);
    F f_;

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (u.*f_)(b1, b2, b3, b4);
    }

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4);
    }

public:

    explicit mf4(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (p->*f_)(a1, a2, a3, a4);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return call(u, &u, a1, a2, a3, a4);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return call(u, &u, a1, a2, a3, a4);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (t.*f_)(a1, a2, a3, a4);
    }

    bool operator==(mf4 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf4 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4 > class cmf4
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (u.*f_)(b1, b2, b3, b4);
    }

    template<class U, class B1, class B2, class B3, class B4> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4);
    }

public:

    explicit cmf4(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return call(u, &u, a1, a2, a3, a4);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4) const
    {
        return (t.*f_)(a1, a2, a3, a4);
    }

    bool operator==(cmf4 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf4 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5 > class mf5
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5);
    }

public:

    explicit mf5(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return call(u, &u, a1, a2, a3, a4, a5);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return call(u, &u, a1, a2, a3, a4, a5);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5);
    }

    bool operator==(mf5 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf5 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5 > class cmf5
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5);
    }

public:

    explicit cmf5(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return call(u, &u, a1, a2, a3, a4, a5);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5);
    }

    bool operator==(cmf5 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf5 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6 > class mf6
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);
    }

public:

    explicit mf6(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6);
    }

    bool operator==(mf6 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf6 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6 > class cmf6
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);
    }

public:

    explicit cmf6(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6);
    }

    bool operator==(cmf6 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf6 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7 > class mf7
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

public:

    explicit mf7(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    bool operator==(mf7 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf7 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7 > class cmf7
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7);
    }

public:

    explicit cmf7(F f): f_(f) {}

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7);
    }

    bool operator==(cmf7 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf7 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class mf8
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7, A8);
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

public:

    explicit mf8(F f): f_(f) {}

    R operator()(T * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    template<class U> R operator()(U & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7, a8);
    }



    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7, a8);
    }



    R operator()(T & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    bool operator==(mf8 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(mf8 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};



template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8 > class cmf8
{
public:

    typedef R result_type;

private:

    typedef R ( T::*F) (A1, A2, A3, A4, A5, A6, A7, A8) const;
    F f_;

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, T const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (u.*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

    template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8> R call(U & u, void const *, B1 & b1, B2 & b2, B3 & b3, B4 & b4, B5 & b5, B6 & b6, B7 & b7, B8 & b8) const
    {
        return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
    }

public:

    explicit cmf8(F f): f_(f) {}

    R operator()(T const * p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (p->*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    template<class U> R operator()(U const & u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return call(u, &u, a1, a2, a3, a4, a5, a6, a7, a8);
    }

    R operator()(T const & t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
    {
        return (t.*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
    }

    bool operator==(cmf8 const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(cmf8 const & rhs) const
    {
        return f_ != rhs.f_;
    }
};
# 216 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mem_fn.hpp" 2 3
# 258 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mem_fn.hpp" 3
}
# 268 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mem_fn.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/bind/mem_fn_cc.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/bind/mem_fn_cc.hpp" 3
template<class R, class T> _mfi::mf0<R, T> mem_fn(R ( T::*f) ())
{
    return _mfi::mf0<R, T>(f);
}

template<class R, class T> _mfi::cmf0<R, T> mem_fn(R ( T::*f) () const)
{
    return _mfi::cmf0<R, T>(f);
}

template<class R, class T, class A1> _mfi::mf1<R, T, A1> mem_fn(R ( T::*f) (A1))
{
    return _mfi::mf1<R, T, A1>(f);
}

template<class R, class T, class A1> _mfi::cmf1<R, T, A1> mem_fn(R ( T::*f) (A1) const)
{
    return _mfi::cmf1<R, T, A1>(f);
}

template<class R, class T, class A1, class A2> _mfi::mf2<R, T, A1, A2> mem_fn(R ( T::*f) (A1, A2))
{
    return _mfi::mf2<R, T, A1, A2>(f);
}

template<class R, class T, class A1, class A2> _mfi::cmf2<R, T, A1, A2> mem_fn(R ( T::*f) (A1, A2) const)
{
    return _mfi::cmf2<R, T, A1, A2>(f);
}

template<class R, class T, class A1, class A2, class A3> _mfi::mf3<R, T, A1, A2, A3> mem_fn(R ( T::*f) (A1, A2, A3))
{
    return _mfi::mf3<R, T, A1, A2, A3>(f);
}

template<class R, class T, class A1, class A2, class A3> _mfi::cmf3<R, T, A1, A2, A3> mem_fn(R ( T::*f) (A1, A2, A3) const)
{
    return _mfi::cmf3<R, T, A1, A2, A3>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4> _mfi::mf4<R, T, A1, A2, A3, A4> mem_fn(R ( T::*f) (A1, A2, A3, A4))
{
    return _mfi::mf4<R, T, A1, A2, A3, A4>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4> _mfi::cmf4<R, T, A1, A2, A3, A4> mem_fn(R ( T::*f) (A1, A2, A3, A4) const)
{
    return _mfi::cmf4<R, T, A1, A2, A3, A4>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5> _mfi::mf5<R, T, A1, A2, A3, A4, A5> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5))
{
    return _mfi::mf5<R, T, A1, A2, A3, A4, A5>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5> _mfi::cmf5<R, T, A1, A2, A3, A4, A5> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5) const)
{
    return _mfi::cmf5<R, T, A1, A2, A3, A4, A5>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6> _mfi::mf6<R, T, A1, A2, A3, A4, A5, A6> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6))
{
    return _mfi::mf6<R, T, A1, A2, A3, A4, A5, A6>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6> _mfi::cmf6<R, T, A1, A2, A3, A4, A5, A6> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6) const)
{
    return _mfi::cmf6<R, T, A1, A2, A3, A4, A5, A6>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7> _mfi::mf7<R, T, A1, A2, A3, A4, A5, A6, A7> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7))
{
    return _mfi::mf7<R, T, A1, A2, A3, A4, A5, A6, A7>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7> _mfi::cmf7<R, T, A1, A2, A3, A4, A5, A6, A7> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7) const)
{
    return _mfi::cmf7<R, T, A1, A2, A3, A4, A5, A6, A7>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> _mfi::mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7, A8))
{
    return _mfi::mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>(f);
}

template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> _mfi::cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8> mem_fn(R ( T::*f) (A1, A2, A3, A4, A5, A6, A7, A8) const)
{
    return _mfi::cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>(f);
}
# 269 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mem_fn.hpp" 2 3
# 311 "/Library/Application Support/MonkeyWorks/Developer/include/boost/mem_fn.hpp" 3
namespace _mfi
{

template<class R, class T> class dm
{
public:

    typedef R const & result_type;
    typedef T const * argument_type;

private:

    typedef R (T::*F);
    F f_;

    template<class U> R const & call(U & u, T const *) const
    {
        return (u.*f_);
    }

    template<class U> R const & call(U & u, void const *) const
    {
        return (get_pointer(u)->*f_);
    }

public:

    explicit dm(F f): f_(f) {}

    R & operator()(T * p) const
    {
        return (p->*f_);
    }

    R const & operator()(T const * p) const
    {
        return (p->*f_);
    }

    template<class U> R const & operator()(U const & u) const
    {
        return call(u, &u);
    }



    R & operator()(T & t) const
    {
        return (t.*f_);
    }

    R const & operator()(T const & t) const
    {
        return (t.*f_);
    }



    bool operator==(dm const & rhs) const
    {
        return f_ == rhs.f_;
    }

    bool operator!=(dm const & rhs) const
    {
        return f_ != rhs.f_;
    }
};

}

template<class R, class T> _mfi::dm<R, T> mem_fn(R T::*f)
{
    return _mfi::dm<R, T>(f);
}

}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/prologue.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/enum.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/enum.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/enum.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/enum.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/detail/auto_rec.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/repetition/enum.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/enum.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/prologue.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/enum_params.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/prologue.hpp" 2 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function.hpp" 2 3
# 64 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R
       
        >
      struct function_invoker0
      {
        static R invoke(function_buffer& function_ptr
                        )
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f();
        }
      };

      template<
        typename FunctionPtr,
        typename R
       
        >
      struct void_function_invoker0
      {
        static void
        invoke(function_buffer& function_ptr
               )

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct function_obj_invoker0
      {
        static R invoke(function_buffer& function_obj_ptr
                        )

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct void_function_obj_invoker0
      {
        static void
        invoke(function_buffer& function_obj_ptr
               )

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct function_ref_invoker0
      {
        static R invoke(function_buffer& function_obj_ptr
                        )

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)();
        }
      };

      template<
        typename FunctionObj,
        typename R
       
      >
      struct void_function_ref_invoker0
      {
        static void
        invoke(function_buffer& function_obj_ptr
               )

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)();
        }
      };

      template<
        typename FunctionPtr,
        typename R
       
      >
      struct get_function_invoker0
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker0<
                            FunctionPtr,
                            R
                           
                          >,
                          function_invoker0<
                            FunctionPtr,
                            R
                           
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R
       
       >
      struct get_function_obj_invoker0
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker0<
                            FunctionObj,
                            R
                           
                          >,
                          function_obj_invoker0<
                            FunctionObj,
                            R
                           
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R
       
       >
      struct get_function_ref_invoker0
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker0<
                            FunctionObj,
                            R
                           
                          >,
                          function_ref_invoker0<
                            FunctionObj,
                            R
                           
                          >
                       >::type type;
      };




      template<typename R >
      struct basic_vtable0 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                           
                                            );

        template<typename F>
        basic_vtable0(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }
        template<typename F,typename Allocator>
        basic_vtable0(F f, Allocator) : vtable_base(), invoker(0)
        {
          init_a<Allocator>(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }
        template<typename Allocator,typename F>
        void init_a(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init_a<Allocator>(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker0<
                             FunctionPtr,
                             R
                            
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr>::manage;
        }
        template<typename Allocator,typename FunctionPtr>
        void init_a(FunctionPtr f, function_ptr_tag)
        {
          typedef typename get_function_invoker0<
                             FunctionPtr,
                             R
                            
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }
# 403 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker0<
                             FunctionObj,
                             R
                            
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj>::manage;
        }
        template<typename Allocator,typename FunctionObj>
        void init_a(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker0<
                             FunctionObj,
                             R
                            
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker0<
                             FunctionObj,
                             R
                            
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }
        template<typename Allocator,typename FunctionObj>
        void
        init_a(const reference_wrapper<FunctionObj>& f, function_obj_ref_tag)
        {
          init(f,function_obj_ref_tag());
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R
   
  >
  class function0 : public function_base
# 559 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable0<
              R >
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 0;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 592 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    static const int arity = 0;
   

    typedef function0 self_type;

    function0() : function_base() { }



    template<typename Functor>
    function0(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function0(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function0(clear_type*) : function_base() { }







    function0(const function0& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function0() { clear(); }
# 656 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    result_type operator()() const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function0&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      try {
        this->assign_to_a(f,a);
      } catch (...) {
        vtable = 0;
        throw;
      }
    }


    function0& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 712 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    function0& operator=(const function0& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function0& other)
    {
      if (&other == this)
        return;

      function0 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function0& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      static vtable_type stored_vtable(f,a);
      if (stored_vtable.assign_to_a(f, functor, a)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R >
  inline void swap(function0<
                     R
                    
                   >& f1,
                   function0<
                     R
                    
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R >
  typename function0<
      R >::result_type
   function0<R >
  ::operator()() const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor );
  }



template<typename R >
  void operator==(const function0<
                          R
                          >&,
                  const function0<
                          R
                          >&);
template<typename R >
  void operator!=(const function0<
                          R
                          >&,
                  const function0<
                          R
                          >& );
# 843 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
template<typename R
         >
class function<R (void)>
  : public function0<R >
{
  typedef function0<R > base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0
        >
      struct function_invoker1
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0
        >
      struct void_function_invoker1
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct function_obj_invoker1
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct void_function_obj_invoker1
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct function_ref_invoker1
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
      >
      struct void_function_ref_invoker1
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0
      >
      struct get_function_invoker1
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker1<
                            FunctionPtr,
                            R ,
                            T0
                          >,
                          function_invoker1<
                            FunctionPtr,
                            R ,
                            T0
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
       >
      struct get_function_obj_invoker1
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >,
                          function_obj_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0
       >
      struct get_function_ref_invoker1
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >,
                          function_ref_invoker1<
                            FunctionObj,
                            R ,
                            T0
                          >
                       >::type type;
      };




      template<typename R , typename T0>
      struct basic_vtable1 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0);

        template<typename F>
        basic_vtable1(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }
        template<typename F,typename Allocator>
        basic_vtable1(F f, Allocator) : vtable_base(), invoker(0)
        {
          init_a<Allocator>(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }
        template<typename Allocator,typename F>
        void init_a(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init_a<Allocator>(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker1<
                             FunctionPtr,
                             R ,
                             T0
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr>::manage;
        }
        template<typename Allocator,typename FunctionPtr>
        void init_a(FunctionPtr f, function_ptr_tag)
        {
          typedef typename get_function_invoker1<
                             FunctionPtr,
                             R ,
                             T0
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }
        template<typename Allocator,typename MemberPtr>
        void init_a(MemberPtr f, member_ptr_tag)
        {



          this->init_a<Allocator>(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker1<
                             FunctionObj,
                             R ,
                             T0
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj>::manage;
        }
        template<typename Allocator,typename FunctionObj>
        void init_a(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker1<
                             FunctionObj,
                             R ,
                             T0
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker1<
                             FunctionObj,
                             R ,
                             T0
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }
        template<typename Allocator,typename FunctionObj>
        void
        init_a(const reference_wrapper<FunctionObj>& f, function_obj_ref_tag)
        {
          init(f,function_obj_ref_tag());
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0
  >
  class function1 : public function_base



    , public std::unary_function<T0,R>







  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable1<
              R , T0>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 1;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };


    typedef T0 argument_type;





    static const int arity = 1;
    typedef T0 arg1_type;

    typedef function1 self_type;

    function1() : function_base() { }



    template<typename Functor>
    function1(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function1(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function1(clear_type*) : function_base() { }







    function1(const function1& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function1() { clear(); }
# 656 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function1&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      try {
        this->assign_to_a(f,a);
      } catch (...) {
        vtable = 0;
        throw;
      }
    }


    function1& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 712 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    function1& operator=(const function1& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function1& other)
    {
      if (&other == this)
        return;

      function1 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function1& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      static vtable_type stored_vtable(f,a);
      if (stored_vtable.assign_to_a(f, functor, a)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0>
  inline void swap(function1<
                     R ,
                     T0
                   >& f1,
                   function1<
                     R ,
                     T0
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0>
  typename function1<
      R , T0>::result_type
   function1<R , T0>
  ::operator()( T0 a0) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0);
  }



template<typename R , typename T0>
  void operator==(const function1<
                          R ,
                          T0>&,
                  const function1<
                          R ,
                          T0>&);
template<typename R , typename T0>
  void operator!=(const function1<
                          R ,
                          T0>&,
                  const function1<
                          R ,
                          T0>& );
# 843 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0>
class function<R ( T0)>
  : public function1<R , T0>
{
  typedef function1<R , T0> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
        >
      struct function_invoker2
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
        >
      struct void_function_invoker2
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct function_obj_invoker2
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct void_function_obj_invoker2
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct function_ref_invoker2
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
      >
      struct void_function_ref_invoker2
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1
      >
      struct get_function_invoker2
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker2<
                            FunctionPtr,
                            R ,
                            T0 , T1
                          >,
                          function_invoker2<
                            FunctionPtr,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
       >
      struct get_function_obj_invoker2
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >,
                          function_obj_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1
       >
      struct get_function_ref_invoker2
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >,
                          function_ref_invoker2<
                            FunctionObj,
                            R ,
                            T0 , T1
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1>
      struct basic_vtable2 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1);

        template<typename F>
        basic_vtable2(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }
        template<typename F,typename Allocator>
        basic_vtable2(F f, Allocator) : vtable_base(), invoker(0)
        {
          init_a<Allocator>(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }
        template<typename Allocator,typename F>
        void init_a(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init_a<Allocator>(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker2<
                             FunctionPtr,
                             R ,
                             T0 , T1
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr>::manage;
        }
        template<typename Allocator,typename FunctionPtr>
        void init_a(FunctionPtr f, function_ptr_tag)
        {
          typedef typename get_function_invoker2<
                             FunctionPtr,
                             R ,
                             T0 , T1
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }
        template<typename Allocator,typename MemberPtr>
        void init_a(MemberPtr f, member_ptr_tag)
        {



          this->init_a<Allocator>(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker2<
                             FunctionObj,
                             R ,
                             T0 , T1
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj>::manage;
        }
        template<typename Allocator,typename FunctionObj>
        void init_a(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker2<
                             FunctionObj,
                             R ,
                             T0 , T1
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker2<
                             FunctionObj,
                             R ,
                             T0 , T1
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }
        template<typename Allocator,typename FunctionObj>
        void
        init_a(const reference_wrapper<FunctionObj>& f, function_obj_ref_tag)
        {
          init(f,function_obj_ref_tag());
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1
  >
  class function2 : public function_base







    , public std::binary_function<T0,T1,R>



  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable2<
              R , T0 , T1>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 2;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };




    typedef T0 first_argument_type;
    typedef T1 second_argument_type;


    static const int arity = 2;
    typedef T0 arg1_type; typedef T1 arg2_type;

    typedef function2 self_type;

    function2() : function_base() { }



    template<typename Functor>
    function2(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function2(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function2(clear_type*) : function_base() { }







    function2(const function2& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function2() { clear(); }
# 656 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function2&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      try {
        this->assign_to_a(f,a);
      } catch (...) {
        vtable = 0;
        throw;
      }
    }


    function2& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 712 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    function2& operator=(const function2& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function2& other)
    {
      if (&other == this)
        return;

      function2 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function2& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      static vtable_type stored_vtable(f,a);
      if (stored_vtable.assign_to_a(f, functor, a)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1>
  inline void swap(function2<
                     R ,
                     T0 , T1
                   >& f1,
                   function2<
                     R ,
                     T0 , T1
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1>
  typename function2<
      R , T0 , T1>::result_type
   function2<R , T0 , T1>
  ::operator()( T0 a0 , T1 a1) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1);
  }



template<typename R , typename T0 , typename T1>
  void operator==(const function2<
                          R ,
                          T0 , T1>&,
                  const function2<
                          R ,
                          T0 , T1>&);
template<typename R , typename T0 , typename T1>
  void operator!=(const function2<
                          R ,
                          T0 , T1>&,
                  const function2<
                          R ,
                          T0 , T1>& );
# 843 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1>
class function<R ( T0 , T1)>
  : public function2<R , T0 , T1>
{
  typedef function2<R , T0 , T1> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 58 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
        >
      struct function_invoker3
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
        >
      struct void_function_invoker3
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct function_obj_invoker3
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct void_function_obj_invoker3
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct function_ref_invoker3
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct void_function_ref_invoker3
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2
      >
      struct get_function_invoker3
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker3<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2
                          >,
                          function_invoker3<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
       >
      struct get_function_obj_invoker3
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >,
                          function_obj_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2
       >
      struct get_function_ref_invoker3
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >,
                          function_ref_invoker3<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2>
      struct basic_vtable3 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2);

        template<typename F>
        basic_vtable3(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }
        template<typename F,typename Allocator>
        basic_vtable3(F f, Allocator) : vtable_base(), invoker(0)
        {
          init_a<Allocator>(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }
        template<typename Allocator,typename F>
        void init_a(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init_a<Allocator>(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker3<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr>::manage;
        }
        template<typename Allocator,typename FunctionPtr>
        void init_a(FunctionPtr f, function_ptr_tag)
        {
          typedef typename get_function_invoker3<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }
        template<typename Allocator,typename MemberPtr>
        void init_a(MemberPtr f, member_ptr_tag)
        {



          this->init_a<Allocator>(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker3<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj>::manage;
        }
        template<typename Allocator,typename FunctionObj>
        void init_a(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker3<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker3<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }
        template<typename Allocator,typename FunctionObj>
        void
        init_a(const reference_wrapper<FunctionObj>& f, function_obj_ref_tag)
        {
          init(f,function_obj_ref_tag());
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2
  >
  class function3 : public function_base
# 559 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable3<
              R , T0 , T1 , T2>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 3;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 592 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    static const int arity = 3;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type;

    typedef function3 self_type;

    function3() : function_base() { }



    template<typename Functor>
    function3(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function3(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function3(clear_type*) : function_base() { }







    function3(const function3& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function3() { clear(); }
# 656 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function3&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      try {
        this->assign_to_a(f,a);
      } catch (...) {
        vtable = 0;
        throw;
      }
    }


    function3& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 712 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    function3& operator=(const function3& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function3& other)
    {
      if (&other == this)
        return;

      function3 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function3& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      static vtable_type stored_vtable(f,a);
      if (stored_vtable.assign_to_a(f, functor, a)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2>
  inline void swap(function3<
                     R ,
                     T0 , T1 , T2
                   >& f1,
                   function3<
                     R ,
                     T0 , T1 , T2
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2>
  typename function3<
      R , T0 , T1 , T2>::result_type
   function3<R , T0 , T1 , T2>
  ::operator()( T0 a0 , T1 a1 , T2 a2) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2);
  }



template<typename R , typename T0 , typename T1 , typename T2>
  void operator==(const function3<
                          R ,
                          T0 , T1 , T2>&,
                  const function3<
                          R ,
                          T0 , T1 , T2>&);
template<typename R , typename T0 , typename T1 , typename T2>
  void operator!=(const function3<
                          R ,
                          T0 , T1 , T2>&,
                  const function3<
                          R ,
                          T0 , T1 , T2>& );
# 843 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2>
class function<R ( T0 , T1 , T2)>
  : public function3<R , T0 , T1 , T2>
{
  typedef function3<R , T0 , T1 , T2> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 63 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
        >
      struct function_invoker4
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
        >
      struct void_function_invoker4
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct function_obj_invoker4
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct void_function_obj_invoker4
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct function_ref_invoker4
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct void_function_ref_invoker4
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
      >
      struct get_function_invoker4
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker4<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3
                          >,
                          function_invoker4<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
       >
      struct get_function_obj_invoker4
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >,
                          function_obj_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3
       >
      struct get_function_ref_invoker4
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >,
                          function_ref_invoker4<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3>
      struct basic_vtable4 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3);

        template<typename F>
        basic_vtable4(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }
        template<typename F,typename Allocator>
        basic_vtable4(F f, Allocator) : vtable_base(), invoker(0)
        {
          init_a<Allocator>(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }
        template<typename Allocator,typename F>
        void init_a(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init_a<Allocator>(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker4<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr>::manage;
        }
        template<typename Allocator,typename FunctionPtr>
        void init_a(FunctionPtr f, function_ptr_tag)
        {
          typedef typename get_function_invoker4<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }
        template<typename Allocator,typename MemberPtr>
        void init_a(MemberPtr f, member_ptr_tag)
        {



          this->init_a<Allocator>(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker4<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj>::manage;
        }
        template<typename Allocator,typename FunctionObj>
        void init_a(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker4<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker4<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }
        template<typename Allocator,typename FunctionObj>
        void
        init_a(const reference_wrapper<FunctionObj>& f, function_obj_ref_tag)
        {
          init(f,function_obj_ref_tag());
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3
  >
  class function4 : public function_base
# 559 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable4<
              R , T0 , T1 , T2 , T3>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 4;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 592 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    static const int arity = 4;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type;

    typedef function4 self_type;

    function4() : function_base() { }



    template<typename Functor>
    function4(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function4(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function4(clear_type*) : function_base() { }







    function4(const function4& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function4() { clear(); }
# 656 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function4&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      try {
        this->assign_to_a(f,a);
      } catch (...) {
        vtable = 0;
        throw;
      }
    }


    function4& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 712 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    function4& operator=(const function4& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function4& other)
    {
      if (&other == this)
        return;

      function4 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function4& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      static vtable_type stored_vtable(f,a);
      if (stored_vtable.assign_to_a(f, functor, a)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3>
  inline void swap(function4<
                     R ,
                     T0 , T1 , T2 , T3
                   >& f1,
                   function4<
                     R ,
                     T0 , T1 , T2 , T3
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3>
  typename function4<
      R , T0 , T1 , T2 , T3>::result_type
   function4<R , T0 , T1 , T2 , T3>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3>
  void operator==(const function4<
                          R ,
                          T0 , T1 , T2 , T3>&,
                  const function4<
                          R ,
                          T0 , T1 , T2 , T3>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3>
  void operator!=(const function4<
                          R ,
                          T0 , T1 , T2 , T3>&,
                  const function4<
                          R ,
                          T0 , T1 , T2 , T3>& );
# 843 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3>
class function<R ( T0 , T1 , T2 , T3)>
  : public function4<R , T0 , T1 , T2 , T3>
{
  typedef function4<R , T0 , T1 , T2 , T3> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 68 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
        >
      struct function_invoker5
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
        >
      struct void_function_invoker5
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct function_obj_invoker5
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct void_function_obj_invoker5
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct function_ref_invoker5
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct void_function_ref_invoker5
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
      >
      struct get_function_invoker5
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker5<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >,
                          function_invoker5<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
       >
      struct get_function_obj_invoker5
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >,
                          function_obj_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4
       >
      struct get_function_ref_invoker5
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >,
                          function_ref_invoker5<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
      struct basic_vtable5 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4);

        template<typename F>
        basic_vtable5(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }
        template<typename F,typename Allocator>
        basic_vtable5(F f, Allocator) : vtable_base(), invoker(0)
        {
          init_a<Allocator>(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }
        template<typename Allocator,typename F>
        void init_a(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init_a<Allocator>(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker5<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr>::manage;
        }
        template<typename Allocator,typename FunctionPtr>
        void init_a(FunctionPtr f, function_ptr_tag)
        {
          typedef typename get_function_invoker5<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }
        template<typename Allocator,typename MemberPtr>
        void init_a(MemberPtr f, member_ptr_tag)
        {



          this->init_a<Allocator>(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker5<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj>::manage;
        }
        template<typename Allocator,typename FunctionObj>
        void init_a(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker5<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker5<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }
        template<typename Allocator,typename FunctionObj>
        void
        init_a(const reference_wrapper<FunctionObj>& f, function_obj_ref_tag)
        {
          init(f,function_obj_ref_tag());
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4
  >
  class function5 : public function_base
# 559 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable5<
              R , T0 , T1 , T2 , T3 , T4>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 5;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 592 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    static const int arity = 5;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type;

    typedef function5 self_type;

    function5() : function_base() { }



    template<typename Functor>
    function5(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function5(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function5(clear_type*) : function_base() { }







    function5(const function5& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function5() { clear(); }
# 656 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function5&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      try {
        this->assign_to_a(f,a);
      } catch (...) {
        vtable = 0;
        throw;
      }
    }


    function5& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 712 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    function5& operator=(const function5& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function5& other)
    {
      if (&other == this)
        return;

      function5 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function5& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      static vtable_type stored_vtable(f,a);
      if (stored_vtable.assign_to_a(f, functor, a)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
  inline void swap(function5<
                     R ,
                     T0 , T1 , T2 , T3 , T4
                   >& f1,
                   function5<
                     R ,
                     T0 , T1 , T2 , T3 , T4
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
  typename function5<
      R , T0 , T1 , T2 , T3 , T4>::result_type
   function5<R , T0 , T1 , T2 , T3 , T4>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
  void operator==(const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4>&,
                  const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
  void operator!=(const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4>&,
                  const function5<
                          R ,
                          T0 , T1 , T2 , T3 , T4>& );
# 843 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
class function<R ( T0 , T1 , T2 , T3 , T4)>
  : public function5<R , T0 , T1 , T2 , T3 , T4>
{
  typedef function5<R , T0 , T1 , T2 , T3 , T4> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 73 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
        >
      struct function_invoker6
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
        >
      struct void_function_invoker6
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct function_obj_invoker6
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct void_function_obj_invoker6
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct function_ref_invoker6
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct void_function_ref_invoker6
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
      >
      struct get_function_invoker6
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker6<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >,
                          function_invoker6<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
       >
      struct get_function_obj_invoker6
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >,
                          function_obj_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
       >
      struct get_function_ref_invoker6
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >,
                          function_ref_invoker6<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
      struct basic_vtable6 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5);

        template<typename F>
        basic_vtable6(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }
        template<typename F,typename Allocator>
        basic_vtable6(F f, Allocator) : vtable_base(), invoker(0)
        {
          init_a<Allocator>(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }
        template<typename Allocator,typename F>
        void init_a(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init_a<Allocator>(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker6<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr>::manage;
        }
        template<typename Allocator,typename FunctionPtr>
        void init_a(FunctionPtr f, function_ptr_tag)
        {
          typedef typename get_function_invoker6<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }
        template<typename Allocator,typename MemberPtr>
        void init_a(MemberPtr f, member_ptr_tag)
        {



          this->init_a<Allocator>(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker6<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj>::manage;
        }
        template<typename Allocator,typename FunctionObj>
        void init_a(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker6<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker6<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }
        template<typename Allocator,typename FunctionObj>
        void
        init_a(const reference_wrapper<FunctionObj>& f, function_obj_ref_tag)
        {
          init(f,function_obj_ref_tag());
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5
  >
  class function6 : public function_base
# 559 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable6<
              R , T0 , T1 , T2 , T3 , T4 , T5>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 6;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 592 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    static const int arity = 6;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type;

    typedef function6 self_type;

    function6() : function_base() { }



    template<typename Functor>
    function6(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function6(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function6(clear_type*) : function_base() { }







    function6(const function6& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function6() { clear(); }
# 656 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function6&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      try {
        this->assign_to_a(f,a);
      } catch (...) {
        vtable = 0;
        throw;
      }
    }


    function6& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 712 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    function6& operator=(const function6& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function6& other)
    {
      if (&other == this)
        return;

      function6 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function6& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      static vtable_type stored_vtable(f,a);
      if (stored_vtable.assign_to_a(f, functor, a)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
  inline void swap(function6<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5
                   >& f1,
                   function6<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
  typename function6<
      R , T0 , T1 , T2 , T3 , T4 , T5>::result_type
   function6<R , T0 , T1 , T2 , T3 , T4 , T5>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
  void operator==(const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5>&,
                  const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
  void operator!=(const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5>&,
                  const function6<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5>& );
# 843 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5)>
  : public function6<R , T0 , T1 , T2 , T3 , T4 , T5>
{
  typedef function6<R , T0 , T1 , T2 , T3 , T4 , T5> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 78 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
        >
      struct function_invoker7
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
        >
      struct void_function_invoker7
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct function_obj_invoker7
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct void_function_obj_invoker7
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct function_ref_invoker7
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct void_function_ref_invoker7
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
      >
      struct get_function_invoker7
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker7<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >,
                          function_invoker7<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
       >
      struct get_function_obj_invoker7
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >,
                          function_obj_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
       >
      struct get_function_ref_invoker7
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >,
                          function_ref_invoker7<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
      struct basic_vtable7 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6);

        template<typename F>
        basic_vtable7(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }
        template<typename F,typename Allocator>
        basic_vtable7(F f, Allocator) : vtable_base(), invoker(0)
        {
          init_a<Allocator>(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }
        template<typename Allocator,typename F>
        void init_a(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init_a<Allocator>(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker7<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr>::manage;
        }
        template<typename Allocator,typename FunctionPtr>
        void init_a(FunctionPtr f, function_ptr_tag)
        {
          typedef typename get_function_invoker7<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }
        template<typename Allocator,typename MemberPtr>
        void init_a(MemberPtr f, member_ptr_tag)
        {



          this->init_a<Allocator>(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker7<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj>::manage;
        }
        template<typename Allocator,typename FunctionObj>
        void init_a(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker7<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker7<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }
        template<typename Allocator,typename FunctionObj>
        void
        init_a(const reference_wrapper<FunctionObj>& f, function_obj_ref_tag)
        {
          init(f,function_obj_ref_tag());
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6
  >
  class function7 : public function_base
# 559 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable7<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 7;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 592 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    static const int arity = 7;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type;

    typedef function7 self_type;

    function7() : function_base() { }



    template<typename Functor>
    function7(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function7(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function7(clear_type*) : function_base() { }







    function7(const function7& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function7() { clear(); }
# 656 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function7&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      try {
        this->assign_to_a(f,a);
      } catch (...) {
        vtable = 0;
        throw;
      }
    }


    function7& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 712 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    function7& operator=(const function7& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function7& other)
    {
      if (&other == this)
        return;

      function7 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function7& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      static vtable_type stored_vtable(f,a);
      if (stored_vtable.assign_to_a(f, functor, a)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
  inline void swap(function7<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6
                   >& f1,
                   function7<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
  typename function7<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6>::result_type
   function7<R , T0 , T1 , T2 , T3 , T4 , T5 , T6>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
  void operator==(const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6>&,
                  const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
  void operator!=(const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6>&,
                  const function7<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6>& );
# 843 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6)>
  : public function7<R , T0 , T1 , T2 , T3 , T4 , T5 , T6>
{
  typedef function7<R , T0 , T1 , T2 , T3 , T4 , T5 , T6> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 83 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
        >
      struct function_invoker8
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
        >
      struct void_function_invoker8
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct function_obj_invoker8
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct void_function_obj_invoker8
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct function_ref_invoker8
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct void_function_ref_invoker8
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
      >
      struct get_function_invoker8
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker8<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >,
                          function_invoker8<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
       >
      struct get_function_obj_invoker8
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >,
                          function_obj_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
       >
      struct get_function_ref_invoker8
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >,
                          function_ref_invoker8<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
      struct basic_vtable8 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7);

        template<typename F>
        basic_vtable8(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }
        template<typename F,typename Allocator>
        basic_vtable8(F f, Allocator) : vtable_base(), invoker(0)
        {
          init_a<Allocator>(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }
        template<typename Allocator,typename F>
        void init_a(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init_a<Allocator>(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker8<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr>::manage;
        }
        template<typename Allocator,typename FunctionPtr>
        void init_a(FunctionPtr f, function_ptr_tag)
        {
          typedef typename get_function_invoker8<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }
        template<typename Allocator,typename MemberPtr>
        void init_a(MemberPtr f, member_ptr_tag)
        {



          this->init_a<Allocator>(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker8<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj>::manage;
        }
        template<typename Allocator,typename FunctionObj>
        void init_a(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker8<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker8<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }
        template<typename Allocator,typename FunctionObj>
        void
        init_a(const reference_wrapper<FunctionObj>& f, function_obj_ref_tag)
        {
          init(f,function_obj_ref_tag());
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7
  >
  class function8 : public function_base
# 559 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable8<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 8;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 592 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    static const int arity = 8;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type; typedef T7 arg8_type;

    typedef function8 self_type;

    function8() : function_base() { }



    template<typename Functor>
    function8(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function8(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function8(clear_type*) : function_base() { }







    function8(const function8& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function8() { clear(); }
# 656 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function8&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      try {
        this->assign_to_a(f,a);
      } catch (...) {
        vtable = 0;
        throw;
      }
    }


    function8& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 712 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    function8& operator=(const function8& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function8& other)
    {
      if (&other == this)
        return;

      function8 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function8& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      static vtable_type stored_vtable(f,a);
      if (stored_vtable.assign_to_a(f, functor, a)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
  inline void swap(function8<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                   >& f1,
                   function8<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
  typename function8<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>::result_type
   function8<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
  void operator==(const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>&,
                  const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
  void operator!=(const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>&,
                  const function8<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>& );
# 843 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7)>
  : public function8<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
{
  typedef function8<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 54 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 88 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 58 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
        >
      struct function_invoker9
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
        >
      struct void_function_invoker9
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct function_obj_invoker9
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct void_function_obj_invoker9
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct function_ref_invoker9
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct void_function_ref_invoker9
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
      >
      struct get_function_invoker9
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker9<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >,
                          function_invoker9<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
       >
      struct get_function_obj_invoker9
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >,
                          function_obj_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
       >
      struct get_function_ref_invoker9
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >,
                          function_ref_invoker9<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
      struct basic_vtable9 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8);

        template<typename F>
        basic_vtable9(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }
        template<typename F,typename Allocator>
        basic_vtable9(F f, Allocator) : vtable_base(), invoker(0)
        {
          init_a<Allocator>(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }
        template<typename Allocator,typename F>
        void init_a(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init_a<Allocator>(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker9<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr>::manage;
        }
        template<typename Allocator,typename FunctionPtr>
        void init_a(FunctionPtr f, function_ptr_tag)
        {
          typedef typename get_function_invoker9<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }
        template<typename Allocator,typename MemberPtr>
        void init_a(MemberPtr f, member_ptr_tag)
        {



          this->init_a<Allocator>(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker9<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj>::manage;
        }
        template<typename Allocator,typename FunctionObj>
        void init_a(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker9<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker9<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }
        template<typename Allocator,typename FunctionObj>
        void
        init_a(const reference_wrapper<FunctionObj>& f, function_obj_ref_tag)
        {
          init(f,function_obj_ref_tag());
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8
  >
  class function9 : public function_base
# 559 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable9<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 9;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 592 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    static const int arity = 9;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type; typedef T7 arg8_type; typedef T8 arg9_type;

    typedef function9 self_type;

    function9() : function_base() { }



    template<typename Functor>
    function9(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function9(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function9(clear_type*) : function_base() { }







    function9(const function9& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function9() { clear(); }
# 656 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function9&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      try {
        this->assign_to_a(f,a);
      } catch (...) {
        vtable = 0;
        throw;
      }
    }


    function9& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 712 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    function9& operator=(const function9& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function9& other)
    {
      if (&other == this)
        return;

      function9 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function9& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      static vtable_type stored_vtable(f,a);
      if (stored_vtable.assign_to_a(f, functor, a)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
  inline void swap(function9<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                   >& f1,
                   function9<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
  typename function9<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>::result_type
   function9<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
  void operator==(const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>&,
                  const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
  void operator!=(const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>&,
                  const function9<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>& );
# 843 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8)>
  : public function9<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
{
  typedef function9<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 59 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 93 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 63 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
namespace boost {
  namespace detail {
    namespace function {
      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
        >
      struct function_invoker10
      {
        static R invoke(function_buffer& function_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)
        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          return f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
        >
      struct void_function_invoker10
      {
        static void
        invoke(function_buffer& function_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
          f( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct function_obj_invoker10
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct void_function_obj_invoker10
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f;
          if (function_allows_small_object_optimization<FunctionObj>::value)
            f = reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
          else
            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct function_ref_invoker10
      {
        static R invoke(function_buffer& function_obj_ptr ,
                        T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          return (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct void_function_ref_invoker10
      {
        static void
        invoke(function_buffer& function_obj_ptr ,
               T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9)

        {
          FunctionObj* f =
            reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
          (*f)( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
        }
      };

      template<
        typename FunctionPtr,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
      >
      struct get_function_invoker10
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_invoker10<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >,
                          function_invoker10<
                            FunctionPtr,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
       >
      struct get_function_obj_invoker10
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_obj_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >,
                          function_obj_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >
                       >::type type;
      };

      template<
        typename FunctionObj,
        typename R ,
        typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
       >
      struct get_function_ref_invoker10
      {
        typedef typename mpl::if_c<(is_void<R>::value),
                            void_function_ref_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >,
                          function_ref_invoker10<
                            FunctionObj,
                            R ,
                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                          >
                       >::type type;
      };




      template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
      struct basic_vtable10 : vtable_base
      {

        typedef R result_type;




        typedef result_type (*invoker_type)(function_buffer&
                                            ,
                                            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9);

        template<typename F>
        basic_vtable10(F f) : vtable_base(), invoker(0)
        {
          init(f);
        }
        template<typename F,typename Allocator>
        basic_vtable10(F f, Allocator) : vtable_base(), invoker(0)
        {
          init_a<Allocator>(f);
        }

        template<typename F>
        bool assign_to(F f, function_buffer& functor)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to(f, functor, tag());
        }
        template<typename F,typename Allocator>
        bool assign_to_a(F f, function_buffer& functor, Allocator a)
        {
          typedef typename get_function_tag<F>::type tag;
          return assign_to_a(f, functor, a, tag());
        }

        void clear(function_buffer& functor)
        {
          if (manager)
            manager(functor, functor, destroy_functor_tag);
        }

      private:
        template<typename F>
        void init(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init(f, tag());
        }
        template<typename Allocator,typename F>
        void init_a(F f)
        {
          typedef typename get_function_tag<F>::type tag;
          init_a<Allocator>(f, tag());
        }


        template<typename FunctionPtr>
        void init(FunctionPtr , function_ptr_tag)
        {
          typedef typename get_function_invoker10<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionPtr>::manage;
        }
        template<typename Allocator,typename FunctionPtr>
        void init_a(FunctionPtr f, function_ptr_tag)
        {
          typedef typename get_function_invoker10<
                             FunctionPtr,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionPtr, Allocator>::manage;
        }

        template<typename FunctionPtr>
        bool
        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag)
        {
          this->clear(functor);
          if (f) {


            functor.func_ptr = (void (*)())(f);
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionPtr,typename Allocator>
        bool
        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag)
        {
          return assign_to(f,functor,function_ptr_tag());
        }



        template<typename MemberPtr>
        void init(MemberPtr f, member_ptr_tag)
        {



          this->init(mem_fn(f));
        }
        template<typename Allocator,typename MemberPtr>
        void init_a(MemberPtr f, member_ptr_tag)
        {



          this->init_a<Allocator>(mem_fn(f));
        }

        template<typename MemberPtr>
        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag)
        {



          if (f) {
            this->assign_to(mem_fn(f), functor);
            return true;
          } else {
            return false;
          }
        }
        template<typename MemberPtr,typename Allocator>
        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag)
        {



          if (f) {
            this->assign_to_a(mem_fn(f), functor, a);
            return true;
          } else {
            return false;
          }
        }



        template<typename FunctionObj>
        void init(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker10<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager<FunctionObj>::manage;
        }
        template<typename Allocator,typename FunctionObj>
        void init_a(FunctionObj , function_obj_tag)
        {
          typedef typename get_function_obj_invoker10<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &functor_manager_a<FunctionObj, Allocator>::manage;
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::true_)
        {
          new ((void*)&functor.data) FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, mpl::true_)
        {
          assign_functor(f,functor,mpl::true_());
        }


        template<typename FunctionObj>
        void
        assign_functor(FunctionObj f, function_buffer& functor, mpl::false_)
        {
          functor.obj_ptr = new FunctionObj(f);
        }
        template<typename FunctionObj,typename Allocator>
        void
        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, mpl::false_)
        {
          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;
          typedef typename Allocator::template rebind<functor_wrapper_type>::other
            wrapper_allocator_type;
          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
          wrapper_allocator_type wrapper_allocator(a);
          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);
          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));
          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);
          functor.obj_ptr = new_f;
        }

        template<typename FunctionObj>
        bool
        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor(f, functor,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag)
        {
          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {
            assign_functor_a(f, functor, a,
                           mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
            return true;
          } else {
            return false;
          }
        }


        template<typename FunctionObj>
        void
        init(const reference_wrapper<FunctionObj>& , function_obj_ref_tag)
        {
          typedef typename get_function_ref_invoker10<
                             FunctionObj,
                             R ,
                             T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                           >::type
            actual_invoker_type;

          invoker = &actual_invoker_type::invoke;
          manager = &reference_manager<FunctionObj>::get;
        }
        template<typename Allocator,typename FunctionObj>
        void
        init_a(const reference_wrapper<FunctionObj>& f, function_obj_ref_tag)
        {
          init(f,function_obj_ref_tag());
        }

        template<typename FunctionObj>
        bool
        assign_to(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, function_obj_ref_tag)
        {
          if (!boost::detail::function::has_empty_target(f.get_pointer())) {




            functor.const_obj_ptr = f.get_pointer();
            return true;
          } else {
            return false;
          }
        }
        template<typename FunctionObj,typename Allocator>
        bool
        assign_to_a(const reference_wrapper<FunctionObj>& f,
                  function_buffer& functor, Allocator, function_obj_ref_tag)
        {
          return assign_to(f,functor,function_obj_ref_tag());
        }

      public:
        invoker_type invoker;
      };
    }
  }

  template<
    typename R ,
    typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9
  >
  class function10 : public function_base
# 559 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
  {
  public:

    typedef R result_type;





  private:
    typedef boost::detail::function::basic_vtable10<
              R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
      vtable_type;

    struct clear_type {};

  public:
    static const int args = 10;


    template<typename Args>
    struct sig
    {
      typedef result_type type;
    };
# 592 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    static const int arity = 10;
    typedef T0 arg1_type; typedef T1 arg2_type; typedef T2 arg3_type; typedef T3 arg4_type; typedef T4 arg5_type; typedef T5 arg6_type; typedef T6 arg7_type; typedef T7 arg8_type; typedef T8 arg9_type; typedef T9 arg10_type;

    typedef function10 self_type;

    function10() : function_base() { }



    template<typename Functor>
    function10(Functor f

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to(f);
    }
    template<typename Functor,typename Allocator>
    function10(Functor f, Allocator a

                            ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                             (is_integral<Functor>::value)>::value),
                                        int>::type = 0

                            ) :
      function_base()
    {
      this->assign_to_a(f,a);
    }


    function10(clear_type*) : function_base() { }







    function10(const function10& f) : function_base()
    {
      this->assign_to_own(f);
    }

    ~function10() { clear(); }
# 656 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    result_type operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9) const;







    template<typename Functor>

    typename enable_if_c<
               (boost::type_traits::ice_not<
                 (is_integral<Functor>::value)>::value),
               function10&>::type



    operator=(Functor f)
    {
      this->clear();
      try {
        this->assign_to(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }
    template<typename Functor,typename Allocator>
    void assign(Functor f, Allocator a)
    {
      this->clear();
      try {
        this->assign_to_a(f,a);
      } catch (...) {
        vtable = 0;
        throw;
      }
    }


    function10& operator=(clear_type*)
    {
      this->clear();
      return *this;
    }
# 712 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
    function10& operator=(const function10& f)
    {
      if (&f == this)
        return *this;

      this->clear();
      try {
        this->assign_to_own(f);
      } catch (...) {
        vtable = 0;
        throw;
      }
      return *this;
    }

    void swap(function10& other)
    {
      if (&other == this)
        return;

      function10 tmp = *this;
      *this = other;
      other = tmp;
    }


    void clear()
    {
      if (vtable) {
        static_cast<vtable_type*>(vtable)->clear(this->functor);
        vtable = 0;
      }
    }





  private:
    struct dummy {
      void nonnull() {};
    };

    typedef void (dummy::*safe_bool)();

  public:
    operator safe_bool () const
      { return (this->empty())? 0 : &dummy::nonnull; }

    bool operator!() const
      { return this->empty(); }


  private:
    void assign_to_own(const function10& f)
    {
      if (!f.empty()) {
        this->vtable = f.vtable;
        f.vtable->manager(f.functor, this->functor,
                          boost::detail::function::clone_functor_tag);
      }
    }

    template<typename Functor>
    void assign_to(Functor f)
    {
      static vtable_type stored_vtable(f);
      if (stored_vtable.assign_to(f, functor)) vtable = &stored_vtable;
      else vtable = 0;
    }
    template<typename Functor,typename Allocator>
    void assign_to_a(Functor f,Allocator a)
    {
      static vtable_type stored_vtable(f,a);
      if (stored_vtable.assign_to_a(f, functor, a)) vtable = &stored_vtable;
      else vtable = 0;
    }
  };

  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
  inline void swap(function10<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                   >& f1,
                   function10<
                     R ,
                     T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9
                   >& f2)
  {
    f1.swap(f2);
  }


  template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
  typename function10<
      R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>::result_type
   function10<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
  ::operator()( T0 a0 , T1 a1 , T2 a2 , T3 a3 , T4 a4 , T5 a5 , T6 a6 , T7 a7 , T8 a8 , T9 a9) const
  {
    if (this->empty())
      boost::throw_exception(bad_function_call());

    return static_cast<vtable_type*>(vtable)->invoker
             (this->functor , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9);
  }



template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
  void operator==(const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>&,
                  const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>&);
template<typename R , typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
  void operator!=(const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>&,
                  const function10<
                          R ,
                          T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>& );
# 843 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/function_template.hpp" 3
template<typename R ,
         typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
class function<R ( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9)>
  : public function10<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
{
  typedef function10<R , T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9> base_type;
  typedef function self_type;

  struct clear_type {};

public:

  function() : base_type() {}

  template<typename Functor>
  function(Functor f

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f)
  {
  }
  template<typename Functor,typename Allocator>
  function(Functor f, Allocator a

           ,typename enable_if_c<
                            (boost::type_traits::ice_not<
                          (is_integral<Functor>::value)>::value),
                       int>::type = 0

           ) :
    base_type(f,a)
  {
  }


  function(clear_type*) : base_type() {}


  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}

  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}

  self_type& operator=(const self_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }

  template<typename Functor>

  typename enable_if_c<
                            (boost::type_traits::ice_not<
                         (is_integral<Functor>::value)>::value),
                      self_type&>::type



  operator=(Functor f)
  {
    self_type(f).swap(*this);
    return *this;
  }


  self_type& operator=(clear_type*)
  {
    this->clear();
    return *this;
  }


  self_type& operator=(const base_type& f)
  {
    self_type(f).swap(*this);
    return *this;
  }
};




}
# 64 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 98 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 65 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function.hpp" 2 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/transform_iterator.hpp" 2 3






# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/function_traits.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/function_traits.hpp" 3
namespace boost {


namespace detail {

template<typename Function> struct function_traits_helper;

template<typename R>
struct function_traits_helper<R (*)(void)>
{
  static const unsigned arity = 0;
  typedef R result_type;
};

template<typename R, typename T1>
struct function_traits_helper<R (*)(T1)>
{
  static const unsigned arity = 1;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T1 argument_type;
};

template<typename R, typename T1, typename T2>
struct function_traits_helper<R (*)(T1, T2)>
{
  static const unsigned arity = 2;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T1 first_argument_type;
  typedef T2 second_argument_type;
};

template<typename R, typename T1, typename T2, typename T3>
struct function_traits_helper<R (*)(T1, T2, T3)>
{
  static const unsigned arity = 3;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4>
struct function_traits_helper<R (*)(T1, T2, T3, T4)>
{
  static const unsigned arity = 4;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5)>
{
  static const unsigned arity = 5;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6)>
{
  static const unsigned arity = 6;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7)>
{
  static const unsigned arity = 7;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8)>
{
  static const unsigned arity = 8;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
  static const unsigned arity = 9;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9,
         typename T10>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
{
  static const unsigned arity = 10;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
  typedef T10 arg10_type;
};

}

template<typename Function>
struct function_traits :
   public detail::function_traits_helper<typename boost::add_pointer<Function>::type>
{
};
# 234 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/function_traits.hpp" 3
}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/transform_iterator.hpp" 2 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/transform_iterator.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_def.hpp" 1 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/transform_iterator.hpp" 2 3


namespace boost
{
  template <class UnaryFunction, class Iterator, class Reference = use_default, class Value = use_default>
  class transform_iterator;

  namespace detail
  {

    template <class UnaryFunc>
    struct function_object_result
    {
      typedef typename UnaryFunc::result_type type;
    };


    template <class Return, class Argument>
    struct function_object_result<Return(*)(Argument)>
    {
      typedef Return type;
    };



    template <class UnaryFunc, class Iterator, class Reference, class Value>
    struct transform_iterator_base
    {
     private:




        typedef typename ia_dflt_help<
            Reference
          , function_object_result<UnaryFunc>
        >::type reference;






        typedef typename ia_dflt_help<
            Value
          , remove_reference<reference>
        >::type cv_value_type;

     public:
        typedef iterator_adaptor<
            transform_iterator<UnaryFunc, Iterator, Reference, Value>
          , Iterator
          , cv_value_type
          , use_default
          , reference
        > type;
    };
  }

  template <class UnaryFunc, class Iterator, class Reference, class Value>
  class transform_iterator
    : public boost::detail::transform_iterator_base<UnaryFunc, Iterator, Reference, Value>::type
  {
    typedef typename
    boost::detail::transform_iterator_base<UnaryFunc, Iterator, Reference, Value>::type
    super_t;

    friend class iterator_core_access;

  public:
    transform_iterator() { }

    transform_iterator(Iterator const& x, UnaryFunc f)
      : super_t(x), m_f(f) { }

    explicit transform_iterator(Iterator const& x)
      : super_t(x)
    {





        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((is_class<UnaryFunc>::value) == 0 ? false : true) >)> boost_static_assert_typedef_113;

    }

    template<
        class OtherUnaryFunction
      , class OtherIterator
      , class OtherReference
      , class OtherValue>
    transform_iterator(
         transform_iterator<OtherUnaryFunction, OtherIterator, OtherReference, OtherValue> const& t
       , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0

       , typename enable_if_convertible<OtherUnaryFunction, UnaryFunc>::type* = 0

    )
      : super_t(t.base()), m_f(t.functor())
   {}

    UnaryFunc functor() const
      { return m_f; }

  private:
    typename super_t::reference dereference() const
    { return m_f(*this->base()); }



    UnaryFunc m_f;
  };

  template <class UnaryFunc, class Iterator>
  transform_iterator<UnaryFunc, Iterator>
  make_transform_iterator(Iterator it, UnaryFunc fun)
  {
      return transform_iterator<UnaryFunc, Iterator>(it, fun);
  }
# 158 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/transform_iterator.hpp" 3
  template <class UnaryFunc, class Iterator>



  typename iterators::enable_if<

      is_class<UnaryFunc>
    , transform_iterator<UnaryFunc, Iterator>



  >::type
  make_transform_iterator(Iterator it)
  {
      return transform_iterator<UnaryFunc, Iterator>(it, UnaryFunc());
  }
# 184 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/transform_iterator.hpp" 3
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/detail/config_undef.hpp" 1 3
# 187 "/Library/Application Support/MonkeyWorks/Developer/include/boost/iterator/transform_iterator.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/case_conv.hpp" 2 3






# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/case_conv.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/case_conv.hpp" 3
namespace boost {
    namespace algorithm {
        namespace detail {
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/case_conv.hpp" 3
            template<typename CharT>
            struct to_lowerF : public std::unary_function<CharT, CharT>
            {

                to_lowerF( const std::locale& Loc ) : m_Loc( Loc ) {}


                CharT operator ()( CharT Ch ) const
                {



                        return std::tolower<CharT>( Ch, m_Loc );

                }
            private:
                const std::locale& m_Loc;
            };


            template<typename CharT>
            struct to_upperF : public std::unary_function<CharT, CharT>
            {

                to_upperF( const std::locale& Loc ) : m_Loc( Loc ) {}


                CharT operator ()( CharT Ch ) const
                {



                        return std::toupper<CharT>( Ch, m_Loc );

                }
            private:
                const std::locale& m_Loc;
            };
# 76 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/case_conv.hpp" 3
            template<typename OutputIteratorT, typename RangeT, typename FunctorT>
            OutputIteratorT transform_range_copy(
                OutputIteratorT Output,
                const RangeT& Input,
                FunctorT Functor)
            {
                return std::transform(
                    ::boost::begin(Input),
                    ::boost::end(Input),
                    Output,
                    Functor);
            }


            template<typename RangeT, typename FunctorT>
            void transform_range(
                const RangeT& Input,
                FunctorT Functor)
            {
                std::transform(
                    ::boost::begin(Input),
                    ::boost::end(Input),
                    ::boost::begin(Input),
                    Functor);
            }

            template<typename SequenceT, typename RangeT, typename FunctorT>
            inline SequenceT transform_range_copy(
                const RangeT& Input,
                FunctorT Functor)
            {
                return SequenceT(
                    make_transform_iterator(
                        ::boost::begin(Input),
                        Functor),
                    make_transform_iterator(
                        ::boost::end(Input),
                        Functor));
            }

        }
    }
}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/case_conv.hpp" 2 3







namespace boost {
    namespace algorithm {
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/case_conv.hpp" 3
        template<typename OutputIteratorT, typename RangeT>
        inline OutputIteratorT
        to_lower_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::detail::transform_range_copy(
               Output,
               as_literal(Input),
               ::boost::algorithm::detail::to_lowerF<
                    typename range_value<RangeT>::type >(Loc));
        }





        template<typename SequenceT>
        inline SequenceT to_lower_copy(
            const SequenceT& Input,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::detail::transform_range_copy<SequenceT>(
                Input,
                ::boost::algorithm::detail::to_lowerF<
                    typename range_value<SequenceT>::type >(Loc));
        }
# 90 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/case_conv.hpp" 3
        template<typename WritableRangeT>
        inline void to_lower(
            WritableRangeT& Input,
            const std::locale& Loc=std::locale())
        {
            ::boost::algorithm::detail::transform_range(
                as_literal(Input),
                ::boost::algorithm::detail::to_lowerF<
                    typename range_value<WritableRangeT>::type >(Loc));
        }
# 118 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/case_conv.hpp" 3
        template<typename OutputIteratorT, typename RangeT>
        inline OutputIteratorT
        to_upper_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::detail::transform_range_copy(
               Output,
               as_literal(Input),
               ::boost::algorithm::detail::to_upperF<
                    typename range_value<RangeT>::type >(Loc));
        }





        template<typename SequenceT>
        inline SequenceT to_upper_copy(
            const SequenceT& Input,
            const std::locale& Loc=std::locale())
        {
            return ::boost::algorithm::detail::transform_range_copy<SequenceT>(
                Input,
                ::boost::algorithm::detail::to_upperF<
                    typename range_value<SequenceT>::type >(Loc));
        }
# 155 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/case_conv.hpp" 3
        template<typename WritableRangeT>
        inline void to_upper(
            WritableRangeT& Input,
            const std::locale& Loc=std::locale())
        {
            ::boost::algorithm::detail::transform_range(
                as_literal(Input),
                ::boost::algorithm::detail::to_upperF<
                    typename range_value<WritableRangeT>::type >(Loc));
        }

    }


    using algorithm::to_lower;
    using algorithm::to_lower_copy;
    using algorithm::to_upper;
    using algorithm::to_upper_copy;

}
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/string_parse_tree.hpp" 2 3





namespace boost { namespace date_time {


template<typename charT>
struct parse_match_result
{
  parse_match_result() :
    match_depth(0),
    current_match(-1)
  {}
  typedef std::basic_string<charT> string_type;
  string_type remaining() const
  {
    if (match_depth == cache.size()) {
      return string_type();
    }
    if (current_match == -1) {
      return cache;
    }

    return string_type(cache, match_depth);
  }
  charT last_char() const
  {
    return cache[cache.size()-1];
  }




  bool has_remaining() const
  {
    return (cache.size() > match_depth);
  }


  string_type cache;
  unsigned short match_depth;
  short current_match;
  enum PARSE_STATE { PARSE_ERROR= -1 };
};


template<typename charT>
std::basic_ostream<charT>&
operator<<(std::basic_ostream<charT>& os, parse_match_result<charT>& mr)
{
  os << "cm: " << mr.current_match
     << " C: '" << mr.cache
     << "' md: " << mr.match_depth
     << " R: " << mr.remaining();
  return os;
}
# 82 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/string_parse_tree.hpp" 3
template<typename charT>
struct string_parse_tree
{



  typedef std::multimap<charT, string_parse_tree > ptree_coll;

  typedef typename ptree_coll::value_type value_type;
  typedef typename ptree_coll::iterator iterator;
  typedef typename ptree_coll::const_iterator const_iterator;
  typedef std::basic_string<charT> string_type;
  typedef std::vector<std::basic_string<charT> > collection_type;
  typedef parse_match_result<charT> parse_match_result_type;






  string_parse_tree(collection_type names, unsigned int starting_point=0)
  {

    unsigned short index = 0;
    while (index != names.size() ) {
      string_type s = boost::algorithm::to_lower_copy(names[index]);
      insert(s, static_cast<unsigned short>(index + starting_point));
      index++;
    }

    index++;
  }


  string_parse_tree(short value = -1) :
    m_value(value)
  {}
  ptree_coll m_next_chars;
  short m_value;

  void insert(const string_type& s, unsigned short value)
  {
    unsigned int i = 0;
    iterator ti;
    while(i < s.size()) {
      if (i==0) {
        if (i == (s.size()-1)) {
          ti = m_next_chars.insert(value_type(s[i],
                                              string_parse_tree<charT>(value)));
        }
        else {
          ti = m_next_chars.insert(value_type(s[i],
                                              string_parse_tree<charT>()));
        }
      }
      else {
        if (i == (s.size()-1)) {
          ti = ti->second.m_next_chars.insert(value_type(s[i],
                                                         string_parse_tree<charT>(value)));
        }

        else {
          ti = ti->second.m_next_chars.insert(value_type(s[i],
                                                         string_parse_tree<charT>()));
        }

      }
      i++;
    }
  }
# 165 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/string_parse_tree.hpp" 3
  short
  match(std::istreambuf_iterator<charT>& sitr,
        std::istreambuf_iterator<charT>& stream_end,
        parse_match_result_type& result,
        unsigned int& level) const
  {

    level++;
    charT c;


    bool adv_itr = true;
    if (level > result.cache.size()) {
      if (sitr == stream_end) return 0;
      c = static_cast<charT>(std::tolower(*sitr));


    }
    else {


      adv_itr = false;
      c = static_cast<charT>(std::tolower(result.cache[level-1]));
    }
    const_iterator litr = m_next_chars.lower_bound(c);
    const_iterator uitr = m_next_chars.upper_bound(c);
    while (litr != uitr) {
      if(adv_itr) {
        sitr++;
        result.cache += c;
      }
      if (litr->second.m_value != -1) {
        if (result.match_depth < level) {
          result.current_match = litr->second.m_value;
          result.match_depth = static_cast<unsigned short>(level);
        }
        litr->second.match(sitr, stream_end,
                           result, level);
        level--;
      }
      else {
        litr->second.match(sitr, stream_end,
                           result, level);
        level--;
      }

      if(level <= result.cache.size()) {
        adv_itr = false;
      }

      litr++;
    }
    return result.current_match;

  }






  parse_match_result_type
  match(std::istreambuf_iterator<charT>& sitr,
        std::istreambuf_iterator<charT>& stream_end) const
  {

    unsigned int level = 0;

    parse_match_result_type result;
    match(sitr, stream_end, result, level);
    return result;
  }

  void printme(std::ostream& os, int& level)
  {
    level++;
    iterator itr = m_next_chars.begin();
    iterator end = m_next_chars.end();

    while (itr != end) {
      os << "level:  " << level
         << " node:  " << itr->first
         << " value: " << itr->second.m_value
         << std::endl;
      itr->second.printme(os, level);
      itr++;
    }
    level--;
  }

  void print(std::ostream& os)
  {
    int level = 0;
    printme(os, level);
  }

  void printmatch(std::ostream& os, charT c)
  {
    iterator litr = m_next_chars.lower_bound(c);
    iterator uitr = m_next_chars.upper_bound(c);
    os << "matches for: " << c << std::endl;
    while (litr != uitr) {
      os << " node:  " << litr->first
         << " value: " << litr->second.m_value
         << std::endl;
      litr++;
    }
  }

};


} }
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period_parser.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/string_convert.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/string_convert.hpp" 3
namespace boost {
namespace date_time {




  template<class InputT, class OutputT>
  inline
  std::basic_string<OutputT> convert_string_type(const std::basic_string<InputT>& inp_str)
  {
    typedef std::basic_string<InputT> input_type;
    typedef std::basic_string<OutputT> output_type;
    output_type result;
    result.insert(result.begin(), inp_str.begin(), inp_str.end());
    return result;
  }

}}
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period_parser.hpp" 2 3


namespace boost { namespace date_time {
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period_parser.hpp" 3
  template<class date_type, typename CharT>
  class period_parser {
  public:
    typedef std::basic_string<CharT> string_type;
    typedef CharT char_type;

    typedef std::istreambuf_iterator<CharT> stream_itr_type;
    typedef string_parse_tree<CharT> parse_tree_type;
    typedef typename parse_tree_type::parse_match_result_type match_results;
    typedef std::vector<std::basic_string<CharT> > collection_type;

    static const char_type default_period_separator[2];
    static const char_type default_period_start_delimeter[2];
    static const char_type default_period_open_range_end_delimeter[2];
    static const char_type default_period_closed_range_end_delimeter[2];

    enum period_range_option { AS_OPEN_RANGE, AS_CLOSED_RANGE };


    period_parser(period_range_option range_option = AS_CLOSED_RANGE,
                  const char_type* const period_separator = default_period_separator,
                  const char_type* const period_start_delimeter = default_period_start_delimeter,
                  const char_type* const period_open_range_end_delimeter = default_period_open_range_end_delimeter,
                  const char_type* const period_closed_range_end_delimeter = default_period_closed_range_end_delimeter)
      : m_range_option(range_option)
    {
      delimiters.push_back(string_type(period_separator));
      delimiters.push_back(string_type(period_start_delimeter));
      delimiters.push_back(string_type(period_open_range_end_delimeter));
      delimiters.push_back(string_type(period_closed_range_end_delimeter));
    }

    period_parser(const period_parser<date_type,CharT>& p_parser)
    {
      this->delimiters = p_parser.delimiters;
      this->m_range_option = p_parser.m_range_option;
    }

    period_range_option range_option() const
    {
      return m_range_option;
    }
    void range_option(period_range_option option)
    {
      m_range_option = option;
    }
    collection_type delimiter_strings() const
    {
      return delimiters;
    }
    void delimiter_strings(const string_type& separator,
                           const string_type& start_delim,
                           const string_type& open_end_delim,
                           const string_type& closed_end_delim)
    {
      delimiters.clear();
      delimiters.push_back(separator);
      delimiters.push_back(start_delim);
      delimiters.push_back(open_end_delim);
      delimiters.push_back(closed_end_delim);
    }
# 118 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/period_parser.hpp" 3
    template<class period_type, class duration_type, class facet_type>
    period_type get_period(stream_itr_type& sitr,
                           stream_itr_type& stream_end,
                           std::ios_base& a_ios,
                           const period_type& p,
                           const duration_type& dur_unit,
                           const facet_type& facet) const
    {

      while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }

      typedef typename period_type::point_type point_type;
      point_type p1(not_a_date_time), p2(not_a_date_time);


      consume_delim(sitr, stream_end, delimiters[START]);
      facet.get(sitr, stream_end, a_ios, p1);
      consume_delim(sitr, stream_end, delimiters[SEPARATOR]);
      facet.get(sitr, stream_end, a_ios, p2);


      if (m_range_option == AS_CLOSED_RANGE) {
        consume_delim(sitr, stream_end, delimiters[CLOSED_END]);

        p2 += dur_unit;
      }
      else {
        consume_delim(sitr, stream_end, delimiters[OPEN_END]);
      }

      return period_type(p1, p2);
    }

  private:
    collection_type delimiters;
    period_range_option m_range_option;

    enum delim_ids { SEPARATOR, START, OPEN_END, CLOSED_END };


    void consume_delim(stream_itr_type& sitr,
                       stream_itr_type& stream_end,
                       const string_type& delim) const
    {





      string_type s;
      for(unsigned int i = 0; i < delim.length() && sitr != stream_end; ++i) {
        s += *sitr;
        ++sitr;
      }
      if(s != delim) {
        throw std::ios_base::failure("Parse failed. Expected '" + convert_string_type<char_type,char>(delim) + "' but found '" + convert_string_type<char_type,char>(s) + "'");
      }
    }
  };

  template <class date_type, class char_type>
  const typename period_parser<date_type, char_type>::char_type
  period_parser<date_type, char_type>::default_period_separator[2] = {'/'};

  template <class date_type, class char_type>
  const typename period_parser<date_type, char_type>::char_type
  period_parser<date_type, char_type>::default_period_start_delimeter[2] = {'['};

  template <class date_type, class char_type>
  const typename period_parser<date_type, char_type>::char_type
  period_parser<date_type, char_type>::default_period_open_range_end_delimeter[2] = {')'};

  template <class date_type, class char_type>
  const typename period_parser<date_type, char_type>::char_type
  period_parser<date_type, char_type>::default_period_closed_range_end_delimeter[2] = {']'};

 } }
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_facet.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generator_formatter.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generator_formatter.hpp" 3
namespace boost {
namespace date_time {
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generator_formatter.hpp" 3
  template <class date_type, class CharT, class OutItrT = std::ostreambuf_iterator<CharT, std::char_traits<CharT> > >
  class date_generator_formatter {
    public:
      typedef partial_date<date_type> partial_date_type;
      typedef nth_kday_of_month<date_type> nth_kday_type;
      typedef first_kday_of_month<date_type> first_kday_type;
      typedef last_kday_of_month<date_type> last_kday_type;
      typedef first_kday_after<date_type> kday_after_type;
      typedef first_kday_before<date_type> kday_before_type;

      typedef CharT char_type;
      typedef std::basic_string<char_type> string_type;
      typedef std::vector<string_type> collection_type;
      static const char_type first_string[6];
      static const char_type second_string[7];
      static const char_type third_string[6];
      static const char_type fourth_string[7];
      static const char_type fifth_string[6];
      static const char_type last_string[5];
      static const char_type before_string[8];
      static const char_type after_string[6];
      static const char_type of_string[3];

      enum phrase_elements {first=0, second, third, fourth, fifth, last,
                         before, after, of, number_of_phrase_elements};


      date_generator_formatter()
      {
        phrase_strings.push_back(string_type(first_string));
        phrase_strings.push_back(string_type(second_string));
        phrase_strings.push_back(string_type(third_string));
        phrase_strings.push_back(string_type(fourth_string));
        phrase_strings.push_back(string_type(fifth_string));
        phrase_strings.push_back(string_type(last_string));
        phrase_strings.push_back(string_type(before_string));
        phrase_strings.push_back(string_type(after_string));
        phrase_strings.push_back(string_type(of_string));
      }


      date_generator_formatter(const string_type& first,
                               const string_type& second,
                               const string_type& third,
                               const string_type& fourth,
                               const string_type& fifth,
                               const string_type& last,
                               const string_type& before,
                               const string_type& after,
                               const string_type& of)
      {
        phrase_strings.push_back(string_type(first_string));
        phrase_strings.push_back(string_type(second_string));
        phrase_strings.push_back(string_type(third_string));
        phrase_strings.push_back(string_type(fourth_string));
        phrase_strings.push_back(string_type(fifth_string));
        phrase_strings.push_back(string_type(last_string));
        phrase_strings.push_back(string_type(before_string));
        phrase_strings.push_back(string_type(after_string));
        phrase_strings.push_back(string_type(of_string));
      }
# 112 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generator_formatter.hpp" 3
      void elements(const collection_type& new_strings,
                    phrase_elements beg_pos=first)
      {
        if(beg_pos < number_of_phrase_elements) {
          typename collection_type::iterator itr = phrase_strings.begin();
          itr += beg_pos;
          std::copy(new_strings.begin(), new_strings.end(),
                    itr);

        }
      }


      template<class facet_type>
      OutItrT put_partial_date(OutItrT next, std::ios_base& a_ios,
                               CharT a_fill, const partial_date_type& pd,
                               const facet_type& facet) const
      {
        facet.put(next, a_ios, a_fill, pd.day());
        next = a_fill;
        facet.put(next, a_ios, a_fill, pd.month());
        return next;
      }


      template<class facet_type>
      OutItrT put_nth_kday(OutItrT next, std::ios_base& a_ios,
                           CharT a_fill, const nth_kday_type& nkd,
                           const facet_type& facet) const
      {
        put_string(next, phrase_strings[nkd.nth_week() -1]);
        next = a_fill;
        facet.put(next, a_ios, a_fill, nkd.day_of_week());
        next = a_fill;
        put_string(next, string_type(of_string));
        next = a_fill;
        facet.put(next, a_ios, a_fill, nkd.month());
        return next;
      }


      template<class facet_type>
      OutItrT put_first_kday(OutItrT next, std::ios_base& a_ios,
                             CharT a_fill, const first_kday_type& fkd,
                             const facet_type& facet) const
      {
        put_string(next, phrase_strings[first]);
        next = a_fill;
        facet.put(next, a_ios, a_fill, fkd.day_of_week());
        next = a_fill;
        put_string(next, string_type(of_string));
        next = a_fill;
        facet.put(next, a_ios, a_fill, fkd.month());
        return next;
      }


      template<class facet_type>
      OutItrT put_last_kday(OutItrT next, std::ios_base& a_ios,
                           CharT a_fill, const last_kday_type& lkd,
                           const facet_type& facet) const
      {
        put_string(next, phrase_strings[last]);
        next = a_fill;
        facet.put(next, a_ios, a_fill, lkd.day_of_week());
        next = a_fill;
        put_string(next, string_type(of_string));
        next = a_fill;
        facet.put(next, a_ios, a_fill, lkd.month());
        return next;
      }


      template<class facet_type>
      OutItrT put_kday_before(OutItrT next, std::ios_base& a_ios,
                              CharT a_fill, const kday_before_type& fkb,
                              const facet_type& facet) const
      {
        facet.put(next, a_ios, a_fill, fkb.day_of_week());
        next = a_fill;
        put_string(next, phrase_strings[before]);
        return next;
      }


      template<class facet_type>
      OutItrT put_kday_after(OutItrT next, std::ios_base& a_ios,
                             CharT a_fill, const kday_after_type& fka,
                             const facet_type& facet) const
      {
        facet.put(next, a_ios, a_fill, fka.day_of_week());
        next = a_fill;
        put_string(next, phrase_strings[after]);
        return next;
      }


    private:
      collection_type phrase_strings;


      OutItrT put_string(OutItrT next, const string_type& str) const
      {
        typename string_type::const_iterator itr = str.begin();
        while(itr != str.end()) {
          *next = *itr;
          ++itr;
          ++next;
        }
        return next;
      }
  };

  template<class date_type, class CharT, class OutItrT>
  const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
  date_generator_formatter<date_type, CharT, OutItrT>::first_string[6] =
    {'f','i','r','s','t'};
  template<class date_type, class CharT, class OutItrT>
  const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
  date_generator_formatter<date_type, CharT, OutItrT>::second_string[7] =
    {'s','e','c','o','n','d'};
  template<class date_type, class CharT, class OutItrT>
  const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
  date_generator_formatter<date_type, CharT, OutItrT>::third_string[6] =
    {'t','h','i','r','d'};
  template<class date_type, class CharT, class OutItrT>
  const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
  date_generator_formatter<date_type, CharT, OutItrT>::fourth_string[7] =
    {'f','o','u','r','t','h'};
  template<class date_type, class CharT, class OutItrT>
  const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
  date_generator_formatter<date_type, CharT, OutItrT>::fifth_string[6] =
    {'f','i','f','t','h'};
  template<class date_type, class CharT, class OutItrT>
  const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
  date_generator_formatter<date_type, CharT, OutItrT>::last_string[5] =
    {'l','a','s','t'};
  template<class date_type, class CharT, class OutItrT>
  const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
  date_generator_formatter<date_type, CharT, OutItrT>::before_string[8] =
    {'b','e','f','o','r','e'};
  template<class date_type, class CharT, class OutItrT>
  const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
  date_generator_formatter<date_type, CharT, OutItrT>::after_string[6] =
    {'a','f','t','e','r'};
  template<class date_type, class CharT, class OutItrT>
  const typename date_generator_formatter<date_type, CharT, OutItrT>::char_type
  date_generator_formatter<date_type, CharT, OutItrT>::of_string[3] =
    {'o','f'};
} }
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_facet.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generator_parser.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generator_parser.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/format_date_parser.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/format_date_parser.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/strings_from_facet.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/strings_from_facet.hpp" 3
namespace boost { namespace date_time {
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/strings_from_facet.hpp" 3
template<typename charT>
std::vector<std::basic_string<charT> >
gather_month_strings(const std::locale& locale, bool short_strings=true)
{
  typedef std::basic_string<charT> string_type;
  typedef std::vector<string_type> collection_type;
  typedef std::basic_ostringstream<charT> ostream_type;
  typedef std::ostreambuf_iterator<charT> ostream_iter_type;
  typedef std::basic_ostringstream<charT> stringstream_type;
  typedef std::time_put<charT> time_put_facet_type;
  charT short_fmt[3] = { '%', 'b' };
  charT long_fmt[3] = { '%', 'B' };
  collection_type months;
  string_type outfmt(short_fmt);
  if (!short_strings) {
    outfmt = long_fmt;
  }
  {


    for (int m=0; m < 12; m++) {
      tm tm_value;
      tm_value.tm_mon = m;
      stringstream_type ss;
      ostream_iter_type oitr(ss);
      std::use_facet<time_put_facet_type>(locale).put(oitr, ss, ss.fill(),
                                                      &tm_value,
                                                      &*outfmt.begin(),
                                                      &*outfmt.begin()+outfmt.size());
      months.push_back(ss.str());
    }
  }
  return months;
}
# 81 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/strings_from_facet.hpp" 3
template<typename charT>
std::vector<std::basic_string<charT> >
gather_weekday_strings(const std::locale& locale, bool short_strings=true)
{
  typedef std::basic_string<charT> string_type;
  typedef std::vector<string_type> collection_type;
  typedef std::basic_ostringstream<charT> ostream_type;
  typedef std::ostreambuf_iterator<charT> ostream_iter_type;
  typedef std::basic_ostringstream<charT> stringstream_type;
  typedef std::time_put<charT> time_put_facet_type;
  charT short_fmt[3] = { '%', 'a' };
  charT long_fmt[3] = { '%', 'A' };

  collection_type weekdays;


  string_type outfmt(short_fmt);
  if (!short_strings) {
    outfmt = long_fmt;
  }
  {


    for (int i=0; i < 7; i++) {
      tm tm_value;
      tm_value.tm_wday = i;
      stringstream_type ss;
      ostream_iter_type oitr(ss);
      std::use_facet<time_put_facet_type>(locale).put(oitr, ss, ss.fill(),
                                                      &tm_value,
                                                      &*outfmt.begin(),
                                                      &*outfmt.begin()+outfmt.size());

      weekdays.push_back(ss.str());
    }
  }
  return weekdays;
}

} }
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/format_date_parser.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/special_values_parser.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/special_values_parser.hpp" 3
namespace boost { namespace date_time {
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/special_values_parser.hpp" 3
  template<class date_type, typename charT>
  class special_values_parser
  {
   public:
    typedef std::basic_string<charT> string_type;

    typedef std::istreambuf_iterator<charT> stream_itr_type;



    typedef typename date_type::duration_type duration_type;


    typedef string_parse_tree<charT> parse_tree_type;
    typedef typename parse_tree_type::parse_match_result_type match_results;
    typedef std::vector<std::basic_string<charT> > collection_type;

    typedef charT char_type;
    static const char_type nadt_string[16];
    static const char_type neg_inf_string[10];
    static const char_type pos_inf_string[10];
    static const char_type min_date_time_string[18];
    static const char_type max_date_time_string[18];


    special_values_parser()
    {
      sv_strings(string_type(nadt_string),
                 string_type(neg_inf_string),
                 string_type(pos_inf_string),
                 string_type(min_date_time_string),
                 string_type(max_date_time_string));
    }


    special_values_parser(const string_type& nadt_str,
                          const string_type& neg_inf_str,
                          const string_type& pos_inf_str,
                          const string_type& min_dt_str,
                          const string_type& max_dt_str)
    {
      sv_strings(nadt_str, neg_inf_str, pos_inf_str, min_dt_str, max_dt_str);
    }

    special_values_parser(typename collection_type::iterator beg, typename collection_type::iterator end)
    {
      collection_type phrases;
      std::copy(beg, end, std::back_inserter(phrases));
      m_sv_strings = parse_tree_type(phrases, static_cast<int>(not_a_date_time));
    }

    special_values_parser(const special_values_parser<date_type,charT>& svp)
    {
      this->m_sv_strings = svp.m_sv_strings;
    }


    void sv_strings(const string_type& nadt_str,
                    const string_type& neg_inf_str,
                    const string_type& pos_inf_str,
                    const string_type& min_dt_str,
                    const string_type& max_dt_str)
    {
      collection_type phrases;
      phrases.push_back(nadt_str);
      phrases.push_back(neg_inf_str);
      phrases.push_back(pos_inf_str);
      phrases.push_back(min_dt_str);
      phrases.push_back(max_dt_str);
      m_sv_strings = parse_tree_type(phrases, static_cast<int>(not_a_date_time));
    }






    bool match(stream_itr_type& sitr,
                        stream_itr_type& str_end,
                        match_results& mr) const
    {
      unsigned int level = 0;
      m_sv_strings.match(sitr, str_end, mr, level);
      return (mr.current_match != match_results::PARSE_ERROR);
    }
# 130 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/special_values_parser.hpp" 3
   private:
    parse_tree_type m_sv_strings;

  };

  template<class date_type, class CharT>
  const typename special_values_parser<date_type, CharT>::char_type
  special_values_parser<date_type, CharT>::nadt_string[16] =
  {'n','o','t','-','a','-','d','a','t','e','-','t','i','m','e'};
  template<class date_type, class CharT>
  const typename special_values_parser<date_type, CharT>::char_type
  special_values_parser<date_type, CharT>::neg_inf_string[10] =
  {'-','i','n','f','i','n','i','t','y'};
  template<class date_type, class CharT>
  const typename special_values_parser<date_type, CharT>::char_type
  special_values_parser<date_type, CharT>::pos_inf_string[10] =
  {'+','i','n','f','i','n','i','t','y'};
  template<class date_type, class CharT>
  const typename special_values_parser<date_type, CharT>::char_type
  special_values_parser<date_type, CharT>::min_date_time_string[18] =
  {'m','i','n','i','m','u','m','-','d','a','t','e','-','t','i','m','e'};
  template<class date_type, class CharT>
  const typename special_values_parser<date_type, CharT>::char_type
  special_values_parser<date_type, CharT>::max_date_time_string[18] =
  {'m','a','x','i','m','u','m','-','d','a','t','e','-','t','i','m','e'};

} }
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/format_date_parser.hpp" 2 3



namespace boost { namespace date_time {






template<typename int_type, typename charT>
inline
int_type
fixed_string_to_int(std::istreambuf_iterator<charT>& itr,
                    std::istreambuf_iterator<charT>& stream_end,
                    parse_match_result<charT>& mr,
                    unsigned int length,
                    const charT& fill_char)
{

  unsigned int j = 0;

  while (j < length && itr != stream_end &&
      (std::isdigit(*itr) || *itr == fill_char)) {
    if(*itr == fill_char) {


      mr.cache += ('0');
    }
    else {
      mr.cache += (*itr);
    }
    itr++;
    j++;
  }
  int_type i = -1;

  if(mr.cache.size() < length) {
    return i;
  }
  try {
    i = boost::lexical_cast<int_type>(mr.cache);
  }catch(bad_lexical_cast blc){

  }
  return i;
}






template<typename int_type, typename charT>
inline
int_type
fixed_string_to_int(std::istreambuf_iterator<charT>& itr,
                    std::istreambuf_iterator<charT>& stream_end,
                    parse_match_result<charT>& mr,
                    unsigned int length)
{
  return fixed_string_to_int<int_type, charT>(itr, stream_end, mr, length, '0');
}





template<typename int_type, typename charT>
inline
int_type
var_string_to_int(std::istreambuf_iterator<charT>& itr,
                  std::istreambuf_iterator<charT>& ,
                  unsigned int max_length)
{
  typedef std::basic_string<charT> string_type;
  unsigned int j = 0;
  string_type s;
  while ((j < max_length) && std::isdigit(*itr)) {
    s += (*itr);
    itr++;
    j++;
  }
  int_type i = -1;
  if(s.length() != 0) {
    i = boost::lexical_cast<int_type>(s);
  }
  return i;
}
# 137 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/format_date_parser.hpp" 3
template<class date_type, typename charT>
class format_date_parser
{
 public:
  typedef std::basic_string<charT> string_type;
  typedef std::basic_ostringstream<charT> stringstream_type;
  typedef std::istreambuf_iterator<charT> stream_itr_type;
  typedef typename string_type::const_iterator const_itr;
  typedef typename date_type::year_type year_type;
  typedef typename date_type::month_type month_type;
  typedef typename date_type::day_type day_type;
  typedef typename date_type::duration_type duration_type;
  typedef typename date_type::day_of_week_type day_of_week_type;
  typedef typename date_type::day_of_year_type day_of_year_type;
  typedef string_parse_tree<charT> parse_tree_type;
  typedef typename parse_tree_type::parse_match_result_type match_results;
  typedef std::vector<std::basic_string<charT> > input_collection_type;



  format_date_parser(const string_type& format_str,
                     const input_collection_type& month_short_names,
                     const input_collection_type& month_long_names,
                     const input_collection_type& weekday_short_names,
                     const input_collection_type& weekday_long_names) :
    m_format(format_str),
    m_month_short_names(month_short_names, 1),
    m_month_long_names(month_long_names, 1),
    m_weekday_short_names(weekday_short_names),
    m_weekday_long_names(weekday_long_names)
  {}

  format_date_parser(const string_type& format_str,
                     const std::locale& locale) :
    m_format(format_str),
    m_month_short_names(gather_month_strings<charT>(locale), 1),
    m_month_long_names(gather_month_strings<charT>(locale, false), 1),
    m_weekday_short_names(gather_weekday_strings<charT>(locale)),
    m_weekday_long_names(gather_weekday_strings<charT>(locale, false))
  {}

  format_date_parser(const format_date_parser<date_type,charT>& fdp)
  {
    this->m_format = fdp.m_format;
    this->m_month_short_names = fdp.m_month_short_names;
    this->m_month_long_names = fdp.m_month_long_names;
    this->m_weekday_short_names = fdp.m_weekday_short_names;
    this->m_weekday_long_names = fdp.m_weekday_long_names;
  }

  string_type format() const
  {
    return m_format;
  }

  void format(string_type format_str)
  {
    m_format = format_str;
  }

  void short_month_names(const input_collection_type& month_names)
  {
    m_month_short_names = parse_tree_type(month_names, 1);
  }
  void long_month_names(const input_collection_type& month_names)
  {
    m_month_long_names = parse_tree_type(month_names, 1);
  }
  void short_weekday_names(const input_collection_type& weekday_names)
  {
    m_weekday_short_names = parse_tree_type(weekday_names);
  }
  void long_weekday_names(const input_collection_type& weekday_names)
  {
    m_weekday_long_names = parse_tree_type(weekday_names);
  }

  date_type
  parse_date(const string_type& value,
             const string_type& format_str,
             const special_values_parser<date_type,charT>& sv_parser) const
  {
    stringstream_type ss;
    ss << value;
    stream_itr_type sitr(ss);
    stream_itr_type stream_end;
    return parse_date(sitr, stream_end, format_str, sv_parser);
  }

  date_type
  parse_date(std::istreambuf_iterator<charT>& sitr,
             std::istreambuf_iterator<charT>& stream_end,
             const special_values_parser<date_type,charT>& sv_parser) const
  {
    return parse_date(sitr, stream_end, m_format, sv_parser);
  }




  date_type
  parse_date(std::istreambuf_iterator<charT>& sitr,
             std::istreambuf_iterator<charT>& stream_end,
             string_type format_str,
             const special_values_parser<date_type,charT>& sv_parser) const
  {
    bool use_current_char = false;


    while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }
    charT current_char = *sitr;

    short year(0), month(0), day(0), day_of_year(0);




    year_type t_year(1400);
    month_type t_month(1);
    day_type t_day(1);
    day_of_week_type wkday(0);


    const_itr itr(format_str.begin());
    while (itr != format_str.end() && (sitr != stream_end)) {
      if (*itr == '%') {
        itr++;
        if (*itr != '%') {
          switch(*itr) {
          case 'a':
            {




              match_results mr = m_weekday_short_names.match(sitr, stream_end);
              if(mr.current_match == match_results::PARSE_ERROR) {

                if(sv_parser.match(sitr, stream_end, mr)) {
                  return date_type(static_cast<special_values>(mr.current_match));
                }
              }
              wkday = mr.current_match;
              if (mr.has_remaining()) {
                current_char = mr.last_char();
                use_current_char = true;
              }
              break;
            }
          case 'A':
            {




              match_results mr = m_weekday_long_names.match(sitr, stream_end);
              if(mr.current_match == match_results::PARSE_ERROR) {

                if(sv_parser.match(sitr, stream_end, mr)) {
                  return date_type(static_cast<special_values>(mr.current_match));
                }
              }
              wkday = mr.current_match;
              if (mr.has_remaining()) {
                current_char = mr.last_char();
                use_current_char = true;
              }
              break;
            }
          case 'b':
            {
              match_results mr = m_month_short_names.match(sitr, stream_end);
              if(mr.current_match == match_results::PARSE_ERROR) {

                if(sv_parser.match(sitr, stream_end, mr)) {
                  return date_type(static_cast<special_values>(mr.current_match));
                }
              }
              t_month = month_type(mr.current_match);
              if (mr.has_remaining()) {
                current_char = mr.last_char();
                use_current_char = true;
              }
              break;
            }
          case 'B':
            {
              match_results mr = m_month_long_names.match(sitr, stream_end);
              if(mr.current_match == match_results::PARSE_ERROR) {

                if(sv_parser.match(sitr, stream_end, mr)) {
                  return date_type(static_cast<special_values>(mr.current_match));
                }
              }
              t_month = month_type(mr.current_match);
              if (mr.has_remaining()) {
                current_char = mr.last_char();
                use_current_char = true;
              }
              break;
            }
          case 'd':
            {
              match_results mr;
              day = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2);
              if(day == -1) {
                if(sv_parser.match(sitr, stream_end, mr)) {
                  return date_type(static_cast<special_values>(mr.current_match));
                }
              }
              t_day = day_type(day);
              break;
            }
          case 'e':
            {
              match_results mr;
              day = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2, ' ');
              if(day == -1) {
                if(sv_parser.match(sitr, stream_end, mr)) {
                  return date_type(static_cast<special_values>(mr.current_match));
                }
              }
              t_day = day_type(day);
              break;
            }
          case 'j':
            {
              match_results mr;
              day_of_year = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 3);
              if(day_of_year == -1) {
                if(sv_parser.match(sitr, stream_end, mr)) {
                  return date_type(static_cast<special_values>(mr.current_match));
                }
              }

              day_of_year_type t_day_of_year(1);
              t_day_of_year = day_of_year_type(day_of_year);
              break;
            }
          case 'm':
            {
              match_results mr;
              month = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2);
              if(month == -1) {
                if(sv_parser.match(sitr, stream_end, mr)) {
                  return date_type(static_cast<special_values>(mr.current_match));
                }
              }
              t_month = month_type(month);
              break;
            }
          case 'Y':
            {
              match_results mr;
              year = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 4);
              if(year == -1) {
                if(sv_parser.match(sitr, stream_end, mr)) {
                  return date_type(static_cast<special_values>(mr.current_match));
                }
              }
              t_year = year_type(year);
              break;
            }
          case 'y':
            {
              match_results mr;
              year = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2);
              if(year == -1) {
                if(sv_parser.match(sitr, stream_end, mr)) {
                  return date_type(static_cast<special_values>(mr.current_match));
                }
              }
              year += 2000;
              t_year = year_type(year);
              break;
            }
          default:
            {}

          }

        }
        else {
          sitr++;
        }

        itr++;
      }
      else {
        itr++;
        if (use_current_char) {
          use_current_char = false;
          current_char = *sitr;
        }
        else {
          sitr++;
        }
      }
    }

    if (day_of_year > 0) {
      date_type d(static_cast<unsigned short>(year-1),12,31);
      return d + duration_type(day_of_year);
    }

    return date_type(t_year, t_month, t_day);

  }


  month_type
  parse_month(std::istreambuf_iterator<charT>& sitr,
             std::istreambuf_iterator<charT>& stream_end,
             string_type format_str) const
  {
    match_results mr;
    return parse_month(sitr, stream_end, format_str, mr);
  }


  month_type
  parse_month(std::istreambuf_iterator<charT>& sitr,
             std::istreambuf_iterator<charT>& stream_end,
             string_type format_str,
             match_results& mr) const
  {
    bool use_current_char = false;


    while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }
    charT current_char = *sitr;

    short month(0);

    const_itr itr(format_str.begin());
    while (itr != format_str.end() && (sitr != stream_end)) {
      if (*itr == '%') {
        itr++;
        if (*itr != '%') {
          switch(*itr) {
          case 'b':
            {
              mr = m_month_short_names.match(sitr, stream_end);
              month = mr.current_match;
              if (mr.has_remaining()) {
                current_char = mr.last_char();
                use_current_char = true;
              }
              break;
            }
          case 'B':
            {
              mr = m_month_long_names.match(sitr, stream_end);
              month = mr.current_match;
              if (mr.has_remaining()) {
                current_char = mr.last_char();
                use_current_char = true;
              }
              break;
            }
          case 'm':
            {
              month = var_string_to_int<short, charT>(sitr, stream_end, 2);


              break;
            }
          default:
            {}

          }

        }
        else {
          sitr++;
        }

        itr++;
      }
      else {
        itr++;
        if (use_current_char) {
          use_current_char = false;
          current_char = *sitr;
        }
        else {
          sitr++;
        }
      }
    }

    return month_type(month);
  }


  day_type
  parse_var_day_of_month(std::istreambuf_iterator<charT>& sitr,
                         std::istreambuf_iterator<charT>& stream_end) const
  {

    while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }

    return day_type(var_string_to_int<short, charT>(sitr, stream_end, 2));
  }

  day_type
  parse_day_of_month(std::istreambuf_iterator<charT>& sitr,
                     std::istreambuf_iterator<charT>& stream_end) const
  {

    while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }


    match_results mr;
    return day_type(fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2));
  }

  day_of_week_type
  parse_weekday(std::istreambuf_iterator<charT>& sitr,
             std::istreambuf_iterator<charT>& stream_end,
             string_type format_str) const
  {
    match_results mr;
    return parse_weekday(sitr, stream_end, format_str, mr);
  }
  day_of_week_type
  parse_weekday(std::istreambuf_iterator<charT>& sitr,
             std::istreambuf_iterator<charT>& stream_end,
             string_type format_str,
             match_results& mr) const
  {
    bool use_current_char = false;


    while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }
    charT current_char = *sitr;

    short wkday(0);

    const_itr itr(format_str.begin());
    while (itr != format_str.end() && (sitr != stream_end)) {
      if (*itr == '%') {
        itr++;
        if (*itr != '%') {
          switch(*itr) {
          case 'a':
            {




              mr = m_weekday_short_names.match(sitr, stream_end);
              wkday = mr.current_match;
              if (mr.has_remaining()) {
                current_char = mr.last_char();
                use_current_char = true;
              }
              break;
            }
          case 'A':
            {




              mr = m_weekday_long_names.match(sitr, stream_end);
              wkday = mr.current_match;
              if (mr.has_remaining()) {
                current_char = mr.last_char();
                use_current_char = true;
              }
              break;
            }
          case 'w':
            {

              wkday = var_string_to_int<short, charT>(sitr, stream_end, 2);
              break;
            }
          default:
            {}

          }

        }
        else {
          sitr++;
        }

        itr++;
      }
      else {
        itr++;
        if (use_current_char) {
          use_current_char = false;
          current_char = *sitr;
        }
        else {
          sitr++;
        }
      }
    }

    return day_of_week_type(wkday);

  }


  year_type
  parse_year(std::istreambuf_iterator<charT>& sitr,
             std::istreambuf_iterator<charT>& stream_end,
             string_type format_str) const
  {
    match_results mr;
    return parse_year(sitr, stream_end, format_str, mr);
  }


  year_type
  parse_year(std::istreambuf_iterator<charT>& sitr,
             std::istreambuf_iterator<charT>& stream_end,
             string_type format_str,
             match_results& mr) const
  {
    bool use_current_char = false;


    while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }
    charT current_char = *sitr;

    unsigned short year(0);

    const_itr itr(format_str.begin());
    while (itr != format_str.end() && (sitr != stream_end)) {
      if (*itr == '%') {
        itr++;
        if (*itr != '%') {

          switch(*itr) {
          case 'Y':
            {

              year = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 4);
              break;
            }
          case 'y':
            {

              year = fixed_string_to_int<short, charT>(sitr, stream_end, mr, 2);
              year += 2000;
              break;
            }
          default:
            {}

          }

        }
        else {
          sitr++;
        }

        itr++;
      }
      else {
        itr++;
        if (use_current_char) {
          use_current_char = false;
          current_char = *sitr;
        }
        else {
          sitr++;
        }
      }
    }

    return year_type(year);
  }


 private:
  string_type m_format;
  parse_tree_type m_month_short_names;
  parse_tree_type m_month_long_names;
  parse_tree_type m_weekday_short_names;
  parse_tree_type m_weekday_long_names;

};

} }
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generator_parser.hpp" 2 3



namespace boost { namespace date_time {
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_generator_parser.hpp" 3
  template<class date_type, typename charT>
  class date_generator_parser
  {
   public:
    typedef std::basic_string<charT> string_type;
    typedef std::istreambuf_iterator<charT> stream_itr_type;

    typedef typename date_type::month_type month_type;
    typedef typename date_type::day_of_week_type day_of_week_type;
    typedef typename date_type::day_type day_type;

    typedef string_parse_tree<charT> parse_tree_type;
    typedef typename parse_tree_type::parse_match_result_type match_results;
    typedef std::vector<std::basic_string<charT> > collection_type;

    typedef partial_date<date_type> partial_date_type;
    typedef nth_kday_of_month<date_type> nth_kday_type;
    typedef first_kday_of_month<date_type> first_kday_type;
    typedef last_kday_of_month<date_type> last_kday_type;
    typedef first_kday_after<date_type> kday_after_type;
    typedef first_kday_before<date_type> kday_before_type;

    typedef charT char_type;
    static const char_type first_string[6];
    static const char_type second_string[7];
    static const char_type third_string[6];
    static const char_type fourth_string[7];
    static const char_type fifth_string[6];
    static const char_type last_string[5];
    static const char_type before_string[8];
    static const char_type after_string[6];
    static const char_type of_string[3];

    enum phrase_elements {first=0, second, third, fourth, fifth, last,
                          before, after, of, number_of_phrase_elements};


    date_generator_parser()
    {
      element_strings(string_type(first_string),
                      string_type(second_string),
                      string_type(third_string),
                      string_type(fourth_string),
                      string_type(fifth_string),
                      string_type(last_string),
                      string_type(before_string),
                      string_type(after_string),
                      string_type(of_string));
    }


    date_generator_parser(const string_type& first_str,
                          const string_type& second_str,
                          const string_type& third_str,
                          const string_type& fourth_str,
                          const string_type& fifth_str,
                          const string_type& last_str,
                          const string_type& before_str,
                          const string_type& after_str,
                          const string_type& of_str)
    {
      element_strings(first_str, second_str, third_str, fourth_str, fifth_str,
                      last_str, before_str, after_str, of_str);
    }


    void element_strings(const string_type& first_str,
                         const string_type& second_str,
                         const string_type& third_str,
                         const string_type& fourth_str,
                         const string_type& fifth_str,
                         const string_type& last_str,
                         const string_type& before_str,
                         const string_type& after_str,
                         const string_type& of_str)
    {
      collection_type phrases;
      phrases.push_back(first_str);
      phrases.push_back(second_str);
      phrases.push_back(third_str);
      phrases.push_back(fourth_str);
      phrases.push_back(fifth_str);
      phrases.push_back(last_str);
      phrases.push_back(before_str);
      phrases.push_back(after_str);
      phrases.push_back(of_str);
      m_element_strings = parse_tree_type(phrases, this->first);
    }

    void element_strings(const collection_type& col)
    {
      m_element_strings = parse_tree_type(col, this->first);
    }



    template<class facet_type>
    partial_date_type
    get_partial_date_type(stream_itr_type& sitr,
                          stream_itr_type& stream_end,
                          std::ios_base& a_ios,
                          const facet_type& facet) const
    {

      while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }

      day_type d(1);
      month_type m(1);
      facet.get(sitr, stream_end, a_ios, d);
      facet.get(sitr, stream_end, a_ios, m);

      return partial_date_type(d,m);
    }


    template<class facet_type>
    nth_kday_type
    get_nth_kday_type(stream_itr_type& sitr,
                      stream_itr_type& stream_end,
                      std::ios_base& a_ios,
                      const facet_type& facet) const
    {

      while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }

      typename nth_kday_type::week_num wn;
      day_of_week_type wd(0);
      month_type m(1);

      match_results mr = m_element_strings.match(sitr, stream_end);
      switch(mr.current_match) {
        case first : { wn = nth_kday_type::first; break; }
        case second : { wn = nth_kday_type::second; break; }
        case third : { wn = nth_kday_type::third; break; }
        case fourth : { wn = nth_kday_type::fourth; break; }
        case fifth : { wn = nth_kday_type::fifth; break; }
        default:
        {
          throw std::ios_base::failure("Parse failed. No match found for '" + mr.cache + "'");
          break;
        }
      }
      facet.get(sitr, stream_end, a_ios, wd);
      extract_element(sitr, stream_end, of);
      facet.get(sitr, stream_end, a_ios, m);

      return nth_kday_type(wn, wd, m);
    }


    template<class facet_type>
    first_kday_type
    get_first_kday_type(stream_itr_type& sitr,
                        stream_itr_type& stream_end,
                        std::ios_base& a_ios,
                        const facet_type& facet) const
    {

      while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }

      day_of_week_type wd(0);
      month_type m(1);

      extract_element(sitr, stream_end, first);
      facet.get(sitr, stream_end, a_ios, wd);
      extract_element(sitr, stream_end, of);
      facet.get(sitr, stream_end, a_ios, m);


      return first_kday_type(wd, m);
    }


    template<class facet_type>
    last_kday_type
    get_last_kday_type(stream_itr_type& sitr,
                       stream_itr_type& stream_end,
                       std::ios_base& a_ios,
                       const facet_type& facet) const
    {

      while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }

      day_of_week_type wd(0);
      month_type m(1);

      extract_element(sitr, stream_end, last);
      facet.get(sitr, stream_end, a_ios, wd);
      extract_element(sitr, stream_end, of);
      facet.get(sitr, stream_end, a_ios, m);


      return last_kday_type(wd, m);
    }


    template<class facet_type>
    kday_before_type
    get_kday_before_type(stream_itr_type& sitr,
                         stream_itr_type& stream_end,
                         std::ios_base& a_ios,
                         const facet_type& facet) const
    {

      while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }

      day_of_week_type wd(0);

      facet.get(sitr, stream_end, a_ios, wd);
      extract_element(sitr, stream_end, before);

      return kday_before_type(wd);
    }


    template<class facet_type>
    kday_after_type
    get_kday_after_type(stream_itr_type& sitr,
                        stream_itr_type& stream_end,
                        std::ios_base& a_ios,
                        const facet_type& facet) const
    {

      while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }

      day_of_week_type wd(0);

      facet.get(sitr, stream_end, a_ios, wd);
      extract_element(sitr, stream_end, after);

      return kday_after_type(wd);
    }

   private:
    parse_tree_type m_element_strings;


    void extract_element(stream_itr_type& sitr,
                         stream_itr_type& stream_end,
                         typename date_generator_parser::phrase_elements ele) const
    {

      while(std::isspace(*sitr) && sitr != stream_end) { ++sitr; }
      match_results mr = m_element_strings.match(sitr, stream_end);
      if(mr.current_match != ele) {
        throw std::ios_base::failure("Parse failed. No match found for '" + mr.cache + "'");
      }
    }

  };

  template<class date_type, class CharT>
  const typename date_generator_parser<date_type, CharT>::char_type
  date_generator_parser<date_type, CharT>::first_string[6] =
    {'f','i','r','s','t'};
  template<class date_type, class CharT>
  const typename date_generator_parser<date_type, CharT>::char_type
  date_generator_parser<date_type, CharT>::second_string[7] =
    {'s','e','c','o','n','d'};
  template<class date_type, class CharT>
  const typename date_generator_parser<date_type, CharT>::char_type
  date_generator_parser<date_type, CharT>::third_string[6] =
    {'t','h','i','r','d'};
  template<class date_type, class CharT>
  const typename date_generator_parser<date_type, CharT>::char_type
  date_generator_parser<date_type, CharT>::fourth_string[7] =
    {'f','o','u','r','t','h'};
  template<class date_type, class CharT>
  const typename date_generator_parser<date_type, CharT>::char_type
  date_generator_parser<date_type, CharT>::fifth_string[6] =
    {'f','i','f','t','h'};
  template<class date_type, class CharT>
  const typename date_generator_parser<date_type, CharT>::char_type
  date_generator_parser<date_type, CharT>::last_string[5] =
    {'l','a','s','t'};
  template<class date_type, class CharT>
  const typename date_generator_parser<date_type, CharT>::char_type
  date_generator_parser<date_type, CharT>::before_string[8] =
    {'b','e','f','o','r','e'};
  template<class date_type, class CharT>
  const typename date_generator_parser<date_type, CharT>::char_type
  date_generator_parser<date_type, CharT>::after_string[6] =
    {'a','f','t','e','r'};
  template<class date_type, class CharT>
  const typename date_generator_parser<date_type, CharT>::char_type
  date_generator_parser<date_type, CharT>::of_string[3] =
    {'o','f'};

} }
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_facet.hpp" 2 3




namespace boost { namespace date_time {
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/date_facet.hpp" 3
  template <class date_type,
            class CharT,
            class OutItrT = std::ostreambuf_iterator<CharT, std::char_traits<CharT> > >
  class date_facet : public std::locale::facet {
  public:
    typedef typename date_type::duration_type duration_type;

    typedef typename date_type::day_of_week_type day_of_week_type;
    typedef typename date_type::day_type day_type;
    typedef typename date_type::month_type month_type;
    typedef boost::date_time::period<date_type,duration_type> period_type;
    typedef std::basic_string<CharT> string_type;
    typedef CharT char_type;
    typedef boost::date_time::period_formatter<CharT> period_formatter_type;
    typedef boost::date_time::special_values_formatter<CharT> special_values_formatter_type;
    typedef std::vector<std::basic_string<CharT> > input_collection_type;

    typedef date_generator_formatter<date_type, CharT> date_gen_formatter_type;
    typedef partial_date<date_type> partial_date_type;
    typedef nth_kday_of_month<date_type> nth_kday_type;
    typedef first_kday_of_month<date_type> first_kday_type;
    typedef last_kday_of_month<date_type> last_kday_type;
    typedef first_kday_after<date_type> kday_after_type;
    typedef first_kday_before<date_type> kday_before_type;
    static const char_type long_weekday_format[3];
    static const char_type short_weekday_format[3];
    static const char_type long_month_format[3];
    static const char_type short_month_format[3];
    static const char_type default_period_separator[4];
    static const char_type standard_format_specifier[3];
    static const char_type iso_format_specifier[7];
    static const char_type iso_format_extended_specifier[9];
    static const char_type default_date_format[9];
    static std::locale::id id;





    explicit date_facet(::size_t a_ref = 0)
      : std::locale::facet(a_ref),

        m_format(default_date_format),
        m_month_format(short_month_format),
        m_weekday_format(short_weekday_format)
    {}

    explicit date_facet(const char_type* format_str,
                        const input_collection_type& short_names,
                        ::size_t ref_count = 0)
      : std::locale::facet(ref_count),
        m_format(format_str),
        m_month_format(short_month_format),
        m_weekday_format(short_weekday_format),
        m_month_short_names(short_names)
    {}


    explicit date_facet(const char_type* format_str,
                        period_formatter_type per_formatter = period_formatter_type(),
                        special_values_formatter_type sv_formatter = special_values_formatter_type(),
                        date_gen_formatter_type dg_formatter = date_gen_formatter_type(),
                        ::size_t ref_count = 0)
      : std::locale::facet(ref_count),
        m_format(format_str),
        m_month_format(short_month_format),
        m_weekday_format(short_weekday_format),
        m_period_formatter(per_formatter),
        m_date_gen_formatter(dg_formatter),
        m_special_values_formatter(sv_formatter)
     {}
    void format(const char_type* const format_str) {
      m_format = format_str;
    }
    virtual void set_iso_format()
    {
      m_format = iso_format_specifier;
    }
    virtual void set_iso_extended_format()
    {
      m_format = iso_format_extended_specifier;
    }
    void month_format(const char_type* const format_str) {
      m_month_format = format_str;
    }
    void weekday_format(const char_type* const format_str) {
      m_weekday_format = format_str;
    }

    void period_formatter(period_formatter_type per_formatter) {
      m_period_formatter= per_formatter;
    }
    void special_values_formatter(const special_values_formatter_type& svf)
    {
      m_special_values_formatter = svf;
    }
    void short_weekday_names(const input_collection_type& short_names)
    {
      m_weekday_short_names = short_names;
    }
    void long_weekday_names(const input_collection_type& long_names)
    {
      m_weekday_long_names = long_names;
    }

    void short_month_names(const input_collection_type& short_names)
    {
      m_month_short_names = short_names;
    }

    void long_month_names(const input_collection_type& long_names)
    {
      m_month_long_names = long_names;
    }

    void date_gen_phrase_strings(const input_collection_type& new_strings,
                           typename date_gen_formatter_type::phrase_elements beg_pos=date_gen_formatter_type::first)
    {
      m_date_gen_formatter.elements(new_strings, beg_pos);
    }

    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const date_type& d) const
    {
      if (d.is_special()) {
        return do_put_special(next, a_ios, fill_char, d.as_special());
      }

      return do_put_tm(next, a_ios, fill_char, to_tm(d), m_format);
    }

    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const duration_type& dd) const
    {
      if (dd.is_special()) {
        return do_put_special(next, a_ios, fill_char, dd.get_rep().as_special());
      }

      typedef std::num_put<CharT, OutItrT> num_put;
      if (std::has_facet<num_put>(a_ios.getloc())) {
        return std::use_facet<num_put>(a_ios.getloc()).put(next, a_ios, fill_char, dd.get_rep().as_number());
      }
      else {
        num_put* f = new num_put();
        std::locale l = std::locale(a_ios.getloc(), f);
        a_ios.imbue(l);
        return f->put(next, a_ios, fill_char, dd.get_rep().as_number());
      }

    }


    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const month_type& m) const
    {




      tm dtm;
      init_tm(dtm);
      dtm.tm_mon = m -1;
      return do_put_tm(next, a_ios, fill_char, dtm, m_month_format);
    }


    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const day_type& day) const
    {
      tm dtm;
      init_tm(dtm);
      dtm.tm_mday = day.as_number();
      char_type tmp[3] = {'%','d'};
      string_type temp_format(tmp);
      return do_put_tm(next, a_ios, fill_char, dtm, temp_format);
    }

    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const day_of_week_type& dow) const
    {




      tm dtm;
      init_tm(dtm);
      dtm.tm_wday = dow;
      return do_put_tm(next, a_ios, fill_char, dtm, m_weekday_format);
    }


    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const period_type& p) const
    {
      return m_period_formatter.put_period(next, a_ios, fill_char, p, *this);
    }

    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const partial_date_type& pd) const
    {
      return m_date_gen_formatter.put_partial_date(next, a_ios, fill_char, pd, *this);
    }

    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const nth_kday_type& nkd) const
    {
      return m_date_gen_formatter.put_nth_kday(next, a_ios, fill_char, nkd, *this);
    }

    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const first_kday_type& fkd) const
    {
      return m_date_gen_formatter.put_first_kday(next, a_ios, fill_char, fkd, *this);
    }

    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const last_kday_type& lkd) const
    {
      return m_date_gen_formatter.put_last_kday(next, a_ios, fill_char, lkd, *this);
    }

    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const kday_before_type& fkb) const
    {
      return m_date_gen_formatter.put_kday_before(next, a_ios, fill_char, fkb, *this);
    }

    OutItrT put(OutItrT next,
                std::ios_base& a_ios,
                char_type fill_char,
                const kday_after_type& fka) const
    {
      return m_date_gen_formatter.put_kday_after(next, a_ios, fill_char, fka, *this);
    }

  protected:

    tm init_tm(tm& tm_value) const
    {
      tm_value.tm_sec = 0;
      tm_value.tm_min = 0;
      tm_value.tm_hour = 0;
      tm_value.tm_mday = 0;
      tm_value.tm_mon = 0;
      tm_value.tm_year = 0;
      tm_value.tm_wday = 0;
      tm_value.tm_yday = 0;
      tm_value.tm_isdst = 0;
      return tm_value;
    }
    virtual OutItrT do_put_special(OutItrT next,
                                   std::ios_base& ,
                                   char_type ,
                                   const boost::date_time::special_values sv) const
    {
      m_special_values_formatter.put_special(next, sv);
      return next;
    }
    virtual OutItrT do_put_tm(OutItrT next,
                              std::ios_base& a_ios,
                              char_type fill_char,
                              const tm& tm_value,
                              string_type a_format) const
    {

      if (m_weekday_long_names.size()) {
        boost::algorithm::replace_all(a_format,
                                      long_weekday_format,
                                      m_weekday_long_names[tm_value.tm_wday]);
      }
      if (m_weekday_short_names.size()) {
        boost::algorithm::replace_all(a_format,
                                      short_weekday_format,
                                      m_weekday_short_names[tm_value.tm_wday]);

      }
      if (m_month_long_names.size()) {
        boost::algorithm::replace_all(a_format,
                                      long_month_format,
                                      m_month_long_names[tm_value.tm_mon]);
      }
      if (m_month_short_names.size()) {
        boost::algorithm::replace_all(a_format,
                                      short_month_format,
                                      m_month_short_names[tm_value.tm_mon]);
      }

      return std::use_facet<std::time_put<CharT> >(a_ios.getloc()).put(next, a_ios,
                                                                       fill_char,
                                                                       &tm_value,
                                                                       &*a_format.begin(),
                                                                       &*a_format.begin()+a_format.size());
    }
  protected:
    string_type m_format;
    string_type m_month_format;
    string_type m_weekday_format;
    period_formatter_type m_period_formatter;
    date_gen_formatter_type m_date_gen_formatter;
    special_values_formatter_type m_special_values_formatter;
    input_collection_type m_month_short_names;
    input_collection_type m_month_long_names;
    input_collection_type m_weekday_short_names;
    input_collection_type m_weekday_long_names;
  private:
  };

  template <class date_type, class CharT, class OutItrT>
  std::locale::id date_facet<date_type, CharT, OutItrT>::id;

  template <class date_type, class CharT, class OutItrT>
  const typename date_facet<date_type, CharT, OutItrT>::char_type
  date_facet<date_type, CharT, OutItrT>::long_weekday_format[3] = {'%','A'};

  template <class date_type, class CharT, class OutItrT>
  const typename date_facet<date_type, CharT, OutItrT>::char_type
  date_facet<date_type, CharT, OutItrT>::short_weekday_format[3] = {'%','a'};

  template <class date_type, class CharT, class OutItrT>
  const typename date_facet<date_type, CharT, OutItrT>::char_type
  date_facet<date_type, CharT, OutItrT>::long_month_format[3] = {'%','B'};

  template <class date_type, class CharT, class OutItrT>
  const typename date_facet<date_type, CharT, OutItrT>::char_type
  date_facet<date_type, CharT, OutItrT>::short_month_format[3] = {'%','b'};

  template <class date_type, class CharT, class OutItrT>
  const typename date_facet<date_type, CharT, OutItrT>::char_type
  date_facet<date_type, CharT, OutItrT>::default_period_separator[4] = { ' ', '/', ' '};

  template <class date_type, class CharT, class OutItrT>
  const typename date_facet<date_type, CharT, OutItrT>::char_type
  date_facet<date_type, CharT, OutItrT>::standard_format_specifier[3] =
    {'%', 'x' };

  template <class date_type, class CharT, class OutItrT>
  const typename date_facet<date_type, CharT, OutItrT>::char_type
  date_facet<date_type, CharT, OutItrT>::iso_format_specifier[7] =
    {'%', 'Y', '%', 'm', '%', 'd' };

  template <class date_type, class CharT, class OutItrT>
  const typename date_facet<date_type, CharT, OutItrT>::char_type
  date_facet<date_type, CharT, OutItrT>::iso_format_extended_specifier[9] =
    {'%', 'Y', '-', '%', 'm', '-', '%', 'd' };

  template <class date_type, class CharT, class OutItrT>
  const typename date_facet<date_type, CharT, OutItrT>::char_type
  date_facet<date_type, CharT, OutItrT>::default_date_format[9] =
    {'%','Y','-','%','b','-','%','d'};




  template <class date_type,
            class CharT,
            class InItrT = std::istreambuf_iterator<CharT, std::char_traits<CharT> > >
  class date_input_facet : public std::locale::facet {
  public:
    typedef typename date_type::duration_type duration_type;

    typedef typename date_type::day_of_week_type day_of_week_type;
    typedef typename date_type::day_type day_type;
    typedef typename date_type::month_type month_type;
    typedef typename date_type::year_type year_type;
    typedef boost::date_time::period<date_type,duration_type> period_type;
    typedef std::basic_string<CharT> string_type;
    typedef CharT char_type;
    typedef boost::date_time::period_parser<date_type, CharT> period_parser_type;
    typedef boost::date_time::special_values_parser<date_type,CharT> special_values_parser_type;
    typedef std::vector<std::basic_string<CharT> > input_collection_type;
    typedef format_date_parser<date_type, CharT> format_date_parser_type;

    typedef date_generator_parser<date_type, CharT> date_gen_parser_type;
    typedef partial_date<date_type> partial_date_type;
    typedef nth_kday_of_month<date_type> nth_kday_type;
    typedef first_kday_of_month<date_type> first_kday_type;
    typedef last_kday_of_month<date_type> last_kday_type;
    typedef first_kday_after<date_type> kday_after_type;
    typedef first_kday_before<date_type> kday_before_type;

    static const char_type long_weekday_format[3];
    static const char_type short_weekday_format[3];
    static const char_type long_month_format[3];
    static const char_type short_month_format[3];
    static const char_type four_digit_year_format[3];
    static const char_type two_digit_year_format[3];
    static const char_type default_period_separator[4];
    static const char_type standard_format_specifier[3];
    static const char_type iso_format_specifier[7];
    static const char_type iso_format_extended_specifier[9];
    static const char_type default_date_format[9];
    static std::locale::id id;

    explicit date_input_facet(::size_t a_ref = 0)
      : std::locale::facet(a_ref),
        m_format(default_date_format),
        m_month_format(short_month_format),
        m_weekday_format(short_weekday_format),
        m_year_format(four_digit_year_format),
        m_parser(m_format, std::locale::classic())

    {}

    explicit date_input_facet(const string_type& format_str,
                              ::size_t a_ref = 0)
      : std::locale::facet(a_ref),
        m_format(format_str),
        m_month_format(short_month_format),
        m_weekday_format(short_weekday_format),
        m_year_format(four_digit_year_format),
        m_parser(m_format, std::locale::classic())

    {}

    explicit date_input_facet(const string_type& format_str,
                              const format_date_parser_type& date_parser,
                              const special_values_parser_type& sv_parser,
                              const period_parser_type& per_parser,
                              const date_gen_parser_type& date_gen_parser,
                              ::size_t ref_count = 0)
      : std::locale::facet(ref_count),
        m_format(format_str),
        m_month_format(short_month_format),
        m_weekday_format(short_weekday_format),
        m_year_format(four_digit_year_format),
        m_parser(date_parser),
        m_date_gen_parser(date_gen_parser),
        m_period_parser(per_parser),
        m_sv_parser(sv_parser)
    {}


    void format(const char_type* const format_str) {
      m_format = format_str;
    }
    virtual void set_iso_format()
    {
      m_format = iso_format_specifier;
    }
    virtual void set_iso_extended_format()
    {
      m_format = iso_format_extended_specifier;
    }
    void month_format(const char_type* const format_str) {
      m_month_format = format_str;
    }
    void weekday_format(const char_type* const format_str) {
      m_weekday_format = format_str;
    }
    void year_format(const char_type* const format_str) {
      m_year_format = format_str;
    }

    void period_parser(period_parser_type per_parser) {
      m_period_parser = per_parser;
    }
    void short_weekday_names(const input_collection_type& weekday_names)
    {
      m_parser.short_weekday_names(weekday_names);
    }
    void long_weekday_names(const input_collection_type& weekday_names)
    {
      m_parser.long_weekday_names(weekday_names);
    }

    void short_month_names(const input_collection_type& month_names)
    {
      m_parser.short_month_names(month_names);
    }

    void long_month_names(const input_collection_type& month_names)
    {
      m_parser.long_month_names(month_names);
    }

    void date_gen_element_strings(const input_collection_type& col)
    {
      m_date_gen_parser.element_strings(col);
    }
    void date_gen_element_strings(const string_type& first,
                                  const string_type& second,
                                  const string_type& third,
                                  const string_type& fourth,
                                  const string_type& fifth,
                                  const string_type& last,
                                  const string_type& before,
                                  const string_type& after,
                                  const string_type& of)

    {
      m_date_gen_parser.element_strings(first,second,third,fourth,fifth,last,before,after,of);
    }

    void special_values_parser(special_values_parser_type sv_parser)
    {
      m_sv_parser = sv_parser;
    }

    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& ,
               date_type& d) const
    {
      d = m_parser.parse_date(from, to, m_format, m_sv_parser);
      return from;
    }
    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& ,
               month_type& m) const
    {
      m = m_parser.parse_month(from, to, m_month_format);
      return from;
    }
    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& ,
               day_of_week_type& wd) const
    {
      wd = m_parser.parse_weekday(from, to, m_weekday_format);
      return from;
    }

    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& ,
               day_type& d) const
    {
      d = m_parser.parse_var_day_of_month(from, to);
      return from;
    }
    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& ,
               year_type& y) const
    {
      y = m_parser.parse_year(from, to, m_year_format);
      return from;
    }
    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& a_ios,
               duration_type& dd) const
    {

      while(std::isspace(*from) && from != to) { ++from; }





      char_type c = '\0';

      if(*from == '-' || *from == '+') {
        c = *from;
      }
      typedef std::num_get<CharT, InItrT> num_get;
      typename duration_type::duration_rep_type val = 0;
      std::ios_base::iostate err = std::ios_base::goodbit;

      if (std::has_facet<num_get>(a_ios.getloc())) {
        from = std::use_facet<num_get>(a_ios.getloc()).get(from, to, a_ios, err, val);
      }
      else {
        num_get* ng = new num_get();
        std::locale l = std::locale(a_ios.getloc(), ng);
        a_ios.imbue(l);
        from = ng->get(from, to, a_ios, err, val);
      }
      if(err & std::ios_base::failbit){
        typedef typename special_values_parser_type::match_results match_results;
        match_results mr;
        if(c == '-' || c == '+') {
          mr.cache += c;
        }
        m_sv_parser.match(from, to, mr);
        if(mr.current_match == match_results::PARSE_ERROR) {
          throw std::ios_base::failure("Parse failed. No match found for '" + mr.cache + "'");
        }
        dd = duration_type(static_cast<special_values>(mr.current_match));
      }
      else {
        dd = duration_type(val);
      }
      return from;
    }
    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& a_ios,
               period_type& p) const
    {
      p = m_period_parser.get_period(from, to, a_ios, p, duration_type::unit(), *this);
      return from;
    }
    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& a_ios,
               nth_kday_type& nkd) const
    {
      nkd = m_date_gen_parser.get_nth_kday_type(from, to, a_ios, *this);
      return from;
    }
    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& a_ios,
               partial_date_type& pd) const
    {

      pd = m_date_gen_parser.get_partial_date_type(from, to, a_ios, *this);
      return from;
    }
    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& a_ios,
               first_kday_type& fkd) const
    {
      fkd = m_date_gen_parser.get_first_kday_type(from, to, a_ios, *this);
      return from;
    }
    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& a_ios,
               last_kday_type& lkd) const
    {
      lkd = m_date_gen_parser.get_last_kday_type(from, to, a_ios, *this);
      return from;
    }
    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& a_ios,
               kday_before_type& fkb) const
    {
      fkb = m_date_gen_parser.get_kday_before_type(from, to, a_ios, *this);
      return from;
    }
    InItrT get(InItrT& from,
               InItrT& to,
               std::ios_base& a_ios,
               kday_after_type& fka) const
    {
      fka = m_date_gen_parser.get_kday_after_type(from, to, a_ios, *this);
      return from;
    }

  protected:
    string_type m_format;
    string_type m_month_format;
    string_type m_weekday_format;
    string_type m_year_format;
    format_date_parser_type m_parser;
    date_gen_parser_type m_date_gen_parser;
    period_parser_type m_period_parser;
    special_values_parser_type m_sv_parser;
  private:
  };


  template <class date_type, class CharT, class OutItrT>
  std::locale::id date_input_facet<date_type, CharT, OutItrT>::id;

  template <class date_type, class CharT, class OutItrT>
  const typename date_input_facet<date_type, CharT, OutItrT>::char_type
  date_input_facet<date_type, CharT, OutItrT>::long_weekday_format[3] = {'%','A'};

  template <class date_type, class CharT, class OutItrT>
  const typename date_input_facet<date_type, CharT, OutItrT>::char_type
  date_input_facet<date_type, CharT, OutItrT>::short_weekday_format[3] = {'%','a'};

  template <class date_type, class CharT, class OutItrT>
  const typename date_input_facet<date_type, CharT, OutItrT>::char_type
  date_input_facet<date_type, CharT, OutItrT>::long_month_format[3] = {'%','B'};

  template <class date_type, class CharT, class OutItrT>
  const typename date_input_facet<date_type, CharT, OutItrT>::char_type
  date_input_facet<date_type, CharT, OutItrT>::short_month_format[3] = {'%','b'};

  template <class date_type, class CharT, class OutItrT>
  const typename date_input_facet<date_type, CharT, OutItrT>::char_type
  date_input_facet<date_type, CharT, OutItrT>::four_digit_year_format[3] = {'%','Y'};

  template <class date_type, class CharT, class OutItrT>
  const typename date_input_facet<date_type, CharT, OutItrT>::char_type
  date_input_facet<date_type, CharT, OutItrT>::two_digit_year_format[3] = {'%','y'};

  template <class date_type, class CharT, class OutItrT>
  const typename date_input_facet<date_type, CharT, OutItrT>::char_type
  date_input_facet<date_type, CharT, OutItrT>::default_period_separator[4] = { ' ', '/', ' '};

  template <class date_type, class CharT, class OutItrT>
  const typename date_input_facet<date_type, CharT, OutItrT>::char_type
  date_input_facet<date_type, CharT, OutItrT>::standard_format_specifier[3] =
    {'%', 'x' };

  template <class date_type, class CharT, class OutItrT>
  const typename date_input_facet<date_type, CharT, OutItrT>::char_type
  date_input_facet<date_type, CharT, OutItrT>::iso_format_specifier[7] =
    {'%', 'Y', '%', 'm', '%', 'd' };

  template <class date_type, class CharT, class OutItrT>
  const typename date_input_facet<date_type, CharT, OutItrT>::char_type
  date_input_facet<date_type, CharT, OutItrT>::iso_format_extended_specifier[9] =
    {'%', 'Y', '-', '%', 'm', '-', '%', 'd' };

  template <class date_type, class CharT, class OutItrT>
  const typename date_input_facet<date_type, CharT, OutItrT>::char_type
  date_input_facet<date_type, CharT, OutItrT>::default_date_format[9] =
    {'%','Y','-','%','b','-','%','d'};

} }
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_io.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/io/ios_state.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/io/ios_state.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/io_fwd.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/io_fwd.hpp" 3
namespace boost
{
namespace io
{




class ios_flags_saver;
class ios_precision_saver;
class ios_width_saver;
class ios_base_all_saver;

template < typename Ch, class Tr = ::std::char_traits<Ch> >
    class basic_ios_iostate_saver;
template < typename Ch, class Tr = ::std::char_traits<Ch> >
    class basic_ios_exception_saver;
template < typename Ch, class Tr = ::std::char_traits<Ch> >
    class basic_ios_tie_saver;
template < typename Ch, class Tr = ::std::char_traits<Ch> >
    class basic_ios_rdbuf_saver;
template < typename Ch, class Tr = ::std::char_traits<Ch> >
    class basic_ios_fill_saver;
template < typename Ch, class Tr = ::std::char_traits<Ch> >
    class basic_ios_locale_saver;
template < typename Ch, class Tr = ::std::char_traits<Ch> >
    class basic_ios_all_saver;

typedef basic_ios_iostate_saver<char> ios_iostate_saver;
typedef basic_ios_iostate_saver<wchar_t> wios_iostate_saver;
typedef basic_ios_exception_saver<char> ios_exception_saver;
typedef basic_ios_exception_saver<wchar_t> wios_exception_saver;
typedef basic_ios_tie_saver<char> ios_tie_saver;
typedef basic_ios_tie_saver<wchar_t> wios_tie_saver;
typedef basic_ios_rdbuf_saver<char> ios_rdbuf_saver;
typedef basic_ios_rdbuf_saver<wchar_t> wios_rdbuf_saver;
typedef basic_ios_fill_saver<char> ios_fill_saver;
typedef basic_ios_fill_saver<wchar_t> wios_fill_saver;
typedef basic_ios_locale_saver<char> ios_locale_saver;
typedef basic_ios_locale_saver<wchar_t> wios_locale_saver;
typedef basic_ios_all_saver<char> ios_all_saver;
typedef basic_ios_all_saver<wchar_t> wios_all_saver;

class ios_iword_saver;
class ios_pword_saver;
class ios_all_word_saver;


}
}
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/io/ios_state.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/io/ios_state.hpp" 3
namespace boost
{
namespace io
{




class ios_flags_saver
{
public:
    typedef ::std::ios_base state_type;
    typedef ::std::ios_base::fmtflags aspect_type;

    explicit ios_flags_saver( state_type &s )
        : s_save_( s ), a_save_( s.flags() )
        {}
    ios_flags_saver( state_type &s, aspect_type const &a )
        : s_save_( s ), a_save_( s.flags(a) )
        {}
    ~ios_flags_saver()
        { this->restore(); }

    void restore()
        { s_save_.flags( a_save_ ); }

private:
    state_type & s_save_;
    aspect_type const a_save_;

    ios_flags_saver& operator=(const ios_flags_saver&);
};

class ios_precision_saver
{
public:
    typedef ::std::ios_base state_type;
    typedef ::std::streamsize aspect_type;

    explicit ios_precision_saver( state_type &s )
        : s_save_( s ), a_save_( s.precision() )
        {}
    ios_precision_saver( state_type &s, aspect_type const &a )
        : s_save_( s ), a_save_( s.precision(a) )
        {}
    ~ios_precision_saver()
        { this->restore(); }

    void restore()
        { s_save_.precision( a_save_ ); }

private:
    state_type & s_save_;
    aspect_type const a_save_;

    ios_precision_saver& operator=(const ios_precision_saver&);
};

class ios_width_saver
{
public:
    typedef ::std::ios_base state_type;
    typedef ::std::streamsize aspect_type;

    explicit ios_width_saver( state_type &s )
        : s_save_( s ), a_save_( s.width() )
        {}
    ios_width_saver( state_type &s, aspect_type const &a )
        : s_save_( s ), a_save_( s.width(a) )
        {}
    ~ios_width_saver()
        { this->restore(); }

    void restore()
        { s_save_.width( a_save_ ); }

private:
    state_type & s_save_;
    aspect_type const a_save_;
    ios_width_saver& operator=(const ios_width_saver&);
};




template < typename Ch, class Tr >
class basic_ios_iostate_saver
{
public:
    typedef ::std::basic_ios<Ch, Tr> state_type;
    typedef ::std::ios_base::iostate aspect_type;

    explicit basic_ios_iostate_saver( state_type &s )
        : s_save_( s ), a_save_( s.rdstate() )
        {}
    basic_ios_iostate_saver( state_type &s, aspect_type const &a )
        : s_save_( s ), a_save_( s.rdstate() )
        { s.clear(a); }
    ~basic_ios_iostate_saver()
        { this->restore(); }

    void restore()
        { s_save_.clear( a_save_ ); }

private:
    state_type & s_save_;
    aspect_type const a_save_;
};

template < typename Ch, class Tr >
class basic_ios_exception_saver
{
public:
    typedef ::std::basic_ios<Ch, Tr> state_type;
    typedef ::std::ios_base::iostate aspect_type;

    explicit basic_ios_exception_saver( state_type &s )
        : s_save_( s ), a_save_( s.exceptions() )
        {}



    basic_ios_exception_saver( state_type &s, aspect_type const &a )

        : s_save_( s ), a_save_( s.exceptions() )
        { s.exceptions(a); }
    ~basic_ios_exception_saver()
        { this->restore(); }

    void restore()
        { s_save_.exceptions( a_save_ ); }

private:
    state_type & s_save_;
    aspect_type const a_save_;
};

template < typename Ch, class Tr >
class basic_ios_tie_saver
{
public:
    typedef ::std::basic_ios<Ch, Tr> state_type;
    typedef ::std::basic_ostream<Ch, Tr> * aspect_type;

    explicit basic_ios_tie_saver( state_type &s )
        : s_save_( s ), a_save_( s.tie() )
        {}
    basic_ios_tie_saver( state_type &s, aspect_type const &a )
        : s_save_( s ), a_save_( s.tie(a) )
        {}
    ~basic_ios_tie_saver()
        { this->restore(); }

    void restore()
        { s_save_.tie( a_save_ ); }

private:
    state_type & s_save_;
    aspect_type const a_save_;
};

template < typename Ch, class Tr >
class basic_ios_rdbuf_saver
{
public:
    typedef ::std::basic_ios<Ch, Tr> state_type;
    typedef ::std::basic_streambuf<Ch, Tr> * aspect_type;

    explicit basic_ios_rdbuf_saver( state_type &s )
        : s_save_( s ), a_save_( s.rdbuf() )
        {}
    basic_ios_rdbuf_saver( state_type &s, aspect_type const &a )
        : s_save_( s ), a_save_( s.rdbuf(a) )
        {}
    ~basic_ios_rdbuf_saver()
        { this->restore(); }

    void restore()
        { s_save_.rdbuf( a_save_ ); }

private:
    state_type & s_save_;
    aspect_type const a_save_;
};

template < typename Ch, class Tr >
class basic_ios_fill_saver
{
public:
    typedef ::std::basic_ios<Ch, Tr> state_type;
    typedef typename state_type::char_type aspect_type;

    explicit basic_ios_fill_saver( state_type &s )
        : s_save_( s ), a_save_( s.fill() )
        {}
    basic_ios_fill_saver( state_type &s, aspect_type const &a )
        : s_save_( s ), a_save_( s.fill(a) )
        {}
    ~basic_ios_fill_saver()
        { this->restore(); }

    void restore()
        { s_save_.fill( a_save_ ); }

private:
    state_type & s_save_;
    aspect_type const a_save_;
};


template < typename Ch, class Tr >
class basic_ios_locale_saver
{
public:
    typedef ::std::basic_ios<Ch, Tr> state_type;
    typedef ::std::locale aspect_type;

    explicit basic_ios_locale_saver( state_type &s )
        : s_save_( s ), a_save_( s.getloc() )
        {}
    basic_ios_locale_saver( state_type &s, aspect_type const &a )
        : s_save_( s ), a_save_( s.imbue(a) )
        {}
    ~basic_ios_locale_saver()
        { this->restore(); }

    void restore()
        { s_save_.imbue( a_save_ ); }

private:
    state_type & s_save_;
    aspect_type const a_save_;
};





class ios_iword_saver
{
public:
    typedef ::std::ios_base state_type;
    typedef int index_type;
    typedef long aspect_type;

    explicit ios_iword_saver( state_type &s, index_type i )
        : s_save_( s ), a_save_( s.iword(i) ), i_save_( i )
        {}
    ios_iword_saver( state_type &s, index_type i, aspect_type const &a )
        : s_save_( s ), a_save_( s.iword(i) ), i_save_( i )
        { s.iword(i) = a; }
    ~ios_iword_saver()
        { this->restore(); }

    void restore()
        { s_save_.iword( i_save_ ) = a_save_; }

private:
    state_type & s_save_;
    aspect_type const a_save_;
    index_type const i_save_;

    ios_iword_saver& operator=(const ios_iword_saver&);
};

class ios_pword_saver
{
public:
    typedef ::std::ios_base state_type;
    typedef int index_type;
    typedef void * aspect_type;

    explicit ios_pword_saver( state_type &s, index_type i )
        : s_save_( s ), a_save_( s.pword(i) ), i_save_( i )
        {}
    ios_pword_saver( state_type &s, index_type i, aspect_type const &a )
        : s_save_( s ), a_save_( s.pword(i) ), i_save_( i )
        { s.pword(i) = a; }
    ~ios_pword_saver()
        { this->restore(); }

    void restore()
        { s_save_.pword( i_save_ ) = a_save_; }

private:
    state_type & s_save_;
    aspect_type const a_save_;
    index_type const i_save_;

    ios_pword_saver operator=(const ios_pword_saver&);
};




class ios_base_all_saver
{
public:
    typedef ::std::ios_base state_type;

    explicit ios_base_all_saver( state_type &s )
        : s_save_( s ), a1_save_( s.flags() ), a2_save_( s.precision() )
        , a3_save_( s.width() )
        {}

    ~ios_base_all_saver()
        { this->restore(); }

    void restore()
    {
        s_save_.width( a3_save_ );
        s_save_.precision( a2_save_ );
        s_save_.flags( a1_save_ );
    }

private:
    state_type & s_save_;
    state_type::fmtflags const a1_save_;
    ::std::streamsize const a2_save_;
    ::std::streamsize const a3_save_;

    ios_base_all_saver& operator=(const ios_base_all_saver&);
};

template < typename Ch, class Tr >
class basic_ios_all_saver
{
public:
    typedef ::std::basic_ios<Ch, Tr> state_type;

    explicit basic_ios_all_saver( state_type &s )
        : s_save_( s ), a1_save_( s.flags() ), a2_save_( s.precision() )
        , a3_save_( s.width() ), a4_save_( s.rdstate() )
        , a5_save_( s.exceptions() ), a6_save_( s.tie() )
        , a7_save_( s.rdbuf() ), a8_save_( s.fill() )

        , a9_save_( s.getloc() )

        {}

    ~basic_ios_all_saver()
        { this->restore(); }

    void restore()
    {

        s_save_.imbue( a9_save_ );

        s_save_.fill( a8_save_ );
        s_save_.rdbuf( a7_save_ );
        s_save_.tie( a6_save_ );
        s_save_.exceptions( a5_save_ );
        s_save_.clear( a4_save_ );
        s_save_.width( a3_save_ );
        s_save_.precision( a2_save_ );
        s_save_.flags( a1_save_ );
    }

private:
    state_type & s_save_;
    typename state_type::fmtflags const a1_save_;
    ::std::streamsize const a2_save_;
    ::std::streamsize const a3_save_;
    typename state_type::iostate const a4_save_;
    typename state_type::iostate const a5_save_;
    ::std::basic_ostream<Ch, Tr> * const a6_save_;
    ::std::basic_streambuf<Ch, Tr> * const a7_save_;
    typename state_type::char_type const a8_save_;

    ::std::locale const a9_save_;

};

class ios_all_word_saver
{
public:
    typedef ::std::ios_base state_type;
    typedef int index_type;

    ios_all_word_saver( state_type &s, index_type i )
        : s_save_( s ), i_save_( i ), a1_save_( s.iword(i) )
        , a2_save_( s.pword(i) )
        {}

    ~ios_all_word_saver()
        { this->restore(); }

    void restore()
    {
        s_save_.pword( i_save_ ) = a2_save_;
        s_save_.iword( i_save_ ) = a1_save_;
    }

private:
    state_type & s_save_;
    index_type const i_save_;
    long const a1_save_;
    void * const a2_save_;

    ios_all_word_saver& operator=(const ios_all_word_saver&);
};


}
}
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/gregorian_io.hpp" 2 3



namespace boost {
namespace gregorian {


  typedef boost::date_time::period_formatter<wchar_t> wperiod_formatter;
  typedef boost::date_time::period_formatter<char> period_formatter;

  typedef boost::date_time::date_facet<date,wchar_t> wdate_facet;
  typedef boost::date_time::date_facet<date,char> date_facet;

  typedef boost::date_time::period_parser<date,char> period_parser;
  typedef boost::date_time::period_parser<date,wchar_t> wperiod_parser;

  typedef boost::date_time::special_values_formatter<char> special_values_formatter;
  typedef boost::date_time::special_values_formatter<wchar_t> wspecial_values_formatter;

  typedef boost::date_time::special_values_parser<date,char> special_values_parser;
  typedef boost::date_time::special_values_parser<date,wchar_t> wspecial_values_parser;

  typedef boost::date_time::date_input_facet<date,char> date_input_facet;
  typedef boost::date_time::date_input_facet<date,wchar_t> wdate_input_facet;

  template <class CharT, class TraitsT>
  inline std::basic_ostream<CharT, TraitsT>&
  operator<<(std::basic_ostream<CharT, TraitsT>& os, const boost::gregorian::date& d) {
    boost::io::ios_flags_saver iflags(os);
    typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
    std::ostreambuf_iterator<CharT> output_itr(os);
    if (std::has_facet<custom_date_facet>(os.getloc()))
      std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), d);
    else {







      custom_date_facet* f = new custom_date_facet();
      std::locale l = std::locale(os.getloc(), f);
      os.imbue(l);
      f->put(output_itr, os, os.fill(), d);
    }
    return os;
  }


  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is, date& d)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, d);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, d);
        }
      }
      catch(...) {

        std::ios_base::iostate exception_mask = is.exceptions();


        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {

          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }

  template <class CharT, class TraitsT>
  inline std::basic_ostream<CharT, TraitsT>&
  operator<<(std::basic_ostream<CharT, TraitsT>& os, const boost::gregorian::date_duration& dd) {
    boost::io::ios_flags_saver iflags(os);
    typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
    std::ostreambuf_iterator<CharT> output_itr(os);
    if (std::has_facet<custom_date_facet>(os.getloc()))
      std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), dd);
    else {
      custom_date_facet* f = new custom_date_facet();
      std::locale l = std::locale(os.getloc(), f);
      os.imbue(l);
      f->put(output_itr, os, os.fill(), dd);

    }
    return os;
  }


  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is, date_duration& dd)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, dd);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, dd);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }

  template <class CharT, class TraitsT>
  inline std::basic_ostream<CharT, TraitsT>&
  operator<<(std::basic_ostream<CharT, TraitsT>& os, const boost::gregorian::date_period& dp) {
    boost::io::ios_flags_saver iflags(os);
    typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
    std::ostreambuf_iterator<CharT> output_itr(os);
    if (std::has_facet<custom_date_facet>(os.getloc()))
      std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), dp);
    else {







      custom_date_facet* f = new custom_date_facet();
      std::locale l = std::locale(os.getloc(), f);
      os.imbue(l);
      f->put(output_itr, os, os.fill(), dp);

    }
    return os;
  }


  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is, date_period& dp)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, dp);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, dp);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }



  template <class CharT, class TraitsT>
  inline std::basic_ostream<CharT, TraitsT>&
  operator<<(std::basic_ostream<CharT, TraitsT>& os, const boost::gregorian::greg_month& gm) {
    boost::io::ios_flags_saver iflags(os);
    typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
    std::ostreambuf_iterator<CharT> output_itr(os);
    if (std::has_facet<custom_date_facet>(os.getloc()))
      std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), gm);
    else {
      custom_date_facet* f = new custom_date_facet();

      std::locale l = std::locale(os.getloc(), f);
      os.imbue(l);
      f->put(output_itr, os, os.fill(), gm);
    }
    return os;
  }


  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is, greg_month& m)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, m);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, m);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }


  template <class CharT, class TraitsT>
  inline std::basic_ostream<CharT, TraitsT>&
  operator<<(std::basic_ostream<CharT, TraitsT>& os, const boost::gregorian::greg_weekday& gw) {
    boost::io::ios_flags_saver iflags(os);
    typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
    std::ostreambuf_iterator<CharT> output_itr(os);
    if (std::has_facet<custom_date_facet>(os.getloc()))
      std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), gw);
    else {
      custom_date_facet* f = new custom_date_facet();
      std::locale l = std::locale(os.getloc(), f);
      os.imbue(l);
      f->put(output_itr, os, os.fill(), gw);
    }
    return os;
  }


  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is, greg_weekday& wd)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, wd);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, wd);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }




  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is, greg_day& gd)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, gd);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, gd);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }




  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is, greg_year& gy)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, gy);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, gy);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }



  template <class CharT, class TraitsT>
  inline std::basic_ostream<CharT, TraitsT>&
  operator<<(std::basic_ostream<CharT, TraitsT>& os, const boost::gregorian::partial_date& pd) {
    boost::io::ios_flags_saver iflags(os);
    typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
    std::ostreambuf_iterator<CharT> output_itr(os);
    if (std::has_facet<custom_date_facet>(os.getloc()))
      std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), pd);
    else {
      custom_date_facet* f = new custom_date_facet();
      std::locale l = std::locale(os.getloc(), f);
      os.imbue(l);
      f->put(output_itr, os, os.fill(), pd);
    }
    return os;
  }


  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is, partial_date& pd)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, pd);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, pd);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }

  template <class CharT, class TraitsT>
  inline std::basic_ostream<CharT, TraitsT>&
  operator<<(std::basic_ostream<CharT, TraitsT>& os, const boost::gregorian::nth_day_of_the_week_in_month& nkd) {
    boost::io::ios_flags_saver iflags(os);
    typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
    std::ostreambuf_iterator<CharT> output_itr(os);
    if (std::has_facet<custom_date_facet>(os.getloc()))
      std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), nkd);
    else {
      custom_date_facet* f = new custom_date_facet();
      std::locale l = std::locale(os.getloc(), f);
      os.imbue(l);
      f->put(output_itr, os, os.fill(), nkd);
    }
    return os;
  }


  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is,
             nth_day_of_the_week_in_month& nday)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, nday);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, nday);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }


  template <class CharT, class TraitsT>
  inline std::basic_ostream<CharT, TraitsT>&
  operator<<(std::basic_ostream<CharT, TraitsT>& os, const boost::gregorian::first_day_of_the_week_in_month& fkd) {
    boost::io::ios_flags_saver iflags(os);
    typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
    std::ostreambuf_iterator<CharT> output_itr(os);
    if (std::has_facet<custom_date_facet>(os.getloc()))
      std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), fkd);
    else {
      custom_date_facet* f = new custom_date_facet();
      std::locale l = std::locale(os.getloc(), f);
      os.imbue(l);
      f->put(output_itr, os, os.fill(), fkd);
    }
    return os;
  }


  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is,
             first_day_of_the_week_in_month& fkd)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, fkd);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, fkd);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }


  template <class CharT, class TraitsT>
  inline std::basic_ostream<CharT, TraitsT>&
  operator<<(std::basic_ostream<CharT, TraitsT>& os, const boost::gregorian::last_day_of_the_week_in_month& lkd) {
    boost::io::ios_flags_saver iflags(os);
    typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
    std::ostreambuf_iterator<CharT> output_itr(os);
    if (std::has_facet<custom_date_facet>(os.getloc()))
      std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), lkd);
    else {
      custom_date_facet* f = new custom_date_facet();
      std::locale l = std::locale(os.getloc(), f);
      os.imbue(l);
      f->put(output_itr, os, os.fill(), lkd);
    }
    return os;
  }


  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is,
             last_day_of_the_week_in_month& lkd)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, lkd);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, lkd);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }


  template <class CharT, class TraitsT>
  inline std::basic_ostream<CharT, TraitsT>&
  operator<<(std::basic_ostream<CharT, TraitsT>& os, const boost::gregorian::first_day_of_the_week_after& fda) {
    boost::io::ios_flags_saver iflags(os);
    typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
    std::ostreambuf_iterator<CharT> output_itr(os);
    if (std::has_facet<custom_date_facet>(os.getloc())) {
      std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), fda);
    }
    else {
      custom_date_facet* f = new custom_date_facet();
      std::locale l = std::locale(os.getloc(), f);
      os.imbue(l);
      f->put(output_itr, os, os.fill(), fda);
    }
    return os;
  }


  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is,
             first_day_of_the_week_after& fka)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, fka);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, fka);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }


  template <class CharT, class TraitsT>
  inline std::basic_ostream<CharT, TraitsT>&
  operator<<(std::basic_ostream<CharT, TraitsT>& os, const boost::gregorian::first_day_of_the_week_before& fdb) {
    boost::io::ios_flags_saver iflags(os);
    typedef boost::date_time::date_facet<date, CharT> custom_date_facet;
    std::ostreambuf_iterator<CharT> output_itr(os);
    if (std::has_facet<custom_date_facet>(os.getloc())) {
      std::use_facet<custom_date_facet>(os.getloc()).put(output_itr, os, os.fill(), fdb);
    }
    else {
      custom_date_facet* f = new custom_date_facet();
      std::locale l = std::locale(os.getloc(), f);
      os.imbue(l);
      f->put(output_itr, os, os.fill(), fdb);
    }
    return os;
  }


  template <class CharT, class Traits>
  inline
  std::basic_istream<CharT, Traits>&
  operator>>(std::basic_istream<CharT, Traits>& is,
             first_day_of_the_week_before& fkb)
  {
    boost::io::ios_flags_saver iflags(is);
    typename std::basic_istream<CharT, Traits>::sentry strm_sentry(is, false);
    if (strm_sentry) {
      try {
        typedef typename date_time::date_input_facet<date, CharT> date_input_facet;

        std::istreambuf_iterator<CharT,Traits> sit(is), str_end;
        if(std::has_facet<date_input_facet>(is.getloc())) {
          std::use_facet<date_input_facet>(is.getloc()).get(sit, str_end, is, fkb);
        }
        else {
          date_input_facet* f = new date_input_facet();
          std::locale l = std::locale(is.getloc(), f);
          is.imbue(l);
          f->get(sit, str_end, is, fkb);
        }
      }
      catch(...) {
        std::ios_base::iostate exception_mask = is.exceptions();
        if(std::ios_base::failbit & exception_mask) {
          try { is.setstate(std::ios_base::failbit); }
          catch(std::ios_base::failure&) {}
          throw;
        }
        else {
          is.setstate(std::ios_base::failbit);
        }

      }
    }
    return is;
  }


} }
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/gregorian/conversion.hpp" 2 3


namespace boost {

namespace gregorian {



  inline
  std::tm to_tm(const date& d)
  {
    if(d.is_pos_infinity() || d.is_neg_infinity() || d.is_not_a_date()){




      std::stringstream ss;
      ss << "tm unable to handle date value of " << d;
      throw std::out_of_range(ss.str());

    }
    std::tm datetm;
    boost::gregorian::date::ymd_type ymd = d.year_month_day();
    datetm.tm_year = ymd.year-1900;
    datetm.tm_mon = ymd.month-1;
    datetm.tm_mday = ymd.day;
    datetm.tm_wday = d.day_of_week();
    datetm.tm_yday = d.day_of_year()-1;
    datetm.tm_hour = datetm.tm_min = datetm.tm_sec = 0;
    datetm.tm_isdst = -1;
    return datetm;
  }


  inline
  date date_from_tm(const std::tm& datetm)
  {
    return date(static_cast<unsigned short>(datetm.tm_year+1900),
                static_cast<unsigned short>(datetm.tm_mon+1),
                static_cast<unsigned short>(datetm.tm_mday));
  }


} }
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/conversion.hpp" 2 3

namespace boost {

namespace posix_time {



  inline
  ptime from_time_t(std::time_t t)
  {
    ptime start(gregorian::date(1970,1,1));
    return start + seconds(static_cast<long>(t));
  }


  inline
  std::tm to_tm(const boost::posix_time::ptime& t) {
    std::tm timetm = boost::gregorian::to_tm(t.date());
    boost::posix_time::time_duration td = t.time_of_day();
    timetm.tm_hour = td.hours();
    timetm.tm_min = td.minutes();
    timetm.tm_sec = td.seconds();
    timetm.tm_isdst = -1;
    return timetm;
  }

  inline
  std::tm to_tm(const boost::posix_time::time_duration& td) {
    std::tm timetm;
    timetm.tm_year = 0;
    timetm.tm_mon = 0;
    timetm.tm_mday = 0;
    timetm.tm_wday = 0;
    timetm.tm_yday = 0;

    timetm.tm_hour = date_time::absolute_value(td.hours());
    timetm.tm_min = date_time::absolute_value(td.minutes());
    timetm.tm_sec = date_time::absolute_value(td.seconds());
    timetm.tm_isdst = -1;
    return timetm;
  }


  inline
  ptime ptime_from_tm(const std::tm& timetm) {
    boost::gregorian::date d = boost::gregorian::date_from_tm(timetm);
    return ptime(d, time_duration(timetm.tm_hour, timetm.tm_min, timetm.tm_sec));
  }
# 87 "/Library/Application Support/MonkeyWorks/Developer/include/boost/date_time/posix_time/conversion.hpp" 3
} }
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/xtime.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/xtime.hpp" 2 3

namespace boost {

enum xtime_clock_types
{
    TIME_UTC=1







};

struct xtime
{



    typedef int_fast64_t xtime_sec_t;


    typedef int_fast32_t xtime_nsec_t;

    xtime_sec_t sec;
    xtime_nsec_t nsec;

    operator system_time() const
    {
        return boost::posix_time::from_time_t(0)+
            boost::posix_time::seconds(static_cast<long>(sec))+



        boost::posix_time::microseconds((nsec+500)/1000);

    }

};

inline xtime get_xtime(boost::system_time const& abs_time)
{
    xtime res;
    boost::posix_time::time_duration const time_since_epoch=abs_time-boost::posix_time::from_time_t(0);

    res.sec=static_cast<xtime::xtime_sec_t>(time_since_epoch.total_seconds());
    res.nsec=static_cast<xtime::xtime_nsec_t>(time_since_epoch.fractional_seconds()*(1000000000/time_since_epoch.ticks_per_second()));
    return res;
}

inline int xtime_get(struct xtime* xtp, int clock_type)
{
    if (clock_type == TIME_UTC)
    {
        *xtp=get_xtime(get_system_time());
        return clock_type;
    }
    return 0;
}


inline int xtime_cmp(const xtime& xt1, const xtime& xt2)
{
    if (xt1.sec == xt2.sec)
        return (int)(xt1.nsec - xt2.nsec);
    else
        return (xt1.sec > xt2.sec) ? 1 : -1;
}

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 91 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/xtime.hpp" 2 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/errno.h" 1 3 4
# 23 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/errno.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/errno.h" 1 3 4
# 73 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/sys/errno.h" 3 4
extern "C" {
extern int * __error(void);

}
# 24 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/errno.h" 2 3 4
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/timespec.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/timespec.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/timespec.hpp" 2 3

namespace boost
{
    namespace detail
    {
        inline struct timespec get_timespec(boost::system_time const& abs_time)
        {
            struct timespec timeout={0,0};
            boost::posix_time::time_duration const time_since_epoch=abs_time-boost::posix_time::from_time_t(0);

            timeout.tv_sec=time_since_epoch.total_seconds();
            timeout.tv_nsec=(long)(time_since_epoch.fractional_seconds()*(1000000000l/time_since_epoch.ticks_per_second()));
            return timeout;
        }
    }
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/timespec.hpp" 2 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 1 3
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 2 3

namespace boost
{
    namespace pthread
    {
        class pthread_mutex_scoped_lock
        {
            pthread_mutex_t* m;
        public:
            explicit pthread_mutex_scoped_lock(pthread_mutex_t* m_):
                m(m_)
            {
                (__builtin_expect(!(!pthread_mutex_lock(m)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 25, "!pthread_mutex_lock(m)") : (void)0);
            }
            ~pthread_mutex_scoped_lock()
            {
                (__builtin_expect(!(!pthread_mutex_unlock(m)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 29, "!pthread_mutex_unlock(m)") : (void)0);
            }

        };

        class pthread_mutex_scoped_unlock
        {
            pthread_mutex_t* m;
        public:
            explicit pthread_mutex_scoped_unlock(pthread_mutex_t* m_):
                m(m_)
            {
                (__builtin_expect(!(!pthread_mutex_unlock(m)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 41, "!pthread_mutex_unlock(m)") : (void)0);
            }
            ~pthread_mutex_scoped_unlock()
            {
                (__builtin_expect(!(!pthread_mutex_lock(m)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 45, "!pthread_mutex_lock(m)") : (void)0);
            }

        };
    }
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 2 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 2 3







# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 2 3

namespace boost
{
    class mutex:
        boost::noncopyable
    {
    private:
        pthread_mutex_t m;
    public:
        mutex()
        {
            int const res=pthread_mutex_init(&m,__null);
            if(res)
            {
                throw thread_resource_error();
            }
        }
        ~mutex()
        {
            (__builtin_expect(!(!pthread_mutex_destroy(&m)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp", 45, "!pthread_mutex_destroy(&m)") : (void)0);
        }

        void lock()
        {
            (__builtin_expect(!(!pthread_mutex_lock(&m)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp", 50, "!pthread_mutex_lock(&m)") : (void)0);
        }

        void unlock()
        {
            (__builtin_expect(!(!pthread_mutex_unlock(&m)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp", 55, "!pthread_mutex_unlock(&m)") : (void)0);
        }

        bool try_lock()
        {
            int const res=pthread_mutex_trylock(&m);
            (__builtin_expect(!(!res || res==16), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp", 61, "!res || res==16") : (void)0);
            return !res;
        }

        typedef pthread_mutex_t* native_handle_type;
        native_handle_type native_handle()
        {
            return &m;
        }

        typedef unique_lock<mutex> scoped_lock;
        typedef detail::try_lock_wrapper<mutex> scoped_try_lock;
    };

    typedef mutex try_mutex;

    class timed_mutex:
        boost::noncopyable
    {
    private:
        pthread_mutex_t m;

        pthread_cond_t cond;
        bool is_locked;

    public:
        timed_mutex()
        {
            int const res=pthread_mutex_init(&m,__null);
            if(res)
            {
                throw thread_resource_error();
            }

            int const res2=pthread_cond_init(&cond,__null);
            if(res2)
            {
                (__builtin_expect(!(!pthread_mutex_destroy(&m)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp", 98, "!pthread_mutex_destroy(&m)") : (void)0);
                throw thread_resource_error();
            }
            is_locked=false;

        }
        ~timed_mutex()
        {
            (__builtin_expect(!(!pthread_mutex_destroy(&m)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp", 106, "!pthread_mutex_destroy(&m)") : (void)0);

            (__builtin_expect(!(!pthread_cond_destroy(&cond)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp", 108, "!pthread_cond_destroy(&cond)") : (void)0);

        }

        template<typename TimeDuration>
        bool timed_lock(TimeDuration const & relative_time)
        {
            return timed_lock(get_system_time()+relative_time);
        }
        bool timed_lock(boost::xtime const & absolute_time)
        {
            return timed_lock(system_time(absolute_time));
        }
# 154 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 3
        void lock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            while(is_locked)
            {
                (__builtin_expect(!(!pthread_cond_wait(&cond,&m)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp", 159, "!pthread_cond_wait(&cond,&m)") : (void)0);
            }
            is_locked=true;
        }

        void unlock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            is_locked=false;
            (__builtin_expect(!(!pthread_cond_signal(&cond)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp", 168, "!pthread_cond_signal(&cond)") : (void)0);
        }

        bool try_lock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            if(is_locked)
            {
                return false;
            }
            is_locked=true;
            return true;
        }

        bool timed_lock(system_time const & abs_time)
        {
            struct timespec const timeout=detail::get_timespec(abs_time);
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            while(is_locked)
            {
                int const cond_res=pthread_cond_timedwait(&cond,&m,&timeout);
                if(cond_res==60)
                {
                    return false;
                }
                (__builtin_expect(!(!cond_res), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp", 193, "!cond_res") : (void)0);
            }
            is_locked=true;
            return true;
        }


        typedef unique_lock<timed_mutex> scoped_timed_lock;
        typedef detail::try_lock_wrapper<timed_mutex> scoped_try_lock;
        typedef scoped_timed_lock scoped_lock;
    };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 208 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/pthread/mutex.hpp" 2 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/thread/mutex.hpp" 2 3
# 24 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Event.h" 2 3
# 40 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Event.h" 3
namespace mw {
 using namespace boost;


 class Event {
    protected:


  int code;


  MonkeyWorksTime time;

  Data data;
  shared_ptr<Event> nextEvent;
  boost::mutex eventLock;
    public:



        Event(const int _code, const MonkeyWorksTime _time, const Data &data);
  Event(const int _code, const Data &data);
  Event(ScarabDatum *datum);
        Event(){ }
        virtual ~Event() {}





        int getEventCode(){
   return code;
  }




        MonkeyWorksTime getTime(){
   return time;
  }

  Data getData() {
   return data;
  }

  shared_ptr<Event> getNextEvent() {
   boost::mutex::scoped_lock lock(eventLock);
   return nextEvent;
  }

  void setNextEvent(shared_ptr<Event> _nextEvent) {
   boost::mutex::scoped_lock lock(eventLock);
   nextEvent = _nextEvent;
  }




        virtual ScarabDatum *toScarabDatum();


        friend class boost::serialization::access;
        template<class Archive>
        void serialize(Archive & ar, const unsigned int version){
            ar & code;
            ar & time;
            ar & data;
        }
 };

}
# 25 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Utilities.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Exceptions.h" 1 3
# 12 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Exceptions.h" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/compat_workarounds.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/compat_workarounds.hpp" 3
namespace boost {
    namespace io {



        template<class Tr>
        class CompatTraits;




        template<class Alloc>
        class CompatAlloc;
    }
}


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/config_macros.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/config_macros.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/workarounds_gcc-2_95.hpp" 1 3
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/config_macros.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/workarounds_stlport.hpp" 1 3
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/config_macros.hpp" 2 3
# 86 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/config_macros.hpp" 3
namespace boost { namespace io { namespace detail {

    typedef ::std:: locale locale_t;



} } }
# 51 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/compat_workarounds.hpp" 2 3
# 65 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/compat_workarounds.hpp" 3
namespace boost {
    namespace io {


        template<class Tr>
        class CompatTraits
        {
        public:
            typedef Tr compatible_type;
        };


        template<class Alloc>
        class CompatAlloc
        {
        public:
            typedef Alloc compatible_type;
        };

    }
}
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3






# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_fwd.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_fwd.hpp" 3
namespace boost {

    template <class Ch,


        class Tr = ::std:: char_traits<Ch>, class Alloc = std::allocator<Ch> >



    class basic_format;

    typedef basic_format<char > format;



    typedef basic_format<wchar_t > wformat;


    namespace io {
        enum format_error_bits { bad_format_string_bit = 1,
                                 too_few_args_bit = 2, too_many_args_bit = 4,
                                 out_of_range_bit = 8,
                                 all_error_bits = 255, no_error_bits=0 };

    }

}
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/internals_fwd.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/internals_fwd.hpp" 3
namespace boost {
namespace io {

namespace detail {
  template<class Ch, class Tr> struct stream_format_state;
    template<class Ch, class Tr, class Alloc> struct format_item;





    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    modify_item_body (basic_format<Ch, Tr, Alloc>& self,
                      int itemN, T manipulator);

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    bind_arg_body (basic_format<Ch, Tr, Alloc>& self,
                   int argN, const T& val);


    template<class Ch, class Tr, class T>
    void apply_manip_body (stream_format_state<Ch, Tr>& self,
                           T manipulator);


    template<class Ch, class Tr, class Alloc, class T>
    void distribute (basic_format<Ch,Tr, Alloc>& self, T x);

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    feed (basic_format<Ch,Tr, Alloc>& self, T x);

}

}
}
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/internals.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/internals.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/internals.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type.hpp" 1 3
# 9 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type.hpp" 3
namespace boost {



  template <class T>
  struct type {};

}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 2 3







# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/reference_content.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/reference_content.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/has_nothrow_copy.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/has_nothrow_copy.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/has_trivial_copy.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/has_trivial_copy.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/has_trivial_copy.hpp" 2 3

namespace boost {

namespace detail {

template <typename T>
struct has_trivial_copy_impl
{
   static const bool value = (::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::is_pod<T>::value, false >::value, ::boost::type_traits::ice_not< ::boost::is_volatile<T>::value >::value >::value);







};

}

template< typename T > struct has_trivial_copy : ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { };
template< typename T > struct has_trivial_copy_constructor : ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/has_trivial_copy.hpp" 2 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/has_nothrow_copy.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/has_nothrow_copy.hpp" 2 3

namespace boost {

namespace detail{

template <class T>
struct has_nothrow_copy_imp{
   static const bool value = (::boost::type_traits::ice_or< ::boost::has_trivial_copy<T>::value, false >::value);




};

}

template< typename T > struct has_nothrow_copy : ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { };
template< typename T > struct has_nothrow_copy_constructor : ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { };

}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/type_traits/has_nothrow_copy.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/reference_content.hpp" 2 3







namespace boost {

namespace detail {






template <typename RefT>
class reference_content
{
private:

    RefT content_;

public:

    ~reference_content()
    {
    }

    reference_content(RefT r)
        : content_( r )
    {
    }

    reference_content(const reference_content& operand)
        : content_( operand.content_ )
    {
    }

private:

    reference_content& operator=(const reference_content&);

public:

    RefT get() const
    {
        return content_;
    }

};







template <typename T = mpl::void_> struct make_reference_content;



template <typename T>
struct make_reference_content
{
    typedef T type;
};

template <typename T>
struct make_reference_content< T& >
{
    typedef reference_content<T&> type;
};
# 109 "/Library/Application Support/MonkeyWorks/Developer/include/boost/detail/reference_content.hpp" 3
template <>
struct make_reference_content< mpl::void_ >
{
    template <typename T>
    struct apply
        : make_reference_content<T>
    {
    };

    typedef mpl::void_ type;
};

}







template <typename T>
struct has_nothrow_copy<
      ::boost::detail::reference_content< T& >
    >
    : mpl::true_
{
};



}
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/none.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/none.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/none_t.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/none_t.hpp" 3
namespace boost {

namespace detail { struct none_helper{}; }

typedef int detail::none_helper::*none_t ;

}
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/none.hpp" 2 3





namespace boost {

none_t const none = ((none_t)0) ;

}
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/compare_pointees.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/compare_pointees.hpp" 3
namespace boost {
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/compare_pointees.hpp" 3
template<class OptionalPointee>
inline
bool equal_pointees ( OptionalPointee const& x, OptionalPointee const& y )
{
  return (!x) != (!y) ? false : ( !x ? true : (*x) == (*y) ) ;
}

template<class OptionalPointee>
struct equal_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
{
  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
    { return equal_pointees(x,y) ; }
} ;
# 51 "/Library/Application Support/MonkeyWorks/Developer/include/boost/utility/compare_pointees.hpp" 3
template<class OptionalPointee>
inline
bool less_pointees ( OptionalPointee const& x, OptionalPointee const& y )
{
  return !y ? false : ( !x ? true : (*x) < (*y) ) ;
}

template<class OptionalPointee>
struct less_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
{
  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
    { return less_pointees(x,y) ; }
} ;

}
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional_fwd.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional_fwd.hpp" 3
namespace boost {

template<class T> class optional ;

}
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 2 3
# 83 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 3
namespace boost_optional_detail
{
  template <class T, class Factory>
  void construct(Factory const& factory, void* address)
  {
    factory.template apply<T>(address);
  }
}


namespace boost {

class in_place_factory_base ;
class typed_in_place_factory_base ;

namespace optional_detail {





template <class T>
class aligned_storage
{

    union dummy_u
    {
        char data[ sizeof(T) ];
        typename type_with_alignment<
          ::boost::alignment_of<T>::value >::type aligner_;
    } dummy_ ;

  public:

    void const* address() const { return &dummy_.data[0]; }
    void * address() { return &dummy_.data[0]; }
} ;

template<class T>
struct types_when_isnt_ref
{
  typedef T const& reference_const_type ;
  typedef T & reference_type ;
  typedef T const* pointer_const_type ;
  typedef T * pointer_type ;
  typedef T const& argument_type ;
} ;
template<class T>
struct types_when_is_ref
{
  typedef typename remove_reference<T>::type raw_type ;

  typedef raw_type& reference_const_type ;
  typedef raw_type& reference_type ;
  typedef raw_type* pointer_const_type ;
  typedef raw_type* pointer_type ;
  typedef raw_type& argument_type ;
} ;

struct optional_tag {} ;

template<class T>
class optional_base : public optional_tag
{
  private :

    typedef

    typename

    ::boost::detail::make_reference_content<T>::type internal_type ;

    typedef aligned_storage<internal_type> storage_type ;

    typedef types_when_isnt_ref<T> types_when_not_ref ;
    typedef types_when_is_ref<T> types_when_ref ;

    typedef optional_base<T> this_type ;

  protected :

    typedef T value_type ;

    typedef mpl::true_ is_reference_tag ;
    typedef mpl::false_ is_not_reference_tag ;

    typedef typename is_reference<T>::type is_reference_predicate ;

    typedef typename mpl::if_<is_reference_predicate,types_when_ref,types_when_not_ref>::type types ;

    typedef bool (this_type::*unspecified_bool_type)() const;

    typedef typename types::reference_type reference_type ;
    typedef typename types::reference_const_type reference_const_type ;
    typedef typename types::pointer_type pointer_type ;
    typedef typename types::pointer_const_type pointer_const_type ;
    typedef typename types::argument_type argument_type ;



    optional_base()
      :
      m_initialized(false) {}



    optional_base ( none_t )
      :
      m_initialized(false) {}



    optional_base ( argument_type val )
      :
      m_initialized(false)
    {
      construct(val);
    }



    optional_base ( bool cond, argument_type val )
      :
      m_initialized(false)
    {
      if ( cond )
        construct(val);
    }



    optional_base ( optional_base const& rhs )
      :
      m_initialized(false)
    {
      if ( rhs.is_initialized() )
        construct(rhs.get_impl());
    }





    template<class Expr>
    explicit optional_base ( Expr const& expr, Expr const* tag )
      :
      m_initialized(false)
    {
      construct(expr,tag);
    }




    ~optional_base() { destroy() ; }


    void assign ( optional_base const& rhs )
    {
      if (is_initialized())
      {
        if ( rhs.is_initialized() )
             assign_value(rhs.get_impl(), is_reference_predicate() );
        else destroy();
      }
      else
      {
        if ( rhs.is_initialized() )
          construct(rhs.get_impl());
      }
    }


    template<class U>
    void assign ( optional<U> const& rhs )
    {
      if (is_initialized())
      {
        if ( rhs.is_initialized() )
             assign_value(static_cast<value_type>(rhs.get()), is_reference_predicate() );
        else destroy();
      }
      else
      {
        if ( rhs.is_initialized() )
          construct(static_cast<value_type>(rhs.get()));
      }
    }


    void assign ( argument_type val )
    {
      if (is_initialized())
           assign_value(val, is_reference_predicate() );
      else construct(val);
    }



    void assign ( none_t ) { destroy(); }


    template<class Expr>
    void assign_expr ( Expr const& expr, Expr const* tag )
      {
        if (is_initialized())
             assign_expr_to_initialized(expr,tag);
        else construct(expr,tag);
      }


  public :



    void reset() { destroy(); }


    void reset ( argument_type val ) { assign(val); }




    pointer_const_type get_ptr() const { return m_initialized ? get_ptr_impl() : 0 ; }
    pointer_type get_ptr() { return m_initialized ? get_ptr_impl() : 0 ; }

    bool is_initialized() const { return m_initialized ; }

  protected :

    void construct ( argument_type val )
     {
       new (m_storage.address()) internal_type(val) ;
       m_initialized = true ;
     }



    template<class Expr>
    void construct ( Expr const& factory, in_place_factory_base const* )
     {
       typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((::boost::mpl::not_<is_reference_predicate>::value) == 0 ? false : true) >)> boost_static_assert_typedef_324 ;
       boost_optional_detail::construct<value_type>(factory, m_storage.address());
       m_initialized = true ;
     }


    template<class Expr>
    void construct ( Expr const& factory, typed_in_place_factory_base const* )
     {
       typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((::boost::mpl::not_<is_reference_predicate>::value) == 0 ? false : true) >)> boost_static_assert_typedef_333 ;
       factory.apply(m_storage.address()) ;
       m_initialized = true ;
     }

    template<class Expr>
    void assign_expr_to_initialized ( Expr const& factory, in_place_factory_base const* tag )
     {
       destroy();
       construct(factory,tag);
     }


    template<class Expr>
    void assign_expr_to_initialized ( Expr const& factory, typed_in_place_factory_base const* tag )
     {
       destroy();
       construct(factory,tag);
     }






    template<class Expr>
    void construct ( Expr const& expr, void const* )
     {
       new (m_storage.address()) internal_type(expr) ;
       m_initialized = true ;
     }





    template<class Expr>
    void assign_expr_to_initialized ( Expr const& expr, void const* )
     {
       assign_value(expr, is_reference_predicate());
     }
# 402 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 3
    void assign_value ( argument_type val, is_not_reference_tag ) { get_impl() = val; }
    void assign_value ( argument_type val, is_reference_tag ) { construct(val); }

    void destroy()
    {
      if ( m_initialized )
        destroy_impl(is_reference_predicate()) ;
    }

    unspecified_bool_type safe_bool() const { return m_initialized ? &this_type::is_initialized : 0 ; }

    reference_const_type get_impl() const { return dereference(get_object(), is_reference_predicate() ) ; }
    reference_type get_impl() { return dereference(get_object(), is_reference_predicate() ) ; }

    pointer_const_type get_ptr_impl() const { return cast_ptr(get_object(), is_reference_predicate() ) ; }
    pointer_type get_ptr_impl() { return cast_ptr(get_object(), is_reference_predicate() ) ; }

  private :


    internal_type const* get_object() const { return static_cast<internal_type const*>(m_storage.address()); }
    internal_type * get_object() { return static_cast<internal_type *> (m_storage.address()); }


    reference_const_type dereference( internal_type const* p, is_not_reference_tag ) const { return *p ; }
    reference_type dereference( internal_type* p, is_not_reference_tag ) { return *p ; }
    reference_const_type dereference( internal_type const* p, is_reference_tag ) const { return p->get() ; }
    reference_type dereference( internal_type* p, is_reference_tag ) { return p->get() ; }




    void destroy_impl ( is_not_reference_tag ) { get_ptr_impl()->T::~T() ; m_initialized = false ; }


    void destroy_impl ( is_reference_tag ) { m_initialized = false ; }




    pointer_const_type cast_ptr( internal_type const* p, is_not_reference_tag ) const { return p ; }
    pointer_type cast_ptr( internal_type * p, is_not_reference_tag ) { return p ; }
    pointer_const_type cast_ptr( internal_type const* p, is_reference_tag ) const { return &p->get() ; }
    pointer_type cast_ptr( internal_type * p, is_reference_tag ) { return &p->get() ; }

    bool m_initialized ;
    storage_type m_storage ;
} ;

}

template<class T>
class optional : public optional_detail::optional_base<T>
{
    typedef optional_detail::optional_base<T> base ;

    typedef typename base::unspecified_bool_type unspecified_bool_type ;

  public :

    typedef optional<T> this_type ;

    typedef typename base::value_type value_type ;
    typedef typename base::reference_type reference_type ;
    typedef typename base::reference_const_type reference_const_type ;
    typedef typename base::pointer_type pointer_type ;
    typedef typename base::pointer_const_type pointer_const_type ;
    typedef typename base::argument_type argument_type ;



    optional() : base() {}



    optional( none_t none_ ) : base(none_) {}



    optional ( argument_type val ) : base(val) {}



    optional ( bool cond, argument_type val ) : base(cond,val) {}







    template<class U>
    explicit optional ( optional<U> const& rhs )
      :
      base()
    {
      if ( rhs.is_initialized() )
        this->construct(rhs.get());
    }
# 513 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 3
    template<class Expr>
    explicit optional ( Expr const& expr ) : base(expr,&expr) {}




    optional ( optional const& rhs ) : base(rhs) {}


    ~optional() {}




    template<class Expr>
    optional& operator= ( Expr expr )
      {
        this->assign_expr(expr,&expr);
        return *this ;
      }







    template<class U>
    optional& operator= ( optional<U> const& rhs )
      {
        this->assign(rhs);
        return *this ;
      }





    optional& operator= ( optional const& rhs )
      {
        this->assign( rhs ) ;
        return *this ;
      }



    optional& operator= ( argument_type val )
      {
        this->assign( val ) ;
        return *this ;
      }




    optional& operator= ( none_t none_ )
      {
        this->assign( none_ ) ;
        return *this ;
      }




    reference_const_type get() const { (__builtin_expect(!(this->is_initialized()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp", 577, "this->is_initialized()") : (void)0) ; return this->get_impl(); }
    reference_type get() { (__builtin_expect(!(this->is_initialized()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp", 578, "this->is_initialized()") : (void)0) ; return this->get_impl(); }


    reference_const_type get_value_or ( reference_const_type v ) const { return this->is_initialized() ? get() : v ; }
    reference_type get_value_or ( reference_type v ) { return this->is_initialized() ? get() : v ; }




    pointer_const_type operator->() const { (__builtin_expect(!(this->is_initialized()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp", 587, "this->is_initialized()") : (void)0) ; return this->get_ptr_impl() ; }
    pointer_type operator->() { (__builtin_expect(!(this->is_initialized()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp", 588, "this->is_initialized()") : (void)0) ; return this->get_ptr_impl() ; }




    reference_const_type operator *() const { return this->get() ; }
    reference_type operator *() { return this->get() ; }



    operator unspecified_bool_type() const { return this->safe_bool() ; }



       bool operator!() const { return !this->is_initialized() ; }
} ;


template<class T>
inline
optional<T> make_optional ( T const& v )
{
  return optional<T>(v);
}


template<class T>
inline
optional<T> make_optional ( bool cond, T const& v )
{
  return optional<T>(cond,v);
}



template<class T>
inline
typename optional<T>::reference_const_type
get ( optional<T> const& opt )
{
  return opt.get() ;
}

template<class T>
inline
typename optional<T>::reference_type
get ( optional<T>& opt )
{
  return opt.get() ;
}



template<class T>
inline
typename optional<T>::pointer_const_type
get ( optional<T> const* opt )
{
  return opt->get_ptr() ;
}

template<class T>
inline
typename optional<T>::pointer_type
get ( optional<T>* opt )
{
  return opt->get_ptr() ;
}



template<class T>
inline
typename optional<T>::reference_const_type
get_optional_value_or ( optional<T> const& opt, typename optional<T>::reference_const_type v )
{
  return opt.get_value_or(v) ;
}

template<class T>
inline
typename optional<T>::reference_type
get_optional_value_or ( optional<T>& opt, typename optional<T>::reference_type v )
{
  return opt.get_value_or(v) ;
}



template<class T>
inline
typename optional<T>::pointer_const_type
get_pointer ( optional<T> const& opt )
{
  return opt.get_ptr() ;
}

template<class T>
inline
typename optional<T>::pointer_type
get_pointer ( optional<T>& opt )
{
  return opt.get_ptr() ;
}
# 701 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 3
template<class T>
inline
bool operator == ( optional<T> const& x, optional<T> const& y )
{ return equal_pointees(x,y); }

template<class T>
inline
bool operator < ( optional<T> const& x, optional<T> const& y )
{ return less_pointees(x,y); }

template<class T>
inline
bool operator != ( optional<T> const& x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, optional<T> const& y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( optional<T> const& x, T const& y )
{ return equal_pointees(x, optional<T>(y)); }

template<class T>
inline
bool operator < ( optional<T> const& x, T const& y )
{ return less_pointees(x, optional<T>(y)); }

template<class T>
inline
bool operator != ( optional<T> const& x, T const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, T const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, T const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, T const& y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( T const& x, optional<T> const& y )
{ return equal_pointees( optional<T>(x), y ); }

template<class T>
inline
bool operator < ( T const& x, optional<T> const& y )
{ return less_pointees( optional<T>(x), y ); }

template<class T>
inline
bool operator != ( T const& x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( T const& x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( T const& x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( T const& x, optional<T> const& y )
{ return !( x < y ) ; }






template<class T>
inline
bool operator == ( optional<T> const& x, none_t )
{ return equal_pointees(x, optional<T>() ); }

template<class T>
inline
bool operator < ( optional<T> const& x, none_t )
{ return less_pointees(x,optional<T>() ); }

template<class T>
inline
bool operator != ( optional<T> const& x, none_t y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, none_t y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, none_t y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, none_t y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( none_t x, optional<T> const& y )
{ return equal_pointees(optional<T>() ,y); }

template<class T>
inline
bool operator < ( none_t x, optional<T> const& y )
{ return less_pointees(optional<T>() ,y); }

template<class T>
inline
bool operator != ( none_t x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( none_t x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( none_t x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( none_t x, optional<T> const& y )
{ return !( x < y ) ; }





namespace optional_detail {
# 886 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional/optional.hpp" 3
template<class T>
inline
void optional_swap ( optional<T>& x, optional<T>& y )
{
  if ( !x && !!y )
  {
    x.reset(*y);
    y.reset();
  }
  else if ( !!x && !y )
  {
    y.reset(*x);
    x.reset();
  }
  else if ( !!x && !!y )
  {



    using std::swap ;

    swap(*x,*y);
  }
}

}

template<class T> inline void swap ( optional<T>& x, optional<T>& y )
{
  optional_detail::optional_swap(x,y);
}


}
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/optional.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/internals.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/alt_sstream.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/alt_sstream.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/alt_sstream.hpp" 2 3

namespace boost {
    namespace io {

        template<class Ch, class Tr=::std::char_traits<Ch>,
                 class Alloc=::std::allocator<Ch> >
        class basic_altstringbuf;

        template<class Ch, class Tr =::std::char_traits<Ch>,
                 class Alloc=::std::allocator<Ch> >
        class basic_oaltstringstream;


        template<class Ch, class Tr, class Alloc>
        class basic_altstringbuf
            : public ::std::basic_streambuf<Ch, Tr>
        {
            typedef ::std::basic_streambuf<Ch, Tr> streambuf_t;
            typedef typename CompatAlloc<Alloc>::compatible_type compat_allocator_type;
            typedef typename CompatTraits<Tr>::compatible_type compat_traits_type;
        public:
            typedef Ch char_type;
            typedef Tr traits_type;
            typedef typename compat_traits_type::int_type int_type;
            typedef typename compat_traits_type::pos_type pos_type;
            typedef typename compat_traits_type::off_type off_type;
            typedef Alloc allocator_type;
            typedef ::std::basic_string<Ch, Tr, Alloc> string_type;
            typedef typename string_type::size_type size_type;

            typedef ::std::streamsize streamsize;


            explicit basic_altstringbuf(std::ios_base::openmode mode
                                        = std::ios_base::in | std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                {}
            explicit basic_altstringbuf(const string_type& s,
                                        ::std::ios_base::openmode mode
                                        = ::std::ios_base::in | ::std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                { dealloc(); str(s); }
            virtual ~basic_altstringbuf()
                { dealloc(); }
            using streambuf_t::pbase;
            using streambuf_t::pptr;
            using streambuf_t::epptr;
            using streambuf_t::eback;
            using streambuf_t::gptr;
            using streambuf_t::egptr;

            void clear_buffer();
            void str(const string_type& s);


            Ch * begin() const;
            size_type size() const;
            size_type cur_size() const;
            Ch * pend() const
                { return ((putend_ < pptr()) ? pptr() : putend_); }
            size_type pcount() const
                { return static_cast<size_type>( pptr() - pbase()) ;}


            string_type str() const
                { return string_type(begin(), size()); }
            string_type cur_str() const
                { return string_type(begin(), cur_size()); }
        protected:
            explicit basic_altstringbuf (basic_altstringbuf * s,
                                         ::std::ios_base::openmode mode
                                         = ::std::ios_base::in | ::std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                { dealloc(); str(s); }

            virtual pos_type seekoff(off_type off, ::std::ios_base::seekdir way,
                                     ::std::ios_base::openmode which
                                     = ::std::ios_base::in | ::std::ios_base::out);
            virtual pos_type seekpos (pos_type pos,
                                      ::std::ios_base::openmode which
                                      = ::std::ios_base::in | ::std::ios_base::out);
            virtual int_type underflow();
            virtual int_type pbackfail(int_type meta = compat_traits_type::eof());
            virtual int_type overflow(int_type meta = compat_traits_type::eof());
            void dealloc();
        private:
            enum { alloc_min = 256};

            Ch *putend_;
            bool is_allocated_;
            ::std::ios_base::openmode mode_;
            compat_allocator_type alloc_;
        };



        template <class Ch, class Tr, class Alloc>
        class basic_oaltstringstream
            : private base_from_member< shared_ptr< basic_altstringbuf< Ch, Tr, Alloc> > >,
              public ::std::basic_ostream<Ch, Tr>
        {
            class No_Op {

            public:
                template<class T>
                const T & operator()(const T & arg) { return arg; }
            };
            typedef ::std::basic_ostream<Ch, Tr> stream_t;
            typedef boost::base_from_member<boost::shared_ptr<
                basic_altstringbuf<Ch,Tr, Alloc> > >
                pbase_type;
            typedef ::std::basic_string<Ch, Tr, Alloc> string_type;
            typedef typename string_type::size_type size_type;
            typedef basic_altstringbuf<Ch, Tr, Alloc> stringbuf_t;
        public:
            typedef Alloc allocator_type;
            basic_oaltstringstream()
                : pbase_type(new stringbuf_t), stream_t(rdbuf())
                { }
            basic_oaltstringstream(::boost::shared_ptr<stringbuf_t> buf)
                : pbase_type(buf), stream_t(rdbuf())
                { }
            basic_oaltstringstream(stringbuf_t * buf)
                : pbase_type(buf, No_Op() ), stream_t(rdbuf())
                { }
            stringbuf_t * rdbuf() const
                { return pbase_type::member.get(); }
            void clear_buffer()
                { rdbuf()->clear_buffer(); }


            Ch * begin() const
                { return rdbuf()->begin(); }
            size_type size() const
                { return rdbuf()->size(); }
            size_type cur_size() const
                { return rdbuf()->cur_size(); }


            string_type str() const
                { return rdbuf()->str(); }
            string_type cur_str() const
                { return rdbuf()->cur_str(); }
            void str(const string_type& s)
                { rdbuf()->str(s); }
        };

    }
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/alt_sstream_impl.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/alt_sstream_impl.hpp" 3
namespace boost {
    namespace io {


        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>::
        clear_buffer () {
            const Ch * p = pptr();
            const Ch * b = pbase();
            if(p != __null && p != b) {
                seekpos(0, ::std::ios_base::out);
            }
            p = gptr();
            b = eback();
            if(p != __null && p != b) {
                seekpos(0, ::std::ios_base::in);
            }
        }

        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>::
        str (const string_type& s) {
            size_type sz=s.size();
            if(sz != 0 && mode_ & (::std::ios_base::in | ::std::ios_base::out) ) {
                Ch *new_ptr = alloc_.allocate(sz, is_allocated_? eback() : 0);

                dealloc();
                sz = s.copy(new_ptr, sz);
                putend_ = new_ptr + sz;
                if(mode_ & ::std::ios_base::in)
                    streambuf_t::setg(new_ptr, new_ptr, new_ptr + sz);
                if(mode_ & ::std::ios_base::out) {
                    streambuf_t::setp(new_ptr, new_ptr + sz);
                    if(mode_ & (::std::ios_base::app | ::std::ios_base::ate))
                        streambuf_t::pbump(static_cast<int>(sz));
                    if(gptr() == __null)
                        streambuf_t::setg(new_ptr, __null, new_ptr);
                }
                is_allocated_ = true;
            }
            else
                dealloc();
        }
        template<class Ch, class Tr, class Alloc>
        Ch* basic_altstringbuf<Ch, Tr, Alloc>::
        begin () const {
            if(mode_ & ::std::ios_base::out && pptr() != __null)
                return pbase();
            else if(mode_ & ::std::ios_base::in && gptr() != __null)
                return eback();
            return __null;
        }

        template<class Ch, class Tr, class Alloc>
        typename std::basic_string<Ch,Tr,Alloc>::size_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        size () const {
            if(mode_ & ::std::ios_base::out && pptr())
                return static_cast<size_type>(pend() - pbase());
            else if(mode_ & ::std::ios_base::in && gptr())
                return static_cast<size_type>(egptr() - eback());
            else
                return 0;
        }

        template<class Ch, class Tr, class Alloc>
        typename std::basic_string<Ch,Tr,Alloc>::size_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        cur_size () const {
            if(mode_ & ::std::ios_base::out && pptr())
                return static_cast<streamsize>( pptr() - pbase());
            else if(mode_ & ::std::ios_base::in && gptr())
                return static_cast<streamsize>( gptr() - eback());
            else
                return 0;
        }

        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        seekoff (off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which) {
            if(pptr() != __null && putend_ < pptr())
                putend_ = pptr();
            if(which & ::std::ios_base::in && gptr() != __null) {

                if(way == ::std::ios_base::end)
                    off += static_cast<off_type>(putend_ - gptr());
                else if(way == ::std::ios_base::beg)
                    off += static_cast<off_type>(eback() - gptr());
                else if(way != ::std::ios_base::cur || (which & ::std::ios_base::out) )

                    return pos_type(off_type(-1));
                if(eback() <= off+gptr() && off+gptr() <= putend_ ) {

                    streambuf_t::gbump(static_cast<int>(off));
                    if(which & ::std::ios_base::out && pptr() != __null)

                        streambuf_t::pbump(static_cast<int>(gptr()-pptr()));
                }
                else
                    off = off_type(-1);
            }
            else if(which & ::std::ios_base::out && pptr() != __null) {

                if(way == ::std::ios_base::end)
                    off += static_cast<off_type>(putend_ - pptr());
                else if(way == ::std::ios_base::beg)
                    off += static_cast<off_type>(pbase() - pptr());
                else if(way != ::std::ios_base::beg)
                    return pos_type(off_type(-1));
                if(pbase() <= off+pptr() && off+pptr() <= putend_)

                    streambuf_t::pbump(static_cast<int>(off));
                else
                    off = off_type(-1);
            }
            else
                off = off_type(-1);
            return (pos_type(off));
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        seekpos (pos_type pos, ::std::ios_base::openmode which) {
            off_type off = off_type(pos);
            if(pptr() != __null && putend_ < pptr())
                putend_ = pptr();
            if(off != off_type(-1)) {
                if(which & ::std::ios_base::in && gptr() != __null) {

                    if(0 <= off && off <= putend_ - eback()) {
                        streambuf_t::gbump(static_cast<int>(eback() - gptr() + off));
                        if(which & ::std::ios_base::out && pptr() != __null) {

                            streambuf_t::pbump(static_cast<int>(gptr()-pptr()));
                        }
                    }
                    else
                        off = off_type(-1);
                }
                else if(which & ::std::ios_base::out && pptr() != __null) {

                    if(0 <= off && off <= putend_ - eback())
                        streambuf_t::pbump(static_cast<int>(eback() - pptr() + off));
                    else
                        off = off_type(-1);
                }
                else
                    off = off_type(-1);
                return (pos_type(off));
            }
            else {
                (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/alt_sstream_impl.hpp", 171, "0") : (void)0);
                return pos_type(off_type(-1));
            }
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        underflow () {
            if(gptr() == __null)
                return (compat_traits_type::eof());
            else if(gptr() < egptr())
                return (compat_traits_type::to_int_type(*gptr()));
            else if(mode_ & ::std::ios_base::in && pptr() != __null
                    && (gptr() < pptr() || gptr() < putend_) )
                {
                    if(putend_ < pptr())
                        putend_ = pptr();
                    streambuf_t::setg(eback(), gptr(), putend_);
                    return (compat_traits_type::to_int_type(*gptr()));
                }
            else
                return (compat_traits_type::eof());
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        pbackfail (int_type meta) {
            if(gptr() != __null && (eback() < gptr())
               && (mode_ & (::std::ios_base::out)
                   || compat_traits_type::eq_int_type(compat_traits_type::eof(), meta)
                   || compat_traits_type::eq(compat_traits_type::to_char_type(meta), gptr()[-1]) ) ) {
                streambuf_t::gbump(-1);
                if(!compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))

                    *gptr() = compat_traits_type::to_char_type(meta);
                return (compat_traits_type::not_eof(meta));
            }
            else
                return (compat_traits_type::eof());
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        overflow (int_type meta) {




            if(compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))
                return compat_traits_type::not_eof(meta);
            else if(pptr() != __null && pptr() < epptr()) {
                streambuf_t::sputc(compat_traits_type::to_char_type(meta));
                return meta;
            }
            else if(! (mode_ & ::std::ios_base::out))

                return compat_traits_type::eof();
            else {
                std::size_t prev_size = pptr() == __null ? 0 : epptr() - eback();
                std::size_t new_size = prev_size;

                std::size_t add_size = new_size / 2;
                if(add_size < alloc_min)
                    add_size = alloc_min;
                Ch * newptr = __null, *oldptr = eback();


                while (0 < add_size && ((std::numeric_limits<std::size_t>::max)()
                                        - add_size < new_size) )
                    add_size /= 2;
                if(0 < add_size) {
                    new_size += add_size;
                    newptr = alloc_.allocate(new_size, is_allocated_? oldptr : 0);
                }

                if(0 < prev_size)
                    compat_traits_type::copy(newptr, oldptr, prev_size);
                if(is_allocated_)
                    alloc_.deallocate(oldptr, prev_size);
                is_allocated_=true;

                if(prev_size == 0) {
                    putend_ = newptr;
                    streambuf_t::setp(newptr, newptr + new_size);
                    if(mode_ & ::std::ios_base::in)
                        streambuf_t::setg(newptr, newptr, newptr + 1);
                    else
                        streambuf_t::setg(newptr, 0, newptr);
                }
                else {
                    putend_ = putend_ - oldptr + newptr;
                    int pptr_count = static_cast<int>(pptr()-pbase());
                    int gptr_count = static_cast<int>(gptr()-eback());
                    streambuf_t::setp(pbase() - oldptr + newptr, newptr + new_size);
                    streambuf_t::pbump(pptr_count);
                    if(mode_ & ::std::ios_base::in)
                        streambuf_t::setg(newptr, newptr + gptr_count, pptr() + 1);
                    else
                        streambuf_t::setg(newptr, 0, newptr);
                }
                streambuf_t::sputc(compat_traits_type::to_char_type(meta));
                return meta;
            }



        }


        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>:: dealloc() {
            if(is_allocated_)
                alloc_.deallocate(eback(), (pptr() != __null ? epptr() : egptr()) - eback());
            is_allocated_ = false;
            streambuf_t::setg(0, 0, 0);
            streambuf_t::setp(0, 0);
            putend_ = __null;
        }

    }
}
# 174 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/alt_sstream.hpp" 2 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/internals.hpp" 2 3

namespace boost {
namespace io {
namespace detail {





    template<class Ch, class Tr>
    struct stream_format_state
    {
        typedef ::std:: basic_ios<Ch, Tr> basic_ios;

        stream_format_state(Ch fill) { reset(fill); }


        void reset(Ch fill);
        void set_by_stream(const basic_ios& os);
        void apply_on(basic_ios & os,
                      boost::io::detail::locale_t * loc_default = 0) const;
        template<class T>
        void apply_manip(T manipulator)
            { apply_manip_body<Ch, Tr, T>( *this, manipulator) ; }


        std::streamsize width_;
        std::streamsize precision_;
        Ch fill_;
        std::ios_base::fmtflags flags_;
        std::ios_base::iostate rdstate_;
        std::ios_base::iostate exceptions_;
        boost::optional<boost::io::detail::locale_t> loc_;
    };





    template<class Ch, class Tr, class Alloc>
    struct format_item
    {
        enum pad_values { zeropad = 1, spacepad =2, centered=4, tabulation = 8 };



        enum arg_values { argN_no_posit = -1,
                          argN_tabulation = -2,
                          argN_ignored = -3
        };
        typedef ::std:: basic_ios<Ch, Tr> basic_ios;
        typedef detail::stream_format_state<Ch, Tr> stream_format_state;
        typedef ::std::basic_string<Ch, Tr, Alloc> string_type;

        format_item(Ch fill) :argN_(argN_no_posit), fmtstate_(fill),
                              truncate_(max_streamsize()), pad_scheme_(0) {}
        void reset(Ch fill);
        void compute_states();

        static std::streamsize max_streamsize() {
            return (std::numeric_limits<std::streamsize>::max)();
        }


        int argN_;

        string_type res_;
        string_type appendix_;

        stream_format_state fmtstate_;

        std::streamsize truncate_;
        unsigned int pad_scheme_;
    };






    template<class Ch, class Tr>
    void stream_format_state<Ch,Tr>:: apply_on (basic_ios & os,
                      boost::io::detail::locale_t * loc_default) const {

        if(width_ != -1)
            os.width(width_);
        if(precision_ != -1)
            os.precision(precision_);
        if(fill_ != 0)
            os.fill(fill_);
        os.flags(flags_);
        os.clear(rdstate_);
        os.exceptions(exceptions_);

        if(loc_)
            os.imbue(loc_.get());
        else if(loc_default)
            os.imbue(*loc_default);



    }

    template<class Ch, class Tr>
    void stream_format_state<Ch,Tr>:: set_by_stream(const basic_ios& os) {

        flags_ = os.flags();
        width_ = os.width();
        precision_ = os.precision();
        fill_ = os.fill();
        rdstate_ = os.rdstate();
        exceptions_ = os.exceptions();
    }


    template<class Ch, class Tr, class T>
    void apply_manip_body( stream_format_state<Ch, Tr>& self,
                           T manipulator) {

        basic_oaltstringstream<Ch, Tr> ss;
        self.apply_on( ss );
        ss << manipulator;
        self.set_by_stream( ss );
    }

    template<class Ch, class Tr> inline
    void stream_format_state<Ch,Tr>:: reset(Ch fill) {

        width_=0; precision_=6;
        fill_=fill;
        flags_ = std::ios_base::dec | std::ios_base::skipws;

        exceptions_ = std::ios_base::goodbit;
        rdstate_ = std::ios_base::goodbit;
    }




    template<class Ch, class Tr, class Alloc>
    void format_item<Ch, Tr, Alloc>::
    reset (Ch fill) {
        argN_=argN_no_posit; truncate_ = max_streamsize(); pad_scheme_ =0;
        res_.resize(0); appendix_.resize(0);
        fmtstate_.reset(fill);
    }

    template<class Ch, class Tr, class Alloc>
    void format_item<Ch, Tr, Alloc>::
    compute_states() {


        if(pad_scheme_ & zeropad) {

            if(fmtstate_.flags_ & std::ios_base::left) {
              (__builtin_expect(!(!(fmtstate_.flags_ &(std::ios_base::adjustfield ^std::ios_base::left))), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/internals.hpp", 179, "!(fmtstate_.flags_ &(std::ios_base::adjustfield ^std::ios_base::left))") : (void)0);

              pad_scheme_ = pad_scheme_ & (~zeropad);
            }
            else {
                pad_scheme_ &= ~spacepad;
                fmtstate_.fill_='0';
                fmtstate_.flags_ = (fmtstate_.flags_ & ~std::ios_base::adjustfield)
                    | std::ios_base::internal;

            }
        }
        if(pad_scheme_ & spacepad) {
            if(fmtstate_.flags_ & std::ios_base::showpos)
                pad_scheme_ &= ~spacepad;
        }
    }


} } }
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_class.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_class.hpp" 3
namespace boost {

    template<class Ch, class Tr, class Alloc>
    class basic_format
    {
        typedef typename io::CompatTraits<Tr>::compatible_type compat_traits;
    public:
        typedef Ch CharT;
        typedef std::basic_string<Ch, Tr, Alloc> string_type;
        typedef typename string_type::size_type size_type;
        typedef io::detail::format_item<Ch, Tr, Alloc> format_item_t;
        typedef io::basic_altstringbuf<Ch, Tr, Alloc> internal_streambuf_t;


        explicit basic_format(const Ch* str=__null);
        explicit basic_format(const string_type& s);
        basic_format(const basic_format& x);
        basic_format& operator= (const basic_format& x);
        void swap(basic_format& x);


        explicit basic_format(const Ch* str, const std::locale & loc);
        explicit basic_format(const string_type& s, const std::locale & loc);

        io::detail::locale_t getloc() const;

        basic_format& clear();
        basic_format& clear_binds();
        basic_format& parse(const string_type&);


        size_type size() const;
        string_type str() const;


        template<class T>
        basic_format& operator%(const T& x)
            { return io::detail::feed<CharT, Tr, Alloc, const T&>(*this,x); }


        template<class T> basic_format& operator%(T& x)
            { return io::detail::feed<CharT, Tr, Alloc, T&>(*this,x); }



        template<class T>
        basic_format& bind_arg(int argN, const T& val)
            { return io::detail::bind_arg_body(*this, argN, val); }
        basic_format& clear_bind(int argN);
        template<class T>
        basic_format& modify_item(int itemN, T manipulator)
            { return io::detail::modify_item_body<Ch,Tr, Alloc, T> (*this, itemN, manipulator);}


        unsigned char exceptions() const;
        unsigned char exceptions(unsigned char newexcept);
# 91 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_class.hpp" 3
        template<class Ch2, class Tr2, class Alloc2>
        friend std::basic_ostream<Ch2, Tr2> &
        operator<<( std::basic_ostream<Ch2, Tr2> & ,
                    const basic_format<Ch2, Tr2, Alloc2>& );







        template<class Ch2, class Tr2, class Alloc2, class T>
        friend basic_format<Ch2, Tr2, Alloc2>&
        io::detail::feed (basic_format<Ch2, Tr2, Alloc2>&, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        void io::detail::distribute (basic_format<Ch2, Tr2, Alloc2>&, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        basic_format<Ch2, Tr2, Alloc2>&
        io::detail::modify_item_body (basic_format<Ch2, Tr2, Alloc2>&, int, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        basic_format<Ch2, Tr2, Alloc2>&
        io::detail::bind_arg_body (basic_format<Ch2, Tr2, Alloc2>&, int, const T&);

    private:

        typedef io::detail::stream_format_state<Ch, Tr> stream_format_state;

        enum style_values { ordered = 1,
                             special_needs = 4 };

        void make_or_reuse_data(std::size_t nbitems);


        std::vector<format_item_t> items_;
        std::vector<bool> bound_;

        int style_;
        int cur_arg_;
        int num_args_;
        mutable bool dumped_;
        string_type prefix_;
        unsigned char exceptions_;
        internal_streambuf_t buf_;
        boost::optional<io::detail::locale_t> loc_;
    };

}
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/exceptions.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/exceptions.hpp" 3
namespace boost {

    namespace io {



        class format_error : public std::exception
        {
        public:
            format_error() {}
            virtual const char *what() const throw() {
                return "boost::format_error: "
                    "format generic failure";
            }
        };

        class bad_format_string : public format_error
        {
            std::size_t pos_, next_;
        public:
            bad_format_string(std::size_t pos, std::size_t size)
                : pos_(pos), next_(size) {}
            std::size_t get_pos() const { return pos_; }
            std::size_t get_next() const { return next_; }
            virtual const char *what() const throw() {
                return "boost::bad_format_string: format-string is ill-formed";
            }
        };

        class too_few_args : public format_error
        {
            std::size_t cur_, expected_;
        public:
            too_few_args(std::size_t cur, std::size_t expected)
                : cur_(cur), expected_(expected) {}
            std::size_t get_cur() const { return cur_; }
            std::size_t get_expected() const { return expected_; }
            virtual const char *what() const throw() {
                return "boost::too_few_args: "
                    "format-string referred to more arguments than were passed";
            }
        };

        class too_many_args : public format_error
        {
            std::size_t cur_, expected_;
        public:
            too_many_args(std::size_t cur, std::size_t expected)
                : cur_(cur), expected_(expected) {}
            std::size_t get_cur() const { return cur_; }
            std::size_t get_expected() const { return expected_; }
            virtual const char *what() const throw() {
                return "boost::too_many_args: "
                    "format-string referred to less arguments than were passed";
            }
        };


        class out_of_range : public format_error
        {
            int index_, beg_, end_;
        public:
            out_of_range(int index, int beg, int end)
                : index_(index), beg_(beg), end_(end) {}
            int get_index() const { return index_; }
            int get_beg() const { return beg_; }
            int get_end() const { return end_; }
            virtual const char *what() const throw() {
                return "boost::out_of_range: "
                    "tried to refer to an argument (or item) number which"
                    " is out of range, according to the format string";
            }
        };


    }

}
# 45 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_implementation.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_implementation.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_implementation.hpp" 2 3



namespace boost {



    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits)
    {
        if( s)
            parse( s );
    }


    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s, const std::locale & loc)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          loc_(loc), exceptions_(io::all_error_bits)
    {
        if(s) parse( s );
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s, const std::locale & loc)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          loc_(loc), exceptions_(io::all_error_bits)
    {
        parse(s);
    }

    template< class Ch, class Tr, class Alloc>
    io::detail::locale_t basic_format<Ch, Tr, Alloc>::
    getloc() const {
        return loc_ ? loc_.get() : io::detail::locale_t();
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits)
    {
        parse(s);
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const basic_format& x)
        : items_(x.items_), bound_(x.bound_), style_(x.style_),
          cur_arg_(x.cur_arg_), num_args_(x.num_args_), dumped_(false),
          prefix_(x.prefix_), exceptions_(x.exceptions_), loc_(x.loc_)
    {
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>::
    operator= (const basic_format& x) {
        if(this == &x)
            return *this;
        (basic_format<Ch, Tr, Alloc>(x)).swap(*this);
        return *this;
    }
    template< class Ch, class Tr, class Alloc>
    void basic_format<Ch, Tr, Alloc>::
    swap (basic_format & x) {
        std::swap(exceptions_, x.exceptions_);
        std::swap(style_, x.style_);
        std::swap(cur_arg_, x.cur_arg_);
        std::swap(num_args_, x.num_args_);
        std::swap(dumped_, x.dumped_);

        items_.swap(x.items_);
        prefix_.swap(x.prefix_);
        bound_.swap(x.bound_);
    }

    template< class Ch, class Tr, class Alloc>
    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions() const {
        return exceptions_;
    }

    template< class Ch, class Tr, class Alloc>
    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions(unsigned char newexcept) {
        unsigned char swp = exceptions_;
        exceptions_ = newexcept;
        return swp;
    }

    template<class Ch, class Tr, class Alloc>
    void basic_format<Ch, Tr, Alloc>::
    make_or_reuse_data (std::size_t nbitems) {

        Ch fill = ( std::use_facet< std::ctype<Ch> >(getloc()) ). widen(' ');



        if(items_.size() == 0)
            items_.assign( nbitems, format_item_t(fill) );
        else {
            if(nbitems>items_.size())
                items_.resize(nbitems, format_item_t(fill));
            bound_.resize(0);
            for(std::size_t i=0; i < nbitems; ++i)
                items_[i].reset(fill);
        }
        prefix_.resize(0);
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear () {



        (__builtin_expect(!(bound_.size()==0 || num_args_ == static_cast<int>(bound_.size())), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_implementation.hpp", 135, "bound_.size()==0 || num_args_ == static_cast<int>(bound_.size())") : (void)0);

        for(unsigned long i=0; i<items_.size(); ++i) {

            if( bound_.size()==0 || items_[i].argN_<0 || !bound_[ items_[i].argN_ ] )
                items_[i].res_.resize(0);
        }
        cur_arg_=0; dumped_=false;

        if(bound_.size() != 0) {
            for(; cur_arg_ < num_args_ && bound_[cur_arg_]; ++cur_arg_)
                {}
        }
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear_binds () {

        bound_.resize(0);
        clear();
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear_bind (int argN) {

        if(argN<1 || argN > num_args_ || bound_.size()==0 || !bound_[argN-1] ) {
            if( exceptions() & io::out_of_range_bit)
                boost::throw_exception(io::out_of_range(argN, 1, num_args_+1 ) );
            else return *this;
        }
        bound_[argN-1]=false;
        clear();
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    typename basic_format<Ch, Tr, Alloc>::string_type
    basic_format<Ch,Tr, Alloc>::
    str () const {
        if(items_.size()==0)
            return prefix_;
        if( cur_arg_ < num_args_)
            if( exceptions() & io::too_few_args_bit )

                boost::throw_exception(io::too_few_args(cur_arg_, num_args_));

        unsigned long i;
        string_type res;
        res.reserve(size());
        res += prefix_;
        for(i=0; i < items_.size(); ++i) {
            const format_item_t& item = items_[i];
            res += item.res_;
            if( item.argN_ == format_item_t::argN_tabulation) {
                (__builtin_expect(!(item.pad_scheme_ & format_item_t::tabulation), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_implementation.hpp", 193, "item.pad_scheme_ & format_item_t::tabulation") : (void)0);
                if( static_cast<size_type>(item.fmtstate_.width_) > res.size() )
                    res.append( static_cast<size_type>(item.fmtstate_.width_) - res.size(),
                                        item.fmtstate_.fill_ );
            }
            res += item.appendix_;
        }
        dumped_=true;
        return res;
    }
    template< class Ch, class Tr, class Alloc>
    typename std::basic_string<Ch, Tr, Alloc>::size_type basic_format<Ch,Tr, Alloc>::
    size () const {







        using std::max;
        size_type sz = prefix_.size();
        unsigned long i;
        for(i=0; i < items_.size(); ++i) {
            const format_item_t& item = items_[i];
            sz += item.res_.size();
            if( item.argN_ == format_item_t::argN_tabulation)
                sz = max (sz,
                                        static_cast<size_type>(item.fmtstate_.width_) );
            sz += item.appendix_.size();
        }
        return sz;



    }

namespace io {
namespace detail {

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    bind_arg_body (basic_format<Ch, Tr, Alloc>& self, int argN, const T& val) {


        if(self.dumped_)
            self.clear();
        if(argN<1 || argN > self.num_args_) {
            if( self.exceptions() & io::out_of_range_bit )
                boost::throw_exception(io::out_of_range(argN, 1, self.num_args_+1 ) );
            else return self;
        }
        if(self.bound_.size()==0)
            self.bound_.assign(self.num_args_,false);
        else
            (__builtin_expect(!(self.num_args_ == static_cast<signed int>(self.bound_.size())), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_implementation.hpp", 248, "self.num_args_ == static_cast<signed int>(self.bound_.size())") : (void)0);
        int o_cur_arg = self.cur_arg_;
        self.cur_arg_ = argN-1;

        self.bound_[self.cur_arg_]=false;
        self.operator%(val);



        self.cur_arg_ = o_cur_arg;
        self.bound_[argN-1]=true;
        if(self.cur_arg_ == argN-1 ) {

            while(self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_])
                ++self.cur_arg_;
        }

        (__builtin_expect(!(self.cur_arg_ >= self.num_args_ || ! self.bound_[self.cur_arg_]), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/format_implementation.hpp", 265, "self.cur_arg_ >= self.num_args_ || ! self.bound_[self.cur_arg_]") : (void)0);
        return self;
    }

    template<class Ch, class Tr, class Alloc, class T> basic_format<Ch, Tr, Alloc>&
    modify_item_body (basic_format<Ch, Tr, Alloc>& self, int itemN, T manipulator) {


        if(itemN<1 || itemN > static_cast<signed int>(self.items_.size() )) {
            if( self.exceptions() & io::out_of_range_bit )
                boost::throw_exception(io::out_of_range(itemN, 1, static_cast<int>(self.items_.size()) ));
            else return self;
        }
        self.items_[itemN-1].fmtstate_. template apply_manip<T> ( manipulator );
        return self;
    }

}
}
}
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/group.hpp" 1 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/group.hpp" 3
namespace boost {
namespace io {


namespace detail {



struct group0
{
    group0() {}
};

template <class Ch, class Tr>
inline
::std:: basic_ostream<Ch, Tr>&
operator << ( ::std:: basic_ostream<Ch, Tr>& os,
             const group0& )
{
   return os;
}

template <class T1>
struct group1
{
    T1 a1_;
    group1(T1 a1)
      : a1_(a1)
      {}
private:
   group1& operator=(const group1&);
};

template <class Ch, class Tr, class T1>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group1<T1>& x)
{
   os << x.a1_;
   return os;
}




template <class T1,class T2>
struct group2
{
    T1 a1_;
    T2 a2_;
    group2(T1 a1,T2 a2)
      : a1_(a1),a2_(a2)
      {}
private:
   group2& operator=(const group2&);
};

template <class Ch, class Tr, class T1,class T2>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group2<T1,T2>& x)
{
   os << x.a1_<< x.a2_;
   return os;
}

template <class T1,class T2,class T3>
struct group3
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    group3(T1 a1,T2 a2,T3 a3)
      : a1_(a1),a2_(a2),a3_(a3)
      {}
private:
   group3& operator=(const group3&);
};

template <class Ch, class Tr, class T1,class T2,class T3>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group3<T1,T2,T3>& x)
{
   os << x.a1_<< x.a2_<< x.a3_;
   return os;
}

template <class T1,class T2,class T3,class T4>
struct group4
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    group4(T1 a1,T2 a2,T3 a3,T4 a4)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4)
      {}
private:
   group4& operator=(const group4&);
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group4<T1,T2,T3,T4>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5>
struct group5
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    group5(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group5<T1,T2,T3,T4,T5>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6>
struct group6
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    group6(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group6<T1,T2,T3,T4,T5,T6>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
struct group7
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    group7(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group7<T1,T2,T3,T4,T5,T6,T7>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
struct group8
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    group8(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group8<T1,T2,T3,T4,T5,T6,T7,T8>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
struct group9
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    T9 a9_;
    group9(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group9<T1,T2,T3,T4,T5,T6,T7,T8,T9>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
struct group10
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    T9 a9_;
    T10 a10_;
    group10(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9,T10 a10)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9),a10_(a10)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_<< x.a10_;
   return os;
}




template <class T1,class T2>
inline
group1<T1>
group_head( group2<T1,T2> const& x)
{
   return group1<T1> (x.a1_);
}

template <class T1,class T2>
inline
group1<T2>
group_last( group2<T1,T2> const& x)
{
   return group1<T2> (x.a2_);
}



template <class T1,class T2,class T3>
inline
group2<T1,T2>
group_head( group3<T1,T2,T3> const& x)
{
   return group2<T1,T2> (x.a1_,x.a2_);
}

template <class T1,class T2,class T3>
inline
group1<T3>
group_last( group3<T1,T2,T3> const& x)
{
   return group1<T3> (x.a3_);
}



template <class T1,class T2,class T3,class T4>
inline
group3<T1,T2,T3>
group_head( group4<T1,T2,T3,T4> const& x)
{
   return group3<T1,T2,T3> (x.a1_,x.a2_,x.a3_);
}

template <class T1,class T2,class T3,class T4>
inline
group1<T4>
group_last( group4<T1,T2,T3,T4> const& x)
{
   return group1<T4> (x.a4_);
}



template <class T1,class T2,class T3,class T4,class T5>
inline
group4<T1,T2,T3,T4>
group_head( group5<T1,T2,T3,T4,T5> const& x)
{
   return group4<T1,T2,T3,T4> (x.a1_,x.a2_,x.a3_,x.a4_);
}

template <class T1,class T2,class T3,class T4,class T5>
inline
group1<T5>
group_last( group5<T1,T2,T3,T4,T5> const& x)
{
   return group1<T5> (x.a5_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6>
inline
group5<T1,T2,T3,T4,T5>
group_head( group6<T1,T2,T3,T4,T5,T6> const& x)
{
   return group5<T1,T2,T3,T4,T5> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6>
inline
group1<T6>
group_last( group6<T1,T2,T3,T4,T5,T6> const& x)
{
   return group1<T6> (x.a6_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
group6<T1,T2,T3,T4,T5,T6>
group_head( group7<T1,T2,T3,T4,T5,T6,T7> const& x)
{
   return group6<T1,T2,T3,T4,T5,T6> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
group1<T7>
group_last( group7<T1,T2,T3,T4,T5,T6,T7> const& x)
{
   return group1<T7> (x.a7_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
group7<T1,T2,T3,T4,T5,T6,T7>
group_head( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)
{
   return group7<T1,T2,T3,T4,T5,T6,T7> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
group1<T8>
group_last( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)
{
   return group1<T8> (x.a8_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
group8<T1,T2,T3,T4,T5,T6,T7,T8>
group_head( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)
{
   return group8<T1,T2,T3,T4,T5,T6,T7,T8> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
group1<T9>
group_last( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)
{
   return group1<T9> (x.a9_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
group9<T1,T2,T3,T4,T5,T6,T7,T8,T9>
group_head( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)
{
   return group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_,x.a9_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
group1<T10>
group_last( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)
{
   return group1<T10> (x.a10_);
}





}






inline detail::group1< detail::group0 >
group() { return detail::group1< detail::group0 > ( detail::group0() ); }

template <class T1, class Var>
inline
detail::group1< detail::group2<T1, Var const&> >
  group(T1 a1, Var const& var)
{
   return detail::group1< detail::group2<T1, Var const&> >
                   ( detail::group2<T1, Var const&>
                        (a1, var)
                  );
}

template <class T1,class T2, class Var>
inline
detail::group1< detail::group3<T1,T2, Var const&> >
  group(T1 a1,T2 a2, Var const& var)
{
   return detail::group1< detail::group3<T1,T2, Var const&> >
                   ( detail::group3<T1,T2, Var const&>
                        (a1,a2, var)
                  );
}

template <class T1,class T2,class T3, class Var>
inline
detail::group1< detail::group4<T1,T2,T3, Var const&> >
  group(T1 a1,T2 a2,T3 a3, Var const& var)
{
   return detail::group1< detail::group4<T1,T2,T3, Var const&> >
                   ( detail::group4<T1,T2,T3, Var const&>
                        (a1,a2,a3, var)
                  );
}

template <class T1,class T2,class T3,class T4, class Var>
inline
detail::group1< detail::group5<T1,T2,T3,T4, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4, Var const& var)
{
   return detail::group1< detail::group5<T1,T2,T3,T4, Var const&> >
                   ( detail::group5<T1,T2,T3,T4, Var const&>
                        (a1,a2,a3,a4, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5, class Var>
inline
detail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var const& var)
{
   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >
                   ( detail::group6<T1,T2,T3,T4,T5, Var const&>
                        (a1,a2,a3,a4,a5, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6, class Var>
inline
detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var const& var)
{
   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >
                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var const&>
                        (a1,a2,a3,a4,a5,a6, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var>
inline
detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var const& var)
{
   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >
                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var>
inline
detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var const& var)
{
   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >
                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7,a8, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var>
inline
detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var const& var)
{
   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >
                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var)
                  );
}




template <class T1, class Var>
inline
detail::group1< detail::group2<T1, Var&> >
  group(T1 a1, Var& var)
{
   return detail::group1< detail::group2<T1, Var&> >
                   ( detail::group2<T1, Var&>
                        (a1, var)
                  );
}

template <class T1,class T2, class Var>
inline
detail::group1< detail::group3<T1,T2, Var&> >
  group(T1 a1,T2 a2, Var& var)
{
   return detail::group1< detail::group3<T1,T2, Var&> >
                   ( detail::group3<T1,T2, Var&>
                        (a1,a2, var)
                  );
}

template <class T1,class T2,class T3, class Var>
inline
detail::group1< detail::group4<T1,T2,T3, Var&> >
  group(T1 a1,T2 a2,T3 a3, Var& var)
{
   return detail::group1< detail::group4<T1,T2,T3, Var&> >
                   ( detail::group4<T1,T2,T3, Var&>
                        (a1,a2,a3, var)
                  );
}

template <class T1,class T2,class T3,class T4, class Var>
inline
detail::group1< detail::group5<T1,T2,T3,T4, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4, Var& var)
{
   return detail::group1< detail::group5<T1,T2,T3,T4, Var&> >
                   ( detail::group5<T1,T2,T3,T4, Var&>
                        (a1,a2,a3,a4, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5, class Var>
inline
detail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var& var)
{
   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >
                   ( detail::group6<T1,T2,T3,T4,T5, Var&>
                        (a1,a2,a3,a4,a5, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6, class Var>
inline
detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var& var)
{
   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >
                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var&>
                        (a1,a2,a3,a4,a5,a6, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var>
inline
detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var& var)
{
   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >
                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&>
                        (a1,a2,a3,a4,a5,a6,a7, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var>
inline
detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var& var)
{
   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >
                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&>
                        (a1,a2,a3,a4,a5,a6,a7,a8, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var>
inline
detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var& var)
{
   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >
                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&>
                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var)
                  );
}





}

}
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/feed_args.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/feed_args.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/feed_args.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/msvc_disambiguater.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/feed_args.hpp" 2 3

namespace boost {
namespace io {
namespace detail {

    template<class Ch, class Tr, class Alloc>
    void mk_str( std::basic_string<Ch,Tr, Alloc> & res,
                 const Ch * beg,
                 typename std::basic_string<Ch,Tr,Alloc>::size_type size,
                 std::streamsize w,
                 const Ch fill_char,
                 std::ios_base::fmtflags f,
                 const Ch prefix_space,
                 bool center)


    {
        typedef typename std::basic_string<Ch,Tr,Alloc>::size_type size_type;
        res.resize(0);
        if(w<=0 || static_cast<size_type>(w) <=size) {

            res.reserve(size + !!prefix_space);
            if(prefix_space)
              res.append(1, prefix_space);
            if (size)
              res.append(beg, size);
        }
        else {
            std::streamsize n=static_cast<std::streamsize>(w-size-!!prefix_space);
            std::streamsize n_after = 0, n_before = 0;
            res.reserve(static_cast<size_type>(w));
            if(center)
                n_after = n/2, n_before = n - n_after;
            else
                if(f & std::ios_base::left)
                    n_after = n;
                else
                    n_before = n;

            if(n_before) res.append(static_cast<size_type>(n_before), fill_char);
            if(prefix_space)
              res.append(1, prefix_space);
            if (size)
              res.append(beg, size);
            if(n_after) res.append(static_cast<size_type>(n_after), fill_char);
        }
    }
# 89 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/feed_args.hpp" 3
    template< class Ch, class Tr, class T> inline
    void put_head (::std:: basic_ostream<Ch, Tr> &, const T& ) {
    }

    template< class Ch, class Tr, class T> inline
    void put_head( ::std:: basic_ostream<Ch, Tr> & os, const group1<T>& x ) {
        os << group_head(x.a1_);
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, const T& x ) {
        os << x ;
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, const group1<T>& x ) {
        os << group_last(x.a1_);
    }


    template< class Ch, class Tr, class T> inline
    void put_head( ::std:: basic_ostream<Ch, Tr> &, T& ) {
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, T& x) {
        os << x ;
    }




    template< class Ch, class Tr, class Alloc, class T>
    void put( T x,
              const format_item<Ch, Tr, Alloc>& specs,
              typename basic_format<Ch, Tr, Alloc>::string_type& res,
              typename basic_format<Ch, Tr, Alloc>::internal_streambuf_t & buf,
              io::detail::locale_t *loc_p = __null)
    {
# 138 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/feed_args.hpp" 3
        typedef typename basic_format<Ch, Tr, Alloc>::string_type string_type;
        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;
        typedef typename string_type::size_type size_type;

        basic_oaltstringstream<Ch, Tr, Alloc> oss( &buf);
        specs.fmtstate_.apply_on(oss, loc_p);


        put_head( oss, x );



        const std::ios_base::fmtflags fl=oss.flags();
        const bool internal = (fl & std::ios_base::internal) != 0;
        const std::streamsize w = oss.width();
        const bool two_stepped_padding= internal && (w!=0);

        res.resize(0);
        if(! two_stepped_padding) {
            if(w>0)
                oss.width(0);
            put_last( oss, x);
            const Ch * res_beg = buf.pbase();
            Ch prefix_space = 0;
            if(specs.pad_scheme_ & format_item_t::spacepad)
                if(buf.pcount()== 0 ||
                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-') ))
                    prefix_space = oss.widen(' ');
            size_type res_size = (std::min)(
                static_cast<size_type>(specs.truncate_ - !!prefix_space),
                buf.pcount() );
            mk_str(res, res_beg, res_size, w, oss.fill(), fl,
                   prefix_space, (specs.pad_scheme_ & format_item_t::centered) !=0 );
        }
        else {



            put_last( oss, x);
            const Ch * res_beg = buf.pbase();
            size_type res_size = buf.pcount();
            bool prefix_space=false;
            if(specs.pad_scheme_ & format_item_t::spacepad)
                if(buf.pcount()== 0 ||
                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-') ))
                    prefix_space = true;
            if(res_size == static_cast<size_type>(w) && w<=specs.truncate_ && !prefix_space) {

                res.assign(res_beg, res_size);
            }
            else {



                res.assign(res_beg, res_size);
                res_beg=__null;


                buf.clear_buffer();
                basic_oaltstringstream<Ch, Tr, Alloc> oss2( &buf);
                specs.fmtstate_.apply_on(oss2, loc_p);
                put_head( oss2, x );

                oss2.width(0);
                if(prefix_space)
                    oss2 << ' ';
                put_last(oss2, x );
                if(buf.pcount()==0 && specs.pad_scheme_ & format_item_t::spacepad) {
                    prefix_space =true;
                    oss2 << ' ';
                }

                const Ch * tmp_beg = buf.pbase();
                size_type tmp_size = (std::min)(static_cast<size_type>(specs.truncate_),
                                                buf.pcount() );


                if(static_cast<size_type>(w) <= tmp_size) {

                        res.assign(tmp_beg, tmp_size);
                }
                else {

                    size_type sz = (std::min)(res_size + (prefix_space ? 1 : 0), tmp_size);
                    size_type i = prefix_space;
                    for(; i<sz && tmp_beg[i] == res[i - (prefix_space ? 1 : 0)]; ++i) {}
                    if(i>=tmp_size) i=prefix_space;
                    res.assign(tmp_beg, i);
                                        std::streamsize d = w - static_cast<std::streamsize>(tmp_size);
                                        (__builtin_expect(!(d>0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/feed_args.hpp", 227, "d>0") : (void)0);
                    res.append(static_cast<size_type>( d ), oss2.fill());
                    res.append(tmp_beg+i, tmp_size-i);
                    (__builtin_expect(!(i+(tmp_size-i)+(std::max)(d,(std::streamsize)0) == static_cast<size_type>(w)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/feed_args.hpp", 231, "i+(tmp_size-i)+(std::max)(d,(std::streamsize)0) == static_cast<size_type>(w)") : (void)0);

                    (__builtin_expect(!(res.size() == static_cast<size_type>(w)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/feed_args.hpp", 232, "res.size() == static_cast<size_type>(w)") : (void)0);
                }
            }
        }
        buf.clear_buffer();



    }


    template< class Ch, class Tr, class Alloc, class T>
    void distribute (basic_format<Ch,Tr, Alloc>& self, T x) {

        if(self.cur_arg_ >= self.num_args_) {
            if( self.exceptions() & too_many_args_bit )
                boost::throw_exception(too_many_args(self.cur_arg_, self.num_args_));
            else return;
        }
        for(unsigned long i=0; i < self.items_.size(); ++i) {
            if(self.items_[i].argN_ == self.cur_arg_) {
                put<Ch, Tr, Alloc, T> (x, self.items_[i], self.items_[i].res_,
                                self.buf_, boost::get_pointer(self.loc_) );
            }
        }
    }

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    feed (basic_format<Ch,Tr, Alloc>& self, T x) {
        if(self.dumped_) self.clear();
        distribute<Ch, Tr, Alloc, T> (self, x);
        ++self.cur_arg_;
        if(self.bound_.size() != 0) {
                while( self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_] )
                    ++self.cur_arg_;
        }
        return self;
    }

}
}
}
# 50 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/parsing.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/parsing.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/parsing.hpp" 2 3


namespace boost {
namespace io {
namespace detail {
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/parsing.hpp" 3
    template<class T>
    const T& const_or_not(const T& x) {
        return x;
    }


    template<class Ch, class Facet> inline
    char wrap_narrow(const Facet& fac, Ch c, char deflt) {
        return const_or_not(fac).narrow(c, deflt);
    }

    template<class Ch, class Facet> inline
    bool wrap_isdigit(const Facet& fac, Ch c) {

        return fac.is(std::ctype<Ch>::digit, c);




    }

    template<class Iter, class Facet>
    Iter wrap_scan_notdigit(const Facet & fac, Iter beg, Iter end) {
        using namespace std;
        for( ; beg!=end && wrap_isdigit(fac, *beg); ++beg) ;
        return beg;
    }






    template<class Res, class Iter, class Facet>
    Iter str2int (const Iter & start, const Iter & last, Res & res,
                 const Facet& fac)
    {
        using namespace std;
        Iter it;
        res=0;
        for(it=start; it != last && wrap_isdigit(fac, *it); ++it ) {
            char cur_ch = wrap_narrow(fac, *it, 0);
            res *= 10;
            res += cur_ch - '0';
        }
        return it;
    }






    template<class Iter, class Facet>
    Iter skip_asterisk(Iter start, Iter last, const Facet& fac)
    {
        using namespace std;
        ++ start;
        start = wrap_scan_notdigit(fac, start, last);
        if(start!=last && *start== const_or_not(fac).widen( '$') )
            ++start;
        return start;
    }





    inline void maybe_throw_exception(unsigned char exceptions,
                                      std::size_t pos, std::size_t size)
    {
        if(exceptions & io::bad_format_string_bit)
            boost::throw_exception(io::bad_format_string(pos, size) );
    }
# 121 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/parsing.hpp" 3
    template<class Ch, class Tr, class Alloc, class Iter, class Facet>
    bool parse_printf_directive(Iter & start, const Iter& last,
                                detail::format_item<Ch, Tr, Alloc> * fpar,
                                const Facet& fac,
                                std::size_t offset, unsigned char exceptions)
    {
        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;

        fpar->argN_ = format_item_t::argN_no_posit;
        bool precision_set = false;
        bool in_brackets=false;
        Iter start0 = start;
        std::size_t fstring_size = last-start0+offset;

        if(start>= last) {
                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);
                return false;
        }

        if(*start== const_or_not(fac).widen( '|')) {
            in_brackets=true;
            if( ++start >= last ) {
                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);
                return false;
            }
        }


        if(*start== const_or_not(fac).widen( '0'))
            goto parse_flags;


        if(wrap_isdigit(fac, *start)) {
            int n;
            start = str2int(start, last, n, fac);
            if( start >= last ) {
                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
                return false;
            }


            if( *start == const_or_not(fac).widen( '%') ) {
                fpar->argN_ = n-1;
                ++start;
                if( in_brackets)
                    maybe_throw_exception(exceptions, start-start0+offset, fstring_size);

                else
                    return true;
            }

            if ( *start== const_or_not(fac).widen( '$') ) {
                fpar->argN_ = n-1;
                ++start;
            }
            else {

                fpar->fmtstate_.width_ = n;
                fpar->argN_ = format_item_t::argN_no_posit;
                goto parse_precision;
            }
        }

      parse_flags:

        while ( start != last) {

            switch ( wrap_narrow(fac, *start, 0)) {
            case '\'' : break;
            case 'l':
            case 'h':
                break;
            case '-':
                fpar->fmtstate_.flags_ |= std::ios_base::left;
                break;
            case '=':
                fpar->pad_scheme_ |= format_item_t::centered;
                break;
            case '_':
                fpar->fmtstate_.flags_ |= std::ios_base::internal;
                break;
            case ' ':
                fpar->pad_scheme_ |= format_item_t::spacepad;
                break;
            case '+':
                fpar->fmtstate_.flags_ |= std::ios_base::showpos;
                break;
            case '0':
                fpar->pad_scheme_ |= format_item_t::zeropad;


                break;
            case '#':
                fpar->fmtstate_.flags_ |= std::ios_base::showpoint | std::ios_base::showbase;
                break;
            default:
                goto parse_width;
            }
            ++start;
        }

        if( start>=last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }
      parse_width:


        if(*start == const_or_not(fac).widen( '*') )
            start = skip_asterisk(start, last, fac);
        if(start!=last && wrap_isdigit(fac, *start))
            start = str2int(start, last, fpar->fmtstate_.width_, fac);

      parse_precision:
        if( start>= last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }

        if (*start== const_or_not(fac).widen( '.')) {
            ++start;
            if(start != last && *start == const_or_not(fac).widen( '*') )
                start = skip_asterisk(start, last, fac);
            if(start != last && wrap_isdigit(fac, *start)) {
                start = str2int(start, last, fpar->fmtstate_.precision_, fac);
                precision_set = true;
            }
            else
                fpar->fmtstate_.precision_ =0;
        }


        while( start != last && ( *start== const_or_not(fac).widen( 'l')
                                  || *start== const_or_not(fac).widen( 'L')
                                  || *start== const_or_not(fac).widen( 'h')) )
            ++start;
        if( start>=last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }

        if( in_brackets && *start== const_or_not(fac).widen( '|') ) {
            ++start;
            return true;
        }
        switch ( wrap_narrow(fac, *start, 0) ) {
        case 'X':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
        case 'p':
        case 'x':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::hex;
            break;

        case 'o':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::oct;
            break;

        case 'E':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
        case 'e':
            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            fpar->fmtstate_.flags_ |= std::ios_base::scientific;

            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;
            break;

        case 'f':
            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            fpar->fmtstate_.flags_ |= std::ios_base::fixed;
        case 'u':
        case 'd':
        case 'i':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;
            break;

        case 'T':
            ++start;
            if( start >= last)
                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            else
                fpar->fmtstate_.fill_ = *start;
            fpar->pad_scheme_ |= format_item_t::tabulation;
            fpar->argN_ = format_item_t::argN_tabulation;
            break;
        case 't':
            fpar->fmtstate_.fill_ = const_or_not(fac).widen( ' ');
            fpar->pad_scheme_ |= format_item_t::tabulation;
            fpar->argN_ = format_item_t::argN_tabulation;
            break;

        case 'G':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
            break;
        case 'g':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;


            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            break;

        case 'C':
        case 'c':
            fpar->truncate_ = 1;
            break;
        case 'S':
        case 's':
            if(precision_set)
                fpar->truncate_ = fpar->fmtstate_.precision_;
            fpar->fmtstate_.precision_ = 6;
            break;
        case 'n' :
            fpar->argN_ = format_item_t::argN_ignored;
            break;
        default:
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
        }
        ++start;

        if( in_brackets ) {
            if( start != last && *start== const_or_not(fac).widen( '|') ) {
                ++start;
                return true;
            }
            else maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
        }
        return true;
    }


    template<class String, class Facet>
    int upper_bound_from_fstring(const String& buf,
                                 const typename String::value_type arg_mark,
                                 const Facet& fac,
                                 unsigned char exceptions)
    {


        using namespace boost::io;
        typename String::size_type i1=0;
        int num_items=0;
        while( (i1=buf.find(arg_mark,i1)) != String::npos ) {
            if( i1+1 >= buf.size() ) {
                if(exceptions & bad_format_string_bit)
                    boost::throw_exception(bad_format_string(i1, buf.size() ));
                else {
                  ++num_items;
                  break;
                }
            }
            if(buf[i1+1] == buf[i1] ) {
                i1+=2; continue;
            }

            ++i1;

            i1 = detail::wrap_scan_notdigit(fac, buf.begin()+i1, buf.end()) - buf.begin();
            if( i1 < buf.size() && buf[i1] == arg_mark )
                ++i1;
            ++num_items;
        }
        return num_items;
    }
    template<class String> inline
    void append_string(String& dst, const String& src,
                       const typename String::size_type beg,
                       const typename String::size_type end) {

        dst.append(src.begin()+beg, src.begin()+end);



    }

}
}






    template<class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>::
    parse (const string_type& buf) {

        using namespace std;

        const std::ctype<Ch> & fac = std::use_facet< std::ctype<Ch> >(getloc());





        const Ch arg_mark = io::detail::const_or_not(fac).widen( '%');
        bool ordered_args=true;
        int max_argN=-1;


        int num_items = io::detail::upper_bound_from_fstring(buf, arg_mark, fac, exceptions());
        make_or_reuse_data(num_items);


        num_items=0;
        typename string_type::size_type i0=0, i1=0;
        typename string_type::const_iterator it;
        bool special_things=false;
        int cur_item=0;
        while( (i1=buf.find(arg_mark,i1)) != string_type::npos ) {
            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;
            if( buf[i1+1] == buf[i1] ) {
                io::detail::append_string(piece, buf, i0, i1+1);
                i1+=2; i0=i1;
                continue;
            }
            (__builtin_expect(!(static_cast<unsigned int>(cur_item) < items_.size() || cur_item==0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/parsing.hpp", 440, "static_cast<unsigned int>(cur_item) < items_.size() || cur_item==0") : (void)0);

            if(i1!=i0) {
                io::detail::append_string(piece, buf, i0, i1);
                i0=i1;
            }
            ++i1;
            it = buf.begin()+i1;
            bool parse_ok = io::detail::parse_printf_directive(
                it, buf.end(), &items_[cur_item], fac, i1, exceptions());
            i1 = it - buf.begin();
            if( ! parse_ok )
                continue;
            i0=i1;
            items_[cur_item].compute_states();

            int argN=items_[cur_item].argN_;
            if(argN == format_item_t::argN_ignored)
                continue;
            if(argN ==format_item_t::argN_no_posit)
                ordered_args=false;
            else if(argN == format_item_t::argN_tabulation) special_things=true;
            else if(argN > max_argN) max_argN = argN;
            ++num_items;
            ++cur_item;
        }
        (__builtin_expect(!(cur_item == num_items), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/parsing.hpp", 466, "cur_item == num_items") : (void)0);


        {
            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;
            io::detail::append_string(piece, buf, i0, buf.size());
        }

        if( !ordered_args) {
            if(max_argN >= 0 ) {
                if(exceptions() & io::bad_format_string_bit)
                    boost::throw_exception(io::bad_format_string(max_argN, 0));

            }

            int non_ordered_items = 0;
            for(int i=0; i< num_items; ++i)
                if(items_[i].argN_ == format_item_t::argN_no_posit) {
                    items_[i].argN_ = non_ordered_items;
                    ++non_ordered_items;
                }
            max_argN = non_ordered_items-1;
        }


        items_.resize(num_items, format_item_t(io::detail::const_or_not(fac).widen( ' ')) );

        if(special_things) style_ |= special_needs;
        num_args_ = max_argN + 1;
        if(ordered_args) style_ |= ordered;
        else style_ &= ~ordered;
        return *this;
    }

}
# 51 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/free_funcs.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/free_funcs.hpp" 3
namespace boost {

    template<class Ch, class Tr, class Alloc> inline
    std::basic_string<Ch, Tr, Alloc> str(const basic_format<Ch, Tr, Alloc>& f) {

        return f.str();
    }
    namespace io {
         using ::boost::str;
    }


        template<class Ch, class Tr, class Alloc>
        std::basic_ostream<Ch, Tr> &
        operator<<( std::basic_ostream<Ch, Tr> & os,
                    const basic_format<Ch, Tr, Alloc>& f)







    {
        typedef boost::basic_format<Ch, Tr, Alloc> format_t;
        if(f.items_.size()==0)
            os << f.prefix_;
        else {
            if(f.cur_arg_ < f.num_args_)
                if( f.exceptions() & io::too_few_args_bit )

                    boost::throw_exception(io::too_few_args(f.cur_arg_, f.num_args_));
            if(f.style_ & format_t::special_needs)
                os << f.str();
            else {

                os << f.prefix_;
                for(unsigned long i=0; i<f.items_.size(); ++i) {
                    const typename format_t::format_item_t& item = f.items_[i];
                    os << item.res_;
                    os << item.appendix_;
                }
            }
        }
        f.dumped_=true;
        return os;
    }

}
# 54 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format/detail/unset_macros.hpp" 1 3
# 58 "/Library/Application Support/MonkeyWorks/Developer/include/boost/format.hpp" 2 3
# 13 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Exceptions.h" 2 3



namespace mw {
using namespace std;

class SimpleException : public std::exception {

 protected:

  string message;
  string subject;
  MessageDomain domain;

 public:

  SimpleException(string _message) : message(_message), subject(""){
   domain = M_GENERIC_MESSAGE_DOMAIN;
  };

  SimpleException(string _message, string _subject) : message(_message),
                subject(_subject){
   domain = M_GENERIC_MESSAGE_DOMAIN;
  };

  SimpleException(MessageDomain _domain, string _message, string _subject = ""):
               message(_message),
               subject(_subject){
   domain = _domain;
  }

  SimpleException(const SimpleException& e){
   domain = e.domain;
   message = e.message;
   subject = e.subject;
  }

  virtual ~SimpleException() throw() {}

  string getMessage(){ return message; }
  string getSubject(){ return subject; }
  MessageDomain getDomain(){ return domain; }

  virtual const char* what() const throw(){
   if(subject.empty()){
    return message.c_str();
   } else {
    string returnstring = message + ": ";
    returnstring = returnstring + subject;
    return returnstring.c_str();
   }
  }

};

class NonFatalSimpleException : public SimpleException{ };


class MalformedXMLException : public SimpleException{

 public:

 MalformedXMLException(string _message)
       : SimpleException(M_PARSER_MESSAGE_DOMAIN, _message){
 };
};

class InvalidXMLException : public SimpleException{

 protected:

 string reference_id;


 public:

 InvalidXMLException(string _refid, string _message, string _subject = "") :
    SimpleException(M_PARSER_MESSAGE_DOMAIN, _message, _subject){

  reference_id = _refid;
 }

 InvalidXMLException(string _refid, const SimpleException& e) :
    SimpleException(e){
  reference_id = _refid;
 }

 virtual ~InvalidXMLException() throw() {}

 string getReferenceID(){ return reference_id; }
};


class ComponentFactoryConflictException : public SimpleException{


public:

    ComponentFactoryConflictException(string _subject) :
        SimpleException(M_PLUGIN_MESSAGE_DOMAIN, "A plugin has attempted to redefine the behavior of an existing XML signature.", _subject){
        }

    virtual ~ComponentFactoryConflictException() throw() {}
};

}
# 27 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Utilities.h" 2 3
namespace mw {
# 36 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Utilities.h" 3
void mprintf(const char *format, ...);
void mprintf(MessageDomain dom, const char *format, ...);
void parserwarning(const char *format, ...);
void mwarning(MessageDomain dom, const char *format, ...);
void parsererror(const char *format, ...);
void merror(MessageDomain dom, const char *format, ...);
void mfatal_error(MessageDomain dom, const char *format, ...);
void mnetwork(const char * format, ...);


void mgeneric_printf(int type, const char *format, ...);
# 55 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Utilities.h" 3
void mdebug(const char* format, ...);

static inline MonkeyWorksTime MIN_MONKEY_WORKS_TIME() {
 MonkeyWorksTime min = 1;
 for(unsigned int i=0; i<(sizeof(MonkeyWorksTime)*8)-1; ++i) {
  min = min << 1;
 }
 return min;
}

static inline MonkeyWorksTime MAX_MONKEY_WORKS_TIME() {
 MonkeyWorksTime max = 0;
 MonkeyWorksTime min = MIN_MONKEY_WORKS_TIME();
 max = ~max;
 max = max ^ min;
 return max;
}

extern MessageOrigin GlobalMessageOrigin;





}
# 18 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Component.h" 2 3
namespace mw {
 using namespace boost;

 class ComponentRegistry;

 class Component {

 protected:

  std::string tag;
  std::string reference_id;




  long compact_id;

  weak_ptr<mw::Component> self_ptr;

  static long _id_count;

 public:

  Component(){
   compact_id = mw::Component::_id_count++;
  }
  Component(std::string _tag){
   tag = _tag;
   compact_id = mw::Component::_id_count++;
  }

  virtual ~Component(){ }

  Component( const mw::Component& copy ){
   tag = copy.tag;
   reference_id = copy.reference_id;
  }

  virtual bool isAmbiguous(){ return false; }

  virtual void setSelfPtr(weak_ptr<mw::Component> ptr){ self_ptr = ptr; }

  template <class T>
  weak_ptr<T> getSelfPtr(){
   shared_ptr<mw::Component> shared(self_ptr);
   shared_ptr<T> casted = dynamic_pointer_cast<T, mw::Component>(shared);
   weak_ptr<T> weakened(casted);
   return weakened;
  }

  virtual void setTag(std::string _tag){ tag = _tag; }
  virtual std::string getTag(){ return tag; }

  void setReferenceID(std::string ref_id){ reference_id = ref_id; }
  std::string getReferenceID(){ return reference_id; }

  long getCompactID(){ return compact_id; }


  virtual shared_ptr<mw::Component> createInstanceObject(){
   mprintf("Using base createInstanceObject()");
   shared_ptr<mw::Component> self_ptr(getSelfPtr<mw::Component>());
   return self_ptr;
  }

  virtual void addChild(std::map<std::string, std::string> parameters,
         ComponentRegistry *reg,
         shared_ptr<mw::Component> child){

   throw SimpleException("Attempt to use base-class addChild component method");
  }

  virtual void finalize(std::map<std::string, std::string> parameters,
         ComponentRegistry *reg){
   return;
  }

 };


 class AmbiguousComponentReference : public mw::Component{

    protected:

  vector< shared_ptr<mw::Component> > ambiguous_components;



    public:

  virtual bool isAmbiguous(){ return true; }

  virtual void addAmbiguousComponent(shared_ptr<mw::Component> component_to_add){
   ambiguous_components.push_back(component_to_add);
  }

  virtual vector< shared_ptr<mw::Component> > getAmbiguousComponents(){
   return ambiguous_components;
  }

 };
}
# 17 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Clock.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/RegisteredSingleton.h" 1 3
# 13 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/RegisteredSingleton.h" 3
namespace mw {
template <class T> class RegisteredSingleton {
protected:
 static boost::shared_ptr<T> singleton_instance;
public:
 static boost::shared_ptr<T> instance(const bool should_throw=true) {
  if(singleton_instance == 0 && should_throw) {
   throw SimpleException("trying to access singleton instance before it is registered");
  }

  return singleton_instance;
 }

 static void registerInstance(const boost::shared_ptr<mw::Component> &an_instance) {

  if(an_instance == 0) {
   throw SimpleException("attempting to register NULL instance for a singleton") ;
  }

  if(singleton_instance != 0) {
   throw SimpleException("attempting to register singleton instance when there's already an instance");
  }

  singleton_instance = dynamic_pointer_cast<T, mw::Component>(an_instance);

  if(singleton_instance == 0) {
   throw SimpleException("attempting to register singleton instance for wrong type of object");
  }
 }

 static void destroy() {
  if(singleton_instance == 0) {
   throw SimpleException("trying to destroy singleton when there isn't one registered");
  }

  singleton_instance = boost::shared_ptr<T>();
 }
};

template <class T> boost::shared_ptr<T> RegisteredSingleton<T> ::singleton_instance;

}
# 18 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Clock.h" 2 3
namespace mw {


class Clock : public mw::Component, public RegisteredSingleton<Clock> {

protected:
 long current_time, interval;

public:

 Clock(long interval_microseconds);
 virtual ~Clock();

 virtual MonkeyWorksTime getCurrentTime();
 virtual MonkeyWorksTime getCurrentTimeMS();
 virtual MonkeyWorksTime getCurrentTimeUS();
 virtual MonkeyWorksTime getCurrentTimeNS();

 virtual void sleepMS(MonkeyWorksTime time);
 virtual void sleepUS(MonkeyWorksTime time);
 virtual void sleepNS(MonkeyWorksTime time);

 virtual long getInterval();
 virtual void setInterval(long micro);

 virtual void startClock();
 virtual void stopClock();

 virtual MonkeyWorksTime getSystemTimeMS();
 virtual MonkeyWorksTime getSystemTimeUS();
 virtual MonkeyWorksTime getSystemTimeNS();




 virtual MonkeyWorksTime getSystemReferenceTime();
};

}
# 32 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentRegistry.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StateSystem.h" 1 3







# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/States.h" 1 3
# 20 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/States.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Selection.h" 1 3
# 23 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Selection.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericVariable.h" 1 3
# 54 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericVariable.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentFactory.h" 1 3
# 16 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentFactory.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentFactoryException.h" 1 3
# 12 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentFactoryException.h" 3
namespace mw {
class ComponentFactoryException : public std::exception {
protected:
 std::string _what;
 std::string _referenceID;
public:
 ComponentFactoryException(const std::string &refID) {
  _referenceID = refID;
 }

 virtual ~ComponentFactoryException() throw() {}
 virtual const char* what() const throw() = 0;

 virtual const char* referenceID() const throw() {
  return _referenceID.c_str();
 }
};

class MissingAttributeException : public ComponentFactoryException {
public:
 MissingAttributeException(const std::string &referenceID,
          const std::string &errorMessage) : ComponentFactoryException(referenceID) {
  _what = errorMessage;
 }

 virtual ~MissingAttributeException() throw() {}

 virtual const char* what() const throw() {
  return _what.c_str();
 }
};

class InvalidReferenceException : public ComponentFactoryException {
public:
 InvalidReferenceException(const std::string &referenceID,
          const std::string &name,
          const std::string &value) : ComponentFactoryException(referenceID) {


  _what = "invalid value \"" + value + "\" for attribute \"" + name + "\"";
 }

 virtual ~InvalidReferenceException() throw() {}

 virtual const char* what() const throw() {
  return _what.c_str();
 }
};

class InvalidAttributeException : public ComponentFactoryException {
public:
 InvalidAttributeException(const std::string &referenceID,
          const std::string &name,
          const std::string &value) : ComponentFactoryException(referenceID) {
  _what = "invalid value (" + value + ") for attribute \"" + name + "\"";
 }

 virtual ~InvalidAttributeException() throw() {}

 virtual const char* what() const throw() {
  return _what.c_str();
 }
};

class MissingReferenceException : public ComponentFactoryException {
protected:
public:
 MissingReferenceException(const std::string &referenceID,
          const std::string &name,
          const std::string &value) : ComponentFactoryException(referenceID) {
  _what = "can't find a reference for \"" + value + "\" for attribute \"" + name + "\"";
 }

 virtual ~MissingReferenceException() throw() {}

 virtual const char* what() const throw() {
  return _what.c_str();
 }
};
}
# 17 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentFactory.h" 2 3




namespace mw {
extern const mw::Component *InvalidObject;
# 40 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentFactory.h" 3
using namespace boost;

class ComponentRegistry;

class ComponentFactory {
protected:
 virtual void requireAttributes(const std::map<std::string, std::string> &parameters,
           const std::vector<std::string> &attributes);
 virtual void checkAttribute(const shared_ptr<mw::Component> &component,
        const std::string &refID,
        const std::string &name,
        const std::string &value);

public:
 ComponentFactory(){ }
 virtual ~ComponentFactory(){ }

 virtual shared_ptr<mw::Component> createObject(std::map<std::string, std::string> parameters,
            ComponentRegistry *reg){
  return shared_ptr<mw::Component>();
 }
};
}
# 55 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericVariable.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/LinkedList.h" 1 3
# 20 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/LinkedList.h" 3
namespace mw {
using namespace boost;





template <class T>
class LinkedList;

template <class T>
class LinkedListNode {

 protected:

 shared_ptr<T> previous;
 shared_ptr<T> next;


  LinkedList<T> *list;

  shared_ptr<T> _getSelfReference(){
   shared_ptr<T> empty;

   if(previous != empty){
    return previous->getNext();
   }

   if(next != empty){
    return next->getPrevious();
   }

   if(list != __null){
    return list->getFrontmost();
   }

   return empty;
  }

    public:

        LinkedListNode(){
   list = __null;
  }

  virtual ~LinkedListNode(){};

        virtual void remove();


        virtual shared_ptr<T> getPrevious();
        virtual shared_ptr<T> getNext();

        virtual void setPrevious(shared_ptr<T> newprev);
        virtual void setNext(shared_ptr<T> newnext);


  virtual void moveForward();
  virtual void moveBackward();

        virtual void moveDown();
        virtual void moveUp();

  virtual void sendToBack();
  virtual void bringToFront();

  virtual LinkedList<T> *getList(){ return list; }
  virtual void setList(LinkedList<T> *_list){ list = _list; }
};

template <class T>
class LinkedList : public Lockable {

 protected:

 shared_ptr<T> head;
 shared_ptr<T> tail;

 int nelements;

 public:

 LinkedList();

 shared_ptr<T> getFrontmost();
 shared_ptr<T> getBackmost();

 void addToFront(shared_ptr<T> data);
 void addToBack(shared_ptr<T> data);

 shared_ptr<T> popElement();

    int getNElements() { return nelements; }

    void decrement() { nelements--; }

 void setFrontmost(shared_ptr<T> node){ head = node; }
 void setBackmost(shared_ptr<T> node){tail = node; }

};



template <class T>
void LinkedListNode<T>::remove(){

 Lockable *list_lock = __null;
 if(list != __null){
  list_lock = list;
  list_lock->lock();
 }

 if(list != __null){
  if(this == (list->getFrontmost()).get()){
   list->setFrontmost(getNext());
  }

  if(this == (list->getBackmost()).get()){
   list->setBackmost(getPrevious());
  }
 }

 if(previous != shared_ptr<T>()){
  previous->setNext(next);
 }

 if(next != shared_ptr<T>()){
  next->setPrevious(previous);
 }

 if(list != __null){
  list->decrement();
 }

 if(list_lock != __null){
  list_lock->unlock();
 }

 next = shared_ptr<T>();
 previous = shared_ptr<T>();

 list = __null;
}


template <class T>
shared_ptr<T> LinkedListNode<T>::getPrevious(){

 if(previous.get() == this){
  return shared_ptr<T>();
 }

 return previous;
}

template <class T>
shared_ptr<T> LinkedListNode<T>::getNext(){


 if(next.get() == this){
  return shared_ptr<T>();
 }

 return next;
}

template <class T>
void LinkedListNode<T>::setPrevious(shared_ptr<T> newprev){

 previous = newprev;
}

template <class T>
void LinkedListNode<T>::setNext(shared_ptr<T> newnext){
 next = newnext;
}

template <class T>
void LinkedListNode<T>::moveUp(){
 moveForward();
}

template <class T>
void LinkedListNode<T>::moveDown(){
 moveBackward();
}
# 214 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/LinkedList.h" 3
template <class T>
void LinkedListNode<T>::moveForward(){


 Lockable *list_lock = __null;
 if(list != __null){
  list_lock = list;
  list_lock->lock();
 }

 shared_ptr<T> theprev;
 shared_ptr<T> theprevprev;
 shared_ptr<T> thenext;
 shared_ptr<T> self_ref;


 if(previous == shared_ptr<T>()){
  return;
 }

 theprev = previous;
 thenext = next;
 self_ref = _getSelfReference();


 if(list != __null && (list->getBackmost()) == self_ref){

  list->setBackmost(previous);
 }

 theprevprev = theprev->getPrevious();

 if(theprevprev){

  theprevprev->setNext(theprev->getNext());
 }

 previous = theprevprev;
 next = theprev;
 theprev->setPrevious(self_ref);
 theprev->setNext(thenext);

 if(thenext){
  thenext->setPrevious(theprev);
 }

 if(list != __null && previous == shared_ptr<T>()){
  list->setFrontmost(self_ref);
 }

 if(list_lock != __null){
  list_lock->unlock();
 }


}


template <class T>
void LinkedListNode<T>::moveBackward() {

 Lockable *list_lock = __null;
 if(list != __null){
  list_lock = list;
  list_lock->lock();
 }

 shared_ptr<T> theprev;
 shared_ptr<T> thenext;
 shared_ptr<T> thenextnext;
 shared_ptr<T> self_ref;

 if(next == shared_ptr<T>()){
  return;
 }

 thenext = next;
 theprev = previous;
 self_ref = _getSelfReference();


 if(list != __null && list->getFrontmost() == self_ref){
  list->setFrontmost(next);
 }


 if(thenext == shared_ptr<T>()){
  return;
 }
 thenextnext = thenext->getNext();

 if(thenextnext) {
  thenextnext->setPrevious(self_ref);
 }

 next = thenextnext;
 previous = thenext;
 thenext->setNext(self_ref);
 thenext->setPrevious(theprev);

 if(theprev) {
  theprev->setNext(thenext);
 }

 if(list != __null && next == shared_ptr<T>()){
  list->setBackmost(self_ref);
 }

 if(list_lock != __null){
  list_lock->unlock();
 }

}

template <class T>
void LinkedListNode<T>::bringToFront(){

 shared_ptr<T> previous;
 while(previous = getPrevious()){
  moveForward();
 }
}

template <class T>
void LinkedListNode<T>::sendToBack(){

 shared_ptr<T> next;
 while(next = getNext()){
  moveBackward();
 }
}

template <class T>
LinkedList<T>::LinkedList() : Lockable() {
    nelements = 0;
}

template <class T>
shared_ptr<T> LinkedList<T>::getFrontmost() {
 return head;
}

template <class T>
shared_ptr<T> LinkedList<T>::getBackmost() {
 return tail;
}

template <class T>
void LinkedList<T>::addToFront(shared_ptr<T> newnode) {
 lock();

 if(head == shared_ptr<T>()) {
  head = newnode;
 } else {
  newnode->setNext(head);
  head->setPrevious(newnode);
  head = newnode;
 }
 if(tail == shared_ptr<T>()) {
  tail = newnode;
 }

 newnode->setList(this);
 nelements++;

 unlock();
}

template <class T>
void LinkedList<T>::addToBack(shared_ptr<T> newnode) {

 lock();

 shared_ptr<T> empty;

 if(tail == shared_ptr<T>()) {
  tail = newnode;
  tail->setNext(empty);
 } else {
  newnode->setPrevious(tail);
  tail->setNext(newnode);
  tail = newnode;
 }
 if(head == shared_ptr<T>()) {
  head = newnode;
  head->setPrevious(empty);
 }
 nelements++;

 unlock();
}

template <class T>
shared_ptr<T> LinkedList<T>::popElement(){

 lock();

 if(head == shared_ptr<T>()){
  mwarning(M_SYSTEM_MESSAGE_DOMAIN, "Attempt to pop an element off of a headless list");
  return shared_ptr<T>();
 }

 shared_ptr<T> node = head;
 head = head->getNext();
 if(head != shared_ptr<T>()){
  head->setPrevious(shared_ptr<T>());
 }


 node->setNext(shared_ptr<T>());
 nelements--;

 unlock();

 return node;
}
}
# 57 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericVariable.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableNotification.h" 1 3
# 16 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableNotification.h" 3
namespace mw {


class VariableNotification : public LinkedListNode<VariableNotification> {

 public:
        VariableNotification();

        virtual ~VariableNotification();
        virtual void notify(const Data& data, MonkeyWorksTime time);
};

}
# 58 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericVariable.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Clonable.h" 1 3
# 13 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Clonable.h" 3
namespace mw {
using namespace std;


class Clonable {

 protected:

  bool is_a_clone;

 public:
  virtual ~Clonable() { }


  virtual void *clone();

  virtual bool isAClone(){ return is_a_clone; }
  virtual void setIsAClone(bool isit){ is_a_clone = isit; }
};
}
# 60 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GenericVariable.h" 2 3



namespace mw {
class BufferManager;

using namespace boost;

enum VariableScope{ M_INVALID_SCOPE = -1,
      M_EXPERIMENTWIDE_SCOPE,
      M_LOCAL_SCOPE };


enum WhenType{M_NEVER = -1, M_WHEN_IDLE, M_ALWAYS, M_AT_STARTUP, M_EVERY_TRIAL, M_WHEN_CHANGED};





const int __VARIABLE_PACKAGE_SIZE__ = 6;
const int __VALUE_PACKAGE_SIZE__ = 1;


enum Operator { M_PLUS,
     M_INCREMENT,
     M_MINUS,
     M_DECREMENT,
     M_TIMES,
     M_DIVIDE,
     M_MOD,
     M_IS_EQUAL,
     M_IS_NOT_EQUAL,
     M_IS_GREATER_THAN,
     M_IS_LESS_THAN,
     M_IS_GREATER_THAN_OR_EQUAL,
     M_IS_LESS_THAN_OR_EQUAL,
     M_FLOAT_CAST,
     M_INTEGER_CAST,
     M_BOOLEAN_CAST,
     M_AND,
     M_OR,
     M_NOT,
     M_UNARY_MINUS,
     M_UNARY_PLUS
    };


class VariableProperties;
class ExpressionVariable;


class Variable : public mw::Component, public ComponentFactory {

protected:

 VariableProperties *properties;
 LinkedList<VariableNotification> notifications;

 int codec_code;

 WhenType logging;


 shared_ptr<BufferManager> buffer_manager;

public:


 Variable(VariableProperties *properties=__null);
 Variable(const Variable& tocopy);
 virtual ~Variable();


 virtual Variable *clone() = 0;
 virtual Variable *frozenClone();




 virtual void setBufferManager(shared_ptr<BufferManager> _buffer_manager){
  buffer_manager = _buffer_manager;
 }

 virtual VariableProperties *getProperties(){ return properties; }
 virtual void setProperties(VariableProperties *props){ properties=props; }

 std::string getVariableName();

 int getCodecCode(){ return codec_code; }
 void setCodecCode(int _code){ codec_code = _code; }

 WhenType getLogging();
 void setLogging(WhenType when);



 virtual void addNotification(shared_ptr<VariableNotification> note);
 void lockNotifications(){ notifications.lock(); }
 void unlockNotifications(){ notifications.unlock(); }

 shared_ptr<VariableNotification> getFirstNotification(){
  return notifications.getFrontmost();
 }

 virtual void performNotifications(Data data);
 virtual void performNotifications(Data data, MonkeyWorksTime timeUS);


 virtual void announce();
 virtual void announce(MonkeyWorksTime _when);


 virtual Data getValue() = 0;
 virtual void setValue(Data _data) = 0;
 virtual void setValue(Data _data, MonkeyWorksTime _when) = 0;
 virtual void setSilentValue(Data _value) = 0;






 virtual void operator=(long a);
 virtual void operator=(int a);
 virtual void operator=(short a);
 virtual void operator=(double a);
 virtual void operator=(float a);
 virtual void operator=(bool a);
 virtual void operator=(MonkeyWorksTime a);
 virtual void operator=(std::string a);
 virtual void operator=(Data a);


 virtual operator long();
 virtual operator int();
 virtual operator short();
 virtual operator double();
 virtual operator float();
 virtual operator bool();
 virtual operator MonkeyWorksTime();
 virtual operator Data();


 virtual ExpressionVariable operator+(Variable& v);
 virtual ExpressionVariable operator-(Variable& v);
 virtual ExpressionVariable operator*(Variable& v);
 virtual ExpressionVariable operator/(Variable& v);
 virtual ExpressionVariable operator==(Variable& v);
 virtual ExpressionVariable operator!=(Variable& v);
 virtual ExpressionVariable operator%(Variable& v);
 virtual ExpressionVariable operator>(Variable& v);
 virtual ExpressionVariable operator<(Variable& v);
 virtual ExpressionVariable operator>=(Variable& v);
 virtual ExpressionVariable operator<=(Variable& v);
 virtual ExpressionVariable operator&&(Variable& v);
 virtual ExpressionVariable operator||(Variable& v);
 virtual ExpressionVariable operator++();
 virtual ExpressionVariable operator--();
 virtual ExpressionVariable operator!();
 virtual ExpressionVariable operator-();
 virtual ExpressionVariable operator+();

 virtual void addChild(std::map<std::string, std::string> parameters,
        ComponentRegistry *reg,
        shared_ptr<mw::Component> child);
};


class VariableFactory : public ComponentFactory {


 virtual shared_ptr<mw::Component> createObject(std::map<std::string, std::string> parameters,
            ComponentRegistry *reg);

};


class EmptyVariable : public Variable {

public:

 EmptyVariable(VariableProperties *p = __null) : Variable(p){ };

 virtual void announce(){ }
 virtual void announce(MonkeyWorksTime t){ }

 virtual Data getValue(){ return Data(0L); }
 virtual void setValue(Data v){ }
 virtual void setValue(Data v, MonkeyWorksTime t){ }
 virtual void setSilentValue(Data _value){ return; }

 virtual Variable *clone(){
  return new EmptyVariable((const EmptyVariable&)(*this));
 }

};
}
# 24 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Selection.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpandableList.h" 1 3
# 39 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpandableList.h" 3
namespace mw {
 using namespace boost;

template <class Class>
class ExpandableList : public Lockable {
    protected:
 shared_ptr<Class> *list;

        int elementincrement;
        int nelements;
        int nactualelements;

    private:


        void init() {
            for(int i = 0; i < nelements; i++) {

            }
        }


        void init(Class ** nList, int size) {
            for(int i = 0; i < size; i++) {

            }
        }


        void expandList() {
            if(elementincrement < 1){
    elementincrement = 10;
   }

   shared_ptr<Class> * newlist =
   new shared_ptr<Class>[nelements + elementincrement];
# 84 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpandableList.h" 3
            for(int i = 0; i < nactualelements; i++) {
                newlist[i] = list[i];
            }
            delete [] list;
            list = newlist;
            nelements = nelements + elementincrement;
        }




        void expandList(int nitems) {
            shared_ptr<Class> * newlist = new shared_ptr<Class>[nitems];
            if(newlist == __null) {

                throw SimpleException("Out of memory");
    return;
            }



            for(int i = 0; i < nactualelements; i++) {
                newlist[i] = list[i];
            }
            delete [] list;
            list = newlist;
            nelements = nitems;
        }

 public:






        ExpandableList() {
            elementincrement = 10;
            nelements = elementincrement;
            nactualelements = 0;
            list = new shared_ptr<Class>[nelements];
            init();
        }







        ExpandableList(int arraysize) {
            nelements = arraysize;
   if(elementincrement > 0){
    elementincrement = arraysize;
            } else {
    elementincrement = 1;
   }
   nactualelements = 0;
            if(nelements == 0) {
                nelements = 1;
            }
            if(nelements < 0) {
                throw("Invalid array size in constructing an ExpandableList");
            }
            if(nelements > 10000) {
                throw("Error: enormous freak'n Expandable list.  Did you mean to do that?");
            }
            list = new shared_ptr<Class>[nelements];
            init();
        }




        ExpandableList(const ExpandableList<Class>& listRef){

            nactualelements = listRef.nactualelements;
            nelements = listRef.nelements;
            elementincrement = listRef.elementincrement;


            list = new shared_ptr<Class>[nelements];
            for(int i = 0; i < nelements; i++) {





                list[i] = listRef.list[i];
            }
        }




        ~ExpandableList() {


            for(int i = 0; i < nactualelements; i++) {
                if(list[i]) {


                }
            }

            delete [] list;
            list = __null;
        }
# 201 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpandableList.h" 3
  void releaseElements(){

    lock();


   for(int i = 0; i < nelements; i++){

    list[i] = shared_ptr<Class>();
   }


    unlock();

  }






        int getListCapacity() {
            return nelements;
        }




        int getExpansionFactor() {
            return elementincrement;
        }





int addElement(shared_ptr<Class> objtoadd) {

    lock();

   if(nactualelements >= nelements) {
                expandList();
            }

            if(objtoadd == __null) {
                list[nactualelements] = shared_ptr<Class>();
            } else {

                list[nactualelements] = objtoadd;
            }
            int returnval = nactualelements++;


    unlock();


   return returnval;
        }




        int addElement(Class thingtoadd) {
   shared_ptr<Class> p(new Class((const Class&)thingtoadd));
            return addElement(p);
        }
# 275 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpandableList.h" 3
int addElement(int index, shared_ptr<Class> objtoadd) {

    lock();



            if((index < 0) || (index > 10000)) {

                return -1;
            }
            if(index >= nelements) {




                expandList(index+1);
            }

            nactualelements = index+1;
# 302 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpandableList.h" 3
   if(objtoadd == __null) {
                list[index] = shared_ptr<Class>();
            } else {


    list[index] = objtoadd;
            }

   int returnval = nactualelements;


    unlock();


   return returnval;
        }





        int addElement(int index, Class thingtoadd) {
   shared_ptr<Class> p(new Class((const Class&)thingtoadd));
            return addElement(index, p);
        }
# 335 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpandableList.h" 3
int addReference(shared_ptr<Class> objtoadd){
   return addElement(objtoadd);
  }
# 362 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpandableList.h" 3
int addReference(int index, shared_ptr<Class> objtoadd){
   return addElement(index, objtoadd);
  }
# 415 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpandableList.h" 3
        void trimList() {

    lock();



            if(nactualelements == nelements) {

     unlock();

    return;
            }

   shared_ptr<Class> * newlist =
    new shared_ptr<Class>[nactualelements];

   for(int i = 0; i < nactualelements; i++) {

                if(list[i] != __null) {



     newlist[i] = list[i];

                } else {
                    newlist[i] = __null;
                }
            }
            delete [] list;
            list = newlist;
            nelements = nactualelements;


    unlock();

  }

  Class *getRawElement(int i){
   return (getElement(i)).get();
  }





shared_ptr<Class> getElement(int i) {

    lock();


   if(i >= nelements) {

    fprintf(__stderrp, "Error: attempt to access index (%d) greater than nelements (%d) in an ExpandableList structure",
                                                                i, nelements);
                fflush(__stderrp);
                i = nelements - 1;
            }
            if(i < 0) {

    fprintf(__stderrp, "Error: attempt to access negative index on an expandable list (%d)", i);
                fflush(__stderrp);
                i = 0;
            }

   shared_ptr<Class> return_pointer = list[i];

    unlock();

            return return_pointer;
        }






  bool getElement(int i, Class *target) {

    lock();


   if(i >= nelements) {

    fprintf(__stderrp, "Error: attempt to access index (%d) greater than nelements (%d) in an ExpandableList structure",
                                                                i, nelements);
                fflush(__stderrp);
                i = nelements - 1;
            }
            if(i < 0) {

    fprintf(__stderrp, "Error: attempt to access negative index on an expandable list (%d)", i);
                fflush(__stderrp);
                i = 0;
            }

   shared_ptr<Class> return_pointer = list[i];

   if(return_pointer == __null){

     unlock();

    return false;
   }

   *target = *return_pointer;


    unlock();

            return true;
        }






        void setElement(int i, const Class value) {
   shared_ptr<Class> copied(new Class(value));
   setElement(i, copied);
  }


  void setElement(int i, shared_ptr<Class> value) {

    lock();


   if((i < 0)) {

    fprintf(__stderrp, "bad index in set element, should i throw an error?\n");
                fflush(__stderrp);

     unlock();


    return;
            }
   if(i >= nelements) {
    expandList(i+10);
    nactualelements = i+1;
   }

            if(list[i] != __null) {


            }
            if(value == __null) {

            } else {


    list[i] = value;
            }


    unlock();

        }




shared_ptr<Class> operator[](int i) {
            return list[i];
        }




        int getNElements() {

    lock();


   int returnval = nactualelements;


    unlock();


            return returnval;
        }




        void clear() {

    lock();


            for(int i = 0; i < nactualelements; i++) {
                if(list[i] != __null) {



                    list[i] = shared_ptr<Class>();
                }
            }
            nactualelements = 0;


    unlock();

  }
};
}
# 25 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Selection.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Selectable.h" 1 3
# 15 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Selectable.h" 3
namespace mw {
 using namespace boost;


class Selection;

class Selectable {

 protected:

  shared_ptr<Selection> selection;

 public:

  Selectable();
  virtual ~Selectable();

  void attachSelection(shared_ptr<Selection> _selection);
        shared_ptr<Selection> getSelectionClone();


  virtual int getNItems() = 0;

  virtual void acceptSelections();
  virtual void rejectSelections();
  virtual void resetSelections();

  virtual int getNDone();
  virtual int getNLeft();

};
}
# 27 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Selection.h" 2 3
namespace mw {

enum SelectionType { M_SEQUENTIAL, M_SEQUENTIAL_ASCENDING,
                     M_SEQUENTIAL_DESCENDING, M_RANDOM_WITH_REPLACEMENT,
                     M_RANDOM_WOR };

enum SampleType { M_SAMPLES, M_CYCLES };

class SelectionOffEdgeException : public std::exception{
virtual const char* what() const throw()
  {
    return "There are no more items left to draw";
  }
};

class InvalidSelectionException : public std::exception{
virtual const char* what() const throw()
  {
    return "Attempt to draw an invalid selection index";
  }
};

class Selection {

 protected:
  Selectable *selectable;


  int n_draws;
  int done_so_far;

  std::vector<int> tentative_selections;

 public:

        Selection(int _n_draws);
        virtual ~Selection() { }


  virtual void setSelectable(Selectable *_selectable){
   selectable = _selectable;
   reset();
  }
  virtual int getNItems();


  virtual int draw() = 0;


  virtual void reset();


  virtual void acceptSelections();



  virtual void rejectSelections() = 0;


  virtual bool isFinished(){ return (done_so_far >= n_draws); }
  virtual int getNDone(){ return done_so_far; }
  virtual int getNLeft(){ return n_draws - done_so_far; }

  virtual shared_ptr<Selection> clone() = 0;



};

}
# 21 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/States.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScopedVariableContext.h" 1 3





# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScopedVariable.h" 1 3
# 14 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScopedVariable.h" 3
namespace mw {
class ScopedVariableEnvironment;

class ScopedVariable : public Variable {

 protected:

 int context_index;
 ScopedVariableEnvironment *environment;


 public:

 ScopedVariable(VariableProperties *_properties);


 ScopedVariable(const ScopedVariable&);





 virtual Variable *clone();





 virtual ~ScopedVariable(){ }



 ScopedVariableEnvironment *getEnvironment();
 void setEnvironment(ScopedVariableEnvironment *_env);

 int getContextIndex();
 void setContextIndex(int i);



 virtual Data getValue();

 virtual void setValue(Data _data);
 virtual void setValue(Data _data, MonkeyWorksTime _when);
 virtual void setSilentValue(Data _value);
 virtual void setSilentValue(Data _value, MonkeyWorksTime _when);

};
}
# 7 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScopedVariableContext.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScopedVariableEnvironment.h" 1 3
# 13 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScopedVariableEnvironment.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScopedVariableContext.h" 1 3
# 14 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScopedVariableEnvironment.h" 2 3
namespace mw {
class ScopedVariableContext;

class ScopedVariable;

class ScopedVariableEnvironment {

 protected:

  ExpandableList<ScopedVariable> variables;
  shared_ptr<ScopedVariableContext> current_context;

 public:

  ScopedVariableEnvironment();


  int addVariable(shared_ptr<ScopedVariable> var);




  shared_ptr<ScopedVariableContext> createNewContext();
  shared_ptr<ScopedVariableContext> createNewDefaultContext();



  void setCurrentContext(shared_ptr<ScopedVariableContext> new_context);

  shared_ptr<ScopedVariableContext> getCurrentContext(){
   return current_context;
  }

  int getNVariables(){
   return variables.getNElements();
  }


  Data getValue(int index);
  void setValue(int index, Data value);




  void announceAll();
};
}
# 8 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScopedVariableContext.h" 2 3
# 49 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ScopedVariableContext.h" 3
namespace mw {
enum Transparency{ M_TRANSPARENT, M_OPAQUE };



class ScopedVariableContext : public Lockable{

 protected:

  ScopedVariableEnvironment *environment;
  std::map< int, shared_ptr<Data> > data;
  std::map<int, Transparency> transparency;


 public:

  ScopedVariableContext(ScopedVariableEnvironment *env);
  ScopedVariableContext(shared_ptr<ScopedVariableContext> ownersinfo);

  void inheritFrom(shared_ptr<ScopedVariableContext> info_to_inherit);

  virtual ~ScopedVariableContext();

  virtual Transparency getTransparency(ScopedVariable *param);
  virtual Transparency getTransparency(int i);

  int getNFields();

  ScopedVariableEnvironment *getEnvironment(){ return environment; }


  Data get(int index);

  void set(int index, shared_ptr<Data> newdata);
  void set(int index, const Data& newdata);
  void setWithTransparency(int index, shared_ptr<Data> newdata);
  void setWithTransparency(int index, const Data& newdata);

};
}
# 22 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/States.h" 2 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StandardVariables.h" 1 3
# 14 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StandardVariables.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableRegistry.h" 1 3
# 69 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableRegistry.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ConstantVariable.h" 1 3
# 13 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ConstantVariable.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GlobalVariable.h" 1 3
# 33 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GlobalVariable.h" 3
namespace mw {
class GlobalVariable : public Variable{
    protected:
  shared_ptr<Data> value;
  shared_ptr<Lockable> valueLock;

 public:



        GlobalVariable(Data _value, VariableProperties *interface=__null);




        GlobalVariable(VariableProperties *_interface);
# 60 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GlobalVariable.h" 3
  virtual Variable *clone();

        virtual ~GlobalVariable();





        virtual Data getValue();





  void setValue(Data newval);
  void setValue(Data newval, MonkeyWorksTime time);
  void setSilentValue(Data newval);
  void setSilentValue(Data newval, MonkeyWorksTime time);




  bool isValue();
# 93 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/GlobalVariable.h" 3
        virtual void printToSTDERR();
};
}
# 14 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ConstantVariable.h" 2 3

namespace mw {
class ConstantVariable : public GlobalVariable {


public:

 ConstantVariable(Data _value) : GlobalVariable(_value, __null){ }


 virtual void setValue(Data _value){ *value = _value;}
 virtual void setValue(Data _value, MonkeyWorksTime time){ *value = _value;}
 virtual void setSilentValue(Data _value){ return; }


};
}
# 70 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableRegistry.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/SelectionVariable.h" 1 3
# 17 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/SelectionVariable.h" 3
namespace mw {

class SelectionVariable : public Selectable, public Variable {

protected:

 ExpandableList<Variable> values;
 shared_ptr<Variable> selected_value;
public:

 SelectionVariable(VariableProperties *props);
 SelectionVariable(VariableProperties *props, shared_ptr<Selection> _sel);





 virtual ~SelectionVariable(){
  values.releaseElements();

 }


 virtual void addValue(shared_ptr<Variable> _var){
  values.addReference(_var);
  if(selection != __null){
   selection->reset();
  }
 }

 virtual shared_ptr<Variable> getValue(int i){
  return values[i];
 }



 virtual Variable *clone();

 virtual void nextValue();

 virtual Data getValue();
 virtual void setValue(Data data){ return; }
 virtual void setValue(Data data, MonkeyWorksTime time){ return; }
 virtual void setSilentValue(Data data){ return; }

 virtual int getNChildren(){ return values.getNElements(); }



 virtual int getNItems(){ return getNChildren(); }
 virtual void resetSelections() {
  selected_value = shared_ptr<Variable>();
  selection->reset();
 }


 void rejectSelections() {
  selection->rejectSelections();
  this->nextValue();
 }

};


class SelectionVariableFactory : public ComponentFactory {
 virtual shared_ptr<mw::Component> createObject(std::map<std::string, std::string> parameters,
            ComponentRegistry *reg);
};
}
# 71 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableRegistry.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Timer.h" 1 3
# 14 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Timer.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Scheduler.h" 1 3
# 20 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Scheduler.h" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/enable_shared_from_this.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/enable_shared_from_this.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/enable_shared_from_this.hpp" 2 3


namespace boost
{

template<class T> class enable_shared_from_this
{
protected:

    enable_shared_from_this()
    {
    }

    enable_shared_from_this(enable_shared_from_this const &)
    {
    }

    enable_shared_from_this & operator=(enable_shared_from_this const &)
    {
        return *this;
    }

    ~enable_shared_from_this()
    {
    }

public:

    shared_ptr<T> shared_from_this()
    {
        shared_ptr<T> p(_internal_weak_this);
        (__builtin_expect(!(p.get() == this), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/enable_shared_from_this.hpp", 50, "p.get() == this") : (void)0);
        return p;
    }

    shared_ptr<T const> shared_from_this() const
    {
        shared_ptr<T const> p(_internal_weak_this);
        (__builtin_expect(!(p.get() == this), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/enable_shared_from_this.hpp", 57, "p.get() == this") : (void)0);
        return p;
    }







    typedef T _internal_element_type;
    mutable weak_ptr<_internal_element_type> _internal_weak_this;
};

}
# 21 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Scheduler.h" 2 3
namespace mw {

enum MissedExecutionBehavior{ M_MISSED_EXECUTION_DROP,
 M_MISSED_EXECUTION_CATCH_UP,
M_MISSED_EXECUTION_FAIL};
# 62 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Scheduler.h" 3
using namespace boost;

void *dummy_function(void *);



class ScheduleTask{
protected:
 std::string description;
public:

 ScheduleTask(){ };
 virtual ~ScheduleTask(){ };

 virtual bool isActive() = 0;
 virtual bool isAlive() = 0;


 virtual void cancel() = 0;


 virtual void pause() = 0;
 virtual void resume() = 0;
 virtual void kill() = 0;

 virtual std::string getDescription() {
  return description;
 }
};


class Scheduler : public mw::Component, public enable_shared_from_this<Scheduler>, public RegisteredSingleton<Scheduler> {

protected:
 pthread_cond_t direct_tick_condition;
 boost::shared_ptr <Clock> the_clock;

public:
 Scheduler(const boost::shared_ptr <Clock> &a_clock);
 virtual ~Scheduler() {}

 virtual shared_ptr<ScheduleTask> scheduleMS(const std::string &description,
             MonkeyWorksTime initial_delay_ms,
             MonkeyWorksTime repeat_interval_ms,
             int ntimes,
             boost::function<void *()> _functor,
             int priority,
             MonkeyWorksTime warn_slop,
             MonkeyWorksTime fail_slop,
             MissedExecutionBehavior behav);

 virtual shared_ptr<ScheduleTask> scheduleUS(const std::string &description,
             MonkeyWorksTime initial_delay_us,
             MonkeyWorksTime repeat_interval_us,
             int ntimes,
             boost::function<void *()> _functor,
             int priority,
             MonkeyWorksTime warn_slop,
             MonkeyWorksTime fail_slop,
             MissedExecutionBehavior behav) = 0;



 virtual void removeTask(long id) = 0;

 virtual void fork(boost::function<void *()> _functor,
       int priority);

 boost::shared_ptr<Clock> getClock() const;

 virtual void launchWatchdogThread(){ return; }
};

}
# 15 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Timer.h" 2 3




namespace mw {

class TimeBase : public mw::Component {

protected:

 MonkeyWorksTime time_us;

public:

 TimeBase();

 void setTime(MonkeyWorksTime _time);
 void setNow();
 MonkeyWorksTime getTime();
};


class Timer : public Variable, public enable_shared_from_this<Timer> {

protected:
 shared_ptr<bool> has_expired;
 shared_ptr<ScheduleTask> schedule_node;



 shared_ptr<boost::mutex> internalLock;

public:
 Timer(VariableProperties *props = 0);
 ~Timer();

 void start(MonkeyWorksTime howlongms);
 void startMS(MonkeyWorksTime howlongms);
 void startUS(MonkeyWorksTime howlongus);
 void setExpired(bool has_it);
 bool hasExpired();
 void forceExpired();
 void cleanUp();
 Data getValue();
 void setValue(Data v){ }
 void setValue(Data v, MonkeyWorksTime t){ }
 void setSilentValue(Data _value){ }
 Variable *clone();


};


void *expireTheTimer(const shared_ptr<Timer> &the_timer);
}
# 72 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableRegistry.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableProperties.h" 1 3
# 45 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableProperties.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/limits.h" 1 3 4






# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/syslimits.h" 1 3 4
# 8 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/limits.h" 2 3 4
# 46 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableProperties.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/lib/gcc/i686-apple-darwin9/4.0.1/include/float.h" 1 3 4
# 47 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableProperties.h" 2 3
namespace mw {


const int __PACKAGESIZE__ = 11;

enum DomainType{ M_CONTINUOUS_INFINITE, M_CONTINUOUS_FINITE, M_DISCRETE,
                  M_DISCRETE_BOOLEAN, M_INTEGER_FINITE, M_INTEGER_INFINITE,
                  M_STRUCTURED };



const int M_INT_MIN = (-2147483647 - 1);
const int M_INT_MAX = 2147483647;
const double M_FLOAT_MIN = 2.2250738585072014e-308;
const double M_FLOAT_MAX = 1.7976931348623157e+308;


class VariableProperties {
 protected:
  std::string tagname;
        std::string shortname;
        std::string longname;
  WhenType editable;
  DomainType domain;
  bool viewable;
  bool persistant;
        Data * range;
  int nvals;
  WhenType logging;
  Variable *parameter;
  Data defaultvalue;
  std::vector <std::string> groups;





  std::vector <std::string> parseGroupList(const std::string &groups_csv) const;

    private:

        void operator=(const VariableProperties& that) { }

 public:

  VariableProperties(){ };
# 101 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableProperties.h" 3
        VariableProperties(Data * def,
       std::string tag,
       std::string full,
       std::string desc,
       WhenType edit,
       WhenType log,
       bool view,
       bool persist,
       DomainType dType,
       std::string groups);






  VariableProperties(Data * def,
       std::string tag,
       std::string full,
       std::string desc,
       WhenType edit,
       WhenType log,
       bool view,
       bool persist,
       DomainType dType,
       Data * rg,
       std::string groups);






  VariableProperties(Data * def,
       std::string tag,
       std::string full,
       std::string desc,
       WhenType edit,
       WhenType log,
       bool view,
       bool persist,
       DomainType dType,
       Data * rg,
       int numvals,
       std::string groups);



        VariableProperties(ScarabDatum * datum);


        VariableProperties(VariableProperties& copy);




        virtual ~VariableProperties();

        Data getDefaultValue();
        Variable * getVariable();
  WhenType getLogging();
  WhenType getEditable();
        DomainType getDomainType();
        int getNumberValuesInRange();
        Data * getRange();
        std::string getTagName();
        std::string getShortName();
  std::string getLongName();
  bool getViewable();
  bool getPersistant();
        void setVariable(Variable *theparam);
        void addRange(Data *, int);
  std::vector <std::string> getGroups();




        virtual ScarabDatum *toScarabDatum();

  operator Data();




        void printToSTDERR();
};
}
# 73 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableRegistry.h" 2 3
# 83 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableRegistry.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpressionParser.h" 1 3
# 34 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpressionParser.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 35 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpressionParser.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_ptr.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_ptr.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_array.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_array.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_array.hpp" 2 3







namespace boost
{
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_array.hpp" 3
template<class T> class scoped_array
{
private:

    T * ptr;

    scoped_array(scoped_array const &);
    scoped_array & operator=(scoped_array const &);

    typedef scoped_array<T> this_type;

    void operator==( scoped_array const& ) const;
    void operator!=( scoped_array const& ) const;

public:

    typedef T element_type;

    explicit scoped_array(T * p = 0) : ptr(p)
    {



    }

    ~scoped_array()
    {



        boost::checked_array_delete(ptr);
    }

    void reset(T * p = 0)
    {
        (__builtin_expect(!(p == 0 || p != ptr), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_array.hpp", 73, "p == 0 || p != ptr") : (void)0);
        this_type(p).swap(*this);
    }

    T & operator[](std::ptrdiff_t i) const
    {
        (__builtin_expect(!(ptr != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_array.hpp", 79, "ptr != 0") : (void)0);
        (__builtin_expect(!(i >= 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_array.hpp", 80, "i >= 0") : (void)0);
        return ptr[i];
    }

    T * get() const
    {
        return ptr;
    }
# 108 "/Library/Application Support/MonkeyWorks/Developer/include/boost/scoped_array.hpp" 3
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return ptr == 0? 0: &this_type::ptr;
    }



    bool operator! () const
    {
        return ptr == 0;
    }

    void swap(scoped_array & b)
    {
        T * tmp = b.ptr;
        b.ptr = ptr;
        ptr = tmp;
    }

};

template<class T> inline void swap(scoped_array<T> & a, scoped_array<T> & b)
{
    a.swap(b);
}

}
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_ptr.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_array.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_array.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_array.hpp" 2 3
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_array.hpp" 3
namespace boost
{
# 46 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_array.hpp" 3
template<class T> class shared_array
{
private:


    typedef checked_array_deleter<T> deleter;
    typedef shared_array<T> this_type;

public:

    typedef T element_type;

    explicit shared_array(T * p = 0): px(p), pn(p, deleter())
    {
    }







    template<class D> shared_array(T * p, D d): px(p), pn(p, d)
    {
    }



    void reset(T * p = 0)
    {
        (__builtin_expect(!(p == 0 || p != px), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_array.hpp", 76, "p == 0 || p != px") : (void)0);
        this_type(p).swap(*this);
    }

    template <class D> void reset(T * p, D d)
    {
        this_type(p, d).swap(*this);
    }

    T & operator[] (std::ptrdiff_t i) const
    {
        (__builtin_expect(!(px != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_array.hpp", 87, "px != 0") : (void)0);
        (__builtin_expect(!(i >= 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_array.hpp", 88, "i >= 0") : (void)0);
        return px[i];
    }

    T * get() const
    {
        return px;
    }
# 132 "/Library/Application Support/MonkeyWorks/Developer/include/boost/shared_array.hpp" 3
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return px == 0? 0: &this_type::px;
    }



    bool operator! () const
    {
        return px == 0;
    }

    bool unique() const
    {
        return pn.unique();
    }

    long use_count() const
    {
        return pn.use_count();
    }

    void swap(shared_array<T> & other)
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

private:

    T * px;
    detail::shared_count pn;

};

template<class T> inline bool operator==(shared_array<T> const & a, shared_array<T> const & b)
{
    return a.get() == b.get();
}

template<class T> inline bool operator!=(shared_array<T> const & a, shared_array<T> const & b)
{
    return a.get() != b.get();
}

template<class T> inline bool operator<(shared_array<T> const & a, shared_array<T> const & b)
{
    return std::less<T*>()(a.get(), b.get());
}

template<class T> void swap(shared_array<T> & a, shared_array<T> & b)
{
    a.swap(b);
}

}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/smart_ptr.hpp" 2 3
# 36 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpressionParser.h" 2 3



namespace stx {



class ExpressionParserException : public std::runtime_error
{
public:

    inline ExpressionParserException(const std::string &s) throw()
 : std::runtime_error(s)
    { }
};




class ConversionException : public ExpressionParserException
{
public:

    inline ConversionException(const std::string &s) throw()
 : ExpressionParserException(s)
    { }
};




class ArithmeticException : public ExpressionParserException
{
public:

    inline ArithmeticException(const std::string &s) throw()
 : ExpressionParserException(s)
    { }
};




class BadSyntaxException : public ExpressionParserException
{
public:

    inline BadSyntaxException(const std::string &s) throw()
 : ExpressionParserException(s)
    { }
};




class UnknownSymbolException : public ExpressionParserException
{
public:

    inline UnknownSymbolException(const std::string &s) throw()
 : ExpressionParserException(s)
    { }
};




class BadFunctionCallException : public ExpressionParserException
{
public:

    inline BadFunctionCallException(const std::string &s) throw()
 : ExpressionParserException(s)
    { }
};





class SymbolTable
{
public:

    typedef std::vector<AnyScalar> paramlist_type;


    virtual ~SymbolTable();


    virtual AnyScalar lookupVariable(const std::string &varname) const = 0;



    virtual AnyScalar processFunction(const std::string &funcname,
     const paramlist_type &paramlist) const = 0;
};





class EmptySymbolTable : public SymbolTable
{
public:

    typedef std::vector<AnyScalar> paramlist_type;


    virtual ~EmptySymbolTable();



    virtual AnyScalar lookupVariable(const std::string &varname) const;




    virtual AnyScalar processFunction(const std::string &funcname,
     const paramlist_type &paramlist) const;
};






class BasicSymbolTable : public SymbolTable
{
public:

    typedef AnyScalar (*functionptr_type)(const paramlist_type& paramlist);

protected:


    typedef std::map<std::string, AnyScalar> variablemap_type;


    struct FunctionInfo
    {


 int arguments;


 functionptr_type func;


 FunctionInfo(int _arguments = 0, functionptr_type _func = __null)
     : arguments(_arguments), func(_func)
 {
 }
    };


    typedef std::map<std::string, struct FunctionInfo> functionmap_type;

private:

    variablemap_type variablemap;


    functionmap_type functionmap;

protected:



    static AnyScalar funcPI(const paramlist_type& paramlist);


    static AnyScalar funcSIN(const paramlist_type& paramlist);


    static AnyScalar funcCOS(const paramlist_type& paramlist);


    static AnyScalar funcTAN(const paramlist_type& paramlist);


    static AnyScalar funcABS(const paramlist_type& paramlist);


    static AnyScalar funcEXP(const paramlist_type& paramlist);


    static AnyScalar funcLOGN(const paramlist_type& paramlist);


    static AnyScalar funcPOW(const paramlist_type& paramlist);


    static AnyScalar funcSQRT(const paramlist_type& paramlist);

    static AnyScalar funcUNIFORM_RAND(const paramlist_type& paramlist);
    static AnyScalar funcDISC_UNIFORM_RAND(const paramlist_type& paramlist);
 static AnyScalar funcGEOM_RAND(const paramlist_type& paramlist);
 static AnyScalar funcNOW(const paramlist_type& paramlist);
 static AnyScalar funcTIMER_EXPIRED(const paramlist_type& paramlist);

public:

    BasicSymbolTable();


    virtual ~BasicSymbolTable();



    virtual AnyScalar lookupVariable(const std::string &varname) const;



    virtual AnyScalar processFunction(const std::string &funcname,
     const paramlist_type &paramlist) const;


    void setVariable(const std::string& varname, const AnyScalar &value);


    void setFunction(const std::string& funcname, int arguments, functionptr_type funcptr);


    void clearVariables();


    void clearFunctions();


    void addStandardFunctions();
};





class ParseNode
{
protected:

    inline ParseNode()
    { }


    ParseNode(const ParseNode &pn);


    ParseNode& operator=(const ParseNode &pn);

public:


    virtual ~ParseNode()
    {
    }



    virtual AnyScalar evaluate(const class SymbolTable &st = BasicSymbolTable()) const = 0;






    virtual bool evaluate_const(AnyScalar *dest) const = 0;


    virtual std::string toString() const = 0;
};




class ParseTree
{
protected:


    boost::shared_ptr<ParseNode> rootnode;

public:


    ParseTree()
 : rootnode(static_cast<ParseNode*>(__null))
    {
    }


    ParseTree(ParseNode* pt)
 : rootnode(pt)
    {
    }


    inline bool isEmpty() const
    {
 return (rootnode.get() == __null);
    }



    AnyScalar evaluate(const class SymbolTable &st = BasicSymbolTable()) const
    {
  (__builtin_expect(!(rootnode.get() != __null), 0) ? __assert_rtn(__func__, "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpressionParser.h", 342, "rootnode.get() != NULL") : (void)0);
  return rootnode->evaluate(st);
    }


    std::string toString() const
    {
 (__builtin_expect(!(rootnode.get() != __null), 0) ? __assert_rtn(__func__, "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ExpressionParser.h", 349, "rootnode.get() != NULL") : (void)0);
 return rootnode->toString();
    }
};



const ParseTree parseExpression(const std::string &input);



std::string parseExpressionXML(const std::string &input);




class ParseTreeList : public std::vector<ParseTree>
{
protected:

    typedef std::vector<ParseTree> parent_type;

public:


    std::vector<AnyScalar> evaluate(const class SymbolTable &st = BasicSymbolTable()) const;



    std::string toString() const;
};




ParseTreeList parseExpressionList(const std::string &input);

}
# 84 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableRegistry.h" 2 3
namespace mw {



class VariableRegistry : public stx::BasicSymbolTable {

private:

 int currentUnique;

 boost::mutex lock;

 shared_ptr<BufferManager> buffer_manager;






protected:




 ExpandableList<Variable> master_variable_list;


    map< string, shared_ptr<Variable> > master_variable_dictionary;


 ExpandableList<ScopedVariable> local_variable_list;


 ExpandableList<GlobalVariable> global_variable_list;


 ExpandableList<SelectionVariable> selection_variable_list;






 shared_ptr<ScopedVariable> addScopedVariable(weak_ptr<ScopedVariableEnvironment> env,
              VariableProperties *p = __null);
 shared_ptr<GlobalVariable> addGlobalVariable(VariableProperties *p = __null);
 shared_ptr<SelectionVariable> addSelectionVariable(VariableProperties *p = __null);

 shared_ptr<ConstantVariable> addConstantVariable(Data value);
 shared_ptr<EmptyVariable> addPlaceholderVariable(VariableProperties *p = __null);


public:

 VariableRegistry(shared_ptr<BufferManager> _buffer_manager);
 ~VariableRegistry();

 void addPlaceholders();






    shared_ptr<BufferManager> getBufferManager(){ return buffer_manager; }




 shared_ptr<Variable> getVariable(const std::string& tagname) const;
 shared_ptr<Variable> getVariable(int codecCode);

 std::vector<std::string> getVariableTagnames();


 bool hasVariable(const char *tagname) const;
 bool hasVariable(std::string &tagname) const;

 int getNVariables();

 ExpandableList<ScopedVariable> *getLocalVariables();
 ExpandableList<GlobalVariable> *getGlobalVariables();




 void announceLocalVariables();
 void announceGlobalVariables();
 void announceSelectionVariables();
 void announceAll();



 shared_ptr<ScopedVariable> createScopedVariable(weak_ptr<ScopedVariableEnvironment> env,
              VariableProperties *p = __null);

 shared_ptr<GlobalVariable> createGlobalVariable(VariableProperties *p = __null);
 shared_ptr<SelectionVariable> createSelectionVariable(VariableProperties *p = __null);

 shared_ptr<ConstantVariable> createConstantVariable(Data value);
 shared_ptr<Timer> createTimer(VariableProperties *p = __null);
 shared_ptr<EmptyVariable> createPlaceholderVariable(VariableProperties *p = __null);
# 198 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableRegistry.h" 3
 Data getCodec();
 void update(const Data &codec);
# 208 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/VariableRegistry.h" 3
 virtual stx::AnyScalar lookupVariable(const std::string &varname) const;

};

extern shared_ptr<VariableRegistry> GlobalVariableRegistry;
void initializeVariableRegistry();
}
# 15 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StandardVariables.h" 2 3
namespace mw {
# 109 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StandardVariables.h" 3
enum {IDLE, STOPPING, RUNNING, TASKMODES};






extern shared_ptr<Variable> task_mode;




extern shared_ptr<Variable> stimDisplayUpdate;

extern shared_ptr<Variable> GlobalMessageVariable;


extern shared_ptr<Variable> GlobalSystemEventVariable;




extern shared_ptr<Variable> currentState;




extern shared_ptr<Variable> trialAnnounce;
extern shared_ptr<Variable> blockAnnounce;


extern shared_ptr<Variable> assertionFailure;


extern shared_ptr<Variable> serverName;



extern shared_ptr<Variable> experimentLoadProgress;

extern shared_ptr<Variable> beamPosition;
# 175 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StandardVariables.h" 3
extern shared_ptr<Variable> mainDisplayInfo;




extern shared_ptr<Variable> debuggerActive;


extern shared_ptr<Variable> debuggerRunning;


extern shared_ptr<Variable> debuggerStep;


void initializeStandardVariables(shared_ptr<VariableRegistry> registry);
}
# 25 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/States.h" 2 3



# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Announcers.h" 1 3
# 19 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Announcers.h" 3
namespace mw {
class RequestNotification;
class PrivateDataNotification;

class Announcable {

 private:
 shared_ptr<Variable> announceVariable;
        Data lastAnnouncedData;
        bool validAnnounceData;

    public:
        Announcable(std::string _announceVariableTagname);
        virtual ~Announcable();

  void announce(Data _announceData, MonkeyWorksTime time);

  void announce(Data _announceData);
        void announce();

};




class Requestable {

private:
 shared_ptr<Variable> requestVariable;
 std::string requestVariableTagname;
 shared_ptr<RequestNotification> requestNotificationObject;

protected:
 void requestSelf(Data data);

public:
 Requestable(std::string _requestVariableTagname);
 virtual ~Requestable();
 virtual void notifyRequest(const Data& data, MonkeyWorksTime timeUS) = 0;

};

class RequestNotification : public VariableNotification{

protected:
 Requestable *requestedObject;

public:
 RequestNotification(Requestable *_requestable);
 virtual void notify(const Data& data, MonkeyWorksTime timeUS);

};





class PrivateDataStorable {

protected:
 bool privateVariableNameAlreadyInstantiated;
 shared_ptr<Variable> privateVariable;
 std::string privateVariableTagname;
 shared_ptr<PrivateDataNotification> privateDataNotificationObject;
 void storePrivateData(Data data);

public:
 PrivateDataStorable(std::string _privateVariableBaseName,
       std::string _privateVariableSubName);
 virtual ~PrivateDataStorable();
 virtual void notifyPrivate(const Data& data, MonkeyWorksTime timeUS)=0;

};

class PrivateDataNotification : public VariableNotification{

protected:
 PrivateDataStorable * privateDataStorableObject;
 Data lastPrivateData;
 bool respondingToPrivateVarNotification;
 Lockable *privateDataLock;

public:
 PrivateDataNotification(PrivateDataStorable *_privateDataStorableObject);
 virtual void notify(const Data& data, MonkeyWorksTime timeUS);
 void setLastPrivateData(Data data);
 bool isRespondingToPrivateVarNotification();

};



}
# 29 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/States.h" 2 3
namespace mw {
class Experiment;

using namespace std;




class State : public ScopedVariableEnvironment,
      public Clonable,
      public mw::Component,
      public ComponentFactory {
 protected:

        weak_ptr<State> parent;


        weak_ptr<Experiment> experiment;
  weak_ptr<ScopedVariableEnvironment> environment;

  shared_ptr<ScopedVariableContext> local_variable_context;


        std::string name;
        std::string description;

  bool interruptible;

 public:






        State();
# 77 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/States.h" 3
        virtual ~State();

  virtual void requestVariableContext();

  virtual shared_ptr<mw::Component> createInstanceObject();
  virtual void *scopedClone();

  void setParameters(std::map<std::string, std::string> parameters,
           ComponentRegistry *reg);

        virtual void action();





        virtual void update();




        virtual weak_ptr<State> next();

        virtual void setParent(weak_ptr<State> newparent);
        weak_ptr<State> getParent();


        virtual void updateHierarchy();

        virtual void reset();




        virtual weak_ptr<Experiment> getExperiment();
        virtual void setExperiment(weak_ptr<Experiment> _experiment);

  virtual weak_ptr<ScopedVariableEnvironment> State::getScopedVariableEnvironment();
        virtual void setScopedVariableEnvironment(weak_ptr<ScopedVariableEnvironment> _env);

  virtual void updateCurrentScopedVariableContext();
  void setLocalScopedVariableContext(shared_ptr<ScopedVariableContext> c);

  shared_ptr<ScopedVariableContext> getLocalScopedVariableContext();




  State *getStateInstance();

  void setInterruptible(bool _interruptible){ interruptible = _interruptible; }
  bool isInterruptible(){ return interruptible; }





        void setName(std::string);
  void setName(const char *n);




        std::string getName();




        void setDescription(std::string);





        std::string getDescription();

};


class StateReference : public State {

 protected:
  State *state;

 public:

  StateReference(State *ref);

  virtual void action();
  virtual weak_ptr<State> next();

  virtual void update();

};

class ContainerState : public State {

 protected:



  shared_ptr< vector< shared_ptr<State> > > list;
  bool accessed;

 public:


  ContainerState();


  virtual ~ContainerState();

  virtual shared_ptr<mw::Component> createInstanceObject();

  shared_ptr< vector< shared_ptr<State> > > getList();
  void setList(shared_ptr< vector< shared_ptr<State> > > newlist);

  virtual void updateHierarchy();


  virtual void addChild(std::map<std::string, std::string> parameters,
        ComponentRegistry *reg,
        shared_ptr<mw::Component> child){

   std::cerr << "addChild start" << std::endl;
   shared_ptr<State> state = dynamic_pointer_cast<State, mw::Component>(child);

   if(state == __null){

    throw SimpleException("Attempt to add non-paradigm component object as child of a paradigm component");
   }

   list->push_back(state);
   state->setParent(getSelfPtr<State>());
   state->updateHierarchy();

   std::cerr << "addChild end" << std::endl;
  }

};


class ListState : public ContainerState, public Selectable {
 protected:

  bool has_more_children_to_run;

 public:

  ListState();

  virtual ~ListState();


  virtual shared_ptr<mw::Component> createInstanceObject();


  virtual int getNChildren();



  virtual void update();


  virtual weak_ptr<State> next();
  virtual void reset();


  virtual int getNItems();

  void finalize(std::map<std::string, std::string> parameters,
            ComponentRegistry *reg);

};

template <class T>
class ListStateFactory : public ComponentFactory {
 virtual shared_ptr<mw::Component>
  createObject(std::map<std::string, std::string> parameters,
     ComponentRegistry *reg){

  shared_ptr<T> newListState = shared_ptr<T>(new T());
  newListState->setParameters(parameters, reg);

  return newListState;
 }
};
}
# 9 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StateSystem.h" 2 3





namespace mw {
class StateSystem : public mw::Component, public enable_shared_from_this<StateSystem>, public RegisteredSingleton<StateSystem> {
protected:
 shared_ptr <Clock> the_clock;

public:

 StateSystem(const shared_ptr <Clock> &a_clock);

 virtual ~StateSystem();







 virtual void start();
 virtual void stop();
 virtual void pause();

 virtual bool isRunning();
 virtual bool isPaused();

 virtual bool isInAction();
 virtual bool isInTransition();

 virtual void setInAction(bool);
 virtual void setInTransition(bool);


 virtual void sendSystemStateEvent();

 weak_ptr<State> getCurrentState();
 void setCurrentState(weak_ptr<State> current);
 shared_ptr<Clock> getClock() const;
};

}
# 33 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentRegistry.h" 2 3



# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Stimulus.h" 1 3
# 40 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Stimulus.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StimulusDisplay.h" 1 3
# 14 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StimulusDisplay.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 1 3




extern "C" {
# 40 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 3
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;

typedef long GLintptr;
typedef long GLsizeiptr;



    typedef char GLchar;



# 1 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 1 3
# 9 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern "C" {
# 171 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
typedef char GLcharARB;
typedef void *GLhandleARB;



typedef long GLintptrARB;
typedef long GLsizeiptrARB;
# 2757 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glActiveTextureARB (GLenum);
extern void glClientActiveTextureARB (GLenum);
extern void glMultiTexCoord1dARB (GLenum, GLdouble);
extern void glMultiTexCoord1dvARB (GLenum, const GLdouble *);
extern void glMultiTexCoord1fARB (GLenum, GLfloat);
extern void glMultiTexCoord1fvARB (GLenum, const GLfloat *);
extern void glMultiTexCoord1iARB (GLenum, GLint);
extern void glMultiTexCoord1ivARB (GLenum, const GLint *);
extern void glMultiTexCoord1sARB (GLenum, GLshort);
extern void glMultiTexCoord1svARB (GLenum, const GLshort *);
extern void glMultiTexCoord2dARB (GLenum, GLdouble, GLdouble);
extern void glMultiTexCoord2dvARB (GLenum, const GLdouble *);
extern void glMultiTexCoord2fARB (GLenum, GLfloat, GLfloat);
extern void glMultiTexCoord2fvARB (GLenum, const GLfloat *);
extern void glMultiTexCoord2iARB (GLenum, GLint, GLint);
extern void glMultiTexCoord2ivARB (GLenum, const GLint *);
extern void glMultiTexCoord2sARB (GLenum, GLshort, GLshort);
extern void glMultiTexCoord2svARB (GLenum, const GLshort *);
extern void glMultiTexCoord3dARB (GLenum, GLdouble, GLdouble, GLdouble);
extern void glMultiTexCoord3dvARB (GLenum, const GLdouble *);
extern void glMultiTexCoord3fARB (GLenum, GLfloat, GLfloat, GLfloat);
extern void glMultiTexCoord3fvARB (GLenum, const GLfloat *);
extern void glMultiTexCoord3iARB (GLenum, GLint, GLint, GLint);
extern void glMultiTexCoord3ivARB (GLenum, const GLint *);
extern void glMultiTexCoord3sARB (GLenum, GLshort, GLshort, GLshort);
extern void glMultiTexCoord3svARB (GLenum, const GLshort *);
extern void glMultiTexCoord4dARB (GLenum, GLdouble, GLdouble, GLdouble, GLdouble);
extern void glMultiTexCoord4dvARB (GLenum, const GLdouble *);
extern void glMultiTexCoord4fARB (GLenum, GLfloat, GLfloat, GLfloat, GLfloat);
extern void glMultiTexCoord4fvARB (GLenum, const GLfloat *);
extern void glMultiTexCoord4iARB (GLenum, GLint, GLint, GLint, GLint);
extern void glMultiTexCoord4ivARB (GLenum, const GLint *);
extern void glMultiTexCoord4sARB (GLenum, GLshort, GLshort, GLshort, GLshort);
extern void glMultiTexCoord4svARB (GLenum, const GLshort *);
# 2801 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glLoadTransposeMatrixfARB (const GLfloat *);
extern void glLoadTransposeMatrixdARB (const GLdouble *);
extern void glMultTransposeMatrixfARB (const GLfloat *);
extern void glMultTransposeMatrixdARB (const GLdouble *);
# 2813 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glSampleCoverageARB (GLclampf, GLboolean);
extern void glSamplePassARB (GLenum);
# 2828 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glCompressedTexImage3DARB (GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
extern void glCompressedTexImage2DARB (GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
extern void glCompressedTexImage1DARB (GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, const GLvoid *);
extern void glCompressedTexSubImage3DARB (GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
extern void glCompressedTexSubImage2DARB (GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
extern void glCompressedTexSubImage1DARB (GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, const GLvoid *);
extern void glGetCompressedTexImageARB (GLenum, GLint, GLvoid *);
# 2851 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glWeightbvARB(GLint, const GLbyte *);
extern void glWeightsvARB(GLint, const GLshort *);
extern void glWeightivARB(GLint, const GLint *);
extern void glWeightfvARB(GLint, const GLfloat *);
extern void glWeightdvARB(GLint, const GLdouble *);
extern void glWeightubvARB(GLint, const GLubyte *);
extern void glWeightusvARB(GLint, const GLushort *);
extern void glWeightuivARB(GLint, const GLuint *);
extern void glWeightPointerARB(GLint, GLenum, GLsizei, const GLvoid *);
extern void glVertexBlendARB(GLint);
# 2883 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glWindowPos2dARB (GLdouble, GLdouble);
extern void glWindowPos2dvARB (const GLdouble *);
extern void glWindowPos2fARB (GLfloat, GLfloat);
extern void glWindowPos2fvARB (const GLfloat *);
extern void glWindowPos2iARB (GLint, GLint);
extern void glWindowPos2ivARB (const GLint *);
extern void glWindowPos2sARB (GLshort, GLshort);
extern void glWindowPos2svARB (const GLshort *);
extern void glWindowPos3dARB (GLdouble, GLdouble, GLdouble);
extern void glWindowPos3dvARB (const GLdouble *);
extern void glWindowPos3fARB (GLfloat, GLfloat, GLfloat);
extern void glWindowPos3fvARB (const GLfloat *);
extern void glWindowPos3iARB (GLint, GLint, GLint);
extern void glWindowPos3ivARB (const GLint *);
extern void glWindowPos3sARB (GLshort, GLshort, GLshort);
extern void glWindowPos3svARB (const GLshort *);
# 2913 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGenQueriesARB(GLsizei n, GLuint *ids);
extern void glDeleteQueriesARB(GLsizei n, const GLuint *ids);
extern GLboolean glIsQueryARB(GLuint id);
extern void glBeginQueryARB(GLenum target, GLuint id);
extern void glEndQueryARB(GLenum target);
extern void glGetQueryivARB(GLenum target, GLenum pname, GLint *params);
extern void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params);
extern void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params);
# 2929 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPointParameterfARB(GLenum pname, GLfloat param);
extern void glPointParameterfvARB(GLenum pname, const GLfloat *params);
# 2965 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindProgramARB(GLenum target, GLuint program);
extern void glDeleteProgramsARB(GLsizei n, const GLuint *programs);
extern void glGenProgramsARB(GLsizei n, GLuint *programs);
extern GLboolean glIsProgramARB(GLuint program);

extern void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
extern void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);
extern void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
extern void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);

extern void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params);
extern void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params);

extern void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);
extern void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);


extern void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params);
extern void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params);

extern void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string);
extern void glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string);

extern void glGetProgramivARB(GLenum target, GLenum pname, GLint *params);
# 3048 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexAttrib1dARB(GLuint index, GLdouble x);
extern void glVertexAttrib1dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib1fARB(GLuint index, GLfloat x);
extern void glVertexAttrib1fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib1sARB(GLuint index, GLshort x);
extern void glVertexAttrib1svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y);
extern void glVertexAttrib2dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y);
extern void glVertexAttrib2fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y);
extern void glVertexAttrib2svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void glVertexAttrib3dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void glVertexAttrib3fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z);
extern void glVertexAttrib3svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4NbvARB(GLuint index, const GLbyte *v);
extern void glVertexAttrib4NivARB(GLuint index, const GLint *v);
extern void glVertexAttrib4NsvARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void glVertexAttrib4NubvARB(GLuint index, const GLubyte *v);
extern void glVertexAttrib4NuivARB(GLuint index, const GLuint *v);
extern void glVertexAttrib4NusvARB(GLuint index, const GLushort *v);
extern void glVertexAttrib4bvARB(GLuint index, const GLbyte *v);
extern void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertexAttrib4dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertexAttrib4fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib4ivARB(GLuint index, const GLint *v);
extern void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertexAttrib4svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4ubvARB(GLuint index, const GLubyte *v);
extern void glVertexAttrib4uivARB(GLuint index, const GLuint *v);
extern void glVertexAttrib4usvARB(GLuint index, const GLushort *v);
extern void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);

extern void glDisableVertexAttribArrayARB(GLuint index);
extern void glEnableVertexAttribArrayARB(GLuint index);

extern void glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer);
extern void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params);
extern void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params);
extern void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params);
# 3139 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDeleteObjectARB(GLhandleARB obj);
extern GLhandleARB glGetHandleARB(GLenum pname);
extern void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj);
extern GLhandleARB glCreateShaderObjectARB(GLenum shaderType);
extern void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length);
extern void glCompileShaderARB(GLhandleARB shaderObj);
extern GLhandleARB glCreateProgramObjectARB(void);
extern void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj);
extern void glLinkProgramARB(GLhandleARB programObj);
extern void glUseProgramObjectARB(GLhandleARB programObj);
extern void glValidateProgramARB(GLhandleARB programObj);
extern void glUniform1fARB(GLint location, GLfloat v0);
extern void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1);
extern void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void glUniform1iARB(GLint location, GLint v0);
extern void glUniform2iARB(GLint location, GLint v0, GLint v1);
extern void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2);
extern void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform1ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform2ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform3ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform4ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params);
extern void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params);
extern void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
extern void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
extern GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name);
extern void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params);
extern void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params);
extern void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
# 3187 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name);
extern void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name);
# 3207 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindBufferARB(GLenum target, GLuint buffer);
extern void glDeleteBuffersARB(GLsizei n, const GLuint *buffers);
extern void glGenBuffersARB(GLsizei n, GLuint *buffers);
extern GLboolean glIsBufferARB(GLuint buffer);
extern void glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
extern void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
extern void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
extern GLvoid *glMapBufferARB(GLenum target, GLenum access);
extern GLboolean glUnmapBufferARB(GLenum target);
extern void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params);
extern void glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params);
# 3226 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDrawBuffersARB(GLsizei n, const GLenum *bufs);







extern void glBlendColorEXT (GLclampf, GLclampf, GLclampf, GLclampf);
# 3386 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBlendEquationEXT (GLenum);
# 3408 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glColorTableEXT (GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
extern void glColorSubTableEXT (GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
extern void glGetColorTableEXT (GLenum, GLenum, GLenum, GLvoid *);
extern void glGetColorTableParameterivEXT (GLenum, GLenum, GLint *);
extern void glGetColorTableParameterfvEXT (GLenum, GLenum, GLfloat *);
# 3437 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glLockArraysEXT (GLint, GLsizei);
extern void glUnlockArraysEXT (void);
# 3456 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDrawRangeElementsEXT (GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *);
# 3506 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glSecondaryColor3bEXT (GLbyte, GLbyte, GLbyte);
extern void glSecondaryColor3bvEXT (const GLbyte *);
extern void glSecondaryColor3dEXT (GLdouble, GLdouble, GLdouble);
extern void glSecondaryColor3dvEXT (const GLdouble *);
extern void glSecondaryColor3fEXT (GLfloat, GLfloat, GLfloat);
extern void glSecondaryColor3fvEXT (const GLfloat *);
extern void glSecondaryColor3iEXT (GLint, GLint, GLint);
extern void glSecondaryColor3ivEXT (const GLint *);
extern void glSecondaryColor3sEXT (GLshort, GLshort, GLshort);
extern void glSecondaryColor3svEXT (const GLshort *);
extern void glSecondaryColor3ubEXT (GLubyte, GLubyte, GLubyte);
extern void glSecondaryColor3ubvEXT (const GLubyte *);
extern void glSecondaryColor3uiEXT (GLuint, GLuint, GLuint);
extern void glSecondaryColor3uivEXT (const GLuint *);
extern void glSecondaryColor3usEXT (GLushort, GLushort, GLushort);
extern void glSecondaryColor3usvEXT (const GLushort *);
extern void glSecondaryColorPointerEXT (GLint, GLenum, GLsizei, const GLvoid *);
# 3539 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glMultiDrawArraysEXT (GLenum, const GLint *, const GLsizei *, GLsizei);
extern void glMultiDrawElementsEXT (GLenum, const GLsizei *, GLenum, const GLvoid* *, GLsizei);
# 3552 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glFogCoordfEXT (GLfloat);
extern void glFogCoordfvEXT (const GLfloat *);
extern void glFogCoorddEXT (GLdouble);
extern void glFogCoorddvEXT (const GLdouble *);
extern void glFogCoordPointerEXT (GLenum, GLsizei, const GLvoid *);
# 3614 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBlendFuncSeparateEXT (GLenum, GLenum, GLenum, GLenum);
# 3768 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glActiveStencilFaceEXT(GLenum face);







extern void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax);







extern void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha);
# 3808 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLboolean glIsRenderbufferEXT(GLuint renderbuffer);
extern void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer);
extern void glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers);
extern void glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers);
extern void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern GLboolean glIsFramebufferEXT(GLuint framebuffer);
extern void glBindFramebufferEXT(GLenum target, GLuint framebuffer);
extern void glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers);
extern void glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers);
extern GLenum glCheckFramebufferStatusEXT(GLenum target);
extern void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern void glGenerateMipmapEXT(GLenum target);







extern void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);







extern void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 3851 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);
extern void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
extern void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
# 3870 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
extern void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer);
extern void glBeginTransformFeedbackEXT(GLenum primitiveMode);
extern void glEndTransformFeedbackEXT(void);
extern void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode);
extern void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
extern void glGetIntegerIndexedvEXT(GLenum param, GLuint index, GLint *values);
extern void glGetBooleanIndexedvEXT(GLenum param, GLuint index, GLboolean *values);
# 3888 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer);
extern GLint glGetUniformBufferSizeEXT(GLuint program, GLint location);
extern GLintptr glGetUniformOffsetEXT(GLuint program, GLint location);
# 3903 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glClearColorIiEXT( GLint r, GLint g, GLint b, GLint a );
extern void glClearColorIuiEXT( GLuint r, GLuint g, GLuint b, GLuint a );
extern void glTexParameterIivEXT( GLenum target, GLenum pname, GLint *params );
extern void glTexParameterIuivEXT( GLenum target, GLenum pname, GLuint *params );
extern void glGetTexParameterIivEXT( GLenum target, GLenum pname, GLint *params);
extern void glGetTexParameterIiuvEXT( GLenum target, GLenum pname, GLuint *params);
# 3949 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexAttribI1iEXT(GLuint index, GLint x);
extern void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y);
extern void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z);
extern void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w);
extern void glVertexAttribI1uiEXT(GLuint index, GLuint x);
extern void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y);
extern void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z);
extern void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern void glVertexAttribI1ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI2ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI3ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI4ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI1uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI2uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI3uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI4uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI4bvEXT(GLuint index, const GLbyte *v);
extern void glVertexAttribI4svEXT(GLuint index, const GLshort *v);
extern void glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v);
extern void glVertexAttribI4usvEXT(GLuint index, const GLushort *v);
extern void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params);
extern void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params);
extern void glUniform1uiEXT(GLint location, GLuint v0);
extern void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1);
extern void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2);
extern void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern void glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glGetUniformuivEXT(GLuint program, GLint location, GLuint *params);
extern void glBindFragDataLocationEXT(GLuint program, GLuint colorNumber, const GLchar *name);
extern GLint glGetFragDataLocationEXT(GLuint program, const GLchar *name);
# 3991 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer);
extern void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params);
# 4002 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer);
extern void glFlushVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer);
extern void glVertexArrayParameteriAPPLE(GLenum pname, GLint param);
# 4015 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindVertexArrayAPPLE(GLuint id);
extern void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *ids);
extern void glGenVertexArraysAPPLE(GLsizei n, GLuint *ids);
extern GLboolean glIsVertexArrayAPPLE(GLuint id);
# 4033 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGenFencesAPPLE(GLsizei n, GLuint *fences);
extern void glDeleteFencesAPPLE(GLsizei n, const GLuint *fences);
extern void glSetFenceAPPLE(GLuint fence);
extern GLboolean glIsFenceAPPLE(GLuint fence);
extern GLboolean glTestFenceAPPLE(GLuint fence);
extern void glFinishFenceAPPLE(GLuint fence);
extern GLboolean glTestObjectAPPLE(GLenum object, GLuint name);
extern void glFinishObjectAPPLE(GLenum object, GLuint name);
# 4052 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glElementPointerAPPLE(GLenum type, const GLvoid *pointer);
extern void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count);
extern void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
extern void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
# 4066 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glFlushRenderAPPLE(void);
extern void glFinishRenderAPPLE(void);
extern void glSwapAPPLE(void);
# 4082 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glEnableVertexAttribAPPLE(GLuint index, GLenum pname);
extern void glDisableVertexAttribAPPLE(GLuint index, GLenum pname);
extern GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname);
extern void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
# 4097 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param);
extern void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size);
# 4108 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);
extern GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);
extern void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint* params);
# 4119 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPNTrianglesiATI(GLenum pname, GLint param);
extern void glPNTrianglesfATI(GLenum pname, GLfloat param);







extern void glBlendEquationSeparateATI(GLenum equationRGB, GLenum equationAlpha);
# 4137 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
extern void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
# 4147 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPNTrianglesiATIX(GLenum pname, GLint param);
extern void glPNTrianglesfATIX(GLenum pname, GLfloat param);
# 4255 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glCombinerParameterfvNV (GLenum, const GLfloat *);
extern void glCombinerParameterfNV (GLenum, GLfloat);
extern void glCombinerParameterivNV (GLenum, const GLint *);
extern void glCombinerParameteriNV (GLenum, GLint);
extern void glCombinerInputNV (GLenum, GLenum, GLenum, GLenum, GLenum, GLenum);
extern void glCombinerOutputNV (GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLboolean, GLboolean, GLboolean);
extern void glFinalCombinerInputNV (GLenum, GLenum, GLenum, GLenum);
extern void glGetCombinerInputParameterfvNV (GLenum, GLenum, GLenum, GLenum, GLfloat *);
extern void glGetCombinerInputParameterivNV (GLenum, GLenum, GLenum, GLenum, GLint *);
extern void glGetCombinerOutputParameterfvNV (GLenum, GLenum, GLenum, GLfloat *);
extern void glGetCombinerOutputParameterivNV (GLenum, GLenum, GLenum, GLint *);
extern void glGetFinalCombinerInputParameterfvNV (GLenum, GLenum, GLfloat *);
extern void glGetFinalCombinerInputParameterivNV (GLenum, GLenum, GLint *);
# 4276 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glCombinerStageParameterfvNV (GLenum, GLenum, const GLfloat *);
extern void glGetCombinerStageParameterfvNV (GLenum, GLenum, GLfloat *);
# 4420 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPointParameteriNV(GLenum pname, GLint param);
extern void glPointParameterivNV(GLenum pname, const GLint *params);
# 4860 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
}
# 66 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 2 3
# 2427 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 3
extern void glAccum (GLenum op, GLfloat value);
extern void glAlphaFunc (GLenum func, GLclampf ref);
extern GLboolean glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
extern void glArrayElement (GLint i);
extern void glBegin (GLenum mode);
extern void glBindTexture (GLenum target, GLuint texture);
extern void glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void glBlendColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glBlendEquation (GLenum mode);
extern void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
extern void glBlendFunc (GLenum sfactor, GLenum dfactor);
extern void glCallList (GLuint list);
extern void glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
extern void glClear (GLbitfield mask);
extern void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glClearDepth (GLclampd depth);
extern void glClearIndex (GLfloat c);
extern void glClearStencil (GLint s);
extern void glClipPlane (GLenum plane, const GLdouble *equation);
extern void glColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glColor3bv (const GLbyte *v);
extern void glColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glColor3dv (const GLdouble *v);
extern void glColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glColor3fv (const GLfloat *v);
extern void glColor3i (GLint red, GLint green, GLint blue);
extern void glColor3iv (const GLint *v);
extern void glColor3s (GLshort red, GLshort green, GLshort blue);
extern void glColor3sv (const GLshort *v);
extern void glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glColor3ubv (const GLubyte *v);
extern void glColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glColor3uiv (const GLuint *v);
extern void glColor3us (GLushort red, GLushort green, GLushort blue);
extern void glColor3usv (const GLushort *v);
extern void glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void glColor4bv (const GLbyte *v);
extern void glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void glColor4dv (const GLdouble *v);
extern void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glColor4fv (const GLfloat *v);
extern void glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
extern void glColor4iv (const GLint *v);
extern void glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void glColor4sv (const GLshort *v);
extern void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void glColor4ubv (const GLubyte *v);
extern void glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void glColor4uiv (const GLuint *v);
extern void glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void glColor4usv (const GLushort *v);
extern void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void glColorMaterial (GLenum face, GLenum mode);
extern void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glColorSubTable (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
extern void glColorTable (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
extern void glColorTableParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glColorTableParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glConvolutionFilter1D (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
extern void glConvolutionFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
extern void glConvolutionParameterf (GLenum target, GLenum pname, GLfloat params);
extern void glConvolutionParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glConvolutionParameteri (GLenum target, GLenum pname, GLint params);
extern void glConvolutionParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glCopyColorSubTable (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
extern void glCopyColorTable (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void glCopyConvolutionFilter1D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void glCopyConvolutionFilter2D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void glCopyTexImage1D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern void glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCullFace (GLenum mode);
extern void glDeleteLists (GLuint list, GLsizei range);
extern void glDeleteTextures (GLsizei n, const GLuint *textures);
extern void glDepthFunc (GLenum func);
extern void glDepthMask (GLboolean flag);
extern void glDepthRange (GLclampd zNear, GLclampd zFar);
extern void glDisable (GLenum cap);
extern void glDisableClientState (GLenum array);
extern void glDrawArrays (GLenum mode, GLint first, GLsizei count);
extern void glDrawBuffer (GLenum mode);
extern void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
extern void glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
extern void glEdgeFlag (GLboolean flag);
extern void glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
extern void glEdgeFlagv (const GLboolean *flag);
extern void glEnable (GLenum cap);
extern void glEnableClientState (GLenum array);
extern void glEnd (void);
extern void glEndList (void);
extern void glEvalCoord1d (GLdouble u);
extern void glEvalCoord1dv (const GLdouble *u);
extern void glEvalCoord1f (GLfloat u);
extern void glEvalCoord1fv (const GLfloat *u);
extern void glEvalCoord2d (GLdouble u, GLdouble v);
extern void glEvalCoord2dv (const GLdouble *u);
extern void glEvalCoord2f (GLfloat u, GLfloat v);
extern void glEvalCoord2fv (const GLfloat *u);
extern void glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
extern void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void glEvalPoint1 (GLint i);
extern void glEvalPoint2 (GLint i, GLint j);
extern void glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
extern void glFinish (void);
extern void glFlush (void);
extern void glFogf (GLenum pname, GLfloat param);
extern void glFogfv (GLenum pname, const GLfloat *params);
extern void glFogi (GLenum pname, GLint param);
extern void glFogiv (GLenum pname, const GLint *params);
extern void glFrontFace (GLenum mode);
extern void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern GLuint glGenLists (GLsizei range);
extern void glGenTextures (GLsizei n, GLuint *textures);
extern void glGetBooleanv (GLenum pname, GLboolean *params);
extern void glGetClipPlane (GLenum plane, GLdouble *equation);
extern void glGetColorTable (GLenum target, GLenum format, GLenum type, GLvoid *table);
extern void glGetColorTableParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetColorTableParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetConvolutionFilter (GLenum target, GLenum format, GLenum type, GLvoid *image);
extern void glGetConvolutionParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetConvolutionParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetDoublev (GLenum pname, GLdouble *params);
extern GLenum glGetError (void);
extern void glGetFloatv (GLenum pname, GLfloat *params);
extern void glGetHistogram (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void glGetHistogramParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetHistogramParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetIntegerv (GLenum pname, GLint *params);
extern void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
extern void glGetLightiv (GLenum light, GLenum pname, GLint *params);
extern void glGetMapdv (GLenum target, GLenum query, GLdouble *v);
extern void glGetMapfv (GLenum target, GLenum query, GLfloat *v);
extern void glGetMapiv (GLenum target, GLenum query, GLint *v);
extern void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
extern void glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
extern void glGetMinmax (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void glGetMinmaxParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetMinmaxParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetPixelMapfv (GLenum map, GLfloat *values);
extern void glGetPixelMapuiv (GLenum map, GLuint *values);
extern void glGetPixelMapusv (GLenum map, GLushort *values);
extern void glGetPointerv (GLenum pname, GLvoid* *params);
extern void glGetPolygonStipple (GLubyte *mask);
extern void glGetSeparableFilter (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
extern const GLubyte * glGetString (GLenum name);
extern void glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
extern void glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
extern void glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
extern void glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
extern void glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
extern void glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
extern void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glHint (GLenum target, GLenum mode);
extern void glHistogram (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
extern void glIndexMask (GLuint mask);
extern void glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glIndexd (GLdouble c);
extern void glIndexdv (const GLdouble *c);
extern void glIndexf (GLfloat c);
extern void glIndexfv (const GLfloat *c);
extern void glIndexi (GLint c);
extern void glIndexiv (const GLint *c);
extern void glIndexs (GLshort c);
extern void glIndexsv (const GLshort *c);
extern void glIndexub (GLubyte c);
extern void glIndexubv (const GLubyte *c);
extern void glInitNames (void);
extern void glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
extern GLboolean glIsEnabled (GLenum cap);
extern GLboolean glIsList (GLuint list);
extern GLboolean glIsTexture (GLuint texture);
extern void glLightModelf (GLenum pname, GLfloat param);
extern void glLightModelfv (GLenum pname, const GLfloat *params);
extern void glLightModeli (GLenum pname, GLint param);
extern void glLightModeliv (GLenum pname, const GLint *params);
extern void glLightf (GLenum light, GLenum pname, GLfloat param);
extern void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
extern void glLighti (GLenum light, GLenum pname, GLint param);
extern void glLightiv (GLenum light, GLenum pname, const GLint *params);
extern void glLineStipple (GLint factor, GLushort pattern);
extern void glLineWidth (GLfloat width);
extern void glListBase (GLuint base);
extern void glLoadIdentity (void);
extern void glLoadMatrixd (const GLdouble *m);
extern void glLoadMatrixf (const GLfloat *m);
extern void glLoadName (GLuint name);
extern void glLogicOp (GLenum opcode);
extern void glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
extern void glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
extern void glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void glMaterialf (GLenum face, GLenum pname, GLfloat param);
extern void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
extern void glMateriali (GLenum face, GLenum pname, GLint param);
extern void glMaterialiv (GLenum face, GLenum pname, const GLint *params);
extern void glMatrixMode (GLenum mode);
extern void glMinmax (GLenum target, GLenum internalformat, GLboolean sink);
extern void glMultMatrixd (const GLdouble *m);
extern void glMultMatrixf (const GLfloat *m);
extern void glNewList (GLuint list, GLenum mode);
extern void glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
extern void glNormal3bv (const GLbyte *v);
extern void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
extern void glNormal3dv (const GLdouble *v);
extern void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
extern void glNormal3fv (const GLfloat *v);
extern void glNormal3i (GLint nx, GLint ny, GLint nz);
extern void glNormal3iv (const GLint *v);
extern void glNormal3s (GLshort nx, GLshort ny, GLshort nz);
extern void glNormal3sv (const GLshort *v);
extern void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern void glPassThrough (GLfloat token);
extern void glPixelMapfv (GLenum map, GLint mapsize, const GLfloat *values);
extern void glPixelMapuiv (GLenum map, GLint mapsize, const GLuint *values);
extern void glPixelMapusv (GLenum map, GLint mapsize, const GLushort *values);
extern void glPixelStoref (GLenum pname, GLfloat param);
extern void glPixelStorei (GLenum pname, GLint param);
extern void glPixelTransferf (GLenum pname, GLfloat param);
extern void glPixelTransferi (GLenum pname, GLint param);
extern void glPixelZoom (GLfloat xfactor, GLfloat yfactor);
extern void glPointSize (GLfloat size);
extern void glPolygonMode (GLenum face, GLenum mode);
extern void glPolygonOffset (GLfloat factor, GLfloat units);
extern void glPolygonStipple (const GLubyte *mask);
extern void glPopAttrib (void);
extern void glPopClientAttrib (void);
extern void glPopMatrix (void);
extern void glPopName (void);
extern void glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void glPushAttrib (GLbitfield mask);
extern void glPushClientAttrib (GLbitfield mask);
extern void glPushMatrix (void);
extern void glPushName (GLuint name);
extern void glRasterPos2d (GLdouble x, GLdouble y);
extern void glRasterPos2dv (const GLdouble *v);
extern void glRasterPos2f (GLfloat x, GLfloat y);
extern void glRasterPos2fv (const GLfloat *v);
extern void glRasterPos2i (GLint x, GLint y);
extern void glRasterPos2iv (const GLint *v);
extern void glRasterPos2s (GLshort x, GLshort y);
extern void glRasterPos2sv (const GLshort *v);
extern void glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glRasterPos3dv (const GLdouble *v);
extern void glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glRasterPos3fv (const GLfloat *v);
extern void glRasterPos3i (GLint x, GLint y, GLint z);
extern void glRasterPos3iv (const GLint *v);
extern void glRasterPos3s (GLshort x, GLshort y, GLshort z);
extern void glRasterPos3sv (const GLshort *v);
extern void glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glRasterPos4dv (const GLdouble *v);
extern void glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glRasterPos4fv (const GLfloat *v);
extern void glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
extern void glRasterPos4iv (const GLint *v);
extern void glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glRasterPos4sv (const GLshort *v);
extern void glReadBuffer (GLenum mode);
extern void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern void glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void glRectdv (const GLdouble *v1, const GLdouble *v2);
extern void glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void glRectfv (const GLfloat *v1, const GLfloat *v2);
extern void glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
extern void glRectiv (const GLint *v1, const GLint *v2);
extern void glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void glRectsv (const GLshort *v1, const GLshort *v2);
extern GLint glRenderMode (GLenum mode);
extern void glResetHistogram (GLenum target);
extern void glResetMinmax (GLenum target);
extern void glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void glScaled (GLdouble x, GLdouble y, GLdouble z);
extern void glScalef (GLfloat x, GLfloat y, GLfloat z);
extern void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
extern void glSelectBuffer (GLsizei size, GLuint *buffer);
extern void glSeparableFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
extern void glShadeModel (GLenum mode);
extern void glStencilFunc (GLenum func, GLint ref, GLuint mask);
extern void glStencilMask (GLuint mask);
extern void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
extern void glTexCoord1d (GLdouble s);
extern void glTexCoord1dv (const GLdouble *v);
extern void glTexCoord1f (GLfloat s);
extern void glTexCoord1fv (const GLfloat *v);
extern void glTexCoord1i (GLint s);
extern void glTexCoord1iv (const GLint *v);
extern void glTexCoord1s (GLshort s);
extern void glTexCoord1sv (const GLshort *v);
extern void glTexCoord2d (GLdouble s, GLdouble t);
extern void glTexCoord2dv (const GLdouble *v);
extern void glTexCoord2f (GLfloat s, GLfloat t);
extern void glTexCoord2fv (const GLfloat *v);
extern void glTexCoord2i (GLint s, GLint t);
extern void glTexCoord2iv (const GLint *v);
extern void glTexCoord2s (GLshort s, GLshort t);
extern void glTexCoord2sv (const GLshort *v);
extern void glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
extern void glTexCoord3dv (const GLdouble *v);
extern void glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
extern void glTexCoord3fv (const GLfloat *v);
extern void glTexCoord3i (GLint s, GLint t, GLint r);
extern void glTexCoord3iv (const GLint *v);
extern void glTexCoord3s (GLshort s, GLshort t, GLshort r);
extern void glTexCoord3sv (const GLshort *v);
extern void glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glTexCoord4dv (const GLdouble *v);
extern void glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glTexCoord4fv (const GLfloat *v);
extern void glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
extern void glTexCoord4iv (const GLint *v);
extern void glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
extern void glTexCoord4sv (const GLshort *v);
extern void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
extern void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexEnvi (GLenum target, GLenum pname, GLint param);
extern void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
extern void glTexGend (GLenum coord, GLenum pname, GLdouble param);
extern void glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
extern void glTexGenf (GLenum coord, GLenum pname, GLfloat param);
extern void glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
extern void glTexGeni (GLenum coord, GLenum pname, GLint param);
extern void glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
extern void glTexImage1D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
extern void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexParameteri (GLenum target, GLenum pname, GLint param);
extern void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTranslated (GLdouble x, GLdouble y, GLdouble z);
extern void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex2d (GLdouble x, GLdouble y);
extern void glVertex2dv (const GLdouble *v);
extern void glVertex2f (GLfloat x, GLfloat y);
extern void glVertex2fv (const GLfloat *v);
extern void glVertex2i (GLint x, GLint y);
extern void glVertex2iv (const GLint *v);
extern void glVertex2s (GLshort x, GLshort y);
extern void glVertex2sv (const GLshort *v);
extern void glVertex3d (GLdouble x, GLdouble y, GLdouble z);
extern void glVertex3dv (const GLdouble *v);
extern void glVertex3f (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex3fv (const GLfloat *v);
extern void glVertex3i (GLint x, GLint y, GLint z);
extern void glVertex3iv (const GLint *v);
extern void glVertex3s (GLshort x, GLshort y, GLshort z);
extern void glVertex3sv (const GLshort *v);
extern void glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertex4dv (const GLdouble *v);
extern void glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertex4fv (const GLfloat *v);
extern void glVertex4i (GLint x, GLint y, GLint z, GLint w);
extern void glVertex4iv (const GLint *v);
extern void glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertex4sv (const GLshort *v);
extern void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);

extern void glSampleCoverage (GLclampf value, GLboolean invert);
extern void glSamplePass (GLenum pass);

extern void glLoadTransposeMatrixf (const GLfloat *m);
extern void glLoadTransposeMatrixd (const GLdouble *m);
extern void glMultTransposeMatrixf (const GLfloat *m);
extern void glMultTransposeMatrixd (const GLdouble *m);

extern void glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage1D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glGetCompressedTexImage (GLenum target, GLint lod, GLvoid *img);

extern void glActiveTexture (GLenum texture);
extern void glClientActiveTexture (GLenum texture);
extern void glMultiTexCoord1d (GLenum target, GLdouble s);
extern void glMultiTexCoord1dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord1f (GLenum target, GLfloat s);
extern void glMultiTexCoord1fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord1i (GLenum target, GLint s);
extern void glMultiTexCoord1iv (GLenum target, const GLint *v);
extern void glMultiTexCoord1s (GLenum target, GLshort s);
extern void glMultiTexCoord1sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord2d (GLenum target, GLdouble s, GLdouble t);
extern void glMultiTexCoord2dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord2f (GLenum target, GLfloat s, GLfloat t);
extern void glMultiTexCoord2fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord2i (GLenum target, GLint s, GLint t);
extern void glMultiTexCoord2iv (GLenum target, const GLint *v);
extern void glMultiTexCoord2s (GLenum target, GLshort s, GLshort t);
extern void glMultiTexCoord2sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord3d (GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern void glMultiTexCoord3dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord3f (GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern void glMultiTexCoord3fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord3i (GLenum target, GLint s, GLint t, GLint r);
extern void glMultiTexCoord3iv (GLenum target, const GLint *v);
extern void glMultiTexCoord3s (GLenum target, GLshort s, GLshort t, GLshort r);
extern void glMultiTexCoord3sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord4d (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glMultiTexCoord4dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glMultiTexCoord4fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord4i (GLenum target, GLint, GLint s, GLint t, GLint r);
extern void glMultiTexCoord4iv (GLenum target, const GLint *v);
extern void glMultiTexCoord4s (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern void glMultiTexCoord4sv (GLenum target, const GLshort *v);

extern void glFogCoordf (GLfloat coord);
extern void glFogCoordfv (const GLfloat *coord);
extern void glFogCoordd (GLdouble coord);
extern void glFogCoorddv (const GLdouble * coord);
extern void glFogCoordPointer (GLenum type, GLsizei stride, const GLvoid *pointer);

extern void glSecondaryColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glSecondaryColor3bv (const GLbyte *v);
extern void glSecondaryColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glSecondaryColor3dv (const GLdouble *v);
extern void glSecondaryColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glSecondaryColor3fv (const GLfloat *v);
extern void glSecondaryColor3i (GLint red, GLint green, GLint blue);
extern void glSecondaryColor3iv (const GLint *v);
extern void glSecondaryColor3s (GLshort red, GLshort green, GLshort blue);
extern void glSecondaryColor3sv (const GLshort *v);
extern void glSecondaryColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glSecondaryColor3ubv (const GLubyte *v);
extern void glSecondaryColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glSecondaryColor3uiv (const GLuint *v);
extern void glSecondaryColor3us (GLushort red, GLushort green, GLushort blue);
extern void glSecondaryColor3usv (const GLushort *v);
extern void glSecondaryColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

extern void glPointParameterf (GLenum pname, GLfloat param);
extern void glPointParameterfv (GLenum pname, const GLfloat *params);
extern void glPointParameteri (GLenum pname, GLint param);
extern void glPointParameteriv (GLenum pname, const GLint *params);

extern void glBlendFuncSeparate (GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

extern void glMultiDrawArrays (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawElements (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);

extern void glWindowPos2d (GLdouble x, GLdouble y);
extern void glWindowPos2dv (const GLdouble *v);
extern void glWindowPos2f (GLfloat x, GLfloat y);
extern void glWindowPos2fv (const GLfloat *v);
extern void glWindowPos2i (GLint x, GLint y);
extern void glWindowPos2iv (const GLint *v);
extern void glWindowPos2s (GLshort x, GLshort y);
extern void glWindowPos2sv (const GLshort *v);
extern void glWindowPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glWindowPos3dv (const GLdouble *v);
extern void glWindowPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glWindowPos3fv (const GLfloat *v);
extern void glWindowPos3i (GLint x, GLint y, GLint z);
extern void glWindowPos3iv (const GLint *v);
extern void glWindowPos3s (GLshort x, GLshort y, GLshort z);
extern void glWindowPos3sv (const GLshort *v);

extern void glGenQueries(GLsizei n, GLuint *ids);
extern void glDeleteQueries(GLsizei n, const GLuint *ids);
extern GLboolean glIsQuery(GLuint id);
extern void glBeginQuery(GLenum target, GLuint id);
extern void glEndQuery(GLenum target);
extern void glGetQueryiv(GLenum target, GLenum pname, GLint *params);
extern void glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params);
extern void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params);

extern void glBindBuffer (GLenum target, GLuint buffer);
extern void glDeleteBuffers (GLsizei n, const GLuint *buffers);
extern void glGenBuffers (GLsizei n, GLuint *buffers);
extern GLboolean glIsBuffer (GLuint buffer);
extern void glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
extern void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
extern void glGetBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
extern GLvoid * glMapBuffer (GLenum target, GLenum access);
extern GLboolean glUnmapBuffer (GLenum target);
extern void glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetBufferPointerv (GLenum target, GLenum pname, GLvoid **params);

extern void glDrawBuffers (GLsizei n, const GLenum *bufs);
extern void glVertexAttrib1d (GLuint index, GLdouble x);
extern void glVertexAttrib1dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib1f (GLuint index, GLfloat x);
extern void glVertexAttrib1fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib1s (GLuint index, GLshort x);
extern void glVertexAttrib1sv (GLuint index, const GLshort *v);
extern void glVertexAttrib2d (GLuint index, GLdouble x, GLdouble y);
extern void glVertexAttrib2dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib2f (GLuint index, GLfloat x, GLfloat y);
extern void glVertexAttrib2fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib2s (GLuint index, GLshort x, GLshort y);
extern void glVertexAttrib2sv (GLuint index, const GLshort *v);
extern void glVertexAttrib3d (GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void glVertexAttrib3dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib3f (GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void glVertexAttrib3fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib3s (GLuint index, GLshort x, GLshort y, GLshort z);
extern void glVertexAttrib3sv (GLuint index, const GLshort *v);
extern void glVertexAttrib4Nbv (GLuint index, const GLbyte *v);
extern void glVertexAttrib4Niv (GLuint index, const GLint *v);
extern void glVertexAttrib4Nsv (GLuint index, const GLshort *v);
extern void glVertexAttrib4Nub (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void glVertexAttrib4Nubv (GLuint index, const GLubyte *v);
extern void glVertexAttrib4Nuiv (GLuint index, const GLuint *v);
extern void glVertexAttrib4Nusv (GLuint index, const GLushort *v);
extern void glVertexAttrib4bv (GLuint index, const GLbyte *v);
extern void glVertexAttrib4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertexAttrib4dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib4f (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertexAttrib4fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib4iv (GLuint index, const GLint *v);
extern void glVertexAttrib4s (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertexAttrib4sv (GLuint index, const GLshort *v);
extern void glVertexAttrib4ubv (GLuint index, const GLubyte *v);
extern void glVertexAttrib4uiv (GLuint index, const GLuint *v);
extern void glVertexAttrib4usv (GLuint index, const GLushort *v);
extern void glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
extern void glEnableVertexAttribArray (GLuint index);
extern void glDisableVertexAttribArray (GLuint index);
extern void glGetVertexAttribdv (GLuint index, GLenum pname, GLdouble *params);
extern void glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat *params);
extern void glGetVertexAttribiv (GLuint index, GLenum pname, GLint *params);
extern void glGetVertexAttribPointerv (GLuint index, GLenum pname, GLvoid* *pointer);
extern void glDeleteShader (GLuint shader);
extern void glDetachShader (GLuint program, GLuint shader);
extern GLuint glCreateShader (GLenum type);
extern void glShaderSource (GLuint shader, GLsizei count, const GLchar* *string, const GLint *length);
extern void glCompileShader (GLuint shader);
extern GLuint glCreateProgram (void);
extern void glAttachShader (GLuint program, GLuint shader);
extern void glLinkProgram (GLuint program);
extern void glUseProgram (GLuint program);
extern void glDeleteProgram (GLuint program);
extern void glValidateProgram (GLuint program);
extern void glUniform1f (GLint location, GLfloat v0);
extern void glUniform2f (GLint location, GLfloat v0, GLfloat v1);
extern void glUniform3f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void glUniform4f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void glUniform1i (GLint location, GLint v0);
extern void glUniform2i (GLint location, GLint v0, GLint v1);
extern void glUniform3i (GLint location, GLint v0, GLint v1, GLint v2);
extern void glUniform4i (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void glUniform1fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform2fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform3fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform4fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform1iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform2iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform3iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform4iv (GLint location, GLsizei count, const GLint *value);
extern void glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern GLboolean glIsShader (GLuint shader);
extern GLboolean glIsProgram (GLuint program);
extern void glGetShaderiv (GLuint shader, GLenum pname, GLint *params);
extern void glGetProgramiv (GLuint program, GLenum pname, GLint *params);
extern void glGetAttachedShaders (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
extern void glGetShaderInfoLog (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern void glGetProgramInfoLog (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern GLint glGetUniformLocation (GLuint program, const GLchar *name);
extern void glGetActiveUniform (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern void glGetUniformfv (GLuint program, GLint location, GLfloat *params);
extern void glGetUniformiv (GLuint program, GLint location, GLint *params);
extern void glGetShaderSource (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
extern void glBindAttribLocation (GLuint program, GLuint index, const GLchar *name);
extern void glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern GLint glGetAttribLocation (GLuint program, const GLchar *name);
extern void glStencilFuncSeparate (GLenum face, GLenum func, GLint ref, GLuint mask);
extern void glStencilOpSeparate (GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
extern void glStencilMaskSeparate (GLenum face, GLuint mask);

extern void glUniformMatrix2x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix2x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);





}
# 15 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StimulusDisplay.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 1 3
# 11 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
extern "C" {
# 218 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
class GLUnurbs;
class GLUquadric;
class GLUtesselator;

typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;
# 239 "/Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
extern void gluBeginCurve (GLUnurbs* nurb);
extern void gluBeginPolygon (GLUtesselator* tess);
extern void gluBeginSurface (GLUnurbs* nurb);
extern void gluBeginTrim (GLUnurbs* nurb);
extern GLint gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
extern GLint gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
extern GLint gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
extern GLboolean gluCheckExtension (const GLubyte *extName, const GLubyte *extString);
extern void gluCylinder (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks);
extern void gluDeleteNurbsRenderer (GLUnurbs* nurb);
extern void gluDeleteQuadric (GLUquadric* quad);
extern void gluDeleteTess (GLUtesselator* tess);
extern void gluDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops);
extern void gluEndCurve (GLUnurbs* nurb);
extern void gluEndPolygon (GLUtesselator* tess);
extern void gluEndSurface (GLUnurbs* nurb);
extern void gluEndTrim (GLUnurbs* nurb);
extern const GLubyte * gluErrorString (GLenum error);
extern void gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data);
extern const GLubyte * gluGetString (GLenum name);
extern void gluGetTessProperty (GLUtesselator* tess, GLenum which, GLdouble* data);
extern void gluLoadSamplingMatrices (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view);
extern void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ);
extern GLUnurbs* gluNewNurbsRenderer (void);
extern GLUquadric* gluNewQuadric (void);
extern GLUtesselator* gluNewTess (void);
extern void gluNextContour (GLUtesselator* tess, GLenum type);
extern void gluNurbsCallback (GLUnurbs* nurb, GLenum which, GLvoid (*CallBackFunc)());
extern void gluNurbsCallbackData (GLUnurbs* nurb, GLvoid* userData);
extern void gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
extern void gluNurbsCurve (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type);
extern void gluNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat value);
extern void gluNurbsSurface (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type);
extern void gluOrtho2D (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top);
extern void gluPartialDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep);
extern void gluPerspective (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);
extern void gluPickMatrix (GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport);
extern GLint gluProject (GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* winX, GLdouble* winY, GLdouble* winZ);
extern void gluPwlCurve (GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type);
extern void gluQuadricCallback (GLUquadric* quad, GLenum which, GLvoid (*CallBackFunc)());
extern void gluQuadricDrawStyle (GLUquadric* quad, GLenum draw);
extern void gluQuadricNormals (GLUquadric* quad, GLenum normal);
extern void gluQuadricOrientation (GLUquadric* quad, GLenum orientation);
extern void gluQuadricTexture (GLUquadric* quad, GLboolean texture);
extern GLint gluScaleImage (GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut);
extern void gluSphere (GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks);
extern void gluTessBeginContour (GLUtesselator* tess);
extern void gluTessBeginPolygon (GLUtesselator* tess, GLvoid* data);
extern void gluTessCallback (GLUtesselator* tess, GLenum which, GLvoid (*CallBackFunc)());
extern void gluTessEndContour (GLUtesselator* tess);
extern void gluTessEndPolygon (GLUtesselator* tess);
extern void gluTessNormal (GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ);
extern void gluTessProperty (GLUtesselator* tess, GLenum which, GLdouble data);
extern void gluTessVertex (GLUtesselator* tess, GLdouble *location, GLvoid* data);
extern GLint gluUnProject (GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* objX, GLdouble* objY, GLdouble* objZ);
extern GLint gluUnProject4 (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearPlane, GLdouble farPlane, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW);


}
# 16 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StimulusDisplay.h" 2 3
# 26 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StimulusDisplay.h" 3
namespace mw {
 using namespace boost;





 class Stimulus;
 class StimulusNode;
 class StimulusDisplay;
# 81 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StimulusDisplay.h" 3
 class StimulusDisplayChain : public LinkedList<StimulusNode> {
    protected:

  StimulusDisplay *stimulus_display;

    public:
  StimulusDisplayChain(StimulusDisplay *display);
        virtual ~StimulusDisplayChain();

        void execute();
  void announce(MonkeyWorksTime time);
  Data getAnnounceData();

    private:
        StimulusDisplayChain(const StimulusDisplayChain& s) { }
        void operator=(const StimulusDisplayChain& l) { }
 };



 class StimulusDisplay : public enable_shared_from_this<StimulusDisplay> {
    protected:
        std::vector<int> context_ids;
  shared_ptr<StimulusDisplayChain> stimulus_chain;

  GLuint current_context;
  int current_context_index;

  boost::mutex display_lock;

  double left, right, top, bottom;

  bool update_stim_chain_next_refresh;

        void glInit();

    public:

  StimulusDisplay();
  ~StimulusDisplay();

  void addContext(int _context_id);


  int getNContexts();
  void setCurrent(int i);
  GLuint getCurrentContext();
  int getCurrentContextIndex();

        shared_ptr<StimulusNode> addStimulus(shared_ptr<Stimulus> stim);
  void addStimulusNode(shared_ptr<StimulusNode> stimnode);

  void asynchronousUpdateDisplay();
  void updateDisplay();
  void clearDisplay();
  void setDisplayBounds();

 private:
        StimulusDisplay(const StimulusDisplay& s) { }
        void operator=(const StimulusDisplay& l) { }
 };
}
# 41 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Stimulus.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StimulusNode.h" 1 3
# 15 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StimulusNode.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Stimulus.h" 1 3
# 16 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StimulusNode.h" 2 3


namespace mw {
class StimulusGroup;

class StimulusNode : public Lockable, public LinkedListNode<StimulusNode>, public mw::Component {
    protected:




 shared_ptr<Stimulus> stim;




 shared_ptr<Stimulus> frozen_stim;





        bool visible;
        bool visible_on_last_update;





  bool frozen;

    public:

  StimulusNode();
  StimulusNode(shared_ptr<Stimulus> _stim);

  virtual ~StimulusNode(){}



  virtual shared_ptr<Stimulus> getStimulus();

  virtual void addToDisplay(shared_ptr<StimulusNode> stimnode, shared_ptr<StimulusDisplay> display);


  virtual void setVisible(bool _vis);
        virtual bool isVisible();


  virtual void setFrozen(bool _frozen);
  virtual bool isFrozen();

  virtual void draw(StimulusDisplay* display);

  virtual void announceStimulusDraw(MonkeyWorksTime time);
  virtual Data getCurrentAnnounceDrawData();

    virtual void load(shared_ptr<StimulusDisplay> display);

    virtual bool isLoaded();

    private:

        StimulusNode(const StimulusNode&) { }
        void operator=(const StimulusNode& lval) { }
 };
# 90 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StimulusNode.h" 3
class StimulusNodeGroup : public ExpandableList<StimulusNode>, public mw::Component {

 public:

 StimulusNodeGroup(shared_ptr<StimulusGroup> _group);
};

class StimulusGroupReferenceNode : public StimulusNode {
    protected:
 shared_ptr<Variable> index;
 shared_ptr<StimulusNodeGroup> stimulus_nodes;

  int getIndexValue();

    public:

  StimulusGroupReferenceNode(shared_ptr<StimulusNodeGroup> _group,
          shared_ptr<Variable> _index);
  virtual ~StimulusGroupReferenceNode(){}

  virtual void addToDisplay(shared_ptr<StimulusNode> stimnode, shared_ptr<StimulusDisplay> display);


  virtual void setVisible(bool _vis);
        virtual bool isVisible();


  virtual void setFrozen(bool _frozen);
  virtual bool isFrozen();

        virtual void draw(StimulusDisplay * display);
        virtual void announceStimulusDraw(MonkeyWorksTime time);
  virtual Data getCurrentAnnounceDrawData();


    virtual void load(shared_ptr<StimulusDisplay> display);

    virtual bool isLoaded();


  virtual void remove();
  virtual void bringToFront();
  virtual void sendToBack();
  virtual void bringForward();
  virtual void sendBackward();

};
 }
# 42 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Stimulus.h" 2 3
# 59 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Stimulus.h" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilut.h" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilut.h" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/IL/il.h" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/IL/il.h" 3
extern "C" {
# 58 "/Library/Application Support/MonkeyWorks/Developer/include/IL/il.h" 3
typedef unsigned int ILenum;
typedef unsigned char ILboolean;
typedef unsigned int ILbitfield;
typedef char ILbyte;
typedef short ILshort;
typedef int ILint;
typedef int ILsizei;
typedef unsigned char ILubyte;
typedef unsigned short ILushort;
typedef unsigned int ILuint;
typedef float ILfloat;
typedef float ILclampf;
typedef double ILdouble;
typedef double ILclampd;
typedef void ILvoid;
# 413 "/Library/Application Support/MonkeyWorks/Developer/include/IL/il.h" 3
typedef void* ILHANDLE;
typedef ILvoid ( *fCloseRProc)(ILHANDLE);
typedef ILboolean ( *fEofProc) (ILHANDLE);
typedef ILint ( *fGetcProc) (ILHANDLE);
typedef ILHANDLE ( *fOpenRProc) (const char*);
typedef ILint ( *fReadProc) (void*, ILuint, ILuint, ILHANDLE);
typedef ILint ( *fSeekRProc) (ILHANDLE, ILint, ILint);
typedef ILint ( *fTellRProc) (ILHANDLE);


typedef ILvoid ( *fCloseWProc)(ILHANDLE);
typedef ILHANDLE ( *fOpenWProc) (const char*);
typedef ILint ( *fPutcProc) (ILubyte, ILHANDLE);
typedef ILint ( *fSeekWProc) (ILHANDLE, ILint, ILint);
typedef ILint ( *fTellWProc) (ILHANDLE);
typedef ILint ( *fWriteProc) (const void*, ILuint, ILuint, ILHANDLE);


typedef ILvoid* ( *mAlloc)(ILuint);
typedef ILvoid ( *mFree) (ILvoid*);


typedef ILenum ( *IL_LOADPROC)(const char*);
typedef ILenum ( *IL_SAVEPROC)(const char*);



extern ILboolean ilActiveImage(ILuint Number);
extern ILboolean ilActiveLayer(ILuint Number);
extern ILboolean ilActiveMipmap(ILuint Number);
extern ILboolean ilApplyPal(const char* FileName);
extern ILboolean ilApplyProfile(char* InProfile, char* OutProfile);
extern ILvoid ilBindImage(ILuint Image);
extern ILboolean ilBlit(ILuint Source, ILint DestX, ILint DestY, ILint DestZ, ILuint SrcX, ILuint SrcY, ILuint SrcZ, ILuint Width, ILuint Height, ILuint Depth);
extern ILvoid ilClearColour(ILclampf Red, ILclampf Green, ILclampf Blue, ILclampf Alpha);
extern ILboolean ilClearImage(ILvoid);
extern ILuint ilCloneCurImage(ILvoid);
extern ILboolean ilCompressFunc(ILenum Mode);
extern ILboolean ilConvertImage(ILenum DestFormat, ILenum DestType);
extern ILboolean ilConvertPal(ILenum DestFormat);
extern ILboolean ilCopyImage(ILuint Src);
extern ILuint ilCopyPixels(ILuint XOff, ILuint YOff, ILuint ZOff, ILuint Width, ILuint Height, ILuint Depth, ILenum Format, ILenum Type, ILvoid *Data);
extern ILuint ilCreateSubImage(ILenum Type, ILuint Num);
extern ILboolean ilDefaultImage(ILvoid);
extern ILvoid ilDeleteImage(const ILuint Num);
extern ILvoid ilDeleteImages(ILsizei Num, const ILuint *Images);
extern ILboolean ilDisable(ILenum Mode);
extern ILboolean ilEnable(ILenum Mode);
extern ILboolean ilFormatFunc(ILenum Mode);
extern ILvoid ilGenImages(ILsizei Num, ILuint *Images);
extern ILint ilGenImage();
extern ILubyte* ilGetAlpha(ILenum Type);
extern ILboolean ilGetBoolean(ILenum Mode);
extern ILvoid ilGetBooleanv(ILenum Mode, ILboolean *Param);
extern ILubyte* ilGetData(ILvoid);
extern ILuint ilGetDXTCData(ILvoid *Buffer, ILuint BufferSize, ILenum DXTCFormat);
extern ILenum ilGetError(ILvoid);
extern ILint ilGetInteger(ILenum Mode);
extern ILvoid ilGetIntegerv(ILenum Mode, ILint *Param);
extern ILuint ilGetLumpPos(ILvoid);
extern ILubyte* ilGetPalette(ILvoid);
extern char* ilGetString(ILenum StringName);
extern ILvoid ilHint(ILenum Target, ILenum Mode);
extern ILvoid ilInit(ILvoid);
extern ILboolean ilIsDisabled(ILenum Mode);
extern ILboolean ilIsEnabled(ILenum Mode);
extern ILboolean ilIsImage(ILuint Image);
extern ILboolean ilIsValid(ILenum Type, char* FileName);
extern ILboolean ilIsValidF(ILenum Type, ILHANDLE File);
extern ILboolean ilIsValidL(ILenum Type, ILvoid *Lump, ILuint Size);
extern ILvoid ilKeyColour(ILclampf Red, ILclampf Green, ILclampf Blue, ILclampf Alpha);
extern ILboolean ilLoad(ILenum Type, const char* FileName);
extern ILboolean ilLoadF(ILenum Type, ILHANDLE File);
extern ILboolean ilLoadImage(const char* FileName);
extern ILboolean ilLoadL(ILenum Type, const ILvoid *Lump, ILuint Size);
extern ILboolean ilLoadPal(const char* FileName);
extern ILvoid ilModAlpha( ILdouble AlphaValue );
extern ILboolean ilOriginFunc(ILenum Mode);
extern ILboolean ilOverlayImage(ILuint Source, ILint XCoord, ILint YCoord, ILint ZCoord);
extern ILvoid ilPopAttrib(ILvoid);
extern ILvoid ilPushAttrib(ILuint Bits);
extern ILvoid ilRegisterFormat(ILenum Format);
extern ILboolean ilRegisterLoad(const char* Ext, IL_LOADPROC Load);
extern ILboolean ilRegisterMipNum(ILuint Num);
extern ILboolean ilRegisterNumImages(ILuint Num);
extern ILvoid ilRegisterOrigin(ILenum Origin);
extern ILvoid ilRegisterPal(ILvoid *Pal, ILuint Size, ILenum Type);
extern ILboolean ilRegisterSave(const char* Ext, IL_SAVEPROC Save);
extern ILvoid ilRegisterType(ILenum Type);
extern ILboolean ilRemoveLoad(const char* Ext);
extern ILboolean ilRemoveSave(const char* Ext);
extern ILvoid ilResetMemory(ILvoid);
extern ILvoid ilResetRead(ILvoid);
extern ILvoid ilResetWrite(ILvoid);
extern ILboolean ilSave(ILenum Type, char* FileName);
extern ILuint ilSaveF(ILenum Type, ILHANDLE File);
extern ILboolean ilSaveImage(const char* FileName);
extern ILuint ilSaveL(ILenum Type, ILvoid *Lump, ILuint Size);
extern ILboolean ilSavePal(const char* FileName);
extern ILvoid ilSetAlpha( ILdouble AlphaValue );
extern ILboolean ilSetData(ILvoid *Data);
extern ILboolean ilSetDuration(ILuint Duration);
extern ILvoid ilSetInteger(ILenum Mode, ILint Param);
extern ILvoid ilSetMemory(mAlloc, mFree);
extern ILvoid ilSetPixels(ILint XOff, ILint YOff, ILint ZOff, ILuint Width, ILuint Height, ILuint Depth, ILenum Format, ILenum Type, ILvoid *Data);
extern ILvoid ilSetRead(fOpenRProc, fCloseRProc, fEofProc, fGetcProc, fReadProc, fSeekRProc, fTellRProc);
extern ILvoid ilSetString(ILenum Mode, const char *String);
extern ILvoid ilSetWrite(fOpenWProc, fCloseWProc, fPutcProc, fSeekWProc, fTellWProc, fWriteProc);
extern ILvoid ilShutDown(ILvoid);
extern ILboolean ilTexImage(ILuint Width, ILuint Height, ILuint Depth, ILubyte numChannels, ILenum Format, ILenum Type, ILvoid *Data);
extern ILenum ilTypeFromExt(const char* FileName);
extern ILboolean ilTypeFunc(ILenum Mode);
extern ILboolean ilLoadData(const char* FileName, ILuint Width, ILuint Height, ILuint Depth, ILubyte Bpp);
extern ILboolean ilLoadDataF(ILHANDLE File, ILuint Width, ILuint Height, ILuint Depth, ILubyte Bpp);
extern ILboolean ilLoadDataL(ILvoid *Lump, ILuint Size, ILuint Width, ILuint Height, ILuint Depth, ILubyte Bpp);
extern ILboolean ilSaveData(const char* FileName);

extern ILboolean ilLoadFromJpegStruct(ILvoid* JpegDecompressorPtr);
extern ILboolean ilSaveFromJpegStruct(ILvoid* JpegCompressorPtr);







}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilut.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilu.h" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilu.h" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/IL/il.h" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilu.h" 2 3


extern "C" {
# 91 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilu.h" 3
typedef struct ILinfo
{
 ILuint Id;
 ILubyte *Data;
 ILuint Width;
 ILuint Height;
 ILuint Depth;
 ILubyte Bpp;
 ILuint SizeOfData;
 ILenum Format;
 ILenum Type;
 ILenum Origin;
 ILubyte *Palette;
 ILenum PalType;
 ILuint PalSize;
 ILenum CubeFlags;
 ILuint NumNext;
 ILuint NumMips;
 ILuint NumLayers;
} ILinfo;


typedef struct ILpointf
{
 ILfloat x, y;
} ILpointf;

typedef struct ILpointi
{
 ILint x, y;
} ILpointi;



extern ILboolean iluAlienify(ILvoid);
extern ILboolean iluBlurAvg(ILuint Iter);
extern ILboolean iluBlurGaussian(ILuint Iter);
extern ILboolean iluBuildMipmaps(ILvoid);
extern ILuint iluColoursUsed(ILvoid);
extern ILboolean iluCompareImage(ILuint Comp);
extern ILboolean iluContrast(ILfloat Contrast);
extern ILboolean iluCrop(ILuint XOff, ILuint YOff, ILuint ZOff, ILuint Width, ILuint Height, ILuint Depth);
extern ILvoid iluDeleteImage(ILuint Id);
extern ILboolean iluEdgeDetectE(ILvoid);
extern ILboolean iluEdgeDetectP(ILvoid);
extern ILboolean iluEdgeDetectS(ILvoid);
extern ILboolean iluEmboss(ILvoid);
extern ILboolean iluEnlargeCanvas(ILuint Width, ILuint Height, ILuint Depth);
extern ILboolean iluEnlargeImage(ILfloat XDim, ILfloat YDim, ILfloat ZDim);
extern ILboolean iluEqualize(ILvoid);
extern char* iluErrorString(ILenum Error);
extern ILboolean iluConvolution(ILint *matrix, ILint scale, ILint bias);
extern ILboolean iluFlipImage(ILvoid);
extern ILboolean iluGammaCorrect(ILfloat Gamma);
extern ILuint iluGenImage(ILvoid);
extern ILvoid iluGetImageInfo(ILinfo *Info);
extern ILint iluGetInteger(ILenum Mode);
extern ILvoid iluGetIntegerv(ILenum Mode, ILint *Param);
extern char* iluGetString(ILenum StringName);
extern ILvoid iluImageParameter(ILenum PName, ILenum Param);
extern ILvoid iluInit(ILvoid);
extern ILboolean iluInvertAlpha(ILvoid);
extern ILuint iluLoadImage(const char* FileName);
extern ILboolean iluMirror(ILvoid);
extern ILboolean iluNegative(ILvoid);
extern ILboolean iluNoisify(ILclampf Tolerance);
extern ILboolean iluPixelize(ILuint PixSize);
extern ILvoid iluRegionfv(ILpointf *Points, ILuint n);
extern ILvoid iluRegioniv(ILpointi *Points, ILuint n);
extern ILboolean iluReplaceColour(ILubyte Red, ILubyte Green, ILubyte Blue, ILfloat Tolerance);
extern ILboolean iluRotate(ILfloat Angle);
extern ILboolean iluRotate3D(ILfloat x, ILfloat y, ILfloat z, ILfloat Angle);
extern ILboolean iluSaturate1f(ILfloat Saturation);
extern ILboolean iluSaturate4f(ILfloat r, ILfloat g, ILfloat b, ILfloat Saturation);
extern ILboolean iluScale(ILuint Width, ILuint Height, ILuint Depth);
extern ILboolean iluScaleAlpha(ILfloat scale);
extern ILboolean iluScaleColours(ILfloat r, ILfloat g, ILfloat b);
extern ILboolean iluSharpen(ILfloat Factor, ILuint Iter);
extern ILboolean iluSwapColours(ILvoid);
extern ILboolean iluWave(ILfloat Angle);







}
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilut.h" 2 3
# 131 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilut.h" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/IL/config.h" 1 3
# 132 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilut.h" 2 3
# 190 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilut.h" 3
extern "C" {



extern ILboolean ilutDisable(ILenum Mode);
extern ILboolean ilutEnable(ILenum Mode);
extern ILboolean ilutGetBoolean(ILenum Mode);
extern ILvoid ilutGetBooleanv(ILenum Mode, ILboolean *Param);
extern ILint ilutGetInteger(ILenum Mode);
extern ILvoid ilutGetIntegerv(ILenum Mode, ILint *Param);
extern char* ilutGetString(ILenum StringName);
extern ILvoid ilutInit(ILvoid);
extern ILboolean ilutIsDisabled(ILenum Mode);
extern ILboolean ilutIsEnabled(ILenum Mode);
extern ILvoid ilutPopAttrib(ILvoid);
extern ILvoid ilutPushAttrib(ILuint Bits);
extern ILvoid ilutSetInteger(ILenum Mode, ILint Param);

extern ILboolean ilutRenderer(ILenum Renderer);




 extern GLuint ilutGLBindTexImage();
 extern GLuint ilutGLBindMipmaps(ILvoid);
 extern ILboolean ilutGLBuildMipmaps(ILvoid);
 extern GLuint ilutGLLoadImage(char* FileName);
 extern ILboolean ilutGLScreen(ILvoid);
 extern ILboolean ilutGLScreenie(ILvoid);
 extern ILboolean ilutGLSaveImage(char* FileName, GLuint TexID);
 extern ILboolean ilutGLSetTex(GLuint TexID);
 extern ILboolean ilutGLTexImage(GLuint Level);
 extern ILboolean ilutGLSubTex(GLuint TexID, ILuint XOff, ILuint YOff);
# 317 "/Library/Application Support/MonkeyWorks/Developer/include/IL/ilut.h" 3
}
# 60 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Stimulus.h" 2 3
namespace mw {
typedef int StimID;
# 70 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Stimulus.h" 3
class StimulusDisplay;


class Stimulus : public Announcable, public mw::Component {
    private:



 protected:
        bool loaded, visible, cached, has_thumbnail;
        Stimulus *thumbnail;



  bool frozen;



    public:



        Stimulus(std::string _tag);




        Stimulus(const Stimulus& copy);
# 106 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Stimulus.h" 3
   virtual Stimulus *frozenClone();




        virtual ~Stimulus();





        virtual void load(StimulusDisplay *display);




        virtual void setVisible(bool newvis);






        virtual void drawInUnitSquare(StimulusDisplay *display);





        virtual void draw(StimulusDisplay *display);





        virtual void draw(StimulusDisplay *display, float x, float y);





        virtual void draw(StimulusDisplay *display, float x, float y,
                                                    float sizex, float sizey);





        virtual void precache();





        virtual void drawThumbnail(StimulusDisplay *display,
              float x, float y);





        virtual void drawThumbnail(StimulusDisplay *display,
                                                float x, float y,
            float sizex, float sizey);




        virtual int* getBounds();




        bool isLoaded();
        bool isVisible();
        bool isCached();
        bool hasThumbnail();
        Stimulus * getThumbnail();
        std::string gettag();





        virtual void announceStimulusDraw(MonkeyWorksTime now);



        virtual Data getCurrentAnnounceDrawData();


  void setIsFrozen(bool _isit){ frozen = _isit; }

};






class StimulusGroup : public ExpandableList<Stimulus>, public mw::Component, public ComponentFactory {
private:
 std::vector <shared_ptr<StimulusGroup> > sub_groups;

 weak_ptr<StimulusGroup> parent;

 void addSubGroup(const shared_ptr <StimulusGroup> stim_group);
 void addStimToParents(const shared_ptr <Stimulus> stim);

public:
 StimulusGroup();
 StimulusGroup(const std::string &_tag);
 virtual ~StimulusGroup();

 unsigned int dimensionSize(const unsigned int dimension);
 unsigned int getNDimensions() const;

 shared_ptr<StimulusGroup> getSubGroup(const unsigned int sub_group_index) const;
 shared_ptr<StimulusGroup> getParent() const;

 void setParent(weak_ptr <StimulusGroup> _parent);

 virtual shared_ptr<mw::Component> createObject(std::map<std::string, std::string> parameters,
            ComponentRegistry *reg);

 virtual void addChild(std::map<std::string, std::string> parameters,
        ComponentRegistry *reg,
        shared_ptr<mw::Component> child);

};
}
# 37 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentRegistry.h" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std_containers_traits.hpp" 1 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std_containers_traits.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std/string_traits.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std/string_traits.hpp" 3
namespace boost {
    namespace algorithm {
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std/string_traits.hpp" 3
        template<typename T, typename TraitsT, typename AllocT>
        class has_native_replace< std::basic_string<T, TraitsT, AllocT> >
        {
        public:



            static const bool value=true;


        typedef mpl::bool_<has_native_replace<T>::value> type;
        };




    }
}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std_containers_traits.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std/list_traits.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std/list_traits.hpp" 3
namespace boost {
    namespace algorithm {
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std/list_traits.hpp" 3
        template<typename T, typename AllocT>
        class has_stable_iterators< ::std::list<T,AllocT> >
        {
        public:



            static const bool value=true;

            typedef mpl::bool_<has_stable_iterators<T>::value> type;
        };


        template<typename T, typename AllocT>
        class has_const_time_insert< ::std::list<T,AllocT> >
        {
        public:



            static const bool value=true;

            typedef mpl::bool_<has_const_time_insert<T>::value> type;
        };


        template<typename T, typename AllocT>
        class has_const_time_erase< ::std::list<T,AllocT> >
        {
        public:



            static const bool value=true;

            typedef mpl::bool_<has_const_time_erase<T>::value> type;
        };



    }
}
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std_containers_traits.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std/slist_traits.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std/slist_traits.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ext/slist" 1 3
# 58 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ext/slist" 3
namespace __gnu_cxx
{
  using std::size_t;
  using std::ptrdiff_t;
  using std::_Construct;
  using std::_Destroy;
  using std::allocator;

  struct _Slist_node_base
  {
    _Slist_node_base* _M_next;
  };

  inline _Slist_node_base*
  __slist_make_link(_Slist_node_base* __prev_node,
      _Slist_node_base* __new_node)
  {
    __new_node->_M_next = __prev_node->_M_next;
    __prev_node->_M_next = __new_node;
    return __new_node;
  }

  inline _Slist_node_base*
  __slist_previous(_Slist_node_base* __head,
     const _Slist_node_base* __node)
  {
    while (__head && __head->_M_next != __node)
      __head = __head->_M_next;
    return __head;
  }

  inline const _Slist_node_base*
  __slist_previous(const _Slist_node_base* __head,
     const _Slist_node_base* __node)
  {
    while (__head && __head->_M_next != __node)
      __head = __head->_M_next;
    return __head;
  }

  inline void
  __slist_splice_after(_Slist_node_base* __pos,
         _Slist_node_base* __before_first,
         _Slist_node_base* __before_last)
  {
    if (__pos != __before_first && __pos != __before_last)
      {
 _Slist_node_base* __first = __before_first->_M_next;
 _Slist_node_base* __after = __pos->_M_next;
 __before_first->_M_next = __before_last->_M_next;
 __pos->_M_next = __first;
 __before_last->_M_next = __after;
      }
  }

  inline void
  __slist_splice_after(_Slist_node_base* __pos, _Slist_node_base* __head)
  {
    _Slist_node_base* __before_last = __slist_previous(__head, 0);
    if (__before_last != __head)
      {
 _Slist_node_base* __after = __pos->_M_next;
 __pos->_M_next = __head->_M_next;
 __head->_M_next = 0;
 __before_last->_M_next = __after;
      }
  }

  inline _Slist_node_base*
  __slist_reverse(_Slist_node_base* __node)
  {
    _Slist_node_base* __result = __node;
    __node = __node->_M_next;
    __result->_M_next = 0;
    while(__node)
      {
 _Slist_node_base* __next = __node->_M_next;
 __node->_M_next = __result;
 __result = __node;
 __node = __next;
      }
    return __result;
  }

  inline size_t
  __slist_size(_Slist_node_base* __node)
  {
    size_t __result = 0;
    for (; __node != 0; __node = __node->_M_next)
      ++__result;
    return __result;
  }

  template <class _Tp>
    struct _Slist_node : public _Slist_node_base
    {
      _Tp _M_data;
    };

  struct _Slist_iterator_base
  {
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef std::forward_iterator_tag iterator_category;

    _Slist_node_base* _M_node;

    _Slist_iterator_base(_Slist_node_base* __x)
    : _M_node(__x) {}

    void
    _M_incr()
    { _M_node = _M_node->_M_next; }

    bool
    operator==(const _Slist_iterator_base& __x) const
    { return _M_node == __x._M_node; }

    bool
    operator!=(const _Slist_iterator_base& __x) const
    { return _M_node != __x._M_node; }
  };

  template <class _Tp, class _Ref, class _Ptr>
    struct _Slist_iterator : public _Slist_iterator_base
    {
      typedef _Slist_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Slist_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
      typedef _Slist_iterator<_Tp, _Ref, _Ptr> _Self;

      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef _Slist_node<_Tp> _Node;

      _Slist_iterator(_Node* __x)
      : _Slist_iterator_base(__x) {}

      _Slist_iterator()
      : _Slist_iterator_base(0) {}

      _Slist_iterator(const iterator& __x)
      : _Slist_iterator_base(__x._M_node) {}

      reference
      operator*() const
      { return ((_Node*) _M_node)->_M_data; }

      pointer
      operator->() const
      { return &(operator*()); }

      _Self&
      operator++()
      {
 _M_incr();
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_incr();
 return __tmp;
      }
    };

  template <class _Tp, class _Alloc>
    struct _Slist_base
    : public _Alloc::template rebind<_Slist_node<_Tp> >::other
    {
      typedef typename _Alloc::template rebind<_Slist_node<_Tp> >::other
        _Node_alloc;
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return *static_cast<const _Node_alloc*>(this); }

      _Slist_base(const allocator_type& __a)
      : _Node_alloc(__a)
      { this->_M_head._M_next = 0; }

      ~_Slist_base()
      { _M_erase_after(&this->_M_head, 0); }

    protected:
      _Slist_node_base _M_head;

      _Slist_node<_Tp>*
      _M_get_node()
      { return _Node_alloc::allocate(1); }

      void
      _M_put_node(_Slist_node<_Tp>* __p)
      { _Node_alloc::deallocate(__p, 1); }

    protected:
      _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)
      {
 _Slist_node<_Tp>* __next = (_Slist_node<_Tp>*) (__pos->_M_next);
 _Slist_node_base* __next_next = __next->_M_next;
 __pos->_M_next = __next_next;
 get_allocator().destroy(&__next->_M_data);
 _M_put_node(__next);
 return __next_next;
      }
      _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);
    };

  template <class _Tp, class _Alloc>
    _Slist_node_base*
    _Slist_base<_Tp,_Alloc>::_M_erase_after(_Slist_node_base* __before_first,
         _Slist_node_base* __last_node)
    {
      _Slist_node<_Tp>* __cur = (_Slist_node<_Tp>*) (__before_first->_M_next);
      while (__cur != __last_node)
 {
   _Slist_node<_Tp>* __tmp = __cur;
   __cur = (_Slist_node<_Tp>*) __cur->_M_next;
   get_allocator().destroy(&__tmp->_M_data);
   _M_put_node(__tmp);
 }
      __before_first->_M_next = __last_node;
      return __last_node;
    }






  template <class _Tp, class _Alloc = allocator<_Tp> >
    class slist : private _Slist_base<_Tp,_Alloc>
    {

     

    private:
      typedef _Slist_base<_Tp,_Alloc> _Base;

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;

      typedef _Slist_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Slist_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      typedef typename _Base::allocator_type allocator_type;

      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }

    private:
      typedef _Slist_node<_Tp> _Node;
      typedef _Slist_node_base _Node_base;
      typedef _Slist_iterator_base _Iterator_base;

      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __node = this->_M_get_node();
 try
   {
     get_allocator().construct(&__node->_M_data, __x);
     __node->_M_next = 0;
   }
 catch(...)
   {
     this->_M_put_node(__node);
     throw;
   }
 return __node;
      }

      _Node*
      _M_create_node()
      {
 _Node* __node = this->_M_get_node();
 try
   {
     get_allocator().construct(&__node->_M_data, value_type());
     __node->_M_next = 0;
   }
 catch(...)
   {
     this->_M_put_node(__node);
     throw;
   }
 return __node;
      }

    public:
      explicit
      slist(const allocator_type& __a = allocator_type())
      : _Base(__a) {}

      slist(size_type __n, const value_type& __x,
     const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_insert_after_fill(&this->_M_head, __n, __x); }

      explicit
      slist(size_type __n)
      : _Base(allocator_type())
      { _M_insert_after_fill(&this->_M_head, __n, value_type()); }



      template <class _InputIterator>
        slist(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        { _M_insert_after_range(&this->_M_head, __first, __last); }

      slist(const slist& __x)
      : _Base(__x.get_allocator())
      { _M_insert_after_range(&this->_M_head, __x.begin(), __x.end()); }

      slist&
      operator= (const slist& __x);

      ~slist() {}

    public:





      void
      assign(size_type __n, const _Tp& __val)
      { _M_fill_assign(__n, __val); }

      void
      _M_fill_assign(size_type __n, const _Tp& __val);

      template <class _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }

      template <class _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign((size_type) __n, (_Tp) __val); }

      template <class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type);

    public:

      iterator
      begin()
      { return iterator((_Node*)this->_M_head._M_next); }

      const_iterator
      begin() const
      { return const_iterator((_Node*)this->_M_head._M_next);}

      iterator
      end()
      { return iterator(0); }

      const_iterator
      end() const
      { return const_iterator(0); }
# 445 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/ext/slist" 3
      iterator
      before_begin()
      { return iterator((_Node*) &this->_M_head); }

      const_iterator
      before_begin() const
      { return const_iterator((_Node*) &this->_M_head); }

      size_type
      size() const
      { return __slist_size(this->_M_head._M_next); }

      size_type
      max_size() const
      { return size_type(-1); }

      bool
      empty() const
      { return this->_M_head._M_next == 0; }

      void
      swap(slist& __x)
      { std::swap(this->_M_head._M_next, __x._M_head._M_next); }

    public:

      reference
      front()
      { return ((_Node*) this->_M_head._M_next)->_M_data; }

      const_reference
      front() const
      { return ((_Node*) this->_M_head._M_next)->_M_data; }

      void
      push_front(const value_type& __x)
      { __slist_make_link(&this->_M_head, _M_create_node(__x)); }

      void
      push_front()
      { __slist_make_link(&this->_M_head, _M_create_node()); }

      void
      pop_front()
      {
 _Node* __node = (_Node*) this->_M_head._M_next;
 this->_M_head._M_next = __node->_M_next;
 get_allocator().destroy(&__node->_M_data);
 this->_M_put_node(__node);
      }

      iterator
      previous(const_iterator __pos)
      { return iterator((_Node*) __slist_previous(&this->_M_head,
        __pos._M_node)); }

      const_iterator
      previous(const_iterator __pos) const
      { return const_iterator((_Node*) __slist_previous(&this->_M_head,
       __pos._M_node)); }

    private:
      _Node*
      _M_insert_after(_Node_base* __pos, const value_type& __x)
      { return (_Node*) (__slist_make_link(__pos, _M_create_node(__x))); }

      _Node*
      _M_insert_after(_Node_base* __pos)
      { return (_Node*) (__slist_make_link(__pos, _M_create_node())); }

      void
      _M_insert_after_fill(_Node_base* __pos,
      size_type __n, const value_type& __x)
      {
 for (size_type __i = 0; __i < __n; ++__i)
   __pos = __slist_make_link(__pos, _M_create_node(__x));
      }


      template <class _InIterator>
        void
        _M_insert_after_range(_Node_base* __pos,
         _InIterator __first, _InIterator __last)
        {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_insert_after_range(__pos, __first, __last, _Integral());
 }

      template <class _Integer>
        void
        _M_insert_after_range(_Node_base* __pos, _Integer __n, _Integer __x,
         __true_type)
        { _M_insert_after_fill(__pos, __n, __x); }

      template <class _InIterator>
        void
        _M_insert_after_range(_Node_base* __pos,
         _InIterator __first, _InIterator __last,
         __false_type)
        {
   while (__first != __last)
     {
       __pos = __slist_make_link(__pos, _M_create_node(*__first));
       ++__first;
     }
 }

    public:
      iterator
      insert_after(iterator __pos, const value_type& __x)
      { return iterator(_M_insert_after(__pos._M_node, __x)); }

      iterator
      insert_after(iterator __pos)
      { return insert_after(__pos, value_type()); }

      void
      insert_after(iterator __pos, size_type __n, const value_type& __x)
      { _M_insert_after_fill(__pos._M_node, __n, __x); }



      template <class _InIterator>
        void
        insert_after(iterator __pos, _InIterator __first, _InIterator __last)
        { _M_insert_after_range(__pos._M_node, __first, __last); }

      iterator
      insert(iterator __pos, const value_type& __x)
      { return iterator(_M_insert_after(__slist_previous(&this->_M_head,
        __pos._M_node),
     __x)); }

      iterator
      insert(iterator __pos)
      { return iterator(_M_insert_after(__slist_previous(&this->_M_head,
        __pos._M_node),
     value_type())); }

      void
      insert(iterator __pos, size_type __n, const value_type& __x)
      { _M_insert_after_fill(__slist_previous(&this->_M_head, __pos._M_node),
        __n, __x); }



      template <class _InIterator>
        void
        insert(iterator __pos, _InIterator __first, _InIterator __last)
        { _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node),
    __first, __last); }

    public:
      iterator
      erase_after(iterator __pos)
      { return iterator((_Node*) this->_M_erase_after(__pos._M_node)); }

      iterator
      erase_after(iterator __before_first, iterator __last)
      { return iterator((_Node*) this->_M_erase_after(__before_first._M_node,
            __last._M_node)); }

      iterator
      erase(iterator __pos)
      { return (_Node*) this->_M_erase_after(__slist_previous(&this->_M_head,
             __pos._M_node)); }

      iterator
      erase(iterator __first, iterator __last)
      { return (_Node*) this->_M_erase_after(__slist_previous(&this->_M_head,
             __first._M_node),
          __last._M_node); }

      void
      resize(size_type new_size, const _Tp& __x);

      void
      resize(size_type new_size)
      { resize(new_size, _Tp()); }

      void
      clear()
      { this->_M_erase_after(&this->_M_head, 0); }

    public:


      void
      splice_after(iterator __pos,
     iterator __before_first, iterator __before_last)
      {
 if (__before_first != __before_last)
   __slist_splice_after(__pos._M_node, __before_first._M_node,
          __before_last._M_node);
      }



      void
      splice_after(iterator __pos, iterator __prev)
      { __slist_splice_after(__pos._M_node,
        __prev._M_node, __prev._M_node->_M_next); }




      void
      splice_after(iterator __pos, slist& __x)
      { __slist_splice_after(__pos._M_node, &__x._M_head); }


      void
      splice(iterator __pos, slist& __x)
      {
 if (__x._M_head._M_next)
   __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),
          &__x._M_head,
          __slist_previous(&__x._M_head, 0)); }


      void
      splice(iterator __pos, slist& __x, iterator __i)
      { __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),
        __slist_previous(&__x._M_head, __i._M_node),
        __i._M_node); }



      void
      splice(iterator __pos, slist& __x, iterator __first, iterator __last)
      {
 if (__first != __last)
   __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),
          __slist_previous(&__x._M_head, __first._M_node),
          __slist_previous(__first._M_node,
      __last._M_node));
      }

    public:
      void
      reverse()
      {
 if (this->_M_head._M_next)
   this->_M_head._M_next = __slist_reverse(this->_M_head._M_next);
      }

      void
      remove(const _Tp& __val);

      void
      unique();

      void
      merge(slist& __x);

      void
      sort();

      template <class _Predicate>
        void
        remove_if(_Predicate __pred);

      template <class _BinaryPredicate>
        void
        unique(_BinaryPredicate __pred);

      template <class _StrictWeakOrdering>
        void
        merge(slist&, _StrictWeakOrdering);

      template <class _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering __comp);
    };

  template <class _Tp, class _Alloc>
    slist<_Tp, _Alloc>&
    slist<_Tp, _Alloc>::operator=(const slist<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   _Node_base* __p1 = &this->_M_head;
   _Node* __n1 = (_Node*) this->_M_head._M_next;
   const _Node* __n2 = (const _Node*) __x._M_head._M_next;
   while (__n1 && __n2)
     {
       __n1->_M_data = __n2->_M_data;
       __p1 = __n1;
       __n1 = (_Node*) __n1->_M_next;
       __n2 = (const _Node*) __n2->_M_next;
     }
   if (__n2 == 0)
     this->_M_erase_after(__p1, 0);
   else
     _M_insert_after_range(__p1, const_iterator((_Node*)__n2),
                                  const_iterator(0));
 }
      return *this;
    }

  template <class _Tp, class _Alloc>
    void
    slist<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val)
    {
      _Node_base* __prev = &this->_M_head;
      _Node* __node = (_Node*) this->_M_head._M_next;
      for (; __node != 0 && __n > 0; --__n)
 {
   __node->_M_data = __val;
   __prev = __node;
   __node = (_Node*) __node->_M_next;
 }
      if (__n > 0)
 _M_insert_after_fill(__prev, __n, __val);
      else
 this->_M_erase_after(__prev, 0);
    }

  template <class _Tp, class _Alloc>
    template <class _InputIterator>
      void
      slist<_Tp, _Alloc>::_M_assign_dispatch(_InputIterator __first,
          _InputIterator __last,
          __false_type)
      {
 _Node_base* __prev = &this->_M_head;
 _Node* __node = (_Node*) this->_M_head._M_next;
 while (__node != 0 && __first != __last)
   {
     __node->_M_data = *__first;
     __prev = __node;
     __node = (_Node*) __node->_M_next;
     ++__first;
   }
 if (__first != __last)
   _M_insert_after_range(__prev, __first, __last);
 else
   this->_M_erase_after(__prev, 0);
      }

  template <class _Tp, class _Alloc>
    inline bool
    operator==(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)
    {
      typedef typename slist<_Tp,_Alloc>::const_iterator const_iterator;
      const_iterator __end1 = _SL1.end();
      const_iterator __end2 = _SL2.end();

      const_iterator __i1 = _SL1.begin();
      const_iterator __i2 = _SL2.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }


  template <class _Tp, class _Alloc>
    inline bool
    operator<(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)
    { return std::lexicographical_compare(_SL1.begin(), _SL1.end(),
       _SL2.begin(), _SL2.end()); }

  template <class _Tp, class _Alloc>
    inline bool
    operator!=(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)
    { return !(_SL1 == _SL2); }

  template <class _Tp, class _Alloc>
    inline bool
    operator>(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)
    { return _SL2 < _SL1; }

  template <class _Tp, class _Alloc>
    inline bool
    operator<=(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)
    { return !(_SL2 < _SL1); }

  template <class _Tp, class _Alloc>
    inline bool
    operator>=(const slist<_Tp, _Alloc>& _SL1, const slist<_Tp, _Alloc>& _SL2)
    { return !(_SL1 < _SL2); }

  template <class _Tp, class _Alloc>
    inline void
    swap(slist<_Tp, _Alloc>& __x, slist<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

  template <class _Tp, class _Alloc>
    void
    slist<_Tp, _Alloc>::resize(size_type __len, const _Tp& __x)
    {
      _Node_base* __cur = &this->_M_head;
      while (__cur->_M_next != 0 && __len > 0)
 {
   --__len;
   __cur = __cur->_M_next;
 }
      if (__cur->_M_next)
 this->_M_erase_after(__cur, 0);
      else
 _M_insert_after_fill(__cur, __len, __x);
    }

  template <class _Tp, class _Alloc>
    void
    slist<_Tp, _Alloc>::remove(const _Tp& __val)
    {
      _Node_base* __cur = &this->_M_head;
      while (__cur && __cur->_M_next)
 {
   if (((_Node*) __cur->_M_next)->_M_data == __val)
     this->_M_erase_after(__cur);
   else
     __cur = __cur->_M_next;
 }
    }

  template <class _Tp, class _Alloc>
    void
    slist<_Tp, _Alloc>::unique()
    {
      _Node_base* __cur = this->_M_head._M_next;
      if (__cur)
 {
   while (__cur->_M_next)
     {
       if (((_Node*)__cur)->_M_data
    == ((_Node*)(__cur->_M_next))->_M_data)
  this->_M_erase_after(__cur);
       else
  __cur = __cur->_M_next;
     }
 }
    }

  template <class _Tp, class _Alloc>
    void
    slist<_Tp, _Alloc>::merge(slist<_Tp, _Alloc>& __x)
    {
      _Node_base* __n1 = &this->_M_head;
      while (__n1->_M_next && __x._M_head._M_next)
 {
   if (((_Node*) __x._M_head._M_next)->_M_data
       < ((_Node*) __n1->_M_next)->_M_data)
     __slist_splice_after(__n1, &__x._M_head, __x._M_head._M_next);
   __n1 = __n1->_M_next;
 }
      if (__x._M_head._M_next)
 {
   __n1->_M_next = __x._M_head._M_next;
   __x._M_head._M_next = 0;
 }
    }

  template <class _Tp, class _Alloc>
    void
    slist<_Tp, _Alloc>::sort()
    {
      if (this->_M_head._M_next && this->_M_head._M_next->_M_next)
 {
   slist __carry;
   slist __counter[64];
   int __fill = 0;
   while (!empty())
     {
       __slist_splice_after(&__carry._M_head,
       &this->_M_head, this->_M_head._M_next);
       int __i = 0;
       while (__i < __fill && !__counter[__i].empty())
  {
    __counter[__i].merge(__carry);
    __carry.swap(__counter[__i]);
    ++__i;
  }
       __carry.swap(__counter[__i]);
       if (__i == __fill)
  ++__fill;
     }

   for (int __i = 1; __i < __fill; ++__i)
     __counter[__i].merge(__counter[__i-1]);
   this->swap(__counter[__fill-1]);
 }
    }

  template <class _Tp, class _Alloc>
    template <class _Predicate>
      void slist<_Tp, _Alloc>::remove_if(_Predicate __pred)
      {
 _Node_base* __cur = &this->_M_head;
 while (__cur->_M_next)
   {
     if (__pred(((_Node*) __cur->_M_next)->_M_data))
       this->_M_erase_after(__cur);
     else
       __cur = __cur->_M_next;
   }
      }

  template <class _Tp, class _Alloc>
    template <class _BinaryPredicate>
      void
      slist<_Tp, _Alloc>::unique(_BinaryPredicate __pred)
      {
 _Node* __cur = (_Node*) this->_M_head._M_next;
 if (__cur)
   {
     while (__cur->_M_next)
       {
  if (__pred(((_Node*)__cur)->_M_data,
      ((_Node*)(__cur->_M_next))->_M_data))
    this->_M_erase_after(__cur);
  else
    __cur = (_Node*) __cur->_M_next;
       }
   }
      }

  template <class _Tp, class _Alloc>
    template <class _StrictWeakOrdering>
      void
      slist<_Tp, _Alloc>::merge(slist<_Tp, _Alloc>& __x,
          _StrictWeakOrdering __comp)
      {
 _Node_base* __n1 = &this->_M_head;
 while (__n1->_M_next && __x._M_head._M_next)
   {
     if (__comp(((_Node*) __x._M_head._M_next)->_M_data,
         ((_Node*) __n1->_M_next)->_M_data))
       __slist_splice_after(__n1, &__x._M_head, __x._M_head._M_next);
     __n1 = __n1->_M_next;
   }
 if (__x._M_head._M_next)
   {
     __n1->_M_next = __x._M_head._M_next;
     __x._M_head._M_next = 0;
   }
      }

  template <class _Tp, class _Alloc>
    template <class _StrictWeakOrdering>
      void
      slist<_Tp, _Alloc>::sort(_StrictWeakOrdering __comp)
      {
 if (this->_M_head._M_next && this->_M_head._M_next->_M_next)
   {
     slist __carry;
     slist __counter[64];
     int __fill = 0;
     while (!empty())
       {
  __slist_splice_after(&__carry._M_head,
         &this->_M_head, this->_M_head._M_next);
  int __i = 0;
  while (__i < __fill && !__counter[__i].empty())
    {
      __counter[__i].merge(__carry, __comp);
      __carry.swap(__counter[__i]);
      ++__i;
    }
  __carry.swap(__counter[__i]);
  if (__i == __fill)
    ++__fill;
       }

     for (int __i = 1; __i < __fill; ++__i)
       __counter[__i].merge(__counter[__i-1], __comp);
     this->swap(__counter[__fill-1]);
   }
      }

}

namespace std
{



  template <class _Tp, class _Alloc>
    class insert_iterator<__gnu_cxx::slist<_Tp, _Alloc> >
    {
    protected:
      typedef __gnu_cxx::slist<_Tp, _Alloc> _Container;
      _Container* container;
      typename _Container::iterator iter;

    public:
      typedef _Container container_type;
      typedef output_iterator_tag iterator_category;
      typedef void value_type;
      typedef void difference_type;
      typedef void pointer;
      typedef void reference;

      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x)
      {
 if (__i == __x.begin())
   iter = __x.before_begin();
 else
   iter = __x.previous(__i);
      }

      insert_iterator<_Container>&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert_after(iter, __value);
 return *this;
      }

      insert_iterator<_Container>&
      operator*()
      { return *this; }

      insert_iterator<_Container>&
      operator++()
      { return *this; }

      insert_iterator<_Container>&
      operator++(int)
      { return *this; }
};

}
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std/slist_traits.hpp" 2 3


namespace boost {
    namespace algorithm {
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std/slist_traits.hpp" 3
        template<typename T, typename AllocT>
        class has_stable_iterators< __gnu_cxx::slist<T,AllocT> >
        {
        public:



            static const bool value=true;

            typedef mpl::bool_<has_stable_iterators<T>::value> type;
        };


        template<typename T, typename AllocT>
        class has_const_time_insert< __gnu_cxx::slist<T,AllocT> >
        {
        public:



            static const bool value=true;

            typedef mpl::bool_<has_const_time_insert<T>::value> type;
        };


        template<typename T, typename AllocT>
        class has_const_time_erase< __gnu_cxx::slist<T,AllocT> >
        {
        public:



            static const bool value=true;

            typedef mpl::bool_<has_const_time_erase<T>::value> type;
        };



    }
}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/std_containers_traits.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/trim.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/trim.hpp" 3
namespace boost {
    namespace algorithm {
        namespace detail {




            template< typename ForwardIteratorT, typename PredicateT >
            inline ForwardIteratorT trim_begin(
                ForwardIteratorT InBegin,
                ForwardIteratorT InEnd,
                PredicateT IsSpace )
            {
                ForwardIteratorT It=InBegin;
                for(; It!=InEnd; ++It )
                {
                    if (!IsSpace(*It))
                        return It;
                }

                return It;
            }


            template< typename ForwardIteratorT, typename PredicateT >
            inline ForwardIteratorT trim_end(
                ForwardIteratorT InBegin,
                ForwardIteratorT InEnd,
                PredicateT IsSpace )
            {
                typedef typename boost::detail::
                    iterator_traits<ForwardIteratorT>::iterator_category category;

                return trim_end_iter_select( InBegin, InEnd, IsSpace, category() );
            }

            template< typename ForwardIteratorT, typename PredicateT >
            inline ForwardIteratorT trim_end_iter_select(
                ForwardIteratorT InBegin,
                ForwardIteratorT InEnd,
                PredicateT IsSpace,
                std::forward_iterator_tag )
            {
                ForwardIteratorT TrimIt=InBegin;

                for( ForwardIteratorT It=InBegin; It!=InEnd; ++It )
                {
                    if ( !IsSpace(*It) )
                    {
                        TrimIt=It;
                        ++TrimIt;
                    }
                }

                return TrimIt;
            }

            template< typename ForwardIteratorT, typename PredicateT >
            inline ForwardIteratorT trim_end_iter_select(
                ForwardIteratorT InBegin,
                ForwardIteratorT InEnd,
                PredicateT IsSpace,
                std::bidirectional_iterator_tag )
            {
                for( ForwardIteratorT It=InEnd; It!=InBegin; )
                {
                    if ( !IsSpace(*(--It)) )
                        return ++It;
                }

                return InBegin;
            }

        }
    }
}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/classification.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/classification.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate_facade.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate_facade.hpp" 3
namespace boost {
    namespace algorithm {
# 35 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate_facade.hpp" 3
        template<typename Derived>
        struct predicate_facade {};

    }
}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/classification.hpp" 2 3


namespace boost {
    namespace algorithm {
        namespace detail {
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/classification.hpp" 3
            struct is_classifiedF :
                public predicate_facade<is_classifiedF>
            {

                template <class Args> struct sig { typedef bool type; };


                is_classifiedF(std::ctype_base::mask Type, std::locale const & Loc = std::locale()) :
                    m_Type(Type), m_Locale(Loc) {}


                template<typename CharT>
                bool operator()( CharT Ch ) const
                {
                    return std::use_facet< std::ctype<CharT> >(m_Locale).is( m_Type, Ch );
                }
# 61 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/classification.hpp" 3
            private:
                const std::ctype_base::mask m_Type;
                const std::locale m_Locale;
            };
# 74 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/classification.hpp" 3
            template<typename CharT>
            struct is_any_ofF :
                public predicate_facade<is_any_ofF<CharT> >
            {
            private:

                typedef typename remove_const<CharT>::type set_value_type;

                static const ::std::size_t FIXED_STORAGE_SIZE = sizeof(set_value_type*)*2;

            public:

                template <class Args> struct sig { typedef bool type; };


                template<typename RangeT>
                is_any_ofF( const RangeT& Range ) : m_Size(0)
                {

                    m_Storage.m_dynSet=0;

                    std::size_t Size=::boost::distance(Range);
                    m_Size=Size;
                    set_value_type* Storage=0;

                    if(m_Size<=FIXED_STORAGE_SIZE)
                    {

                        Storage=&m_Storage.m_fixSet[0];
                    }
                    else
                    {

                        m_Storage.m_dynSet=new set_value_type[m_Size];
                        Storage=m_Storage.m_dynSet;
                    }


                    ::std::copy(::boost::begin(Range), ::boost::end(Range), Storage);
                    ::std::sort(Storage, Storage+m_Size);
                }


                is_any_ofF(const is_any_ofF& Other) : m_Size(Other.m_Size)
                {

                    m_Storage.m_dynSet=0;
                    const set_value_type* SrcStorage=0;
                    set_value_type* DestStorage=0;

                    if(m_Size<=FIXED_STORAGE_SIZE)
                    {

                        DestStorage=&m_Storage.m_fixSet[0];
                        SrcStorage=&Other.m_Storage.m_fixSet[0];
                    }
                    else
                    {

                        m_Storage.m_dynSet=new set_value_type[m_Size];
                        DestStorage=m_Storage.m_dynSet;
                        SrcStorage=Other.m_Storage.m_dynSet;
                    }


                    ::memcpy(DestStorage, SrcStorage, sizeof(set_value_type)*m_Size);
                }


                ~is_any_ofF()
                {
                    if(m_Size>FIXED_STORAGE_SIZE && m_Storage.m_dynSet!=0)
                    {
                        delete m_Storage.m_dynSet;
                    }
                }


                is_any_ofF& operator=(const is_any_ofF& Other)
                {

                    m_Storage.m_dynSet=0;
                    m_Size=Other.m_Size;
                    const set_value_type* SrcStorage=0;
                    set_value_type* DestStorage=0;

                    if(m_Size<=FIXED_STORAGE_SIZE)
                    {

                        DestStorage=&m_Storage.m_fixSet[0];
                        SrcStorage=&Other.m_Storage.m_fixSet[0];
                    }
                    else
                    {

                        m_Storage.m_dynSet=new set_value_type[m_Size];
                        DestStorage=m_Storage.m_dynSet;
                        SrcStorage=Other.m_Storage.m_dynSet;
                    }


                    ::memcpy(DestStorage, SrcStorage, sizeof(set_value_type)*m_Size);

                    return *this;
                }


                template<typename Char2T>
                bool operator()( Char2T Ch ) const
                {
                    const set_value_type* Storage=
                        (m_Size<=FIXED_STORAGE_SIZE)
                        ? &m_Storage.m_fixSet[0]
                        : m_Storage.m_dynSet;

                    return ::std::binary_search(Storage, Storage+m_Size, Ch);
                }

            private:


                union
                {
                    set_value_type* m_dynSet;
                    set_value_type m_fixSet[FIXED_STORAGE_SIZE];
                }
                m_Storage;


                ::std::size_t m_Size;
            };






            template<typename CharT>
            struct is_from_rangeF :
                public predicate_facade< is_from_rangeF<CharT> >
            {

                template <class Args> struct sig { typedef bool type; };


                is_from_rangeF( CharT From, CharT To ) : m_From(From), m_To(To) {}


                template<typename Char2T>
                bool operator()( Char2T Ch ) const
                {
                    return ( m_From <= Ch ) && ( Ch <= m_To );
                }

            private:
                CharT m_From;
                CharT m_To;
            };


            template<typename Pred1T, typename Pred2T>
            struct pred_andF :
                public predicate_facade< pred_andF<Pred1T,Pred2T> >
            {
            public:


                template <class Args> struct sig { typedef bool type; };


                pred_andF( Pred1T Pred1, Pred2T Pred2 ) :
                    m_Pred1(Pred1), m_Pred2(Pred2) {}


                template<typename CharT>
                bool operator()( CharT Ch ) const
                {
                    return m_Pred1(Ch) && m_Pred2(Ch);
                }

            private:
                Pred1T m_Pred1;
                Pred2T m_Pred2;
            };


            template<typename Pred1T, typename Pred2T>
            struct pred_orF :
                public predicate_facade< pred_orF<Pred1T,Pred2T> >
            {
            public:

                template <class Args> struct sig { typedef bool type; };


                pred_orF( Pred1T Pred1, Pred2T Pred2 ) :
                    m_Pred1(Pred1), m_Pred2(Pred2) {}


                template<typename CharT>
                bool operator()( CharT Ch ) const
                {
                    return m_Pred1(Ch) || m_Pred2(Ch);
                }

            private:
                Pred1T m_Pred1;
                Pred2T m_Pred2;
            };


            template< typename PredT >
            struct pred_notF :
                public predicate_facade< pred_notF<PredT> >
            {
            public:

                template <class Args> struct sig { typedef bool type; };


                pred_notF( PredT Pred ) : m_Pred(Pred) {}


                template<typename CharT>
                bool operator()( CharT Ch ) const
                {
                    return !m_Pred(Ch);
                }

            private:
                PredT m_Pred;
            };

        }
    }
}
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 2 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
namespace boost {
    namespace algorithm {
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_classified(std::ctype_base::mask Type, const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(Type, Loc);
        }
# 56 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_space(const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(std::ctype_base::space, Loc);
        }
# 69 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_alnum(const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(std::ctype_base::alnum, Loc);
        }
# 82 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_alpha(const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(std::ctype_base::alpha, Loc);
        }
# 95 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_cntrl(const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(std::ctype_base::cntrl, Loc);
        }
# 108 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_digit(const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(std::ctype_base::digit, Loc);
        }
# 121 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_graph(const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(std::ctype_base::graph, Loc);
        }
# 134 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_lower(const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(std::ctype_base::lower, Loc);
        }
# 147 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_print(const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(std::ctype_base::print, Loc);
        }
# 160 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_punct(const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(std::ctype_base::punct, Loc);
        }
# 173 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_upper(const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(std::ctype_base::upper, Loc);
        }
# 186 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        inline detail::is_classifiedF
        is_xdigit(const std::locale& Loc=std::locale())
        {
            return detail::is_classifiedF(std::ctype_base::xdigit, Loc);
        }
# 200 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        template<typename RangeT>
        inline detail::is_any_ofF<
            typename range_value<RangeT>::type>
        is_any_of( const RangeT& Set )
        {
            iterator_range<typename range_const_iterator<RangeT>::type> lit_set(as_literal(Set));
            return detail::is_any_ofF<typename range_value<RangeT>::type>(lit_set);
        }
# 218 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        template<typename CharT>
        inline detail::is_from_rangeF<CharT> is_from_range(CharT From, CharT To)
        {
            return detail::is_from_rangeF<CharT>(From,To);
        }
# 236 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        template<typename Pred1T, typename Pred2T>
        inline detail::pred_andF<Pred1T, Pred2T>
        operator&&(
            const predicate_facade<Pred1T>& Pred1,
            const predicate_facade<Pred2T>& Pred2 )
        {



            return detail::pred_andF<Pred1T,Pred2T>(
                *static_cast<const Pred1T*>(&Pred1),
                *static_cast<const Pred2T*>(&Pred2) );
        }
# 260 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        template<typename Pred1T, typename Pred2T>
        inline detail::pred_orF<Pred1T, Pred2T>
        operator||(
            const predicate_facade<Pred1T>& Pred1,
            const predicate_facade<Pred2T>& Pred2 )
        {



            return detail::pred_orF<Pred1T,Pred2T>(
                *static_cast<const Pred1T*>(&Pred1),
                *static_cast<const Pred2T*>(&Pred2));
        }
# 282 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/classification.hpp" 3
        template<typename PredT>
        inline detail::pred_notF<PredT>
        operator!( const predicate_facade<PredT>& Pred )
        {



            return detail::pred_notF<PredT>(*static_cast<const PredT*>(&Pred));
        }

    }


    using algorithm::is_classified;
    using algorithm::is_space;
    using algorithm::is_alnum;
    using algorithm::is_alpha;
    using algorithm::is_cntrl;
    using algorithm::is_digit;
    using algorithm::is_graph;
    using algorithm::is_lower;
    using algorithm::is_upper;
    using algorithm::is_print;
    using algorithm::is_punct;
    using algorithm::is_xdigit;
    using algorithm::is_any_of;
    using algorithm::is_from_range;

}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 2 3
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
namespace boost {
    namespace algorithm {
# 60 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename OutputIteratorT, typename RangeT, typename PredicateT>
        inline OutputIteratorT trim_left_copy_if(
            OutputIteratorT Output,
            const RangeT& Input,
            PredicateT IsSpace)
        {
            iterator_range<typename range_const_iterator<RangeT>::type> lit_range(as_literal(Input));

            std::copy(
                ::boost::algorithm::detail::trim_begin(
                    ::boost::begin(lit_range),
                    ::boost::end(lit_range),
                    IsSpace ),
                ::boost::end(lit_range),
                Output);

            return Output;
        }





        template<typename SequenceT, typename PredicateT>
        inline SequenceT trim_left_copy_if(const SequenceT& Input, PredicateT IsSpace)
        {
            return SequenceT(
                ::boost::algorithm::detail::trim_begin(
                    ::boost::begin(Input),
                    ::boost::end(Input),
                    IsSpace ),
                ::boost::end(Input));
        }
# 105 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename SequenceT>
        inline SequenceT trim_left_copy(const SequenceT& Input, const std::locale& Loc=std::locale())
        {
            return
                trim_left_copy_if(
                    Input,
                    is_space(Loc));
        }
# 123 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename SequenceT, typename PredicateT>
        inline void trim_left_if(SequenceT& Input, PredicateT IsSpace)
        {
            Input.erase(
                ::boost::begin(Input),
                ::boost::algorithm::detail::trim_begin(
                    ::boost::begin(Input),
                    ::boost::end(Input),
                    IsSpace));
        }
# 142 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename SequenceT>
        inline void trim_left(SequenceT& Input, const std::locale& Loc=std::locale())
        {
            trim_left_if(
                Input,
                is_space(Loc));
        }
# 168 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename OutputIteratorT, typename RangeT, typename PredicateT>
        inline OutputIteratorT trim_right_copy_if(
            OutputIteratorT Output,
            const RangeT& Input,
            PredicateT IsSpace )
        {
            iterator_range<typename range_const_iterator<RangeT>::type> lit_range(as_literal(Input));

            std::copy(
                ::boost::begin(lit_range),
                ::boost::algorithm::detail::trim_end(
                    ::boost::begin(lit_range),
                    ::boost::end(lit_range),
                    IsSpace ),
                Output );

            return Output;
        }





        template<typename SequenceT, typename PredicateT>
        inline SequenceT trim_right_copy_if(const SequenceT& Input, PredicateT IsSpace)
        {
            return SequenceT(
                ::boost::begin(Input),
                ::boost::algorithm::detail::trim_end(
                    ::boost::begin(Input),
                    ::boost::end(Input),
                    IsSpace)
                );
        }
# 214 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename SequenceT>
        inline SequenceT trim_right_copy(const SequenceT& Input, const std::locale& Loc=std::locale())
        {
            return
                trim_right_copy_if(
                    Input,
                    is_space(Loc));
        }
# 233 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename SequenceT, typename PredicateT>
        inline void trim_right_if(SequenceT& Input, PredicateT IsSpace)
        {
            Input.erase(
                ::boost::algorithm::detail::trim_end(
                    ::boost::begin(Input),
                    ::boost::end(Input),
                    IsSpace ),
                ::boost::end(Input)
                );
        }
# 254 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename SequenceT>
        inline void trim_right(SequenceT& Input, const std::locale& Loc=std::locale())
        {
            trim_right_if(
                Input,
                is_space(Loc) );
        }
# 280 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename OutputIteratorT, typename RangeT, typename PredicateT>
        inline OutputIteratorT trim_copy_if(
            OutputIteratorT Output,
            const RangeT& Input,
            PredicateT IsSpace)
        {
            iterator_range<typename range_const_iterator<RangeT>::type> lit_range(as_literal(Input));

            typename
                range_const_iterator<RangeT>::type TrimEnd=
                ::boost::algorithm::detail::trim_end(
                    ::boost::begin(lit_range),
                    ::boost::end(lit_range),
                    IsSpace);

            std::copy(
                detail::trim_begin(
                    ::boost::begin(lit_range), TrimEnd, IsSpace),
                TrimEnd,
                Output
                );

            return Output;
        }





        template<typename SequenceT, typename PredicateT>
        inline SequenceT trim_copy_if(const SequenceT& Input, PredicateT IsSpace)
        {
            typename
                range_const_iterator<SequenceT>::type TrimEnd=
                    ::boost::algorithm::detail::trim_end(
                        ::boost::begin(Input),
                        ::boost::end(Input),
                        IsSpace);

            return SequenceT(
                detail::trim_begin(
                    ::boost::begin(Input),
                    TrimEnd,
                    IsSpace),
                TrimEnd
                );
        }
# 339 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename SequenceT>
        inline SequenceT trim_copy( const SequenceT& Input, const std::locale& Loc=std::locale() )
        {
            return
                trim_copy_if(
                    Input,
                    is_space(Loc) );
        }
# 357 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename SequenceT, typename PredicateT>
        inline void trim_if(SequenceT& Input, PredicateT IsSpace)
        {
            trim_right_if( Input, IsSpace );
            trim_left_if( Input, IsSpace );
        }
# 372 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/trim.hpp" 3
        template<typename SequenceT>
        inline void trim(SequenceT& Input, const std::locale& Loc=std::locale())
        {
            trim_if(
                Input,
                is_space( Loc ) );
        }

    }


    using algorithm::trim_left;
    using algorithm::trim_left_if;
    using algorithm::trim_left_copy;
    using algorithm::trim_left_copy_if;
    using algorithm::trim_right;
    using algorithm::trim_right_if;
    using algorithm::trim_right_copy;
    using algorithm::trim_right_copy_if;
    using algorithm::trim;
    using algorithm::trim_if;
    using algorithm::trim_copy;
    using algorithm::trim_copy_if;

}
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 1 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 3
namespace boost {
    namespace algorithm {
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 3
        template<typename RangeT, typename FinderT>
        inline iterator_range<
            typename range_iterator<RangeT>::type>
        find(
            RangeT& Input,
            const FinderT& Finder)
        {
            iterator_range<typename range_iterator<RangeT>::type> lit_input(as_literal(Input));

            return Finder(::boost::begin(lit_input),::boost::end(lit_input));
        }
# 77 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 3
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        find_first(
            Range1T& Input,
            const Range2T& Search)
        {
            return find(Input, first_finder(Search));
        }
# 103 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 3
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        ifind_first(
            Range1T& Input,
            const Range2T& Search,
            const std::locale& Loc=std::locale())
        {
            return find(Input, first_finder(Search,is_iequal(Loc)));
        }
# 130 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 3
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        find_last(
            Range1T& Input,
            const Range2T& Search)
        {
            return find(Input, last_finder(Search));
        }
# 156 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 3
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        ifind_last(
            Range1T& Input,
            const Range2T& Search,
            const std::locale& Loc=std::locale())
        {
            return find(Input, last_finder(Search, is_iequal(Loc)));
        }
# 184 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 3
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        find_nth(
            Range1T& Input,
            const Range2T& Search,
            int Nth)
        {
            return find(Input, nth_finder(Search,Nth));
        }
# 214 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 3
        template<typename Range1T, typename Range2T>
        inline iterator_range<
            typename range_iterator<Range1T>::type>
        ifind_nth(
            Range1T& Input,
            const Range2T& Search,
            int Nth,
            const std::locale& Loc=std::locale())
        {
            return find(Input, nth_finder(Search,Nth,is_iequal(Loc)));
        }
# 246 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 3
        template<typename RangeT>
        inline iterator_range<
            typename range_iterator<RangeT>::type>
        find_head(
            RangeT& Input,
            int N)
        {
            return find(Input, head_finder(N));
        }
# 277 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 3
        template<typename RangeT>
        inline iterator_range<
            typename range_iterator<RangeT>::type>
        find_tail(
            RangeT& Input,
            int N)
        {
            return find(Input, tail_finder(N));
        }
# 306 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find.hpp" 3
        template<typename RangeT, typename PredicateT>
        inline iterator_range<
            typename range_iterator<RangeT>::type>
        find_token(
            RangeT& Input,
            PredicateT Pred,
            token_compress_mode_type eCompress=token_compress_off)
        {
            return find(Input, token_finder(Pred, eCompress));
        }

    }


    using algorithm::find;
    using algorithm::find_first;
    using algorithm::ifind_first;
    using algorithm::find_last;
    using algorithm::ifind_last;
    using algorithm::find_nth;
    using algorithm::ifind_nth;
    using algorithm::find_head;
    using algorithm::find_tail;
    using algorithm::find_token;

}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/predicate.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/predicate.hpp" 3
namespace boost {
    namespace algorithm {
        namespace detail {



            template<
                typename ForwardIterator1T,
                typename ForwardIterator2T,
                typename PredicateT>
            inline bool ends_with_iter_select(
                ForwardIterator1T Begin,
                ForwardIterator1T End,
                ForwardIterator2T SubBegin,
                ForwardIterator2T SubEnd,
                PredicateT Comp,
                std::bidirectional_iterator_tag)
            {
                ForwardIterator1T it=End;
                ForwardIterator2T pit=SubEnd;
                for(;it!=Begin && pit!=SubBegin;)
                {
                    if( !(Comp(*(--it),*(--pit))) )
                        return false;
                }

                return pit==SubBegin;
            }

            template<
                typename ForwardIterator1T,
                typename ForwardIterator2T,
                typename PredicateT>
            inline bool ends_with_iter_select(
                ForwardIterator1T Begin,
                ForwardIterator1T End,
                ForwardIterator2T SubBegin,
                ForwardIterator2T SubEnd,
                PredicateT Comp,
                std::forward_iterator_tag)
            {
                if ( SubBegin==SubEnd )
                {

                    return true;
                }

                iterator_range<ForwardIterator1T> Result
                    =last_finder(
                        make_iterator_range(SubBegin, SubEnd),
                        Comp)(Begin, End);

                return !Result.empty() && Result.end()==End;
            }

        }
    }
}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 2 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
namespace boost {
    namespace algorithm {
# 56 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
        template<typename Range1T, typename Range2T, typename PredicateT>
            inline bool starts_with(
            const Range1T& Input,
            const Range2T& Test,
            PredicateT Comp)
        {
            iterator_range<typename range_const_iterator<Range1T>::type> lit_input(as_literal(Input));
            iterator_range<typename range_const_iterator<Range2T>::type> lit_test(as_literal(Test));

            typedef typename
                range_const_iterator<Range1T>::type Iterator1T;
            typedef typename
                range_const_iterator<Range2T>::type Iterator2T;

            Iterator1T InputEnd=::boost::end(lit_input);
            Iterator2T TestEnd=::boost::end(lit_test);

            Iterator1T it=::boost::begin(lit_input);
            Iterator2T pit=::boost::begin(lit_test);
            for(;
                it!=InputEnd && pit!=TestEnd;
                ++it,++pit)
            {
                if( !(Comp(*it,*pit)) )
                    return false;
            }

            return pit==TestEnd;
        }





        template<typename Range1T, typename Range2T>
        inline bool starts_with(
            const Range1T& Input,
            const Range2T& Test)
        {
            return starts_with(Input, Test, is_equal());
        }
# 111 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
        template<typename Range1T, typename Range2T>
        inline bool istarts_with(
            const Range1T& Input,
            const Range2T& Test,
            const std::locale& Loc=std::locale())
        {
            return starts_with(Input, Test, is_iequal(Loc));
        }
# 138 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
        template<typename Range1T, typename Range2T, typename PredicateT>
        inline bool ends_with(
            const Range1T& Input,
            const Range2T& Test,
            PredicateT Comp)
        {
            iterator_range<typename range_const_iterator<Range1T>::type> lit_input(as_literal(Input));
            iterator_range<typename range_const_iterator<Range2T>::type> lit_test(as_literal(Test));

            typedef typename
                range_const_iterator<Range1T>::type Iterator1T;
            typedef typename boost::detail::
                iterator_traits<Iterator1T>::iterator_category category;

            return detail::
                ends_with_iter_select(
                    ::boost::begin(lit_input),
                    ::boost::end(lit_input),
                    ::boost::begin(lit_test),
                    ::boost::end(lit_test),
                    Comp,
                    category());
        }






        template<typename Range1T, typename Range2T>
        inline bool ends_with(
            const Range1T& Input,
            const Range2T& Test)
        {
            return ends_with(Input, Test, is_equal());
        }
# 188 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
        template<typename Range1T, typename Range2T>
        inline bool iends_with(
            const Range1T& Input,
            const Range2T& Test,
            const std::locale& Loc=std::locale())
        {
            return ends_with(Input, Test, is_iequal(Loc));
        }
# 212 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
        template<typename Range1T, typename Range2T, typename PredicateT>
        inline bool contains(
            const Range1T& Input,
            const Range2T& Test,
            PredicateT Comp)
        {
            iterator_range<typename range_const_iterator<Range1T>::type> lit_input(as_literal(Input));
            iterator_range<typename range_const_iterator<Range2T>::type> lit_test(as_literal(Test));

            if (empty(lit_test))
            {

                return true;
            }


            bool bResult=(first_finder(lit_test,Comp)(::boost::begin(lit_input), ::boost::end(lit_input)));
            return bResult;
        }





        template<typename Range1T, typename Range2T>
        inline bool contains(
            const Range1T& Input,
            const Range2T& Test)
        {
            return contains(Input, Test, is_equal());
        }
# 256 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
        template<typename Range1T, typename Range2T>
        inline bool icontains(
            const Range1T& Input,
            const Range2T& Test,
            const std::locale& Loc=std::locale())
        {
            return contains(Input, Test, is_iequal(Loc));
        }
# 283 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
        template<typename Range1T, typename Range2T, typename PredicateT>
        inline bool equals(
            const Range1T& Input,
            const Range2T& Test,
            PredicateT Comp)
        {
            iterator_range<typename range_const_iterator<Range1T>::type> lit_input(as_literal(Input));
            iterator_range<typename range_const_iterator<Range2T>::type> lit_test(as_literal(Test));

            typedef typename
                range_const_iterator<Range1T>::type Iterator1T;
            typedef typename
                range_const_iterator<Range2T>::type Iterator2T;

            Iterator1T InputEnd=::boost::end(lit_input);
            Iterator2T TestEnd=::boost::end(lit_test);

            Iterator1T it=::boost::begin(lit_input);
            Iterator2T pit=::boost::begin(lit_test);
            for(;
                it!=InputEnd && pit!=TestEnd;
                ++it,++pit)
            {
                if( !(Comp(*it,*pit)) )
                    return false;
            }

            return (pit==TestEnd) && (it==InputEnd);
        }





        template<typename Range1T, typename Range2T>
        inline bool equals(
            const Range1T& Input,
            const Range2T& Test)
        {
            return equals(Input, Test, is_equal());
        }
# 340 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
        template<typename Range1T, typename Range2T>
        inline bool iequals(
            const Range1T& Input,
            const Range2T& Test,
            const std::locale& Loc=std::locale())
        {
            return equals(Input, Test, is_iequal(Loc));
        }
# 369 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
        template<typename Range1T, typename Range2T, typename PredicateT>
        inline bool lexicographical_compare(
            const Range1T& Arg1,
            const Range2T& Arg2,
            PredicateT Pred)
        {
            iterator_range<typename range_const_iterator<Range1T>::type> lit_arg1(as_literal(Arg1));
            iterator_range<typename range_const_iterator<Range2T>::type> lit_arg2(as_literal(Arg2));

            return std::lexicographical_compare(
                ::boost::begin(lit_arg1),
                ::boost::end(lit_arg1),
                ::boost::begin(lit_arg2),
                ::boost::end(lit_arg2),
                Pred);
        }





        template<typename Range1T, typename Range2T>
            inline bool lexicographical_compare(
            const Range1T& Arg1,
            const Range2T& Arg2)
        {
            return lexicographical_compare(Arg1, Arg2, is_less());
        }
# 414 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
        template<typename Range1T, typename Range2T>
        inline bool ilexicographical_compare(
            const Range1T& Arg1,
            const Range2T& Arg2,
            const std::locale& Loc=std::locale())
        {
            return lexicographical_compare(Arg1, Arg2, is_iless(Loc));
        }
# 437 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/predicate.hpp" 3
        template<typename RangeT, typename PredicateT>
        inline bool all(
            const RangeT& Input,
            PredicateT Pred)
        {
            iterator_range<typename range_const_iterator<RangeT>::type> lit_input(as_literal(Input));

            typedef typename
                range_const_iterator<RangeT>::type Iterator1T;

            Iterator1T InputEnd=::boost::end(lit_input);
            for( Iterator1T It=::boost::begin(lit_input); It!=InputEnd; ++It)
            {
                if (!Pred(*It))
                    return false;
            }

            return true;
        }

    }


    using algorithm::starts_with;
    using algorithm::istarts_with;
    using algorithm::ends_with;
    using algorithm::iends_with;
    using algorithm::contains;
    using algorithm::icontains;
    using algorithm::equals;
    using algorithm::iequals;
    using algorithm::all;
    using algorithm::lexicographical_compare;
    using algorithm::ilexicographical_compare;

}
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/split.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/split.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/iter_find.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/iter_find.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_iterator.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_iterator.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_iterator.hpp" 1 3
# 18 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_iterator.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function.hpp" 1 3
# 64 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3
# 12 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/slot/detail/shared.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 47 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 58 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 63 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 68 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 73 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 78 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 83 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 88 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 93 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/maybe_include.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function/detail/function_iterate.hpp" 2 3
# 98 "/Library/Application Support/MonkeyWorks/Developer/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3
# 65 "/Library/Application Support/MonkeyWorks/Developer/include/boost/function.hpp" 2 3
# 19 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/detail/find_iterator.hpp" 2 3

namespace boost {
    namespace algorithm {
        namespace detail {




            template<typename IteratorT>
            class find_iterator_base
            {
            protected:

                typedef IteratorT input_iterator_type;
                typedef iterator_range<IteratorT> match_type;
                typedef function2<
                    match_type,
                    input_iterator_type,
                    input_iterator_type> finder_type;

            protected:



                find_iterator_base() {};

                find_iterator_base( const find_iterator_base& Other ) :
                    m_Finder(Other.m_Finder) {}


                template<typename FinderT>
                find_iterator_base( FinderT Finder, int ) :
                    m_Finder(Finder) {}


                ~find_iterator_base() {}


                match_type do_find(
                    input_iterator_type Begin,
                    input_iterator_type End ) const
                {
                    if (!m_Finder.empty())
                    {
                        return m_Finder(Begin,End);
                    }
                    else
                    {
                        return match_type(End,End);
                    }
                }


                bool is_null() const
                {
                    return m_Finder.empty();
                }

            private:

                finder_type m_Finder;
            };

       }
    }
}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_iterator.hpp" 2 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_iterator.hpp" 3
namespace boost {
    namespace algorithm {
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_iterator.hpp" 3
        template<typename IteratorT>
        class find_iterator :
            public iterator_facade<
                find_iterator<IteratorT>,
                const iterator_range<IteratorT>,
                forward_traversal_tag >,
            private detail::find_iterator_base<IteratorT>
        {
        private:

            friend class ::boost::iterator_core_access;

        private:


            typedef detail::find_iterator_base<IteratorT> base_type;
            typedef typename
                base_type::input_iterator_type input_iterator_type;
            typedef typename
                base_type::match_type match_type;

        public:






            find_iterator() {}





            find_iterator( const find_iterator& Other ) :
                base_type(Other),
                m_Match(Other.m_Match),
                m_End(Other.m_End) {}






            template<typename FinderT>
            find_iterator(
                    IteratorT Begin,
                    IteratorT End,
                    FinderT Finder ) :
                detail::find_iterator_base<IteratorT>(Finder,0),
                m_Match(Begin,Begin),
                m_End(End)
            {
                increment();
            }






            template<typename FinderT, typename RangeT>
            find_iterator(
                    RangeT& Col,
                    FinderT Finder ) :
                detail::find_iterator_base<IteratorT>(Finder,0)
            {
                iterator_range<typename range_iterator<RangeT>::type> lit_col(as_literal(Col));
                m_Match=make_iterator_range(::boost::begin(lit_col), ::boost::begin(lit_col));
                m_End=::boost::end(lit_col);

                increment();
            }

        private:



            const match_type& dereference() const
            {
                return m_Match;
            }


            void increment()
            {
                m_Match=this->do_find(m_Match.end(),m_End);
            }


            bool equal( const find_iterator& Other ) const
            {
                bool bEof=eof();
                bool bOtherEof=Other.eof();

                return bEof || bOtherEof ? bEof==bOtherEof :
                    (
                        m_Match==Other.m_Match &&
                        m_End==Other.m_End
                    );
            }

        public:
# 160 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_iterator.hpp" 3
            bool eof() const
            {
                return
                    this->is_null() ||
                    (
                        m_Match.begin() == m_End &&
                        m_Match.end() == m_End
                    );
            }

        private:

            match_type m_Match;
            input_iterator_type m_End;
        };





        template<typename RangeT, typename FinderT>
        inline find_iterator<
            typename range_iterator<RangeT>::type>
        make_find_iterator(
            RangeT& Collection,
            FinderT Finder)
        {
            return find_iterator<typename range_iterator<RangeT>::type>(
                Collection, Finder);
        }
# 205 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_iterator.hpp" 3
        template<typename IteratorT>
        class split_iterator :
            public iterator_facade<
                split_iterator<IteratorT>,
                const iterator_range<IteratorT>,
                forward_traversal_tag >,
            private detail::find_iterator_base<IteratorT>
        {
        private:

            friend class ::boost::iterator_core_access;

        private:


            typedef detail::find_iterator_base<IteratorT> base_type;
            typedef typename
                base_type::input_iterator_type input_iterator_type;
            typedef typename
                base_type::match_type match_type;

        public:






            split_iterator() {}




            split_iterator( const split_iterator& Other ) :
                base_type(Other),
                m_Match(Other.m_Match),
                m_Next(Other.m_Next),
                m_End(Other.m_End),
                m_bEof(false)
            {}






            template<typename FinderT>
            split_iterator(
                    IteratorT Begin,
                    IteratorT End,
                    FinderT Finder ) :
                detail::find_iterator_base<IteratorT>(Finder,0),
                m_Match(Begin,Begin),
                m_Next(Begin),
                m_End(End),
                m_bEof(false)
            {
                increment();
            }





            template<typename FinderT, typename RangeT>
            split_iterator(
                    RangeT& Col,
                    FinderT Finder ) :
                detail::find_iterator_base<IteratorT>(Finder,0),
                m_bEof(false)
            {
                iterator_range<typename range_iterator<RangeT>::type> lit_col(as_literal(Col));
                m_Match=make_iterator_range(::boost::begin(lit_col), ::boost::begin(lit_col));
                m_Next=::boost::begin(lit_col);
                m_End=::boost::end(lit_col);

                increment();
            }


        private:



            const match_type& dereference() const
            {
                return m_Match;
            }


            void increment()
            {
                match_type FindMatch=this->do_find( m_Next, m_End );

                if(FindMatch.begin()==m_End && FindMatch.end()==m_End)
                {
                    if(m_Match.end()==m_End)
                    {

                        m_bEof=true;
                    }
                }

                m_Match=match_type( m_Next, FindMatch.begin() );
                m_Next=FindMatch.end();
            }


            bool equal( const split_iterator& Other ) const
            {
                bool bEof=eof();
                bool bOtherEof=Other.eof();

                return bEof || bOtherEof ? bEof==bOtherEof :
                    (
                        m_Match==Other.m_Match &&
                        m_Next==Other.m_Next &&
                        m_End==Other.m_End
                    );
            }

        public:
# 335 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/find_iterator.hpp" 3
            bool eof() const
            {
                return this->is_null() || m_bEof;
            }

        private:

            match_type m_Match;
            input_iterator_type m_Next;
            input_iterator_type m_End;
            bool m_bEof;
        };





        template<typename RangeT, typename FinderT>
        inline split_iterator<
            typename range_iterator<RangeT>::type>
        make_split_iterator(
            RangeT& Collection,
            FinderT Finder)
        {
            return split_iterator<typename range_iterator<RangeT>::type>(
                Collection, Finder);
        }


    }


    using algorithm::find_iterator;
    using algorithm::make_find_iterator;
    using algorithm::split_iterator;
    using algorithm::make_split_iterator;

}
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/iter_find.hpp" 2 3
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/iter_find.hpp" 3
namespace boost {
    namespace algorithm {
# 67 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/iter_find.hpp" 3
        template<
            typename SequenceSequenceT,
            typename RangeT,
            typename FinderT >
        inline SequenceSequenceT&
        iter_find(
            SequenceSequenceT& Result,
            RangeT& Input,
            FinderT Finder )
        {
            function_requires<
                FinderConcept<FinderT,
                typename range_iterator<RangeT>::type> >();

            iterator_range<typename range_iterator<RangeT>::type> lit_input(as_literal(Input));

            typedef typename
                range_iterator<RangeT>::type input_iterator_type;
            typedef find_iterator<input_iterator_type> find_iterator_type;
            typedef detail::copy_iterator_rangeF<
                typename
                    range_value<SequenceSequenceT>::type,
                input_iterator_type> copy_range_type;

            input_iterator_type InputEnd=::boost::end(lit_input);

            typedef transform_iterator<copy_range_type, find_iterator_type>
                transform_iter_type;

            transform_iter_type itBegin=
                make_transform_iterator(
                    find_iterator_type( ::boost::begin(lit_input), InputEnd, Finder ),
                    copy_range_type());

            transform_iter_type itEnd=
                make_transform_iterator(
                    find_iterator_type(),
                    copy_range_type());

            SequenceSequenceT Tmp(itBegin, itEnd);

            Result.swap(Tmp);
            return Result;
        }
# 136 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/iter_find.hpp" 3
        template<
            typename SequenceSequenceT,
            typename RangeT,
            typename FinderT >
        inline SequenceSequenceT&
        iter_split(
            SequenceSequenceT& Result,
            RangeT& Input,
            FinderT Finder )
        {
            function_requires<
                FinderConcept<FinderT,
                typename range_iterator<RangeT>::type> >();

            iterator_range<typename range_iterator<RangeT>::type> lit_input(as_literal(Input));

            typedef typename
                range_iterator<RangeT>::type input_iterator_type;
            typedef split_iterator<input_iterator_type> find_iterator_type;
            typedef detail::copy_iterator_rangeF<
                typename
                    range_value<SequenceSequenceT>::type,
                input_iterator_type> copy_range_type;

            input_iterator_type InputEnd=::boost::end(lit_input);

            typedef transform_iterator<copy_range_type, find_iterator_type>
                transform_iter_type;

            transform_iter_type itBegin=
                make_transform_iterator(
                    find_iterator_type( ::boost::begin(lit_input), InputEnd, Finder ),
                    copy_range_type() );

            transform_iter_type itEnd=
                make_transform_iterator(
                    find_iterator_type(),
                    copy_range_type() );

            SequenceSequenceT Tmp(itBegin, itEnd);

            Result.swap(Tmp);
            return Result;
        }

    }


    using algorithm::iter_find;
    using algorithm::iter_split;

}
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/split.hpp" 2 3
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/split.hpp" 3
namespace boost {
    namespace algorithm {
# 61 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/split.hpp" 3
        template< typename SequenceSequenceT, typename Range1T, typename Range2T >
        inline SequenceSequenceT& find_all(
            SequenceSequenceT& Result,
            Range1T& Input,
            const Range2T& Search)
        {
            return iter_find(
                Result,
                Input,
                first_finder(Search) );
        }
# 96 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/split.hpp" 3
        template< typename SequenceSequenceT, typename Range1T, typename Range2T >
        inline SequenceSequenceT& ifind_all(
            SequenceSequenceT& Result,
            Range1T& Input,
            const Range2T& Search,
            const std::locale& Loc=std::locale() )
        {
            return iter_find(
                Result,
                Input,
                first_finder(Search, is_iequal(Loc) ) );
        }
# 139 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/split.hpp" 3
        template< typename SequenceSequenceT, typename RangeT, typename PredicateT >
        inline SequenceSequenceT& split(
            SequenceSequenceT& Result,
            RangeT& Input,
            PredicateT Pred,
            token_compress_mode_type eCompress=token_compress_off )
        {
            return iter_split(
                Result,
                Input,
                token_finder( Pred, eCompress ) );
        }

    }


    using algorithm::find_all;
    using algorithm::ifind_all;
    using algorithm::split;

}
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/join.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/join.hpp" 3
namespace boost {
    namespace algorithm {
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/join.hpp" 3
        template< typename SequenceSequenceT, typename Range1T>
        inline typename range_value<SequenceSequenceT>::type
        join(
            const SequenceSequenceT& Input,
            const Range1T& Separator)
        {

            typedef typename range_value<SequenceSequenceT>::type ResultT;
            typedef typename range_const_iterator<SequenceSequenceT>::type InputIteratorT;


            InputIteratorT itBegin=::boost::begin(Input);
            InputIteratorT itEnd=::boost::end(Input);


            ResultT Result;


            if(itBegin!=itEnd)
            {
                detail::insert(Result, ::boost::end(Result), *itBegin);
                ++itBegin;
            }

            for(;itBegin!=itEnd; ++itBegin)
            {

                detail::insert(Result, ::boost::end(Result), as_literal(Separator));

                detail::insert(Result, ::boost::end(Result), *itBegin);
            }

            return Result;
        }
# 94 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/join.hpp" 3
        template< typename SequenceSequenceT, typename Range1T, typename PredicateT>
        inline typename range_value<SequenceSequenceT>::type
        join_if(
            const SequenceSequenceT& Input,
            const Range1T& Separator,
            PredicateT Pred)
        {

            typedef typename range_value<SequenceSequenceT>::type ResultT;
            typedef typename range_const_iterator<SequenceSequenceT>::type InputIteratorT;


            InputIteratorT itBegin=::boost::begin(Input);
            InputIteratorT itEnd=::boost::end(Input);


            ResultT Result;


            while(itBegin!=itEnd && !Pred(*itBegin)) ++itBegin;

            if(itBegin!=itEnd)
            {
                detail::insert(Result, ::boost::end(Result), *itBegin);
                ++itBegin;
            }

            for(;itBegin!=itEnd; ++itBegin)
            {
                if(Pred(*itBegin))
                {

                    detail::insert(Result, ::boost::end(Result), as_literal(Separator));

                    detail::insert(Result, ::boost::end(Result), *itBegin);
                }
            }

            return Result;
        }

    }


    using algorithm::join;
    using algorithm::join_if;

}
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 1 3
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
namespace boost {
    namespace algorithm {
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename OutputIteratorT, typename RangeT>
        inline OutputIteratorT erase_range_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            const iterator_range<
                typename
                    range_const_iterator<RangeT>::type>& SearchRange )
        {
            return find_format_copy(
                Output,
                Input,
                range_finder(SearchRange),
                empty_formatter(Input) );
        }





        template<typename SequenceT>
        inline SequenceT erase_range_copy(
            const SequenceT& Input,
            const iterator_range<
                typename
                    range_const_iterator<SequenceT>::type>& SearchRange )
        {
            return find_format_copy(
                Input,
                range_finder(SearchRange),
                empty_formatter(Input) );
        }
# 89 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename SequenceT>
        inline void erase_range(
            SequenceT& Input,
            const iterator_range<
                typename
                    range_iterator<SequenceT>::type>& SearchRange )
        {
            find_format(
                Input,
                range_finder(SearchRange),
                empty_formatter(Input) );
        }
# 118 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT erase_first_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search )
        {
            return find_format_copy(
                Output,
                Input,
                first_finder(Search),
                empty_formatter(Input) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT erase_first_copy(
            const SequenceT& Input,
            const RangeT& Search )
        {
            return find_format_copy(
                Input,
                first_finder(Search),
                empty_formatter(Input) );
        }
# 157 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void erase_first(
            SequenceT& Input,
            const RangeT& Search )
        {
            find_format(
                Input,
                first_finder(Search),
                empty_formatter(Input) );
        }
# 186 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT ierase_first_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Output,
                Input,
                first_finder(Search, is_iequal(Loc)),
                empty_formatter(Input) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT ierase_first_copy(
            const SequenceT& Input,
            const RangeT& Search,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Input,
                first_finder(Search, is_iequal(Loc)),
                empty_formatter(Input) );
        }
# 228 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void ierase_first(
            SequenceT& Input,
            const RangeT& Search,
            const std::locale& Loc=std::locale() )
        {
            find_format(
                Input,
                first_finder(Search, is_iequal(Loc)),
                empty_formatter(Input) );
        }
# 256 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT erase_last_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search )
        {
            return find_format_copy(
                Output,
                Input,
                last_finder(Search),
                empty_formatter(Input) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT erase_last_copy(
            const SequenceT& Input,
            const RangeT& Search )
        {
            return find_format_copy(
                Input,
                last_finder(Search),
                empty_formatter(Input) );
        }
# 295 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void erase_last(
            SequenceT& Input,
            const RangeT& Search )
        {
            find_format(
                Input,
                last_finder(Search),
                empty_formatter(Input) );
        }
# 324 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT ierase_last_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Output,
                Input,
                last_finder(Search, is_iequal(Loc)),
                empty_formatter(Input) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT ierase_last_copy(
            const SequenceT& Input,
            const RangeT& Search,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Input,
                last_finder(Search, is_iequal(Loc)),
                empty_formatter(Input) );
        }
# 366 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void ierase_last(
            SequenceT& Input,
            const RangeT& Search,
            const std::locale& Loc=std::locale() )
        {
            find_format(
                Input,
                last_finder(Search, is_iequal(Loc)),
                empty_formatter(Input) );
        }
# 397 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT erase_nth_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            int Nth )
        {
            return find_format_copy(
                Output,
                Input,
                nth_finder(Search, Nth),
                empty_formatter(Input) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT erase_nth_copy(
            const SequenceT& Input,
            const RangeT& Search,
            int Nth )
        {
            return find_format_copy(
                Input,
                nth_finder(Search, Nth),
                empty_formatter(Input) );
        }
# 440 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void erase_nth(
            SequenceT& Input,
            const RangeT& Search,
            int Nth )
        {
            find_format(
                Input,
                nth_finder(Search, Nth),
                empty_formatter(Input) );
        }
# 472 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT ierase_nth_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            int Nth,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Output,
                Input,
                nth_finder(Search, Nth, is_iequal(Loc)),
                empty_formatter(Input) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT ierase_nth_copy(
            const SequenceT& Input,
            const RangeT& Search,
            int Nth,
            const std::locale& Loc=std::locale() )
        {
            return find_format_copy(
                Input,
                nth_finder(Search, Nth, is_iequal(Loc)),
                empty_formatter(Input) );
        }
# 518 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void ierase_nth(
            SequenceT& Input,
            const RangeT& Search,
            int Nth,
            const std::locale& Loc=std::locale() )
        {
            find_format(
                Input,
                nth_finder(Search, Nth, is_iequal(Loc)),
                empty_formatter(Input) );
        }
# 549 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT erase_all_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search )
        {
            return find_format_all_copy(
                Output,
                Input,
                first_finder(Search),
                empty_formatter(Input) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT erase_all_copy(
            const SequenceT& Input,
            const RangeT& Search )
        {
            return find_format_all_copy(
                Input,
                first_finder(Search),
                empty_formatter(Input) );
        }
# 588 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void erase_all(
            SequenceT& Input,
            const RangeT& Search )
        {
            find_format_all(
                Input,
                first_finder(Search),
                empty_formatter(Input) );
        }
# 617 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT ierase_all_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const std::locale& Loc=std::locale() )
        {
            return find_format_all_copy(
                Output,
                Input,
                first_finder(Search, is_iequal(Loc)),
                empty_formatter(Input) );
        }





        template<typename SequenceT, typename RangeT>
        inline SequenceT ierase_all_copy(
            const SequenceT& Input,
            const RangeT& Search,
            const std::locale& Loc=std::locale() )
        {
            return find_format_all_copy(
                Input,
                first_finder(Search, is_iequal(Loc)),
                empty_formatter(Input) );
        }
# 659 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename SequenceT, typename RangeT>
        inline void ierase_all(
            SequenceT& Input,
            const RangeT& Search,
            const std::locale& Loc=std::locale() )
        {
            find_format_all(
                Input,
                first_finder(Search, is_iequal(Loc)),
                empty_formatter(Input) );
        }
# 691 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<
            typename OutputIteratorT,
            typename RangeT>
        inline OutputIteratorT erase_head_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            int N )
        {
            return find_format_copy(
                Output,
                Input,
                head_finder(N),
                empty_formatter( Input ) );
        }





        template<typename SequenceT>
        inline SequenceT erase_head_copy(
            const SequenceT& Input,
            int N )
        {
            return find_format_copy(
                Input,
                head_finder(N),
                empty_formatter( Input ) );
        }
# 732 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename SequenceT>
        inline void erase_head(
            SequenceT& Input,
            int N )
        {
            find_format(
                Input,
                head_finder(N),
                empty_formatter( Input ) );
        }
# 763 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<
            typename OutputIteratorT,
            typename RangeT>
        inline OutputIteratorT erase_tail_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            int N )
        {
            return find_format_copy(
                Output,
                Input,
                tail_finder(N),
                empty_formatter( Input ) );
        }





        template<typename SequenceT>
        inline SequenceT erase_tail_copy(
            const SequenceT& Input,
            int N )
        {
            return find_format_copy(
                Input,
                tail_finder(N),
                empty_formatter( Input ) );
        }
# 804 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string/erase.hpp" 3
        template<typename SequenceT>
        inline void erase_tail(
            SequenceT& Input,
            int N )
        {
            find_format(
                Input,
                tail_finder(N),
                empty_formatter( Input ) );
        }

    }


    using algorithm::erase_range_copy;
    using algorithm::erase_range;
    using algorithm::erase_first_copy;
    using algorithm::erase_first;
    using algorithm::ierase_first_copy;
    using algorithm::ierase_first;
    using algorithm::erase_last_copy;
    using algorithm::erase_last;
    using algorithm::ierase_last_copy;
    using algorithm::ierase_last;
    using algorithm::erase_nth_copy;
    using algorithm::erase_nth;
    using algorithm::ierase_nth_copy;
    using algorithm::ierase_nth;
    using algorithm::erase_all_copy;
    using algorithm::erase_all;
    using algorithm::ierase_all_copy;
    using algorithm::ierase_all;
    using algorithm::erase_head_copy;
    using algorithm::erase_head;
    using algorithm::erase_tail_copy;
    using algorithm::erase_tail;

}
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/algorithm/string.hpp" 2 3
# 39 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentRegistry.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 1 3
# 20 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/config.hpp" 1 3
# 110 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/auto_link.hpp" 1 3
# 111 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/config.hpp" 2 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/system_error.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/system_error.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/system_error.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/error_code.hpp" 1 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/error_code.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/config.hpp" 1 3
# 71 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/auto_link.hpp" 1 3
# 72 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/config.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/error_code.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/error_code.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/error_code.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/error_code.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cerrno.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cerrno.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cerrno" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cerrno" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cerrno" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/errno.h" 1 3 4
# 49 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cerrno" 2 3
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cerrno.hpp" 2 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/error_code.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/error_code.hpp" 2 3

namespace boost
{
  namespace system
  {

    class error_code;
    class error_condition;



    template< class T >
    struct is_error_code_enum { static const bool value = false; };

    template< class T >
    struct is_error_condition_enum { static const bool value = false; };



    namespace errc
    {
      enum errc_t
      {
        success = 0,
        address_family_not_supported = 47,
        address_in_use = 48,
        address_not_available = 49,
        already_connected = 56,
        argument_list_too_long = 7,
        argument_out_of_domain = 33,
        bad_address = 14,
        bad_file_descriptor = 9,
        bad_message = 94,
        broken_pipe = 32,
        connection_aborted = 53,
        connection_already_in_progress = 37,
        connection_refused = 61,
        connection_reset = 54,
        cross_device_link = 18,
        destination_address_required = 39,
        device_or_resource_busy = 16,
        directory_not_empty = 66,
        executable_format_error = 8,
        file_exists = 17,
        file_too_large = 27,
        filename_too_long = 63,
        function_not_supported = 78,
        host_unreachable = 65,
        identifier_removed = 90,
        illegal_byte_sequence = 92,
        inappropriate_io_control_operation = 25,
        interrupted = 4,
        invalid_argument = 22,
        invalid_seek = 29,
        io_error = 5,
        is_a_directory = 21,
        message_size = 40,
        network_down = 50,
        network_reset = 52,
        network_unreachable = 51,
        no_buffer_space = 55,
        no_child_process = 10,
        no_link = 97,
        no_lock_available = 77,
        no_message_available = 96,
        no_message = 91,
        no_protocol_option = 42,
        no_space_on_device = 28,
        no_stream_resources = 98,
        no_such_device_or_address = 6,
        no_such_device = 19,
        no_such_file_or_directory = 2,
        no_such_process = 3,
        not_a_directory = 20,
        not_a_socket = 38,
        not_a_stream = 99,
        not_connected = 57,
        not_enough_memory = 12,
        not_supported = 45,
        operation_canceled = 89,
        operation_in_progress = 36,
        operation_not_permitted = 1,
        operation_not_supported = 102,
        operation_would_block = 35,
        owner_dead = 9931,
        permission_denied = 13,
        protocol_error = 100,
        protocol_not_supported = 43,
        read_only_file_system = 30,
        resource_deadlock_would_occur = 11,
        resource_unavailable_try_again = 35,
        result_out_of_range = 34,
        state_not_recoverable = 9934,
        stream_timeout = 101,
        text_file_busy = 26,
        timed_out = 60,
        too_many_files_open_in_system = 23,
        too_many_files_open = 24,
        too_many_links = 31,
        too_many_synbolic_link_levels = 62,
        value_too_large = 84,
        wrong_protocol_type = 41
      };

    }


    namespace posix = errc;
    namespace posix_error = errc;


    template<> struct is_error_condition_enum<errc::errc_t>
      { static const bool value = true; };
# 182 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/error_code.hpp" 3
    class error_category : public noncopyable
    {
    public:
      virtual ~error_category(){}
      virtual inline const char * name() const;
      virtual inline std::string message( int ev ) const;
      virtual inline error_condition default_error_condition( int ev ) const;
      virtual inline bool equivalent( int code, const error_condition & condition ) const;
      virtual inline bool equivalent( const error_code & code, int condition ) const;

      bool operator==(const error_category & rhs) const { return this == &rhs; }
      bool operator!=(const error_category & rhs) const { return this != &rhs; }
      bool operator<( const error_category & rhs ) const
      {
        return std::less<const error_category*>()( this, &rhs );
      }
    };



    const error_category & get_system_category();
    const error_category & get_generic_category();

    static const error_category & system_category = get_system_category();
    static const error_category & generic_category = get_generic_category();



    static const error_category & posix_category = get_generic_category();
    static const error_category & errno_ecat = get_generic_category();
    static const error_category & native_ecat = get_system_category();






    class error_condition
    {
    public:


      error_condition() : m_val(0), m_cat(&get_generic_category()) {}
      error_condition( int val, const error_category & cat ) : m_val(val), m_cat(&cat) {}

      template <class ConditionEnum>
        error_condition(ConditionEnum e,
          typename boost::enable_if<is_error_condition_enum<ConditionEnum> >::type* = 0)
      {
        *this = make_error_condition(e);
      }



      void assign( int val, const error_category & cat )
      {
        m_val = val;
        m_cat = &cat;
      }

      template<typename ConditionEnum>
        typename boost::enable_if<is_error_condition_enum<ConditionEnum>, error_condition>::type &
          operator=( ConditionEnum val )
      {
        *this = make_error_condition(val);
        return *this;
      }

      void clear()
      {
        m_val = 0;
        m_cat = &get_generic_category();
      }


      int value() const { return m_val; }
      const error_category & category() const { return *m_cat; }
      std::string message() const { return m_cat->message(value()); }

      typedef void (*unspecified_bool_type)();
      static void unspecified_bool_true() {}

      operator unspecified_bool_type() const
      {
        return m_val == 0 ? 0 : unspecified_bool_true;
      }

      bool operator!() const
      {
        return m_val == 0;
      }




      inline friend bool operator==( const error_condition & lhs,
                                     const error_condition & rhs )
      {
        return lhs.m_cat == rhs.m_cat && lhs.m_val == rhs.m_val;
      }

      inline friend bool operator<( const error_condition & lhs,
                                    const error_condition & rhs )


      {
        return lhs.m_cat < rhs.m_cat
          || (lhs.m_cat == rhs.m_cat && lhs.m_val < rhs.m_val);
      }

    private:
      int m_val;
      const error_category * m_cat;

    };
# 306 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/error_code.hpp" 3
    class error_code
    {
    public:


      error_code() : m_val(0), m_cat(&get_system_category()) {}
      error_code( int val, const error_category & cat ) : m_val(val), m_cat(&cat) {}

      template <class CodeEnum>
        error_code(CodeEnum e,
          typename boost::enable_if<is_error_code_enum<CodeEnum> >::type* = 0)
      {
        *this = make_error_code(e);
      }


      void assign( int val, const error_category & cat )
      {
        m_val = val;
        m_cat = &cat;
      }

      template<typename CodeEnum>
        typename boost::enable_if<is_error_code_enum<CodeEnum>, error_code>::type &
          operator=( CodeEnum val )
      {
        *this = make_error_code(val);
        return *this;
      }

      void clear()
      {
        m_val = 0;
        m_cat = &get_system_category();
      }


      int value() const { return m_val; }
      const error_category & category() const { return *m_cat; }
      error_condition default_error_condition() const { return m_cat->default_error_condition(value()); }
      std::string message() const { return m_cat->message(value()); }

      typedef void (*unspecified_bool_type)();
      static void unspecified_bool_true() {}

      operator unspecified_bool_type() const
      {
        return m_val == 0 ? 0 : unspecified_bool_true;
      }

      bool operator!() const
      {
        return m_val == 0;
      }


      inline friend bool operator==( const error_code & lhs,
                                     const error_code & rhs )


      {
        return lhs.m_cat == rhs.m_cat && lhs.m_val == rhs.m_val;
      }

      inline friend bool operator<( const error_code & lhs,
                                    const error_code & rhs )


      {
        return lhs.m_cat < rhs.m_cat
          || (lhs.m_cat == rhs.m_cat && lhs.m_val < rhs.m_val);
      }

      private:
      int m_val;
      const error_category * m_cat;

    };



    inline bool operator!=( const error_code & lhs,
                            const error_code & rhs )
    {
      return !(lhs == rhs);
    }

    inline bool operator!=( const error_condition & lhs,
                            const error_condition & rhs )
    {
      return !(lhs == rhs);
    }

    inline bool operator==( const error_code & code,
                            const error_condition & condition )
    {
      return code.category().equivalent( code.value(), condition )
        || condition.category().equivalent( code, condition.value() );
    }

    inline bool operator!=( const error_code & lhs,
                            const error_condition & rhs )
    {
      return !(lhs == rhs);
    }

    inline bool operator==( const error_condition & condition,
                            const error_code & code )
    {
      return condition.category().equivalent( code, condition.value() )
        || code.category().equivalent( code.value(), condition );
    }

    inline bool operator!=( const error_condition & lhs,
                            const error_code & rhs )
    {
      return !(lhs == rhs);
    }



    template <class charT, class traits>
    inline std::basic_ostream<charT,traits>&
      operator<< (std::basic_ostream<charT,traits>& os, error_code ec)
    {
      os << ec.category().name() << ':' << ec.value();
      return os;
    }

    inline std::size_t hash_value( const error_code & ec )
    {
      return static_cast<std::size_t>(ec.value())
        + reinterpret_cast<std::size_t>(&ec.category());
    }



    namespace errc
    {

      inline error_code make_error_code( errc_t e )
        { return error_code( e, get_generic_category() ); }


      inline error_condition make_error_condition( errc_t e )
        { return error_condition( e, get_generic_category() ); }
    }



    inline error_condition error_category::default_error_condition( int ev ) const
    {
      return error_condition( ev, *this );
    }

    inline bool error_category::equivalent( int code,
      const error_condition & condition ) const
    {
      return default_error_condition( code ) == condition;
    }

    inline bool error_category::equivalent( const error_code & code,
      int condition ) const
    {
      return *this == code.category() && code.value() == condition;
    }



    inline const char * error_category::name() const
    {
      return "error: should never be called";
    }

    inline std::string error_category::message( int ) const
    {
      static std::string s("error: should never be called");
      return s;
    }

  }
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 490 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/error_code.hpp" 2 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/system/system_error.hpp" 2 3

namespace boost
{
  namespace system
  {


    class system_error : public std::runtime_error
    {
    public:
      system_error( error_code ec )
          : std::runtime_error(""), m_error_code(ec) {}

      system_error( error_code ec, const std::string & what_arg )
          : std::runtime_error(what_arg), m_error_code(ec) {}

      system_error( error_code ec, const char* what_arg )
          : std::runtime_error(what_arg), m_error_code(ec) {}

      system_error( int ev, const error_category & ecat )
          : std::runtime_error(""), m_error_code(ev,ecat) {}

      system_error( int ev, const error_category & ecat,
        const std::string & what_arg )
          : std::runtime_error(what_arg), m_error_code(ev,ecat) {}

      system_error( int ev, const error_category & ecat,
        const char * what_arg )
          : std::runtime_error(what_arg), m_error_code(ev,ecat) {}

      virtual ~system_error() throw() {}

      const error_code & code() const throw() { return m_error_code; }
      const char * what() const throw();

    private:
      error_code m_error_code;
      mutable std::string m_what;
    };



    inline const char * system_error::what() const throw()

    {
      if ( m_what.empty() )
      {
        try
        {
          m_what = this->std::runtime_error::what();
          if ( m_error_code )
          {
            if ( !m_what.empty() ) m_what += ": ";
            m_what += m_error_code.message();
          }
        }
        catch (...) { return std::runtime_error::what(); }
      }
      return m_what.c_str();
    }

  }
}
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_prefix.hpp" 1 3
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 2 3



namespace boost
{
  namespace filesystem
  {
    template<class String, class Traits> class basic_path;

    struct path_traits;
    typedef basic_path< std::string, path_traits > path;

    struct path_traits
    {
      typedef std::string internal_string_type;
      typedef std::string external_string_type;
      static external_string_type to_external( const path &,
        const internal_string_type & src ) { return src; }
      static internal_string_type to_internal(
        const external_string_type & src ) { return src; }
    };



    struct wpath_traits;

    typedef basic_path< std::wstring, wpath_traits > wpath;

    struct wpath_traits
    {
      typedef std::wstring internal_string_type;







      typedef std::string external_string_type;
      static external_string_type to_external( const wpath & ph,
        const internal_string_type & src );
      static internal_string_type to_internal(
        const external_string_type & src );

      static void imbue( const std::locale & loc );
      static bool imbue( const std::locale & loc, const std::nothrow_t & );
    };





    template<class Path> struct is_basic_path
      { static const bool value = false; };
    template<> struct is_basic_path<path>
      { static const bool value = true; };

    template<> struct is_basic_path<wpath>
      { static const bool value = true; };




    template<class Path> struct slash
      { static const char value = '/'; };

    template<class Path> struct dot
      { static const char value = '.'; };

    template<class Path> struct colon
      { static const char value = ':'; };







    namespace detail
    {
      template<class Path>
      class iterator_helper
      {
      public:
        typedef typename Path::iterator iterator;
        static void do_increment( iterator & ph );
        static void do_decrement( iterator & ph );
      };
    }



    template<class String, class Traits>
    class basic_path
    {







    public:


      typedef basic_path<String, Traits> path_type;
      typedef String string_type;
      typedef typename String::value_type value_type;
      typedef Traits traits_type;
      typedef typename Traits::external_string_type external_string_type;


      basic_path() {}
      basic_path( const string_type & s ) { operator/=( s ); }
      basic_path( const value_type * s ) { operator/=( s ); }

        template <class InputIterator>
          basic_path( InputIterator first, InputIterator last )
            { append( first, last ); }

     ~basic_path() {}


      basic_path & operator=( const string_type & s )
      {



        m_path.erase( m_path.begin(), m_path.end() );

        operator/=( s );
        return *this;
      }
      basic_path & operator=( const value_type * s )
      {



        m_path.erase( m_path.begin(), m_path.end() );

        operator/=( s );
        return *this;
      }

        template <class InputIterator>
          basic_path & assign( InputIterator first, InputIterator last )
            { m_path.clear(); append( first, last ); return *this; }



      basic_path & operator/=( const basic_path & rhs ) { return operator /=( rhs.string().c_str() ); }
      basic_path & operator/=( const string_type & rhs ) { return operator /=( rhs.c_str() ); }
      basic_path & operator/=( const value_type * s );

        template <class InputIterator>
          basic_path & append( InputIterator first, InputIterator last );


      void swap( basic_path & rhs )
      {
        m_path.swap( rhs.m_path );



      }

      basic_path & remove_filename();
      basic_path & replace_extension( const string_type & new_extension = "" );


      basic_path & remove_leaf() { return remove_filename(); }



      const string_type & string() const { return m_path; }
      const string_type file_string() const;
      const string_type directory_string() const { return file_string(); }

      const external_string_type external_file_string() const { return Traits::to_external( *this, file_string() ); }
      const external_string_type external_directory_string() const { return Traits::to_external( *this, directory_string() ); }

      basic_path root_path() const;
      string_type root_name() const;
      string_type root_directory() const;
      basic_path relative_path() const;
      basic_path parent_path() const;
      string_type filename() const;
      string_type stem() const;
      string_type extension() const;


      string_type leaf() const { return filename(); }
      basic_path branch_path() const { return parent_path(); }


      bool empty() const { return m_path.empty(); }
      bool is_complete() const;
      bool has_root_path() const;
      bool has_root_name() const;
      bool has_root_directory() const;
      bool has_relative_path() const { return !relative_path().empty(); }
      bool has_filename() const { return !m_path.empty(); }
      bool has_parent_path() const { return !parent_path().empty(); }


      class iterator : public boost::iterator_facade<
        iterator,
        string_type const,
        boost::bidirectional_traversal_tag >
      {
      private:
        friend class boost::iterator_core_access;
        friend class boost::filesystem::basic_path<String, Traits>;

        const string_type & dereference() const
          { return m_name; }
        bool equal( const iterator & rhs ) const
          { return m_path_ptr == rhs.m_path_ptr && m_pos == rhs.m_pos; }

        friend class boost::filesystem::detail::iterator_helper<path_type>;

        void increment()
        {
          boost::filesystem::detail::iterator_helper<path_type>::do_increment(
            *this );
        }
        void decrement()
        {
          boost::filesystem::detail::iterator_helper<path_type>::do_decrement(
            *this );
        }

        string_type m_name;
        const basic_path * m_path_ptr;
        typename string_type::size_type m_pos;



      };

      typedef iterator const_iterator;

      iterator begin() const;
      iterator end() const;

    private:
# 294 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 3
      string_type m_path;







      void m_append_separator_if_needed();
      void m_append( value_type value );



      friend class iterator;
      friend class boost::filesystem::detail::iterator_helper<path_type>;




    public:
      typedef bool (*name_check)( const std::string & name );
      basic_path( const string_type & str, name_check ) { operator/=( str ); }
      basic_path( const typename string_type::value_type * s, name_check )
        { operator/=( s );}
      string_type native_file_string() const { return file_string(); }
      string_type native_directory_string() const { return directory_string(); }
      static bool default_name_check_writable() { return false; }
      static void default_name_check( name_check ) {}
      static name_check default_name_check() { return 0; }
      basic_path & canonize();
      basic_path & normalize();

    };



    template< class String, class Traits >
    inline void swap( basic_path<String, Traits> & lhs,
               basic_path<String, Traits> & rhs ) { lhs.swap( rhs ); }

    template< class String, class Traits >
    bool operator<( const basic_path<String, Traits> & lhs, const basic_path<String, Traits> & rhs )
    {
      return std::lexicographical_compare(
        lhs.begin(), lhs.end(), rhs.begin(), rhs.end() );
    }

    template< class String, class Traits >
    bool operator<( const typename basic_path<String, Traits>::string_type::value_type * lhs,
                    const basic_path<String, Traits> & rhs )
    {
      basic_path<String, Traits> tmp( lhs );
      return std::lexicographical_compare(
        tmp.begin(), tmp.end(), rhs.begin(), rhs.end() );
    }

    template< class String, class Traits >
    bool operator<( const typename basic_path<String, Traits>::string_type & lhs,
                    const basic_path<String, Traits> & rhs )
    {
      basic_path<String, Traits> tmp( lhs );
      return std::lexicographical_compare(
        tmp.begin(), tmp.end(), rhs.begin(), rhs.end() );
    }

    template< class String, class Traits >
    bool operator<( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type::value_type * rhs )
    {
      basic_path<String, Traits> tmp( rhs );
      return std::lexicographical_compare(
        lhs.begin(), lhs.end(), tmp.begin(), tmp.end() );
    }

    template< class String, class Traits >
    bool operator<( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type & rhs )
    {
      basic_path<String, Traits> tmp( rhs );
      return std::lexicographical_compare(
        lhs.begin(), lhs.end(), tmp.begin(), tmp.end() );
    }

    template< class String, class Traits >
    inline bool operator==( const basic_path<String, Traits> & lhs, const basic_path<String, Traits> & rhs )
    {
      return !(lhs < rhs) && !(rhs < lhs);
    }

    template< class String, class Traits >
    inline bool operator==( const typename basic_path<String, Traits>::string_type::value_type * lhs,
                    const basic_path<String, Traits> & rhs )
    {
      basic_path<String, Traits> tmp( lhs );
      return !(tmp < rhs) && !(rhs < tmp);
    }

    template< class String, class Traits >
    inline bool operator==( const typename basic_path<String, Traits>::string_type & lhs,
                    const basic_path<String, Traits> & rhs )
    {
      basic_path<String, Traits> tmp( lhs );
      return !(tmp < rhs) && !(rhs < tmp);
    }

    template< class String, class Traits >
    inline bool operator==( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type::value_type * rhs )
    {
      basic_path<String, Traits> tmp( rhs );
      return !(lhs < tmp) && !(tmp < lhs);
    }

    template< class String, class Traits >
    inline bool operator==( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type & rhs )
    {
      basic_path<String, Traits> tmp( rhs );
      return !(lhs < tmp) && !(tmp < lhs);
    }

    template< class String, class Traits >
    inline bool operator!=( const basic_path<String, Traits> & lhs, const basic_path<String, Traits> & rhs ) { return !(lhs == rhs); }

    template< class String, class Traits >
    inline bool operator!=( const typename basic_path<String, Traits>::string_type::value_type * lhs,
                    const basic_path<String, Traits> & rhs ) { return !(basic_path<String, Traits>(lhs) == rhs); }

    template< class String, class Traits >
    inline bool operator!=( const typename basic_path<String, Traits>::string_type & lhs,
                    const basic_path<String, Traits> & rhs ) { return !(basic_path<String, Traits>(lhs) == rhs); }

    template< class String, class Traits >
    inline bool operator!=( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type::value_type * rhs )
                    { return !(lhs == basic_path<String, Traits>(rhs)); }

    template< class String, class Traits >
    inline bool operator!=( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type & rhs )
                    { return !(lhs == basic_path<String, Traits>(rhs)); }

    template< class String, class Traits >
    inline bool operator>( const basic_path<String, Traits> & lhs, const basic_path<String, Traits> & rhs ) { return rhs < lhs; }

    template< class String, class Traits >
    inline bool operator>( const typename basic_path<String, Traits>::string_type::value_type * lhs,
                    const basic_path<String, Traits> & rhs ) { return rhs < basic_path<String, Traits>(lhs); }

    template< class String, class Traits >
    inline bool operator>( const typename basic_path<String, Traits>::string_type & lhs,
                    const basic_path<String, Traits> & rhs ) { return rhs < basic_path<String, Traits>(lhs); }

    template< class String, class Traits >
    inline bool operator>( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type::value_type * rhs )
                    { return basic_path<String, Traits>(rhs) < lhs; }

    template< class String, class Traits >
    inline bool operator>( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type & rhs )
                    { return basic_path<String, Traits>(rhs) < lhs; }

    template< class String, class Traits >
    inline bool operator<=( const basic_path<String, Traits> & lhs, const basic_path<String, Traits> & rhs ) { return !(rhs < lhs); }

    template< class String, class Traits >
    inline bool operator<=( const typename basic_path<String, Traits>::string_type::value_type * lhs,
                    const basic_path<String, Traits> & rhs ) { return !(rhs < basic_path<String, Traits>(lhs)); }

    template< class String, class Traits >
    inline bool operator<=( const typename basic_path<String, Traits>::string_type & lhs,
                    const basic_path<String, Traits> & rhs ) { return !(rhs < basic_path<String, Traits>(lhs)); }

    template< class String, class Traits >
    inline bool operator<=( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type::value_type * rhs )
                    { return !(basic_path<String, Traits>(rhs) < lhs); }

    template< class String, class Traits >
    inline bool operator<=( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type & rhs )
                    { return !(basic_path<String, Traits>(rhs) < lhs); }

    template< class String, class Traits >
    inline bool operator>=( const basic_path<String, Traits> & lhs, const basic_path<String, Traits> & rhs ) { return !(lhs < rhs); }

    template< class String, class Traits >
    inline bool operator>=( const typename basic_path<String, Traits>::string_type::value_type * lhs,
                    const basic_path<String, Traits> & rhs ) { return !(lhs < basic_path<String, Traits>(rhs)); }

    template< class String, class Traits >
    inline bool operator>=( const typename basic_path<String, Traits>::string_type & lhs,
                    const basic_path<String, Traits> & rhs ) { return !(lhs < basic_path<String, Traits>(rhs)); }

    template< class String, class Traits >
    inline bool operator>=( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type::value_type * rhs )
                    { return !(basic_path<String, Traits>(lhs) < rhs); }

    template< class String, class Traits >
    inline bool operator>=( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type & rhs )
                    { return !(basic_path<String, Traits>(lhs) < rhs); }



    template< class String, class Traits >
    inline basic_path<String, Traits> operator/(
      const basic_path<String, Traits> & lhs,
      const basic_path<String, Traits> & rhs )
      { return basic_path<String, Traits>( lhs ) /= rhs; }

    template< class String, class Traits >
    inline basic_path<String, Traits> operator/(
      const basic_path<String, Traits> & lhs,
      const typename String::value_type * rhs )
      { return basic_path<String, Traits>( lhs ) /=
          basic_path<String, Traits>( rhs ); }

    template< class String, class Traits >
    inline basic_path<String, Traits> operator/(
      const basic_path<String, Traits> & lhs, const String & rhs )
      { return basic_path<String, Traits>( lhs ) /=
          basic_path<String, Traits>( rhs ); }

    template< class String, class Traits >
    inline basic_path<String, Traits> operator/(
      const typename String::value_type * lhs,
      const basic_path<String, Traits> & rhs )
      { return basic_path<String, Traits>( lhs ) /= rhs; }

    template< class String, class Traits >
    inline basic_path<String, Traits> operator/(
      const String & lhs, const basic_path<String, Traits> & rhs )
      { return basic_path<String, Traits>( lhs ) /= rhs; }





    template< class Path >
    std::basic_ostream< typename Path::string_type::value_type,
      typename Path::string_type::traits_type > &
      operator<<
      ( std::basic_ostream< typename Path::string_type::value_type,
      typename Path::string_type::traits_type >& os, const Path & ph )
    {
      os << ph.string();
      return os;
    }

    template< class Path >
    std::basic_istream< typename Path::string_type::value_type,
      typename Path::string_type::traits_type > &
      operator>>
      ( std::basic_istream< typename Path::string_type::value_type,
      typename Path::string_type::traits_type >& is, Path & ph )
    {
      typename Path::string_type str;
      is >> str;
      ph = str;
      return is;
    }
# 592 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 3
    namespace detail
    {

      inline
      const char * what( const char * sys_err_what,
        const path & path1, const path & path2, std::string & target )
      {
        try
        {
          if ( target.empty() )
          {
            target = sys_err_what;
            if ( !path1.empty() )
            {
              target += ": \"";
              target += path1.file_string();
              target += "\"";
            }
            if ( !path2.empty() )
            {
              target += ", \"";
              target += path2.file_string();
              target += "\"";
            }
          }
          return target.c_str();
        }
        catch (...)
        {
          return sys_err_what;
        }
      }

      template<class Path>
      const char * what( const char * sys_err_what,
        const Path & , const Path & , std::string & )
      {
        return sys_err_what;
      }
    }



    template<class Path>
    class basic_filesystem_error : public system::system_error
    {

    public:


      typedef Path path_type;

      basic_filesystem_error( const std::string & what_arg,
        system::error_code ec );

      basic_filesystem_error( const std::string & what_arg,
        const path_type & path1_arg, system::error_code ec );

      basic_filesystem_error( const std::string & what_arg, const path_type & path1_arg,
        const path_type & path2_arg, system::error_code ec );

      ~basic_filesystem_error() throw() {}

      const path_type & path1() const
      {
        static const path_type empty_path;
        return m_imp_ptr.get() ? m_imp_ptr->m_path1 : empty_path ;
      }
      const path_type & path2() const
      {
        static const path_type empty_path;
        return m_imp_ptr.get() ? m_imp_ptr->m_path2 : empty_path ;
      }

      const char * what() const throw()
      {
        if ( !m_imp_ptr.get() )
          return system::system_error::what();
        return detail::what( system::system_error::what(), m_imp_ptr->m_path1,
          m_imp_ptr->m_path2, m_imp_ptr->m_what );
      }

    private:
      struct m_imp
      {
        path_type m_path1;
        path_type m_path2;
        std::string m_what;
      };
      boost::shared_ptr<m_imp> m_imp_ptr;
    };

    typedef basic_filesystem_error<path> filesystem_error;


    typedef basic_filesystem_error<wpath> wfilesystem_error;




    bool portable_posix_name( const std::string & name );
    bool windows_name( const std::string & name );
    bool portable_name( const std::string & name );
    bool portable_directory_name( const std::string & name );
    bool portable_file_name( const std::string & name );
    bool native( const std::string & name );
    inline bool no_check( const std::string & )
      { return true; }



    namespace detail
    {



      template<class Path>
      inline bool is_separator( typename Path::string_type::value_type c )
      {
        return c == slash<Path>::value



          ;
      }



      template<class String, class Traits>
      typename String::size_type filename_pos(
        const String & str,
        typename String::size_type end_pos )

      {
        typedef typename
          boost::filesystem::basic_path<String, Traits> path_type;


        if ( end_pos == 2
          && str[0] == slash<path_type>::value
          && str[1] == slash<path_type>::value ) return 0;


        if ( end_pos && str[end_pos-1] == slash<path_type>::value )
          return end_pos-1;


        typename String::size_type pos(
          str.find_last_of( slash<path_type>::value, end_pos-1 ) );







        return ( pos == String::npos
          || (pos == 1 && str[0] == slash<path_type>::value) )
            ? 0
            : pos + 1;
      }





      template<class String, class Traits>
        void first_element(
          const String & src,
          typename String::size_type & element_pos,
          typename String::size_type & element_size,

          typename String::size_type size = String::npos



          )
      {
        if ( size == String::npos ) size = src.size();
        element_pos = 0;
        element_size = 0;
        if ( src.empty() ) return;

        typedef typename boost::filesystem::basic_path<String, Traits> path_type;

        typename String::size_type cur(0);


        if ( size >= 2 && src[0] == slash<path_type>::value
          && src[1] == slash<path_type>::value
          && (size == 2
            || src[2] != slash<path_type>::value) )
        {
          cur += 2;
          element_size += 2;
        }


        else if ( src[0] == slash<path_type>::value )
        {
          ++element_size;

          while ( cur+1 < size
            && src[cur+1] == slash<path_type>::value )
          {
            ++cur;
            ++element_pos;
          }
          return;
        }





        while ( cur < size



          && src[cur] != slash<path_type>::value )
        {
          ++cur;
          ++element_size;
        }
# 824 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 3
        return;
      }



      template<class String, class Traits>
      typename String::size_type root_directory_start(
        const String & s,
        typename String::size_type size )

      {
        typedef typename boost::filesystem::basic_path<String, Traits> path_type;
# 845 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 3
        if ( size == 2
          && s[0] == slash<path_type>::value
          && s[1] == slash<path_type>::value ) return String::npos;


        if ( size > 3
          && s[0] == slash<path_type>::value
          && s[1] == slash<path_type>::value
          && s[2] != slash<path_type>::value )
        {
          typename String::size_type pos(
            s.find( slash<path_type>::value, 2 ) );
          return pos < size ? pos : String::npos;
        }


        if ( size > 0 && s[0] == slash<path_type>::value ) return 0;

        return String::npos;
      }



      template<class String, class Traits>
      bool is_non_root_slash( const String & str,
        typename String::size_type pos )
      {
        typedef typename
          boost::filesystem::basic_path<String, Traits>
            path_type;

        (__builtin_expect(!(!str.empty() && str[pos] == slash<path_type>::value && "precondition violation"), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp", 877, "!str.empty() && str[pos] == slash<path_type>::value && \"precondition violation\"") : (void)0);



        while ( pos > 0 && str[pos-1] == slash<path_type>::value )
          --pos;

        return pos != 0
          && (pos <= 2 || str[1] != slash<path_type>::value
            || str.find( slash<path_type>::value, 2 ) != pos)



            ;
      }
    }



    template<class String, class Traits>
    String basic_path<String, Traits>::filename() const
    {
      typename String::size_type end_pos(
        detail::filename_pos<String, Traits>( m_path, m_path.size() ) );
      return (m_path.size()
                && end_pos
                && m_path[end_pos] == slash<path_type>::value
                && detail::is_non_root_slash< String, Traits >(m_path, end_pos))
        ? String( 1, dot<path_type>::value )
        : m_path.substr( end_pos );
    }

    template<class String, class Traits>
    String basic_path<String, Traits>::stem() const
    {
      string_type name = filename();
      typename string_type::size_type n = name.rfind('.');
      return name.substr(0, n);
    }

    template<class String, class Traits>
    String basic_path<String, Traits>::extension() const
    {
      string_type name = filename();
      typename string_type::size_type n = name.rfind('.');
      if (n != string_type::npos)
        return name.substr(n);
      else
        return string_type();
    }

    template<class String, class Traits>
    basic_path<String, Traits> basic_path<String, Traits>::parent_path() const
    {
      typename String::size_type end_pos(
        detail::filename_pos<String, Traits>( m_path, m_path.size() ) );

      bool filename_was_separator( m_path.size()
        && m_path[end_pos] == slash<path_type>::value );


      typename string_type::size_type root_dir_pos( detail::root_directory_start
        <string_type, traits_type>( m_path, end_pos ) );
      for ( ;
        end_pos > 0
        && (end_pos-1) != root_dir_pos
        && m_path[end_pos-1] == slash<path_type>::value
        ;
        --end_pos ) {}

     return (end_pos == 1 && root_dir_pos == 0 && filename_was_separator)
       ? path_type()
       : path_type( m_path.substr( 0, end_pos ) );
    }

    template<class String, class Traits>
    basic_path<String, Traits> basic_path<String, Traits>::relative_path() const
    {
      iterator itr( begin() );
      for ( ; itr.m_pos != m_path.size()
          && (itr.m_name[0] == slash<path_type>::value




             ); ++itr ) {}

      return basic_path<String, Traits>( m_path.substr( itr.m_pos ) );
    }

    template<class String, class Traits>
    String basic_path<String, Traits>::root_name() const
    {
      iterator itr( begin() );

      return ( itr.m_pos != m_path.size()
        && (
            ( itr.m_name.size() > 1
              && itr.m_name[0] == slash<path_type>::value
              && itr.m_name[1] == slash<path_type>::value
            )




           ) )
        ? *itr
        : String();
    }

    template<class String, class Traits>
    String basic_path<String, Traits>::root_directory() const
    {
      typename string_type::size_type start(
        detail::root_directory_start<String, Traits>( m_path, m_path.size() ) );

      return start == string_type::npos
        ? string_type()
        : m_path.substr( start, 1 );
    }

    template<class String, class Traits>
    basic_path<String, Traits> basic_path<String, Traits>::root_path() const
    {

      return basic_path<String, Traits>( root_name() ) /= root_directory();
    }



    template<class String, class Traits>
    inline bool basic_path<String, Traits>::is_complete() const
    {



      return has_root_directory();

    }

    template<class String, class Traits>
    inline bool basic_path<String, Traits>::has_root_path() const
    {
      return !root_path().empty();
    }

    template<class String, class Traits>
    inline bool basic_path<String, Traits>::has_root_name() const
    {
      return !root_name().empty();
    }

    template<class String, class Traits>
    inline bool basic_path<String, Traits>::has_root_directory() const
    {
      return !root_directory().empty();
    }



    template<class String, class Traits>
    void basic_path<String, Traits>::m_append_separator_if_needed()

    {
      if (



        *(m_path.end()-1) != slash<path_type>::value )
      {
        m_path += slash<path_type>::value;
      }
    }

    template<class String, class Traits>
    void basic_path<String, Traits>::m_append( value_type value )
    {
# 1063 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 3
      m_path += value;

    }



    template<class String, class Traits>
    basic_path<String, Traits> & basic_path<String, Traits>::operator /=
      ( const value_type * next_p )
    {

      if ( *next_p == slash<path_type>::value
        && *(next_p+1) == slash<path_type>::value
        && *(next_p+2) == colon<path_type>::value ) next_p += 3;


      if ( !empty() && *next_p != 0
        && !detail::is_separator<path_type>( *next_p ) )
      { m_append_separator_if_needed(); }

      for ( ; *next_p != 0; ++next_p ) m_append( *next_p );
      return *this;
    }


    template<class String, class Traits> template <class InputIterator>
      basic_path<String, Traits> & basic_path<String, Traits>::append(
        InputIterator first, InputIterator last )
    {

      if ( !empty() && first != last
        && !detail::is_separator<path_type>( *first ) )
      { m_append_separator_if_needed(); }




      bool was_escape_sequence(true);
      std::size_t append_count(0);
      typename String::size_type initial_pos( m_path.size() );

      for ( ; first != last && *first; ++first )
      {
        if ( append_count == 0 && *first != slash<path_type>::value )
          was_escape_sequence = false;
        if ( append_count == 1 && *first != slash<path_type>::value )
          was_escape_sequence = false;
        if ( append_count == 2 && *first != colon<path_type>::value )
          was_escape_sequence = false;
        m_append( *first );
        ++append_count;
      }


      if ( was_escape_sequence && append_count >= 3 )
        m_path.erase( initial_pos, 3 );

      return *this;
    }






    template<class String, class Traits>
    basic_path<String, Traits> & basic_path<String, Traits>::canonize()
    {
      static const typename string_type::value_type dot_str[]
        = { dot<path_type>::value, 0 };

      if ( m_path.empty() ) return *this;

      path_type temp;

      for ( iterator itr( begin() ); itr != end(); ++itr )
      {
        temp /= *itr;
      };

      if ( temp.empty() ) temp /= dot_str;
      m_path = temp.m_path;
      return *this;
    }



    template<class String, class Traits>
    basic_path<String, Traits> & basic_path<String, Traits>::normalize()
    {
      static const typename string_type::value_type dot_str[]
        = { dot<path_type>::value, 0 };

      if ( m_path.empty() ) return *this;

      path_type temp;
      iterator start( begin() );
      iterator last( end() );
      iterator stop( last-- );
      for ( iterator itr( start ); itr != stop; ++itr )
      {

        if ( itr->size() == 1
          && (*itr)[0] == dot<path_type>::value
          && itr != start
          && itr != last ) continue;


        if ( !temp.empty()
          && itr->size() == 2
          && (*itr)[0] == dot<path_type>::value
          && (*itr)[1] == dot<path_type>::value )
        {
          string_type lf( temp.filename() );
          if ( lf.size() > 0
            && (lf.size() != 1
              || (lf[0] != dot<path_type>::value
                && lf[0] != slash<path_type>::value))
            && (lf.size() != 2
              || (lf[0] != dot<path_type>::value
                && lf[1] != dot<path_type>::value



                 )
               )
            )
          {
            temp.remove_filename();

            if ( temp.m_path.size() > 0
              && temp.m_path[temp.m_path.size()-1]
                == slash<path_type>::value )
            {
              typename string_type::size_type rds(
                detail::root_directory_start<String,Traits>( temp.m_path,
                  temp.m_path.size() ) );
              if ( rds == string_type::npos
                || rds != temp.m_path.size()-1 )
                { temp.m_path.erase( temp.m_path.size()-1 ); }
            }

            iterator next( itr );
            if ( temp.empty() && ++next != stop
              && next == last && *last == dot_str ) temp /= dot_str;
            continue;
          }
        }

        temp /= *itr;
      };

      if ( temp.empty() ) temp /= dot_str;
      m_path = temp.m_path;
      return *this;
    }





    template<class String, class Traits>
    basic_path<String, Traits> & basic_path<String, Traits>::remove_filename()
    {
      m_path.erase(
        detail::filename_pos<String, Traits>( m_path, m_path.size() ) );
      return *this;
    }

    template<class String, class Traits>
    basic_path<String, Traits> &
    basic_path<String, Traits>::replace_extension( const string_type & new_ext )
    {

      string_type old_ext = extension();
      if ( !old_ext.empty() )
        m_path.erase( m_path.size() - old_ext.size() );

      if ( !new_ext.empty() && new_ext[0] != dot<path_type>::value )
        m_path += dot<path_type>::value;

      m_path += new_ext;

      return *this;
    }




    template<class String, class Traits>
    const String
    basic_path<String, Traits>::file_string() const
    {
# 1304 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 3
      return m_path;

    }



    template<class String, class Traits>
    typename basic_path<String, Traits>::iterator basic_path<String, Traits>::begin() const
    {
      iterator itr;
      itr.m_path_ptr = this;
      typename string_type::size_type element_size;
      detail::first_element<String, Traits>( m_path, itr.m_pos, element_size );
      itr.m_name = m_path.substr( itr.m_pos, element_size );
      return itr;
    }

    template<class String, class Traits>
    typename basic_path<String, Traits>::iterator basic_path<String, Traits>::end() const
      {
        iterator itr;
        itr.m_path_ptr = this;
        itr.m_pos = m_path.size();
        return itr;
      }

    namespace detail
    {


      template<class Path>
      void iterator_helper<Path>::do_increment( iterator & itr )
      {
        typedef typename Path::string_type string_type;
        typedef typename Path::traits_type traits_type;

        (__builtin_expect(!(itr.m_pos < itr.m_path_ptr->m_path.size() && "basic_path::iterator increment past end()"), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp", 1340, "itr.m_pos < itr.m_path_ptr->m_path.size() && \"basic_path::iterator increment past end()\"") : (void)0);

        bool was_net( itr.m_name.size() > 2
          && itr.m_name[0] == slash<Path>::value
          && itr.m_name[1] == slash<Path>::value
          && itr.m_name[2] != slash<Path>::value );


        itr.m_pos += itr.m_name.size();


        if ( itr.m_pos == itr.m_path_ptr->m_path.size() )
        {
          itr.m_name.erase( itr.m_name.begin(), itr.m_name.end() );
          return;
        }


        if ( itr.m_path_ptr->m_path[itr.m_pos] == slash<Path>::value )
        {

          if ( was_net




             )
          {
            itr.m_name = slash<Path>::value;
            return;
          }


          while ( itr.m_pos != itr.m_path_ptr->m_path.size()
            && itr.m_path_ptr->m_path[itr.m_pos] == slash<Path>::value )
            { ++itr.m_pos; }


          if ( itr.m_pos == itr.m_path_ptr->m_path.size()
            && detail::is_non_root_slash< string_type, traits_type >(
                itr.m_path_ptr->m_path, itr.m_pos-1 ) )
          {
            --itr.m_pos;
            itr.m_name = dot<Path>::value;
            return;
          }
        }


        typename string_type::size_type end_pos(
          itr.m_path_ptr->m_path.find( slash<Path>::value, itr.m_pos ) );
        itr.m_name = itr.m_path_ptr->m_path.substr( itr.m_pos, end_pos - itr.m_pos );
      }



      template<class Path>
      void iterator_helper<Path>::do_decrement( iterator & itr )
      {
        (__builtin_expect(!(itr.m_pos && "basic_path::iterator decrement past begin()"), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp", 1399, "itr.m_pos && \"basic_path::iterator decrement past begin()\"") : (void)0);

        typedef typename Path::string_type string_type;
        typedef typename Path::traits_type traits_type;

        typename string_type::size_type end_pos( itr.m_pos );

        typename string_type::size_type root_dir_pos(
          detail::root_directory_start<string_type, traits_type>(
            itr.m_path_ptr->m_path, end_pos ) );


        if ( itr.m_pos == itr.m_path_ptr->m_path.size()
          && itr.m_path_ptr->m_path.size() > 1
          && itr.m_path_ptr->m_path[itr.m_pos-1] == slash<Path>::value
          && detail::is_non_root_slash< string_type, traits_type >(
               itr.m_path_ptr->m_path, itr.m_pos-1 )
           )
        {
          --itr.m_pos;
            itr.m_name = dot<Path>::value;
            return;
        }


        for (
          ;
          end_pos > 0
          && (end_pos-1) != root_dir_pos
          && itr.m_path_ptr->m_path[end_pos-1] == slash<Path>::value
          ;
          --end_pos ) {}

        itr.m_pos = detail::filename_pos<string_type, traits_type>
            ( itr.m_path_ptr->m_path, end_pos );
        itr.m_name = itr.m_path_ptr->m_path.substr( itr.m_pos, end_pos - itr.m_pos );
      }
    }



    template<class Path>
    basic_filesystem_error<Path>::basic_filesystem_error(
      const std::string & what_arg, system::error_code ec )
      : system::system_error(ec, what_arg)
    {
      try
      {
        m_imp_ptr.reset( new m_imp );
      }
      catch (...) { m_imp_ptr.reset(); }
    }

    template<class Path>
    basic_filesystem_error<Path>::basic_filesystem_error(
      const std::string & what_arg, const path_type & path1_arg,
      system::error_code ec )
      : system::system_error(ec, what_arg)
    {
      try
      {
        m_imp_ptr.reset( new m_imp );
        m_imp_ptr->m_path1 = path1_arg;
      }
      catch (...) { m_imp_ptr.reset(); }
    }

    template<class Path>
    basic_filesystem_error<Path>::basic_filesystem_error(
      const std::string & what_arg, const path_type & path1_arg,
      const path_type & path2_arg, system::error_code ec )
      : system::system_error(ec, what_arg)
    {
      try
      {
        m_imp_ptr.reset( new m_imp );
        m_imp_ptr->m_path1 = path1_arg;
        m_imp_ptr->m_path2 = path2_arg;
      }
      catch (...) { m_imp_ptr.reset(); }
    }

  }
}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/abi_suffix.hpp" 1 3
# 1485 "/Library/Application Support/MonkeyWorks/Developer/include/boost/filesystem/path.hpp" 2 3
# 40 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentRegistry.h" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/config.hpp" 1 3
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/user.hpp" 1 3
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/config.hpp" 2 3
# 115 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/config/cwchar.hpp" 1 3
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/config/cwchar.hpp" 3
namespace std{


extern "C"{
# 201 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/config/cwchar.hpp" 3
}


}
# 116 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/config.hpp" 2 3
# 204 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/config.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/config/auto_link.hpp" 1 3
# 205 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/config.hpp" 2 3
# 372 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/config.hpp" 3
namespace boost{ namespace re_detail{

 void* get_mem_block();
 void put_mem_block(void*);

}}
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 1 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_workaround.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_workaround.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 1 3
# 46 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3
       
# 47 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 3

# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 48 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/c++/4.0.0/cassert" 2 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_workaround.hpp" 2 3
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_workaround.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_workaround.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_workaround.hpp" 2 3
# 55 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_workaround.hpp" 3
namespace boost{ namespace re_detail{





using std::distance;

}}
# 97 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_workaround.hpp" 3
namespace boost{ namespace re_detail{






template <class T>
inline void pointer_destroy(T* p)
{ p->~T(); (void)p; }





template <class T>
inline void pointer_construct(T* p, const T& t)
{ new (p) T(t); }

}}
# 126 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_workaround.hpp" 3
namespace boost{ namespace re_detail{
# 154 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_workaround.hpp" 3
   using std::copy;
   using std::equal;







   inline std::size_t strcpy_s(
      char *strDestination,
      std::size_t sizeInBytes,
      const char *strSource
   )
   {
      if(std::strlen(strSource)+1 > sizeInBytes)
         return 1;
      std::strcpy(strDestination, strSource);
      return 0;
   }
   inline std::size_t strcat_s(
      char *strDestination,
      std::size_t sizeInBytes,
      const char *strSource
   )
   {
      if(std::strlen(strSource) + std::strlen(strDestination) + 1 > sizeInBytes)
         return 1;
      std::strcat(strDestination, strSource);
      return 0;
   }



   inline void overflow_error_if_not_zero(std::size_t i)
   {
      if(i)
      {
         std::overflow_error e("String buffer too small");
         boost::throw_exception(e);
      }
   }

}}
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex_fwd.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex_fwd.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_fwd.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_fwd.hpp" 3
namespace boost{

template <class charT>
class cpp_regex_traits;
template <class charT>
struct c_regex_traits;
template <class charT>
class w32_regex_traits;





template <class charT, class implementationT = cpp_regex_traits<charT> >
struct regex_traits;





template <class charT, class traits = regex_traits<charT> >
class basic_regex;

typedef basic_regex<char, regex_traits<char> > regex;

typedef basic_regex<wchar_t, regex_traits<wchar_t> > wregex;


}
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex_fwd.hpp" 2 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/regex_traits.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/regex_traits.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits.hpp" 1 3
# 29 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/syntax_type.hpp" 1 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/syntax_type.hpp" 3
namespace boost{
namespace regex_constants{

typedef unsigned char syntax_type;




static const syntax_type syntax_char = 0;
static const syntax_type syntax_open_mark = 1;
static const syntax_type syntax_close_mark = 2;
static const syntax_type syntax_dollar = 3;
static const syntax_type syntax_caret = 4;
static const syntax_type syntax_dot = 5;
static const syntax_type syntax_star = 6;
static const syntax_type syntax_plus = 7;
static const syntax_type syntax_question = 8;
static const syntax_type syntax_open_set = 9;
static const syntax_type syntax_close_set = 10;
static const syntax_type syntax_or = 11;
static const syntax_type syntax_escape = 12;
static const syntax_type syntax_dash = 14;
static const syntax_type syntax_open_brace = 15;
static const syntax_type syntax_close_brace = 16;
static const syntax_type syntax_digit = 17;
static const syntax_type syntax_comma = 27;
static const syntax_type syntax_equal = 37;
static const syntax_type syntax_colon = 36;
static const syntax_type syntax_not = 53;



static const syntax_type syntax_hash = 13;
static const syntax_type syntax_newline = 26;



typedef syntax_type escape_syntax_type;

static const escape_syntax_type escape_type_word_assert = 18;
static const escape_syntax_type escape_type_not_word_assert = 19;
static const escape_syntax_type escape_type_control_f = 29;
static const escape_syntax_type escape_type_control_n = 30;
static const escape_syntax_type escape_type_control_r = 31;
static const escape_syntax_type escape_type_control_t = 32;
static const escape_syntax_type escape_type_control_v = 33;
static const escape_syntax_type escape_type_ascii_control = 35;
static const escape_syntax_type escape_type_hex = 34;
static const escape_syntax_type escape_type_unicode = 0;
static const escape_syntax_type escape_type_identity = 0;
static const escape_syntax_type escape_type_backref = syntax_digit;
static const escape_syntax_type escape_type_decimal = syntax_digit;
static const escape_syntax_type escape_type_class = 22;
static const escape_syntax_type escape_type_not_class = 23;



static const escape_syntax_type escape_type_left_word = 20;
static const escape_syntax_type escape_type_right_word = 21;
static const escape_syntax_type escape_type_start_buffer = 24;
static const escape_syntax_type escape_type_end_buffer = 25;
static const escape_syntax_type escape_type_control_a = 28;
static const escape_syntax_type escape_type_e = 38;
static const escape_syntax_type escape_type_E = 47;
static const escape_syntax_type escape_type_Q = 48;
static const escape_syntax_type escape_type_X = 49;
static const escape_syntax_type escape_type_C = 50;
static const escape_syntax_type escape_type_Z = 51;
static const escape_syntax_type escape_type_G = 52;

static const escape_syntax_type escape_type_property = 54;
static const escape_syntax_type escape_type_not_property = 55;
static const escape_syntax_type escape_type_named_char = 56;

static const escape_syntax_type syntax_max = 57;

}
}
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/error_type.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/error_type.hpp" 3
namespace boost{



namespace regex_constants{

enum error_type{

   error_ok = 0,
   error_no_match = 1,
   error_bad_pattern = 2,
   error_collate = 3,
   error_ctype = 4,
   error_escape = 5,
   error_backref = 6,
   error_brack = 7,
   error_paren = 8,
   error_brace = 9,
   error_badbrace = 10,
   error_range = 11,
   error_space = 12,
   error_badrepeat = 13,
   error_end = 14,
   error_size = 15,
   error_right_paren = 16,
   error_empty = 17,
   error_complexity = 18,
   error_stack = 19,
   error_unknown = 20
};

}
}
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits_defaults.hpp" 1 3
# 46 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits_defaults.hpp" 3
namespace boost{ namespace re_detail{





template <class charT>
inline bool is_extended(charT c)
{ return c > 256; }
inline bool is_extended(char)
{ return false; }


 const char* get_default_syntax(regex_constants::syntax_type n);
 const char* get_default_error_string(regex_constants::error_type n);
 regex_constants::syntax_type get_default_syntax_type(char c);
 regex_constants::escape_syntax_type get_default_escape_syntax_type(char c);


 bool is_combining_implementation(uint_least16_t s);

template <class charT>
inline bool is_combining(charT c)
{
   return (c <= static_cast<charT>(0)) ? false : ((c >= static_cast<charT>((std::numeric_limits<uint_least16_t>::max)())) ? false : is_combining_implementation(static_cast<unsigned short>(c)));
}
template <>
inline bool is_combining<char>(char)
{
   return false;
}
template <>
inline bool is_combining<signed char>(signed char)
{
   return false;
}
template <>
inline bool is_combining<unsigned char>(unsigned char)
{
   return false;
}
# 114 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits_defaults.hpp" 3
template <class charT>
inline bool is_separator(charT c)
{
   return static_cast<bool>((c == static_cast<charT>('\n')) || (c == static_cast<charT>('\r')) || (c == static_cast<charT>('\f')) || (static_cast<boost::uint16_t>(c) == 0x2028u) || (static_cast<boost::uint16_t>(c) == 0x2029u) || (static_cast<boost::uint16_t>(c) == 0x85u));






}
template <>
inline bool is_separator<char>(char c)
{
   return static_cast<bool>((c == '\n') || (c == '\r') || (c == '\f'));
}




 std::string lookup_default_collate_name(const std::string& name);





template <class charT>
struct character_pointer_range
{
   const charT* p1;
   const charT* p2;

   bool operator < (const character_pointer_range& r)const
   {
      return std::lexicographical_compare(p1, p2, r.p1, r.p2);
   }
   bool operator == (const character_pointer_range& r)const
   {




      return ((p2 - p1) == (r.p2 - r.p1)) && re_detail::equal(p1, p2, r.p1);
   }
};
template <class charT>
int get_default_class_id(const charT* p1, const charT* p2)
{
   static const charT data[72] = {
      'a', 'l', 'n', 'u', 'm',
      'a', 'l', 'p', 'h', 'a',
      'b', 'l', 'a', 'n', 'k',
      'c', 'n', 't', 'r', 'l',
      'd', 'i', 'g', 'i', 't',
      'g', 'r', 'a', 'p', 'h',
      'l', 'o', 'w', 'e', 'r',
      'p', 'r', 'i', 'n', 't',
      'p', 'u', 'n', 'c', 't',
      's', 'p', 'a', 'c', 'e',
      'u', 'n', 'i', 'c', 'o', 'd', 'e',
      'u', 'p', 'p', 'e', 'r',
      'w', 'o', 'r', 'd',
      'x', 'd', 'i', 'g', 'i', 't',
   };

   static const character_pointer_range<charT> ranges[19] =
   {
      {data+0, data+5,},
      {data+5, data+10,},
      {data+10, data+15,},
      {data+15, data+20,},
      {data+20, data+21,},
      {data+20, data+25,},
      {data+25, data+30,},
      {data+30, data+31,},
      {data+30, data+35,},
      {data+35, data+40,},
      {data+40, data+45,},
      {data+45, data+46,},
      {data+45, data+50,},
      {data+57, data+58,},
      {data+50, data+57,},
      {data+57, data+62,},
      {data+62, data+63,},
      {data+62, data+66,},
      {data+66, data+72,},
   };
   static const character_pointer_range<charT>* ranges_begin = ranges;
   static const character_pointer_range<charT>* ranges_end = ranges + (sizeof(ranges)/sizeof(ranges[0]));

   character_pointer_range<charT> t = { p1, p2, };
   const character_pointer_range<charT>* p = std::lower_bound(ranges_begin, ranges_end, t);
   if((p != ranges_end) && (t == *p))
      return static_cast<int>(p - ranges);
   return -1;
}




template <class charT>
std::ptrdiff_t global_length(const charT* p)
{
   std::ptrdiff_t n = 0;
   while(*p)
   {
      ++p;
      ++n;
   }
   return n;
}
template<>
inline std::ptrdiff_t global_length<char>(const char* p)
{
   return (std::strlen)(p);
}

template<>
inline std::ptrdiff_t global_length<wchar_t>(const wchar_t* p)
{
   return (std::wcslen)(p);
}

template <class charT>
inline charT global_lower(charT c)
{
   return c;
}
template <class charT>
inline charT global_upper(charT c)
{
   return c;
}

 char do_global_lower(char c);
 char do_global_upper(char c);

 wchar_t do_global_lower(wchar_t c);
 wchar_t do_global_upper(wchar_t c);
# 268 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits_defaults.hpp" 3
template<> inline char global_lower<char>(char c){ return do_global_lower(c); }
template<> inline char global_upper<char>(char c){ return do_global_upper(c); }

template<> inline wchar_t global_lower<wchar_t>(wchar_t c){ return do_global_lower(c); }
template<> inline wchar_t global_upper<wchar_t>(wchar_t c){ return do_global_upper(c); }






template <class charT>
int global_value(charT c)
{
   static const charT zero = '0';
   static const charT nine = '9';
   static const charT a = 'a';
   static const charT f = 'f';
   static const charT A = 'A';
   static const charT F = 'F';

   if(c > f) return -1;
   if(c >= a) return 10 + (c - a);
   if(c > F) return -1;
   if(c >= A) return 10 + (c - A);
   if(c > nine) return -1;
   if(c >= zero) return c - zero;
   return -1;
}
template <class charT, class traits>
int global_toi(const charT*& p1, const charT* p2, int radix, const traits& t)
{
   (void)t;
   int next_value = t.value(*p1, radix);
   if((p1 == p2) || (next_value < 0) || (next_value >= radix))
      return -1;
   int result = 0;
   while(p1 != p2)
   {
      next_value = t.value(*p1, radix);
      if((next_value < 0) || (next_value >= radix))
         break;
      result *= radix;
      result += next_value;
      ++p1;
   }
   return result;
}

}
}
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 1 3
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pattern_except.hpp" 1 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pattern_except.hpp" 3
namespace boost{
# 47 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pattern_except.hpp" 3
class regex_error : public std::runtime_error
{
public:
   explicit regex_error(const std::string& s, regex_constants::error_type err = regex_constants::error_unknown, std::ptrdiff_t pos = 0);
   explicit regex_error(regex_constants::error_type err);
   ~regex_error() throw();
   regex_constants::error_type code()const
   { return m_error_code; }
   std::ptrdiff_t position()const
   { return m_position; }
   void raise()const;
private:
   regex_constants::error_type m_error_code;
   std::ptrdiff_t m_position;
};

typedef regex_error bad_pattern;
typedef regex_error bad_expression;

namespace re_detail{

 void raise_runtime_error(const std::runtime_error& ex);

template <class traits>
void raise_error(const traits& t, regex_constants::error_type code)
{
   (void)t;
   std::runtime_error e(t.error_string(code));
   ::boost::re_detail::raise_runtime_error(e);
}

}
# 95 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pattern_except.hpp" 3
}
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/static_mutex.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/static_mutex.hpp" 3
namespace boost{

class scoped_static_mutex_lock;

class static_mutex
{
public:
   typedef scoped_static_mutex_lock scoped_lock;
   pthread_mutex_t m_mutex;
};



class scoped_static_mutex_lock
{
public:
   scoped_static_mutex_lock(static_mutex& mut, bool lk = true);
   ~scoped_static_mutex_lock();
   inline bool locked()const
   {
      return m_have_lock;
   }
   inline operator void const*()const
   {
      return locked() ? this : 0;
   }
   void lock();
   void unlock();
private:
   static_mutex& m_mutex;
   bool m_have_lock;
};


}
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/primary_transform.hpp" 1 3
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/primary_transform.hpp" 3
namespace boost{
   namespace re_detail{


enum{
   sort_C,
   sort_fixed,
   sort_delim,
   sort_unknown
};

template <class S, class charT>
unsigned count_chars(const S& s, charT c)
{






   unsigned int count = 0;
   for(unsigned pos = 0; pos < s.size(); ++pos)
   {
      if(s[pos] == c) ++count;
   }
   return count;
}


template <class traits, class charT>
unsigned find_sort_syntax(const traits* pt, charT* delim)
{




   typedef typename traits::string_type string_type;
   typedef typename traits::char_type char_type;


   (void)pt;

   char_type a[2] = {'a', '\0', };
   string_type sa(pt->transform(a, a+1));
   if(sa == a)
   {
      *delim = 0;
      return sort_C;
   }
   char_type A[2] = { 'A', '\0', };
   string_type sA(pt->transform(A, A+1));
   char_type c[2] = { ';', '\0', };
   string_type sc(pt->transform(c, c+1));

   int pos = 0;
   while((pos <= static_cast<int>(sa.size())) && (pos <= static_cast<int>(sA.size())) && (sa[pos] == sA[pos])) ++pos;
   --pos;
   if(pos < 0)
   {
      *delim = 0;
      return sort_unknown;
   }




   charT maybe_delim = sa[pos];
   if((pos != 0) && (count_chars(sa, maybe_delim) == count_chars(sA, maybe_delim)) && (count_chars(sa, maybe_delim) == count_chars(sc, maybe_delim)))
   {
      *delim = maybe_delim;
      return sort_delim;
   }



   if((sa.size() == sA.size()) && (sa.size() == sc.size()))
   {



      *delim = static_cast<charT>(++pos);
      return sort_fixed;
   }



   *delim = 0;
   return sort_unknown;
}


   }
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp" 1 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp" 3
namespace boost{

template <class Key, class Object>
class object_cache
{
public:
   typedef std::pair< ::boost::shared_ptr<Object const>, Key const*> value_type;
   typedef std::list<value_type> list_type;
   typedef typename list_type::iterator list_iterator;
   typedef std::map<Key, list_iterator> map_type;
   typedef typename map_type::iterator map_iterator;
   typedef typename list_type::size_type size_type;
   static boost::shared_ptr<Object const> get(const Key& k, size_type max_cache_size);

private:
   static boost::shared_ptr<Object const> do_get(const Key& k, size_type max_cache_size);

   struct data
   {
      list_type cont;
      map_type index;
   };



   friend struct data;
};

template <class Key, class Object>
boost::shared_ptr<Object const> object_cache<Key, Object>::get(const Key& k, size_type max_cache_size)
{

   static boost::static_mutex mut = { {0x32AAABA7, {0}}, };

   boost::static_mutex::scoped_lock l(mut);
   if(l)
   {
      return do_get(k, max_cache_size);
   }




   ::boost::throw_exception(std::runtime_error("Error in thread safety code: could not acquire a lock"));
   return boost::shared_ptr<Object>();



}

template <class Key, class Object>
boost::shared_ptr<Object const> object_cache<Key, Object>::do_get(const Key& k, size_type max_cache_size)
{
   typedef typename object_cache<Key, Object>::data object_data;
   typedef typename map_type::size_type map_size_type;
   static object_data s_data;




   map_iterator mpos = s_data.index.find(k);
   if(mpos != s_data.index.end())
   {




      if(--(s_data.cont.end()) != mpos->second)
      {

         list_type temp;
         temp.splice(temp.end(), s_data.cont, mpos->second);

         s_data.cont.splice(s_data.cont.end(), temp, temp.begin());
         (__builtin_expect(!(*(s_data.cont.back().second) == k), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp", 106, "*(s_data.cont.back().second) == k") : (void)0);

         mpos->second = --(s_data.cont.end());
         (__builtin_expect(!(&(mpos->first) == mpos->second->second), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp", 109, "&(mpos->first) == mpos->second->second") : (void)0);
         (__builtin_expect(!(&(mpos->first) == s_data.cont.back().second), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp", 110, "&(mpos->first) == s_data.cont.back().second") : (void)0);
      }
      return s_data.cont.back().first;
   }




   boost::shared_ptr<Object const> result(new Object(k));



   s_data.cont.push_back(value_type(result, static_cast<Key const*>(0)));
   s_data.index.insert(std::make_pair(k, --(s_data.cont.end())));
   s_data.cont.back().second = &(s_data.index.find(k)->first);
   map_size_type s = s_data.index.size();
   (__builtin_expect(!(s_data.index[k]->first.get() == result.get()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp", 126, "s_data.index[k]->first.get() == result.get()") : (void)0);
   (__builtin_expect(!(&(s_data.index.find(k)->first) == s_data.cont.back().second), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp", 127, "&(s_data.index.find(k)->first) == s_data.cont.back().second") : (void)0);
   (__builtin_expect(!(s_data.index.find(k)->first == k), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp", 128, "s_data.index.find(k)->first == k") : (void)0);
   if(s > max_cache_size)
   {





      list_iterator pos = s_data.cont.begin();
      list_iterator last = s_data.cont.end();
      while((pos != last) && (s > max_cache_size))
      {
         if(pos->first.unique())
         {
            list_iterator condemmed(pos);
            ++pos;


            (__builtin_expect(!(s_data.index.find(*(condemmed->second)) != s_data.index.end()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp", 146, "s_data.index.find(*(condemmed->second)) != s_data.index.end()") : (void)0);
            s_data.index.erase(*(condemmed->second));
            s_data.cont.erase(condemmed);
            --s;
         }
         else
            --pos;
      }
      (__builtin_expect(!(s_data.index[k]->first.get() == result.get()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp", 154, "s_data.index[k]->first.get() == result.get()") : (void)0);
      (__builtin_expect(!(&(s_data.index.find(k)->first) == s_data.cont.back().second), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp", 155, "&(s_data.index.find(k)->first) == s_data.cont.back().second") : (void)0);
      (__builtin_expect(!(s_data.index.find(k)->first == k), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/pending/object_cache.hpp", 156, "s_data.index.find(k)->first == k") : (void)0);
   }
   return result;
}

}
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 2 3
# 62 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 3
namespace boost{




template <class charT>
class cpp_regex_traits;

namespace re_detail{





template <class charT,
          class traits = ::std::char_traits<charT> >
class parser_buf : public ::std::basic_streambuf<charT, traits>
{
   typedef ::std::basic_streambuf<charT, traits> base_type;
   typedef typename base_type::int_type int_type;
   typedef typename base_type::char_type char_type;
   typedef typename base_type::pos_type pos_type;
   typedef ::std::streamsize streamsize;
   typedef typename base_type::off_type off_type;
public:
   parser_buf() : base_type() { setbuf(0, 0); }
   const charT* getnext() { return this->gptr(); }
protected:
   std::basic_streambuf<charT, traits>* setbuf(char_type* s, streamsize n);
   typename parser_buf<charT, traits>::pos_type seekpos(pos_type sp, ::std::ios_base::openmode which);
   typename parser_buf<charT, traits>::pos_type seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which);
private:
   parser_buf& operator=(const parser_buf&);
   parser_buf(const parser_buf&);
};

template<class charT, class traits>
std::basic_streambuf<charT, traits>*
parser_buf<charT, traits>::setbuf(char_type* s, streamsize n)
{
   this->setg(s, s, s + n);
   return this;
}

template<class charT, class traits>
typename parser_buf<charT, traits>::pos_type
parser_buf<charT, traits>::seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
{
   if(which & ::std::ios_base::out)
      return pos_type(off_type(-1));
   std::ptrdiff_t size = this->egptr() - this->eback();
   std::ptrdiff_t pos = this->gptr() - this->eback();
   charT* g = this->eback();
   switch(way)
   {
   case ::std::ios_base::beg:
      if((off < 0) || (off > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + off, g + size);
      break;
   case ::std::ios_base::end:
      if((off < 0) || (off > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + size - off, g + size);
      break;
   case ::std::ios_base::cur:
   {
      std::ptrdiff_t newpos = static_cast<std::ptrdiff_t>(pos + off);
      if((newpos < 0) || (newpos > size))
         return pos_type(off_type(-1));
      else
         this->setg(g, g + newpos, g + size);
      break;
   }
   default: ;
   }




   return static_cast<pos_type>(this->gptr() - this->eback());



}

template<class charT, class traits>
typename parser_buf<charT, traits>::pos_type
parser_buf<charT, traits>::seekpos(pos_type sp, ::std::ios_base::openmode which)
{
   if(which & ::std::ios_base::out)
      return pos_type(off_type(-1));
   off_type size = static_cast<off_type>(this->egptr() - this->eback());
   charT* g = this->eback();
   if(off_type(sp) <= size)
   {
      this->setg(g, g + off_type(sp), g + size);
   }
   return pos_type(off_type(-1));
}





template <class charT>
struct cpp_regex_traits_base
{
   cpp_regex_traits_base(const std::locale& l)
   { imbue(l); }
   std::locale imbue(const std::locale& l);

   std::locale m_locale;
   std::ctype<charT> const* m_pctype;

   std::messages<charT> const* m_pmessages;

   std::collate<charT> const* m_pcollate;

   bool operator<(const cpp_regex_traits_base& b)const
   {
      if(m_pctype == b.m_pctype)
      {

         if(m_pmessages == b.m_pmessages)
         {
         }
         return m_pmessages < b.m_pmessages;



      }
      return m_pctype < b.m_pctype;
   }
   bool operator==(const cpp_regex_traits_base& b)const
   {
      return (m_pctype == b.m_pctype)

         && (m_pmessages == b.m_pmessages)

         && (m_pcollate == b.m_pcollate);
   }
};

template <class charT>
std::locale cpp_regex_traits_base<charT>::imbue(const std::locale& l)
{
   std::locale result(m_locale);
   m_locale = l;
   m_pctype = &std::use_facet< std::ctype<charT> >(l);

   m_pmessages = &std::use_facet< std::messages<charT> >(l);

   m_pcollate = &std::use_facet< std::collate<charT> >(l);
   return result;
}





template <class charT>
class cpp_regex_traits_char_layer : public cpp_regex_traits_base<charT>
{
   typedef std::basic_string<charT> string_type;
   typedef std::map<charT, regex_constants::syntax_type> map_type;
   typedef typename map_type::const_iterator map_iterator_type;
public:
   cpp_regex_traits_char_layer(const std::locale& l)
      : cpp_regex_traits_base<charT>(l)
   {
      init();
   }
   cpp_regex_traits_char_layer(const cpp_regex_traits_base<charT>& b)
      : cpp_regex_traits_base<charT>(b)
   {
      init();
   }
   void init();

   regex_constants::syntax_type syntax_type(charT c)const
   {
      map_iterator_type i = m_char_map.find(c);
      return ((i == m_char_map.end()) ? 0 : i->second);
   }
   regex_constants::escape_syntax_type escape_syntax_type(charT c) const
   {
      map_iterator_type i = m_char_map.find(c);
      if(i == m_char_map.end())
      {
         if(this->m_pctype->is(std::ctype_base::lower, c)) return regex_constants::escape_type_class;
         if(this->m_pctype->is(std::ctype_base::upper, c)) return regex_constants::escape_type_not_class;
         return 0;
      }
      return i->second;
   }

private:
   string_type get_default_message(regex_constants::syntax_type);

   map_type m_char_map;
};

template <class charT>
void cpp_regex_traits_char_layer<charT>::init()
{




   typename std::messages<charT>::catalog cat = static_cast<std::messages<char>::catalog>(-1);



   std::string cat_name(cpp_regex_traits<charT>::get_catalog_name());
   if(cat_name.size())
   {
      cat = this->m_pmessages->open(
         cat_name,
         this->m_locale);
      if((int)cat < 0)
      {
         std::string m("Unable to open message catalog: ");
         std::runtime_error err(m + cat_name);
         boost::re_detail::raise_runtime_error(err);
      }
   }



   if((int)cat >= 0)
   {

      try{

         for(regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
         {
            string_type mss = this->m_pmessages->get(cat, 0, i, get_default_message(i));
            for(typename string_type::size_type j = 0; j < mss.size(); ++j)
            {
               m_char_map[mss[j]] = i;
            }
         }
         this->m_pmessages->close(cat);

      }
      catch(...)
      {
         this->m_pmessages->close(cat);
         throw;
      }

   }
   else
   {

      for(regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
      {
         const char* ptr = get_default_syntax(i);
         while(ptr && *ptr)
         {
            m_char_map[this->m_pctype->widen(*ptr)] = i;
            ++ptr;
         }
      }

   }

}

template <class charT>
typename cpp_regex_traits_char_layer<charT>::string_type
   cpp_regex_traits_char_layer<charT>::get_default_message(regex_constants::syntax_type i)
{
   const char* ptr = get_default_syntax(i);
   string_type result;
   while(ptr && *ptr)
   {
      result.append(1, this->m_pctype->widen(*ptr));
      ++ptr;
   }
   return result;
}




template <>
class cpp_regex_traits_char_layer<char> : public cpp_regex_traits_base<char>
{
   typedef std::string string_type;
public:
   cpp_regex_traits_char_layer(const std::locale& l)
   : cpp_regex_traits_base<char>(l)
   {
      init();
   }
   cpp_regex_traits_char_layer(const cpp_regex_traits_base<char>& l)
   : cpp_regex_traits_base<char>(l)
   {
      init();
   }

   regex_constants::syntax_type syntax_type(char c)const
   {
      return m_char_map[static_cast<unsigned char>(c)];
   }
   regex_constants::escape_syntax_type escape_syntax_type(char c) const
   {
      return m_char_map[static_cast<unsigned char>(c)];
   }

private:
   regex_constants::syntax_type m_char_map[1u << 8];
   void init();
};
# 406 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 3
template <class charT>
class cpp_regex_traits_implementation : public cpp_regex_traits_char_layer<charT>
{
public:
   typedef typename cpp_regex_traits<charT>::char_class_type char_class_type;
   typedef typename std::ctype<charT>::mask native_mask_type;

   static const char_class_type mask_blank = 1u << 24;
   static const char_class_type mask_word = 1u << 25;
   static const char_class_type mask_unicode = 1u << 26;


   typedef std::basic_string<charT> string_type;
   typedef charT char_type;

   cpp_regex_traits_implementation(const std::locale& l)
      : cpp_regex_traits_char_layer<charT>(l)
   {
      init();
   }
   cpp_regex_traits_implementation(const cpp_regex_traits_base<charT>& l)
      : cpp_regex_traits_char_layer<charT>(l)
   {
      init();
   }
   std::string error_string(regex_constants::error_type n) const
   {
      if(!m_error_strings.empty())
      {
         std::map<int, std::string>::const_iterator p = m_error_strings.find(n);
         return (p == m_error_strings.end()) ? std::string(get_default_error_string(n)) : p->second;
      }
      return get_default_error_string(n);
   }
   char_class_type lookup_classname(const charT* p1, const charT* p2) const
   {
      char_class_type result = lookup_classname_imp(p1, p2);
      if(result == 0)
      {
         string_type temp(p1, p2);
         this->m_pctype->tolower(&*temp.begin(), &*temp.begin() + temp.size());
         result = lookup_classname_imp(&*temp.begin(), &*temp.begin() + temp.size());
      }
      return result;
   }
   string_type lookup_collatename(const charT* p1, const charT* p2) const;
   string_type transform_primary(const charT* p1, const charT* p2) const;
   string_type transform(const charT* p1, const charT* p2) const;
private:
   std::map<int, std::string> m_error_strings;
   std::map<string_type, char_class_type> m_custom_class_names;
   std::map<string_type, string_type> m_custom_collate_names;
   unsigned m_collate_type;
   charT m_collate_delim;



   char_class_type lookup_classname_imp(const charT* p1, const charT* p2) const;
   void init();




};




template <class charT>
typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_blank;
template <class charT>
typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_word;
template <class charT>
typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_unicode;




template <class charT>
typename cpp_regex_traits_implementation<charT>::string_type
   cpp_regex_traits_implementation<charT>::transform_primary(const charT* p1, const charT* p2) const
{
# 496 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 3
   (__builtin_expect(!(*p2 == 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp", 496, "*p2 == 0") : (void)0);

   string_type result;





   try{




      switch(m_collate_type)
      {
      case sort_C:
      case sort_unknown:

         {
            result.assign(p1, p2);
            this->m_pctype->tolower(&*result.begin(), &*result.begin() + result.size());
            result = this->m_pcollate->transform(&*result.begin(), &*result.begin() + result.size());
            break;
         }
      case sort_fixed:
         {

            result.assign(this->m_pcollate->transform(p1, p2));
            result.erase(this->m_collate_delim);
            break;
         }
      case sort_delim:

            result.assign(this->m_pcollate->transform(p1, p2));
            std::size_t i;
            for(i = 0; i < result.size(); ++i)
            {
               if(result[i] == m_collate_delim)
                  break;
            }
            result.erase(i);
            break;
      }
   }catch(...){}
   while(result.size() && (charT(0) == *result.rbegin()))
      result.erase(result.size() - 1);
   if(result.empty())
   {

      result = string_type(1, charT(0));
   }
   return result;
}

template <class charT>
typename cpp_regex_traits_implementation<charT>::string_type
   cpp_regex_traits_implementation<charT>::transform(const charT* p1, const charT* p2) const
{
# 562 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 3
   (__builtin_expect(!(*p2 == 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp", 562, "*p2 == 0") : (void)0);





   string_type result;
   try{
      result = this->m_pcollate->transform(p1, p2);
# 582 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 3
      while(result.size() && (charT(0) == *result.rbegin()))
         result.erase(result.size() - 1);

      (__builtin_expect(!(std::find(result.begin(), result.end(), charT(0)) == result.end()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp", 585, "std::find(result.begin(), result.end(), charT(0)) == result.end()") : (void)0);
   }
   catch(...)
   {
   }
   return result;
}


template <class charT>
typename cpp_regex_traits_implementation<charT>::string_type
   cpp_regex_traits_implementation<charT>::lookup_collatename(const charT* p1, const charT* p2) const
{
   typedef typename std::map<string_type, string_type>::const_iterator iter_type;
   if(m_custom_collate_names.size())
   {
      iter_type pos = m_custom_collate_names.find(string_type(p1, p2));
      if(pos != m_custom_collate_names.end())
         return pos->second;
   }



   std::string name(p1, p2);






   name = lookup_default_collate_name(name);



   if(name.size())
      return string_type(name.begin(), name.end());
# 633 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 3
   if(p2 - p1 == 1)
      return string_type(1, *p1);
   return string_type();
}

template <class charT>
void cpp_regex_traits_implementation<charT>::init()
{


   typename std::messages<charT>::catalog cat = static_cast<std::messages<char>::catalog>(-1);



   std::string cat_name(cpp_regex_traits<charT>::get_catalog_name());
   if(cat_name.size())
   {
      cat = this->m_pmessages->open(
         cat_name,
         this->m_locale);
      if((int)cat < 0)
      {
         std::string m("Unable to open message catalog: ");
         std::runtime_error err(m + cat_name);
         boost::re_detail::raise_runtime_error(err);
      }
   }



   if((int)cat >= 0)
   {



      for(boost::regex_constants::error_type i = static_cast<boost::regex_constants::error_type>(0);
         i <= boost::regex_constants::error_unknown;
         i = static_cast<boost::regex_constants::error_type>(i + 1))
      {
         const char* p = get_default_error_string(i);
         string_type default_message;
         while(*p)
         {
            default_message.append(1, this->m_pctype->widen(*p));
            ++p;
         }
         string_type s = this->m_pmessages->get(cat, 0, i+200, default_message);
         std::string result;
         for(std::string::size_type j = 0; j < s.size(); ++j)
         {
            result.append(1, this->m_pctype->narrow(s[j], 0));
         }
         m_error_strings[i] = result;
      }




      static const char_class_type masks[14] =
      {
         std::ctype<charT>::alnum,
         std::ctype<charT>::alpha,
         std::ctype<charT>::cntrl,
         std::ctype<charT>::digit,
         std::ctype<charT>::graph,
         std::ctype<charT>::lower,
         std::ctype<charT>::print,
         std::ctype<charT>::punct,
         std::ctype<charT>::space,
         std::ctype<charT>::upper,
         std::ctype<charT>::xdigit,
         cpp_regex_traits_implementation<charT>::mask_blank,
         cpp_regex_traits_implementation<charT>::mask_word,
         cpp_regex_traits_implementation<charT>::mask_unicode,
      };
# 727 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 3
      static const string_type null_string;
      for(unsigned int j = 0; j <= 13; ++j)
      {
         string_type s(this->m_pmessages->get(cat, 0, j+300, null_string));
         if(s.size())
            this->m_custom_class_names[s] = masks[j];
      }
   }




   m_collate_type = re_detail::find_sort_syntax(this, &m_collate_delim);
}

template <class charT>
typename cpp_regex_traits_implementation<charT>::char_class_type
   cpp_regex_traits_implementation<charT>::lookup_classname_imp(const charT* p1, const charT* p2) const
{

   static const char_class_type masks[20] =
   {
      0,
      std::ctype<char>::alnum,
      std::ctype<char>::alpha,
      cpp_regex_traits_implementation<charT>::mask_blank,
      std::ctype<char>::cntrl,
      std::ctype<char>::digit,
      std::ctype<char>::digit,
      std::ctype<char>::graph,
      std::ctype<char>::lower,
      std::ctype<char>::lower,
      std::ctype<char>::print,
      std::ctype<char>::punct,
      std::ctype<char>::space,
      std::ctype<char>::space,
      std::ctype<char>::upper,
      cpp_regex_traits_implementation<charT>::mask_unicode,
      std::ctype<char>::upper,
      std::ctype<char>::alnum | cpp_regex_traits_implementation<charT>::mask_word,
      std::ctype<char>::alnum | cpp_regex_traits_implementation<charT>::mask_word,
      std::ctype<char>::xdigit,
   };
# 795 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 3
   if(m_custom_class_names.size())
   {
      typedef typename std::map<std::basic_string<charT>, char_class_type>::const_iterator map_iter;
      map_iter pos = m_custom_class_names.find(string_type(p1, p2));
      if(pos != m_custom_class_names.end())
         return pos->second;
   }
   std::size_t cocoa_friendly_id = 1 + re_detail::get_default_class_id(p1, p2);
   (__builtin_expect(!(cocoa_friendly_id < sizeof(masks) / sizeof(masks[0])), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp", 803, "cocoa_friendly_id < sizeof(masks) / sizeof(masks[0])") : (void)0);
   return masks[cocoa_friendly_id];
}
# 828 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/cpp_regex_traits.hpp" 3
template <class charT>
inline boost::shared_ptr<const cpp_regex_traits_implementation<charT> > create_cpp_regex_traits(const std::locale& l )
{
   cpp_regex_traits_base<charT> key(l);
   return ::boost::object_cache<cpp_regex_traits_base<charT>, cpp_regex_traits_implementation<charT> >::get(key, 5);
}

}

template <class charT>
class cpp_regex_traits
{
private:
   typedef std::ctype<charT> ctype_type;
public:
   typedef charT char_type;
   typedef std::size_t size_type;
   typedef std::basic_string<char_type> string_type;
   typedef std::locale locale_type;
   typedef boost::uint_least32_t char_class_type;

   struct boost_extensions_tag{};

   cpp_regex_traits()
      : m_pimpl(re_detail::create_cpp_regex_traits<charT>(std::locale()))
   { }
   static size_type length(const char_type* p)
   {
      return std::char_traits<charT>::length(p);
   }
   regex_constants::syntax_type syntax_type(charT c)const
   {
      return m_pimpl->syntax_type(c);
   }
   regex_constants::escape_syntax_type escape_syntax_type(charT c) const
   {
      return m_pimpl->escape_syntax_type(c);
   }
   charT translate(charT c) const
   {
      return c;
   }
   charT translate_nocase(charT c) const
   {
      return m_pimpl->m_pctype->tolower(c);
   }
   charT translate(charT c, bool icase) const
   {
      return icase ? m_pimpl->m_pctype->tolower(c) : c;
   }
   charT tolower(charT c) const
   {
      return m_pimpl->m_pctype->tolower(c);
   }
   charT toupper(charT c) const
   {
      return m_pimpl->m_pctype->toupper(c);
   }
   string_type transform(const charT* p1, const charT* p2) const
   {
      return m_pimpl->transform(p1, p2);
   }
   string_type transform_primary(const charT* p1, const charT* p2) const
   {
      return m_pimpl->transform_primary(p1, p2);
   }
   char_class_type lookup_classname(const charT* p1, const charT* p2) const
   {
      return m_pimpl->lookup_classname(p1, p2);
   }
   string_type lookup_collatename(const charT* p1, const charT* p2) const
   {
      return m_pimpl->lookup_collatename(p1, p2);
   }
   bool isctype(charT c, char_class_type f) const
   {

      typedef typename std::ctype<charT>::mask ctype_mask;

      static const ctype_mask mask_base =
         static_cast<ctype_mask>(
            std::ctype<charT>::alnum
            | std::ctype<charT>::alpha
            | std::ctype<charT>::cntrl
            | std::ctype<charT>::digit
            | std::ctype<charT>::graph
            | std::ctype<charT>::lower
            | std::ctype<charT>::print
            | std::ctype<charT>::punct
            | std::ctype<charT>::space
            | std::ctype<charT>::upper
            | std::ctype<charT>::xdigit);

      if((f & mask_base)
         && (m_pimpl->m_pctype->is(
            static_cast<ctype_mask>(f & mask_base), c)))
         return true;
      else if((f & re_detail::cpp_regex_traits_implementation<charT>::mask_unicode) && re_detail::is_extended(c))
         return true;
      else if((f & re_detail::cpp_regex_traits_implementation<charT>::mask_word) && (c == '_'))
         return true;
      else if((f & re_detail::cpp_regex_traits_implementation<charT>::mask_blank)
         && m_pimpl->m_pctype->is(std::ctype<charT>::space, c)
         && !re_detail::is_separator(c))
         return true;
      return false;



   }
   int toi(const charT*& p1, const charT* p2, int radix)const;
   int value(charT c, int radix)const
   {
      const charT* pc = &c;
      return toi(pc, pc + 1, radix);
   }
   locale_type imbue(locale_type l)
   {
      std::locale result(getloc());
      m_pimpl = re_detail::create_cpp_regex_traits<charT>(l);
      return result;
   }
   locale_type getloc()const
   {
      return m_pimpl->m_locale;
   }
   std::string error_string(regex_constants::error_type n) const
   {
      return m_pimpl->error_string(n);
   }





   static std::string catalog_name(const std::string& name);
   static std::string get_catalog_name();

private:
   boost::shared_ptr<const re_detail::cpp_regex_traits_implementation<charT> > m_pimpl;



   static std::string& get_catalog_name_inst();


   static static_mutex& get_mutex_inst();

};


template <class charT>
int cpp_regex_traits<charT>::toi(const charT*& first, const charT* last, int radix)const
{
   re_detail::parser_buf<charT> sbuf;
   std::basic_istream<charT> is(&sbuf);


   last = std::find(first, last, std::use_facet< std::numpunct<charT> >(is.getloc()).thousands_sep());

   sbuf.pubsetbuf(const_cast<charT*>(static_cast<const charT*>(first)), static_cast<std::streamsize>(last-first));
   is.clear();
   if(std::abs(radix) == 16) is >> std::hex;
   else if(std::abs(radix) == 8) is >> std::oct;
   else is >> std::dec;
   int val;
   if(is >> val)
   {
      first = first + ((last - first) - sbuf.in_avail());
      return val;
   }
   else
      return -1;
}

template <class charT>
std::string cpp_regex_traits<charT>::catalog_name(const std::string& name)
{

   static_mutex::scoped_lock lk(get_mutex_inst());

   std::string result(get_catalog_name_inst());
   get_catalog_name_inst() = name;
   return result;
}

template <class charT>
std::string& cpp_regex_traits<charT>::get_catalog_name_inst()
{
   static std::string s_name;
   return s_name;
}

template <class charT>
std::string cpp_regex_traits<charT>::get_catalog_name()
{

   static_mutex::scoped_lock lk(get_mutex_inst());

   std::string result(get_catalog_name_inst());
   return result;
}


template <class charT>
static_mutex& cpp_regex_traits<charT>::get_mutex_inst()
{
   static static_mutex s_mutex = { {0x32AAABA7, {0}}, };
   return s_mutex;
}



}
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits.hpp" 2 3




# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/c_regex_traits.hpp" 1 3
# 48 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/c_regex_traits.hpp" 3
namespace boost{

template <class charT>
struct c_regex_traits;

template<>
struct c_regex_traits<char>
{
   c_regex_traits(){}
   typedef char char_type;
   typedef std::size_t size_type;
   typedef std::string string_type;
   struct locale_type{};
   typedef boost::uint32_t char_class_type;

   static size_type length(const char_type* p)
   {
      return (std::strlen)(p);
   }

   char translate(char c) const
   {
      return c;
   }
   char translate_nocase(char c) const
   {
      return static_cast<char>((std::tolower)(static_cast<unsigned char>(c)));
   }

   static string_type transform(const char* p1, const char* p2);
   static string_type transform_primary(const char* p1, const char* p2);

   static char_class_type lookup_classname(const char* p1, const char* p2);
   static string_type lookup_collatename(const char* p1, const char* p2);

   static bool isctype(char, char_class_type);
   static int value(char, int);

   locale_type imbue(locale_type l)
   { return l; }
   locale_type getloc()const
   { return locale_type(); }

private:

   c_regex_traits(const c_regex_traits&);
   c_regex_traits& operator=(const c_regex_traits&);
};


template<>
struct c_regex_traits<wchar_t>
{
   c_regex_traits(){}
   typedef wchar_t char_type;
   typedef std::size_t size_type;
   typedef std::wstring string_type;
   struct locale_type{};
   typedef boost::uint32_t char_class_type;

   static size_type length(const char_type* p)
   {
      return (std::wcslen)(p);
   }

   wchar_t translate(wchar_t c) const
   {
      return c;
   }
   wchar_t translate_nocase(wchar_t c) const
   {
      return (std::towlower)(c);
   }

   static string_type transform(const wchar_t* p1, const wchar_t* p2);
   static string_type transform_primary(const wchar_t* p1, const wchar_t* p2);

   static char_class_type lookup_classname(const wchar_t* p1, const wchar_t* p2);
   static string_type lookup_collatename(const wchar_t* p1, const wchar_t* p2);

   static bool isctype(wchar_t, char_class_type);
   static int value(wchar_t, int);

   locale_type imbue(locale_type l)
   { return l; }
   locale_type getloc()const
   { return locale_type(); }

private:

   c_regex_traits(const c_regex_traits&);
   c_regex_traits& operator=(const c_regex_traits&);
};
# 195 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/c_regex_traits.hpp" 3
}
# 45 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits.hpp" 2 3
# 70 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits.hpp" 3
namespace boost{

template <class charT, class implementationT >
struct regex_traits : public implementationT
{
   regex_traits() : implementationT() {}
};
# 85 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits.hpp" 3
namespace re_detail{

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_boost_extensions_tag { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::boost_extensions_tag>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
# 96 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits.hpp" 3
template <class BaseT>
struct default_wrapper : public BaseT
{
   typedef typename BaseT::char_type char_type;
   std::string error_string(::boost::regex_constants::error_type e)const
   {
      return ::boost::re_detail::get_default_error_string(e);
   }
   ::boost::regex_constants::syntax_type syntax_type(char_type c)const
   {
      return ((c & 0x7f) == c) ? get_default_syntax_type(static_cast<char>(c)) : ::boost::regex_constants::syntax_char;
   }
   ::boost::regex_constants::escape_syntax_type escape_syntax_type(char_type c)const
   {
      return ((c & 0x7f) == c) ? get_default_escape_syntax_type(static_cast<char>(c)) : ::boost::regex_constants::escape_type_identity;
   }
   int toi(const char_type*& p1, const char_type* p2, int radix)const
   {
      return ::boost::re_detail::global_toi(p1, p2, radix, *this);
   }
   char_type translate(char_type c, bool icase)const
   {
      return (icase ? this->translate_nocase(c) : this->translate(c));
   }
   char_type translate(char_type c)const
   {
      return BaseT::translate(c);
   }
   char_type tolower(char_type c)const
   {
      return ::boost::re_detail::global_lower(c);
   }
   char_type toupper(char_type c)const
   {
      return ::boost::re_detail::global_upper(c);
   }
};

template <class BaseT, bool has_extensions>
struct compute_wrapper_base
{
   typedef BaseT type;
};

template <class BaseT>
struct compute_wrapper_base<BaseT, false>
{
   typedef default_wrapper<BaseT> type;
};
# 160 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_traits.hpp" 3
}

template <class BaseT>
struct regex_traits_wrapper
   : public ::boost::re_detail::compute_wrapper_base<
               BaseT,
               ::boost::re_detail::has_boost_extensions_tag<BaseT>::value
            >::type
{
   regex_traits_wrapper(){}
private:
   regex_traits_wrapper(const regex_traits_wrapper&);
   regex_traits_wrapper& operator=(const regex_traits_wrapper&);
};

}
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/regex_traits.hpp" 2 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3





# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_flags.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_flags.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_flags.hpp" 2 3



namespace boost{
   namespace regex_constants{


typedef enum _match_flags
{
   match_default = 0,
   match_not_bol = 1,
   match_not_eol = match_not_bol << 1,
   match_not_bob = match_not_eol << 1,
   match_not_eob = match_not_bob << 1,
   match_not_bow = match_not_eob << 1,
   match_not_eow = match_not_bow << 1,
   match_not_dot_newline = match_not_eow << 1,
   match_not_dot_null = match_not_dot_newline << 1,
   match_prev_avail = match_not_dot_null << 1,
   match_init = match_prev_avail << 1,
   match_any = match_init << 1,
   match_not_null = match_any << 1,
   match_continuous = match_not_null << 1,

   match_partial = match_continuous << 1,

   match_stop = match_partial << 1,
   match_not_initial_null = match_stop,
   match_all = match_stop << 1,
   match_perl = match_all << 1,
   match_posix = match_perl << 1,
   match_nosubs = match_posix << 1,
   match_extra = match_nosubs << 1,
   match_single_line = match_extra << 1,
   match_unused1 = match_single_line << 1,
   match_unused2 = match_unused1 << 1,
   match_unused3 = match_unused2 << 1,
   match_max = match_unused3,

   format_perl = 0,
   format_default = 0,
   format_sed = match_max << 1,
   format_all = format_sed << 1,
   format_no_copy = format_all << 1,
   format_first_only = format_no_copy << 1,
   format_is_if = format_first_only << 1,
   format_literal = format_is_if << 1

} match_flags;




typedef match_flags match_flag_type;



inline match_flags operator&(match_flags m1, match_flags m2)
{ return static_cast<match_flags>(static_cast<boost::int32_t>(m1) & static_cast<boost::int32_t>(m2)); }
inline match_flags operator|(match_flags m1, match_flags m2)
{ return static_cast<match_flags>(static_cast<boost::int32_t>(m1) | static_cast<boost::int32_t>(m2)); }
inline match_flags operator^(match_flags m1, match_flags m2)
{ return static_cast<match_flags>(static_cast<boost::int32_t>(m1) ^ static_cast<boost::int32_t>(m2)); }
inline match_flags operator~(match_flags m1)
{ return static_cast<match_flags>(~static_cast<boost::int32_t>(m1)); }
inline match_flags& operator&=(match_flags& m1, match_flags m2)
{ m1 = m1&m2; return m1; }
inline match_flags& operator|=(match_flags& m1, match_flags m2)
{ m1 = m1|m2; return m1; }
inline match_flags& operator^=(match_flags& m1, match_flags m2)
{ m1 = m1^m2; return m1; }




}



using regex_constants::match_flag_type;
using regex_constants::match_default;
using regex_constants::match_not_bol;
using regex_constants::match_not_eol;
using regex_constants::match_not_bob;
using regex_constants::match_not_eob;
using regex_constants::match_not_bow;
using regex_constants::match_not_eow;
using regex_constants::match_not_dot_newline;
using regex_constants::match_not_dot_null;
using regex_constants::match_prev_avail;

using regex_constants::match_any;
using regex_constants::match_not_null;
using regex_constants::match_continuous;
using regex_constants::match_partial;

using regex_constants::match_all;
using regex_constants::match_perl;
using regex_constants::match_posix;
using regex_constants::match_nosubs;
using regex_constants::match_extra;
using regex_constants::match_single_line;

using regex_constants::format_all;
using regex_constants::format_sed;
using regex_constants::format_perl;
using regex_constants::format_default;
using regex_constants::format_no_copy;
using regex_constants::format_first_only;


}
# 46 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_raw_buffer.hpp" 1 3
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_raw_buffer.hpp" 3
namespace boost{
   namespace re_detail{
# 45 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_raw_buffer.hpp" 3
struct empty_padding{};

union padding
{
   void* p;
   unsigned int i;
};

template <int N>
struct padding3
{
   enum{
      padding_size = 8,
      padding_mask = 7
   };
};

template<>
struct padding3<2>
{
   enum{
      padding_size = 2,
      padding_mask = 1
   };
};

template<>
struct padding3<4>
{
   enum{
      padding_size = 4,
      padding_mask = 3
   };
};

template<>
struct padding3<8>
{
   enum{
      padding_size = 8,
      padding_mask = 7
   };
};

template<>
struct padding3<16>
{
   enum{
      padding_size = 16,
      padding_mask = 15
   };
};

enum{
   padding_size = padding3<sizeof(padding)>::padding_size,
   padding_mask = padding3<sizeof(padding)>::padding_mask
};







class raw_storage
{
public:
   typedef std::size_t size_type;
   typedef unsigned char* pointer;
private:
   pointer last, start, end;
public:

   raw_storage();
   raw_storage(size_type n);

   ~raw_storage()
   {
      ::operator delete(start);
   }

   void resize(size_type n);

   void* extend(size_type n)
   {
      if(size_type(last - end) < n)
         resize(n + (end - start));
      register pointer result = end;
      end += n;
      return result;
   }

   void* insert(size_type pos, size_type n);

   size_type size()
   {
      return end - start;
   }

   size_type capacity()
   {
      return last - start;
   }

   void* data()const
   {
      return start;
   }

   size_type index(void* ptr)
   {
      return static_cast<pointer>(ptr) - static_cast<pointer>(data());
   }

   void clear()
   {
      end = start;
   }

   void align()
   {

      end = start + (((end - start) + padding_mask) & ~padding_mask);
   }
   void swap(raw_storage& that)
   {
      std::swap(start, that.start);
      std::swap(end, that.end);
      std::swap(last, that.last);
  }
};

inline raw_storage::raw_storage()
{
   last = start = end = 0;
}

inline raw_storage::raw_storage(size_type n)
{
   start = end = static_cast<pointer>(::operator new(n));
  
   last = start + n;
}
# 201 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_raw_buffer.hpp" 3
}
}
# 49 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3






# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/char_regex_traits.hpp" 1 3
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/char_regex_traits.hpp" 3
namespace boost{

namespace deprecated{



template <class charT>
class char_regex_traits_i : public regex_traits<charT> {};

template<>
class char_regex_traits_i<char> : public regex_traits<char>
{
public:
   typedef char char_type;
   typedef unsigned char uchar_type;
   typedef unsigned int size_type;
   typedef regex_traits<char> base_type;

};


template<>
class char_regex_traits_i<wchar_t> : public regex_traits<wchar_t>
{
public:
   typedef wchar_t char_type;
   typedef unsigned short uchar_type;
   typedef unsigned int size_type;
   typedef regex_traits<wchar_t> base_type;

};

}
}
# 56 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/states.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/states.hpp" 3
namespace boost{
namespace re_detail{







enum mask_type
{
   mask_take = 1,
   mask_skip = 2,
   mask_init = 4,
   mask_any = mask_skip | mask_take,
   mask_all = mask_any
};





struct _narrow_type{};
struct _wide_type{};
template <class charT> struct is_byte;
template<> struct is_byte<char> { typedef _narrow_type width_type; };
template<> struct is_byte<unsigned char>{ typedef _narrow_type width_type; };
template<> struct is_byte<signed char> { typedef _narrow_type width_type; };
template <class charT> struct is_byte { typedef _wide_type width_type; };




enum syntax_element_type
{

   syntax_element_startmark = 0,

   syntax_element_endmark = syntax_element_startmark + 1,

   syntax_element_literal = syntax_element_endmark + 1,

   syntax_element_start_line = syntax_element_literal + 1,

   syntax_element_end_line = syntax_element_start_line + 1,

   syntax_element_wild = syntax_element_end_line + 1,

   syntax_element_match = syntax_element_wild + 1,

   syntax_element_word_boundary = syntax_element_match + 1,

   syntax_element_within_word = syntax_element_word_boundary + 1,

   syntax_element_word_start = syntax_element_within_word + 1,

   syntax_element_word_end = syntax_element_word_start + 1,

   syntax_element_buffer_start = syntax_element_word_end + 1,

   syntax_element_buffer_end = syntax_element_buffer_start + 1,

   syntax_element_backref = syntax_element_buffer_end + 1,

   syntax_element_long_set = syntax_element_backref + 1,

   syntax_element_set = syntax_element_long_set + 1,

   syntax_element_jump = syntax_element_set + 1,

   syntax_element_alt = syntax_element_jump + 1,

   syntax_element_rep = syntax_element_alt + 1,

   syntax_element_combining = syntax_element_rep + 1,

   syntax_element_soft_buffer_end = syntax_element_combining + 1,

   syntax_element_restart_continue = syntax_element_soft_buffer_end + 1,

   syntax_element_dot_rep = syntax_element_restart_continue + 1,
   syntax_element_char_rep = syntax_element_dot_rep + 1,
   syntax_element_short_set_rep = syntax_element_char_rep + 1,
   syntax_element_long_set_rep = syntax_element_short_set_rep + 1,

   syntax_element_backstep = syntax_element_long_set_rep + 1,

   syntax_element_assert_backref = syntax_element_backstep + 1,
   syntax_element_toggle_case = syntax_element_assert_backref + 1
};






struct re_syntax_base;






union offset_type
{
   re_syntax_base* p;
   std::ptrdiff_t i;
};




struct re_syntax_base
{
   syntax_element_type type;
   offset_type next;
};




struct re_brace : public re_syntax_base
{


   int index;
};




enum
{
   dont_care = 1,
   force_not_newline = 0,
   force_newline = 2,

   test_not_newline = 2,
   test_newline = 3
};
struct re_dot : public re_syntax_base
{
   unsigned char mask;
};





struct re_literal : public re_syntax_base
{
   unsigned int length;
};




struct re_case : public re_syntax_base
{
   bool icase;
};
# 202 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/states.hpp" 3
template <class mask_type>
struct re_set_long : public re_syntax_base
{
   unsigned int csingles, cranges, cequivalents;
   mask_type cclasses;
   mask_type cnclasses;
   bool isnot;
   bool singleton;
};




struct re_set : public re_syntax_base
{
   unsigned char _map[1 << 8];
};




struct re_jump : public re_syntax_base
{
   offset_type alt;
};




struct re_alt : public re_jump
{
   unsigned char _map[1 << 8];
   unsigned int can_be_null;
};




struct re_repeat : public re_alt
{
   std::size_t min, max;
   int id;
   bool leading;
   bool greedy;
};






enum re_jump_size_type
{
   re_jump_size = (sizeof(re_jump) + padding_mask) & ~(padding_mask),
   re_repeater_size = (sizeof(re_repeat) + padding_mask) & ~(padding_mask),
   re_alt_size = (sizeof(re_alt) + padding_mask) & ~(padding_mask)
};





template<class charT, class traits>
struct regex_data;

template <class iterator, class charT, class traits_type, class char_classT>
iterator re_is_set_member(iterator next,
                          iterator last,
                          const re_set_long<char_classT>* set_,
                          const regex_data<charT, traits_type>& e, bool icase);

}

}
# 59 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regbase.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regbase.hpp" 3
namespace boost{




class regbase
{
public:
   enum flag_type_
   {
# 53 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regbase.hpp" 3
      perl_syntax_group = 0,
      basic_syntax_group = 1,
      literal = 2,
      main_option_type = literal | basic_syntax_group | perl_syntax_group,



      no_bk_refs = 1 << 8,
      no_perl_ex = 1 << 9,
      no_mod_m = 1 << 10,
      mod_x = 1 << 11,
      mod_s = 1 << 12,
      no_mod_s = 1 << 13,




      no_char_classes = 1 << 8,
      no_intervals = 1 << 9,
      bk_plus_qm = 1 << 10,
      bk_vbar = 1 << 11,
      emacs_ex = 1 << 12,




      no_escape_in_lists = 1 << 16,
      newline_alt = 1 << 17,
      no_except = 1 << 18,
      failbit = 1 << 19,
      icase = 1 << 20,
      nocollate = 0,
      collate = 1 << 21,
      nosubs = 1 << 22,
      optimize = 0,



      basic = basic_syntax_group | collate | no_escape_in_lists,
      extended = no_bk_refs | collate | no_perl_ex | no_escape_in_lists,
      normal = 0,
      emacs = basic_syntax_group | collate | emacs_ex | bk_vbar,
      awk = no_bk_refs | collate | no_perl_ex,
      grep = basic | newline_alt,
      egrep = extended | newline_alt,
      sed = basic,
      perl = normal,
      ECMAScript = normal,
      JavaScript = normal,
      JScript = normal
   };
   typedef unsigned int flag_type;

   enum restart_info
   {
      restart_any = 0,
      restart_word = 1,
      restart_line = 2,
      restart_buf = 3,
      restart_continue = 4,
      restart_lit = 5,
      restart_fixed_lit = 6,
      restart_count = 7
   };
};




namespace regex_constants{

   enum flag_type_
   {

      no_except = ::boost::regbase::no_except,
      failbit = ::boost::regbase::failbit,
      literal = ::boost::regbase::literal,
      icase = ::boost::regbase::icase,
      nocollate = ::boost::regbase::nocollate,
      collate = ::boost::regbase::collate,
      nosubs = ::boost::regbase::nosubs,
      optimize = ::boost::regbase::optimize,
      bk_plus_qm = ::boost::regbase::bk_plus_qm,
      bk_vbar = ::boost::regbase::bk_vbar,
      no_intervals = ::boost::regbase::no_intervals,
      no_char_classes = ::boost::regbase::no_char_classes,
      no_escape_in_lists = ::boost::regbase::no_escape_in_lists,
      no_mod_m = ::boost::regbase::no_mod_m,
      mod_x = ::boost::regbase::mod_x,
      mod_s = ::boost::regbase::mod_s,
      no_mod_s = ::boost::regbase::no_mod_s,

      basic = ::boost::regbase::basic,
      extended = ::boost::regbase::extended,
      normal = ::boost::regbase::normal,
      emacs = ::boost::regbase::emacs,
      awk = ::boost::regbase::awk,
      grep = ::boost::regbase::grep,
      egrep = ::boost::regbase::egrep,
      sed = basic,
      perl = normal,
      ECMAScript = normal,
      JavaScript = normal,
      JScript = normal
   };
   typedef ::boost::regbase::flag_type syntax_option_type;

}

}
# 62 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/iterator_traits.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/iterator_traits.hpp" 3
namespace boost{
namespace re_detail{
# 115 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/iterator_traits.hpp" 3
template <class T>
struct regex_iterator_traits : public std::iterator_traits<T> {};



}
}
# 65 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp" 3
namespace boost{





namespace re_detail{




template <class charT, class traits>
class basic_regex_parser;





template <class charT, class traits>
struct regex_data
{
   typedef regex_constants::syntax_option_type flag_type;
   typedef std::size_t size_type;

   regex_data(const ::boost::shared_ptr<
      ::boost::regex_traits_wrapper<traits> >& t)
      : m_ptraits(t), m_expression(0), m_expression_len(0) {}
   regex_data()
      : m_ptraits(new ::boost::regex_traits_wrapper<traits>()), m_expression(0), m_expression_len(0) {}

   ::boost::shared_ptr<
      ::boost::regex_traits_wrapper<traits>
      > m_ptraits;
   flag_type m_flags;
   int m_status;
   const charT* m_expression;
   std::ptrdiff_t m_expression_len;
   size_type m_mark_count;
   re_detail::re_syntax_base* m_first_state;
   unsigned m_restart_type;
   unsigned char m_startmap[1 << 8];
   unsigned int m_can_be_null;
   re_detail::raw_storage m_data;
   typename traits::char_class_type m_word_mask;
};




template <class charT, class traits>
class basic_regex_implementation
   : public regex_data<charT, traits>
{
public:
   typedef regex_constants::syntax_option_type flag_type;
   typedef std::ptrdiff_t difference_type;
   typedef std::size_t size_type;
   typedef typename traits::locale_type locale_type;
   typedef const charT* const_iterator;

   basic_regex_implementation(){}
   basic_regex_implementation(const ::boost::shared_ptr<
      ::boost::regex_traits_wrapper<traits> >& t)
      : regex_data<charT, traits>(t) {}
   void assign(const charT* arg_first,
                          const charT* arg_last,
                          flag_type f)
   {
      regex_data<charT, traits>* pdat = this;
      basic_regex_parser<charT, traits> parser(pdat);
      parser.parse(arg_first, arg_last, f);
   }

   locale_type imbue(locale_type l)
   {
      return this->m_ptraits->imbue(l);
   }
   locale_type getloc()const
   {
      return this->m_ptraits->getloc();
   }
   std::basic_string<charT> str()const
   {
      std::basic_string<charT> result;
      if(this->m_status == 0)
         result = std::basic_string<charT>(this->m_expression, this->m_expression_len);
      return result;
   }
   const_iterator expression()const
   {
      return this->m_expression;
   }


   const_iterator begin()const
   {
      return (!this->m_status ? 0 : this->m_expression);
   }
   const_iterator end()const
   {
      return (!this->m_status ? 0 : this->m_expression + this->m_expression_len);
   }
   flag_type flags()const
   {
      return this->m_flags;
   }
   size_type size()const
   {
      return this->m_expression_len;
   }
   int status()const
   {
      return this->m_status;
   }
   size_type mark_count()const
   {
      return this->m_mark_count;
   }
   const re_detail::re_syntax_base* get_first_state()const
   {
      return this->m_first_state;
   }
   unsigned get_restart_type()const
   {
      return this->m_restart_type;
   }
   const unsigned char* get_map()const
   {
      return this->m_startmap;
   }
   const ::boost::regex_traits_wrapper<traits>& get_traits()const
   {
      return *(this->m_ptraits);
   }
   bool can_be_null()const
   {
      return this->m_can_be_null;
   }
   const regex_data<charT, traits>& get_data()const
   {
      basic_regex_implementation<charT, traits> const* p = this;
      return *static_cast<const regex_data<charT, traits>*>(p);
   }
};

}
# 188 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp" 3
template <class charT, class traits >

class basic_regex : public regbase
{
public:

   typedef typename traits::size_type traits_size_type;
   typedef typename traits::string_type traits_string_type;
   typedef charT char_type;
   typedef traits traits_type;

   typedef charT value_type;
   typedef charT& reference;
   typedef const charT& const_reference;
   typedef const charT* const_iterator;
   typedef const_iterator iterator;
   typedef std::ptrdiff_t difference_type;
   typedef std::size_t size_type;
   typedef regex_constants::syntax_option_type flag_type;



   typedef typename traits::locale_type locale_type;

public:
   explicit basic_regex(){}
   explicit basic_regex(const charT* p, flag_type f = regex_constants::normal)
   {
      assign(p, f);
   }
   basic_regex(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
   {
      assign(p1, p2, f);
   }
   basic_regex(const charT* p, size_type len, flag_type f)
   {
      assign(p, len, f);
   }
   basic_regex(const basic_regex& that)
      : m_pimpl(that.m_pimpl) {}
   ~basic_regex(){}
   basic_regex& operator=(const basic_regex& that)
   {
      return assign(that);
   }
   basic_regex& operator=(const charT* ptr)
   {
      return assign(ptr);
   }



   basic_regex& assign(const basic_regex& that)
   {
      m_pimpl = that.m_pimpl;
      return *this;
   }
   basic_regex& assign(const charT* p, flag_type f = regex_constants::normal)
   {
      return assign(p, p + traits::length(p), f);
   }
   basic_regex& assign(const charT* p, size_type len, flag_type f)
   {
      return assign(p, p + len, f);
   }
private:
   basic_regex& do_assign(const charT* p1,
                          const charT* p2,
                          flag_type f);
public:
   basic_regex& assign(const charT* p1,
                          const charT* p2,
                          flag_type f = regex_constants::normal)
   {
      return do_assign(p1, p2, f);
   }


   template <class ST, class SA>
   unsigned int set_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
   {
      return set_expression(p.data(), p.data() + p.size(), f);
   }

   template <class ST, class SA>
   explicit basic_regex(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
   {
      assign(p, f);
   }

   template <class InputIterator>
   basic_regex(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
   {
      typedef typename traits::string_type seq_type;
      seq_type a(arg_first, arg_last);
      if(a.size())
         assign(&*a.begin(), &*a.begin() + a.size(), f);
      else
         assign(static_cast<const charT*>(0), static_cast<const charT*>(0), f);
   }

   template <class ST, class SA>
   basic_regex& operator=(const std::basic_string<charT, ST, SA>& p)
   {
      return assign(p.data(), p.data() + p.size(), regex_constants::normal);
   }

   template <class string_traits, class A>
   basic_regex& assign(
       const std::basic_string<charT, string_traits, A>& s,
       flag_type f = regex_constants::normal)
   {
      return assign(s.data(), s.data() + s.size(), f);
   }

   template <class InputIterator>
   basic_regex& assign(InputIterator arg_first,
                          InputIterator arg_last,
                          flag_type f = regex_constants::normal)
   {
      typedef typename traits::string_type seq_type;
      seq_type a(arg_first, arg_last);
      if(a.size())
      {
         const charT* p1 = &*a.begin();
         const charT* p2 = &*a.begin() + a.size();
         return assign(p1, p2, f);
      }
      return assign(static_cast<const charT*>(0), static_cast<const charT*>(0), f);
   }
# 345 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp" 3
   locale_type imbue(locale_type l);
   locale_type getloc()const
   {
      return m_pimpl.get() ? m_pimpl->getloc() : locale_type();
   }




   flag_type getflags()const
   {
      return flags();
   }
   flag_type flags()const
   {
      return m_pimpl.get() ? m_pimpl->flags() : 0;
   }


   std::basic_string<charT> str()const
   {
      return m_pimpl.get() ? m_pimpl->str() : std::basic_string<charT>();
   }


   const_iterator begin()const
   {
      return (m_pimpl.get() ? m_pimpl->begin() : 0);
   }
   const_iterator end()const
   {
      return (m_pimpl.get() ? m_pimpl->end() : 0);
   }


   void swap(basic_regex& that)throw()
   {
      m_pimpl.swap(that.m_pimpl);
   }


   size_type size()const
   {
      return (m_pimpl.get() ? m_pimpl->size() : 0);
   }


   size_type max_size()const
   {
      return (2147483647 * 2U + 1U);
   }


   bool empty()const
   {
      return (m_pimpl.get() ? 0 != m_pimpl->status() : true);
   }

   size_type mark_count()const
   {
      return (m_pimpl.get() ? m_pimpl->mark_count() : 0);
   }

   int status()const
   {
      return (m_pimpl.get() ? m_pimpl->status() : regex_constants::error_empty);
   }

   int compare(const basic_regex& that) const
   {
      if(m_pimpl.get() == that.m_pimpl.get())
         return 0;
      if(!m_pimpl.get())
         return -1;
      if(!that.m_pimpl.get())
         return 1;
      if(status() != that.status())
         return status() - that.status();
      if(flags() != that.flags())
         return flags() - that.flags();
      return str().compare(that.str());
   }
   bool operator==(const basic_regex& e)const
   {
      return compare(e) == 0;
   }
   bool operator != (const basic_regex& e)const
   {
      return compare(e) != 0;
   }
   bool operator<(const basic_regex& e)const
   {
      return compare(e) < 0;
   }
   bool operator>(const basic_regex& e)const
   {
      return compare(e) > 0;
   }
   bool operator<=(const basic_regex& e)const
   {
      return compare(e) <= 0;
   }
   bool operator>=(const basic_regex& e)const
   {
      return compare(e) >= 0;
   }




   const charT* expression()const
   {
      return (m_pimpl.get() && !m_pimpl->status() ? m_pimpl->expression() : 0);
   }
   unsigned int set_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
   {
      assign(p1, p2, f | regex_constants::no_except);
      return status();
   }
   unsigned int set_expression(const charT* p, flag_type f = regex_constants::normal)
   {
      assign(p, f | regex_constants::no_except);
      return status();
   }
   unsigned int error_code()const
   {
      return status();
   }



   const re_detail::re_syntax_base* get_first_state()const
   {
      (__builtin_expect(!(0 != m_pimpl.get()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp", 478, "0 != m_pimpl.get()") : (void)0);
      return m_pimpl->get_first_state();
   }
   unsigned get_restart_type()const
   {
      (__builtin_expect(!(0 != m_pimpl.get()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp", 483, "0 != m_pimpl.get()") : (void)0);
      return m_pimpl->get_restart_type();
   }
   const unsigned char* get_map()const
   {
      (__builtin_expect(!(0 != m_pimpl.get()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp", 488, "0 != m_pimpl.get()") : (void)0);
      return m_pimpl->get_map();
   }
   const ::boost::regex_traits_wrapper<traits>& get_traits()const
   {
      (__builtin_expect(!(0 != m_pimpl.get()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp", 493, "0 != m_pimpl.get()") : (void)0);
      return m_pimpl->get_traits();
   }
   bool can_be_null()const
   {
      (__builtin_expect(!(0 != m_pimpl.get()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp", 498, "0 != m_pimpl.get()") : (void)0);
      return m_pimpl->can_be_null();
   }
   const re_detail::regex_data<charT, traits>& get_data()const
   {
      (__builtin_expect(!(0 != m_pimpl.get()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp", 503, "0 != m_pimpl.get()") : (void)0);
      return m_pimpl->get_data();
   }

private:
   shared_ptr<re_detail::basic_regex_implementation<charT, traits> > m_pimpl;
};







template <class charT, class traits>
basic_regex<charT, traits>& basic_regex<charT, traits>::do_assign(const charT* p1,
                        const charT* p2,
                        flag_type f)
{
   shared_ptr<re_detail::basic_regex_implementation<charT, traits> > temp;
   if(!m_pimpl.get())
   {
      temp = shared_ptr<re_detail::basic_regex_implementation<charT, traits> >(new re_detail::basic_regex_implementation<charT, traits>());
   }
   else
   {
      temp = shared_ptr<re_detail::basic_regex_implementation<charT, traits> >(new re_detail::basic_regex_implementation<charT, traits>(m_pimpl->m_ptraits));
   }
   temp->assign(p1, p2, f);
   temp.swap(m_pimpl);
   return *this;
}

template <class charT, class traits>
typename basic_regex<charT, traits>::locale_type basic_regex<charT, traits>::imbue(locale_type l)
{
   shared_ptr<re_detail::basic_regex_implementation<charT, traits> > temp(new re_detail::basic_regex_implementation<charT, traits>());
   locale_type result = temp->imbue(l);
   temp.swap(m_pimpl);
   return result;
}




template <class charT, class traits>
void swap(basic_regex<charT, traits>& e1, basic_regex<charT, traits>& e2)
{
   e1.swap(e2);
}


template <class charT, class traits, class traits2>
std::basic_ostream<charT, traits>&
   operator << (std::basic_ostream<charT, traits>& os,
                const basic_regex<charT, traits2>& e)
{
   return (os << e.str());
}
# 578 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp" 3
template <class charT, class traits >

class reg_expression : public basic_regex<charT, traits>
{
public:
   typedef typename basic_regex<charT, traits>::flag_type flag_type;
   typedef typename basic_regex<charT, traits>::size_type size_type;
   explicit reg_expression(){}
   explicit reg_expression(const charT* p, flag_type f = regex_constants::normal)
      : basic_regex<charT, traits>(p, f){}
   reg_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
      : basic_regex<charT, traits>(p1, p2, f){}
   reg_expression(const charT* p, size_type len, flag_type f)
      : basic_regex<charT, traits>(p, len, f){}
   reg_expression(const reg_expression& that)
      : basic_regex<charT, traits>(that) {}
   ~reg_expression(){}
   reg_expression& operator=(const reg_expression& that)
   {
      return this->assign(that);
   }


   template <class ST, class SA>
   explicit reg_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
   : basic_regex<charT, traits>(p, f)
   {
   }

   template <class InputIterator>
   reg_expression(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
   : basic_regex<charT, traits>(arg_first, arg_last, f)
   {
   }

   template <class ST, class SA>
   reg_expression& operator=(const std::basic_string<charT, ST, SA>& p)
   {
      this->assign(p);
      return *this;
   }
# 632 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex.hpp" 3
};





}
# 68 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp" 1 3
# 39 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp" 3
namespace boost{

namespace re_detail{

template <class charT>
struct digraph : public std::pair<charT, charT>
{
   digraph() : std::pair<charT, charT>(0, 0){}
   digraph(charT c1) : std::pair<charT, charT>(c1, 0){}
   digraph(charT c1, charT c2) : std::pair<charT, charT>(c1, c2)
   {}

   digraph(const digraph<charT>& d) : std::pair<charT, charT>(d.first, d.second){}

   template <class Seq>
   digraph(const Seq& s) : std::pair<charT, charT>()
   {
      (__builtin_expect(!(s.size() <= 2), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp", 56, "s.size() <= 2") : (void)0);
      (__builtin_expect(!(s.size()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp", 57, "s.size()") : (void)0);
      this->first = s[0];
      this->second = (s.size() > 1) ? s[1] : 0;
   }
};

template <class charT, class traits>
class basic_char_set
{
public:
   typedef digraph<charT> digraph_type;
   typedef typename traits::string_type string_type;
   typedef typename traits::char_class_type mask_type;

   basic_char_set()
   {
      m_negate = false;
      m_has_digraphs = false;
      m_classes = 0;
      m_negated_classes = 0;
      m_empty = true;
   }

   void add_single(const digraph_type& s)
   {
      m_singles.insert(m_singles.end(), s);
      if(s.second)
         m_has_digraphs = true;
      m_empty = false;
   }
   void add_range(const digraph_type& first, const digraph_type& end)
   {
      m_ranges.insert(m_ranges.end(), first);
      m_ranges.insert(m_ranges.end(), end);
      if(first.second)
      {
         m_has_digraphs = true;
         add_single(first);
      }
      if(end.second)
      {
         m_has_digraphs = true;
         add_single(end);
      }
      m_empty = false;
   }
   void add_class(mask_type m)
   {
      m_classes |= m;
      m_empty = false;
   }
   void add_negated_class(mask_type m)
   {
      m_negated_classes |= m;
      m_empty = false;
   }
   void add_equivalent(const digraph_type& s)
   {
      m_equivalents.insert(m_equivalents.end(), s);
      if(s.second)
      {
         m_has_digraphs = true;
         add_single(s);
      }
      m_empty = false;
   }
   void negate()
   {
      m_negate = true;

   }




   bool has_digraphs()const
   {
      return m_has_digraphs;
   }
   bool is_negated()const
   {
      return m_negate;
   }
   typedef typename std::vector<digraph_type>::const_iterator list_iterator;
   list_iterator singles_begin()const
   {
      return m_singles.begin();
   }
   list_iterator singles_end()const
   {
      return m_singles.end();
   }
   list_iterator ranges_begin()const
   {
      return m_ranges.begin();
   }
   list_iterator ranges_end()const
   {
      return m_ranges.end();
   }
   list_iterator equivalents_begin()const
   {
      return m_equivalents.begin();
   }
   list_iterator equivalents_end()const
   {
      return m_equivalents.end();
   }
   mask_type classes()const
   {
      return m_classes;
   }
   mask_type negated_classes()const
   {
      return m_negated_classes;
   }
   bool empty()const
   {
      return m_empty;
   }
private:
   std::vector<digraph_type> m_singles;
   std::vector<digraph_type> m_ranges;
   bool m_negate;
   bool m_has_digraphs;
   mask_type m_classes;
   mask_type m_negated_classes;
   bool m_empty;
   std::vector<digraph_type> m_equivalents;
};

template <class charT, class traits>
class basic_regex_creator
{
public:
   basic_regex_creator(regex_data<charT, traits>* data);
   std::ptrdiff_t getoffset(void* addr)
   {
      return getoffset(addr, m_pdata->m_data.data());
   }
   std::ptrdiff_t getoffset(const void* addr, const void* base)
   {
      return static_cast<const char*>(addr) - static_cast<const char*>(base);
   }
   re_syntax_base* getaddress(std::ptrdiff_t off)
   {
      return getaddress(off, m_pdata->m_data.data());
   }
   re_syntax_base* getaddress(std::ptrdiff_t off, void* base)
   {
      return static_cast<re_syntax_base*>(static_cast<void*>(static_cast<char*>(base) + off));
   }
   void init(unsigned l_flags)
   {
      m_pdata->m_flags = l_flags;
      m_icase = l_flags & regex_constants::icase;
   }
   regbase::flag_type flags()
   {
      return m_pdata->m_flags;
   }
   void flags(regbase::flag_type f)
   {
      m_pdata->m_flags = f;
      if(m_icase != static_cast<bool>(f & regbase::icase))
      {
         m_icase = static_cast<bool>(f & regbase::icase);
      }
   }
   re_syntax_base* append_state(syntax_element_type t, std::size_t s = sizeof(re_syntax_base));
   re_syntax_base* insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s = sizeof(re_syntax_base));
   re_literal* append_literal(charT c);
   re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set);
   re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, mpl::false_*);
   re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, mpl::true_*);
   void finalize(const charT* p1, const charT* p2);
protected:
   regex_data<charT, traits>* m_pdata;
   const ::boost::regex_traits_wrapper<traits>&
                                 m_traits;
   re_syntax_base* m_last_state;
   bool m_icase;
   unsigned m_repeater_id;
   bool m_has_backrefs;
   unsigned m_backrefs;
   boost::uintmax_t m_bad_repeats;
   typename traits::char_class_type m_word_mask;
   typename traits::char_class_type m_mask_space;
   typename traits::char_class_type m_lower_mask;
   typename traits::char_class_type m_upper_mask;
   typename traits::char_class_type m_alpha_mask;
private:
   basic_regex_creator& operator=(const basic_regex_creator&);
   basic_regex_creator(const basic_regex_creator&);

   void fixup_pointers(re_syntax_base* state);
   void create_startmaps(re_syntax_base* state);
   int calculate_backstep(re_syntax_base* state);
   void create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask);
   unsigned get_restart_type(re_syntax_base* state);
   void set_all_masks(unsigned char* bits, unsigned char);
   bool is_bad_repeat(re_syntax_base* pt);
   void set_bad_repeat(re_syntax_base* pt);
   syntax_element_type get_repeat_type(re_syntax_base* state);
   void probe_leading_repeat(re_syntax_base* state);
};

template <class charT, class traits>
basic_regex_creator<charT, traits>::basic_regex_creator(regex_data<charT, traits>* data)
   : m_pdata(data), m_traits(*(data->m_ptraits)), m_last_state(0), m_repeater_id(0), m_has_backrefs(false), m_backrefs(0)
{
   m_pdata->m_data.clear();
   m_pdata->m_status = ::boost::regex_constants::error_ok;
   static const charT w = 'w';
   static const charT s = 's';
   static const charT l[5] = { 'l', 'o', 'w', 'e', 'r', };
   static const charT u[5] = { 'u', 'p', 'p', 'e', 'r', };
   static const charT a[5] = { 'a', 'l', 'p', 'h', 'a', };
   m_word_mask = m_traits.lookup_classname(&w, &w +1);
   m_mask_space = m_traits.lookup_classname(&s, &s +1);
   m_lower_mask = m_traits.lookup_classname(l, l + 5);
   m_upper_mask = m_traits.lookup_classname(u, u + 5);
   m_alpha_mask = m_traits.lookup_classname(a, a + 5);
   m_pdata->m_word_mask = m_word_mask;
   (__builtin_expect(!(m_word_mask != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp", 281, "m_word_mask != 0") : (void)0);
   (__builtin_expect(!(m_mask_space != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp", 282, "m_mask_space != 0") : (void)0);
   (__builtin_expect(!(m_lower_mask != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp", 283, "m_lower_mask != 0") : (void)0);
   (__builtin_expect(!(m_upper_mask != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp", 284, "m_upper_mask != 0") : (void)0);
   (__builtin_expect(!(m_alpha_mask != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp", 285, "m_alpha_mask != 0") : (void)0);
}

template <class charT, class traits>
re_syntax_base* basic_regex_creator<charT, traits>::append_state(syntax_element_type t, std::size_t s)
{

   if(t == syntax_element_backref)
      this->m_has_backrefs = true;

   m_pdata->m_data.align();

   if(m_last_state)
      m_last_state->next.i = m_pdata->m_data.size() - getoffset(m_last_state);

   m_last_state = static_cast<re_syntax_base*>(m_pdata->m_data.extend(s));

   m_last_state->next.i = 0;
   m_last_state->type = t;
   return m_last_state;
}

template <class charT, class traits>
re_syntax_base* basic_regex_creator<charT, traits>::insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s)
{

   m_pdata->m_data.align();

   if(m_last_state)
      m_last_state->next.i = m_pdata->m_data.size() - getoffset(m_last_state);

   std::ptrdiff_t off = getoffset(m_last_state) + s;

   re_syntax_base* new_state = static_cast<re_syntax_base*>(m_pdata->m_data.insert(pos, s));

   new_state->next.i = s;
   new_state->type = t;
   m_last_state = getaddress(off);
   return new_state;
}

template <class charT, class traits>
re_literal* basic_regex_creator<charT, traits>::append_literal(charT c)
{
   re_literal* result;

   if((0 == m_last_state) || (m_last_state->type != syntax_element_literal))
   {

      result = static_cast<re_literal*>(append_state(syntax_element_literal, sizeof(re_literal) + sizeof(charT)));
      result->length = 1;
      *static_cast<charT*>(static_cast<void*>(result+1)) = m_traits.translate(c, m_icase);
   }
   else
   {

      std::ptrdiff_t off = getoffset(m_last_state);
      m_pdata->m_data.extend(sizeof(charT));
      m_last_state = result = static_cast<re_literal*>(getaddress(off));
      charT* characters = static_cast<charT*>(static_cast<void*>(result+1));
      characters[result->length] = m_traits.translate(c, m_icase);
      ++(result->length);
   }
   return result;
}

template <class charT, class traits>
inline re_syntax_base* basic_regex_creator<charT, traits>::append_set(
   const basic_char_set<charT, traits>& char_set)
{
   typedef mpl::bool_< (sizeof(charT) == 1) > truth_type;
   return char_set.has_digraphs()
      ? append_set(char_set, static_cast<mpl::false_*>(0))
      : append_set(char_set, static_cast<truth_type*>(0));
}

template <class charT, class traits>
re_syntax_base* basic_regex_creator<charT, traits>::append_set(
   const basic_char_set<charT, traits>& char_set, mpl::false_*)
{
   typedef typename traits::string_type string_type;
   typedef typename basic_char_set<charT, traits>::list_iterator item_iterator;
   typedef typename traits::char_class_type mask_type;

   re_set_long<mask_type>* result = static_cast<re_set_long<mask_type>*>(append_state(syntax_element_long_set, sizeof(re_set_long<mask_type>)));



   result->csingles = static_cast<unsigned int>(::boost::re_detail::distance(char_set.singles_begin(), char_set.singles_end()));
   result->cranges = static_cast<unsigned int>(::boost::re_detail::distance(char_set.ranges_begin(), char_set.ranges_end())) / 2;
   result->cequivalents = static_cast<unsigned int>(::boost::re_detail::distance(char_set.equivalents_begin(), char_set.equivalents_end()));
   result->cclasses = char_set.classes();
   result->cnclasses = char_set.negated_classes();
   if(flags() & regbase::icase)
   {

      if(((result->cclasses & m_lower_mask) == m_lower_mask) || ((result->cclasses & m_upper_mask) == m_upper_mask))
         result->cclasses |= m_alpha_mask;
      if(((result->cnclasses & m_lower_mask) == m_lower_mask) || ((result->cnclasses & m_upper_mask) == m_upper_mask))
         result->cnclasses |= m_alpha_mask;
   }

   result->isnot = char_set.is_negated();
   result->singleton = !char_set.has_digraphs();



   std::ptrdiff_t offset = getoffset(result);



   item_iterator first, last;
   first = char_set.singles_begin();
   last = char_set.singles_end();
   while(first != last)
   {
      charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (first->second ? 3 : 2)));
      p[0] = m_traits.translate(first->first, m_icase);
      if(first->second)
      {
         p[1] = m_traits.translate(first->second, m_icase);
         p[2] = 0;
      }
      else
         p[1] = 0;
      ++first;
   }



   first = char_set.ranges_begin();
   last = char_set.ranges_end();
   while(first != last)
   {

      digraph<charT> c1 = *first;
      c1.first = this->m_traits.translate(c1.first, this->m_icase);
      c1.second = this->m_traits.translate(c1.second, this->m_icase);
      ++first;
      digraph<charT> c2 = *first;
      c2.first = this->m_traits.translate(c2.first, this->m_icase);
      c2.second = this->m_traits.translate(c2.second, this->m_icase);
      ++first;
      string_type s1, s2;

      if(flags() & regex_constants::collate)
      {
# 442 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp" 3
         charT a1[3] = { c1.first, c1.second, charT(0), };
         charT a2[3] = { c2.first, c2.second, charT(0), };
         s1 = this->m_traits.transform(a1, (a1[1] ? a1+2 : a1+1));
         s2 = this->m_traits.transform(a2, (a2[1] ? a2+2 : a2+1));

         if(s1.size() == 0)
            s1 = string_type(1, charT(0));
         if(s2.size() == 0)
            s2 = string_type(1, charT(0));
      }
      else
      {
         if(c1.second)
         {
            s1.insert(s1.end(), c1.first);
            s1.insert(s1.end(), c1.second);
         }
         else
            s1 = string_type(1, c1.first);
         if(c2.second)
         {
            s2.insert(s2.end(), c2.first);
            s2.insert(s2.end(), c2.second);
         }
         else
            s2.insert(s2.end(), c2.first);
      }
      if(s1 > s2)
      {

         return 0;
      }
      charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (s1.size() + s2.size() + 2) ) );
      re_detail::copy(s1.begin(), s1.end(), p);
      p[s1.size()] = charT(0);
      p += s1.size() + 1;
      re_detail::copy(s2.begin(), s2.end(), p);
      p[s2.size()] = charT(0);
   }



   first = char_set.equivalents_begin();
   last = char_set.equivalents_end();
   while(first != last)
   {
      string_type s;
      if(first->second)
      {






         charT cs[3] = { first->first, first->second, charT(0), };
         s = m_traits.transform_primary(cs, cs+2);

      }
      else
         s = m_traits.transform_primary(&first->first, &first->first+1);
      if(s.empty())
         return 0;
      charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (s.size()+1) ) );
      re_detail::copy(s.begin(), s.end(), p);
      p[s.size()] = charT(0);
      ++first;
   }



   m_last_state = result = static_cast<re_set_long<mask_type>*>(getaddress(offset));
   return result;
}

namespace{

template<class T>
inline bool char_less(T t1, T t2)
{
   return t1 < t2;
}
template<>
inline bool char_less<char>(char t1, char t2)
{
   return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);
}
template<>
inline bool char_less<signed char>(signed char t1, signed char t2)
{
   return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);
}
}

template <class charT, class traits>
re_syntax_base* basic_regex_creator<charT, traits>::append_set(
   const basic_char_set<charT, traits>& char_set, mpl::true_*)
{
   typedef typename traits::string_type string_type;
   typedef typename basic_char_set<charT, traits>::list_iterator item_iterator;

   re_set* result = static_cast<re_set*>(append_state(syntax_element_set, sizeof(re_set)));
   bool negate = char_set.is_negated();
   std::memset(result->_map, 0, sizeof(result->_map));



   item_iterator first, last;
   first = char_set.singles_begin();
   last = char_set.singles_end();
   while(first != last)
   {
      for(unsigned int i = 0; i < (1 << 8); ++i)
      {
         if(this->m_traits.translate(static_cast<charT>(i), this->m_icase)
            == this->m_traits.translate(first->first, this->m_icase))
            result->_map[i] = true;
      }
      ++first;
   }



   first = char_set.ranges_begin();
   last = char_set.ranges_end();
   while(first != last)
   {

      charT c1 = this->m_traits.translate(first->first, this->m_icase);
      ++first;
      charT c2 = this->m_traits.translate(first->first, this->m_icase);
      ++first;

      if(flags() & regex_constants::collate)
      {

         charT c3[2] = { c1, charT(0), };
         string_type s1 = this->m_traits.transform(c3, c3+1);
         c3[0] = c2;
         string_type s2 = this->m_traits.transform(c3, c3+1);
         if(s1 > s2)
         {

            return 0;
         }
         (__builtin_expect(!(c3[1] == charT(0)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp", 587, "c3[1] == charT(0)") : (void)0);
         for(unsigned i = 0; i < (1u << 8); ++i)
         {
            c3[0] = static_cast<charT>(i);
            string_type s3 = this->m_traits.transform(c3, c3 +1);
            if((s1 <= s3) && (s3 <= s2))
               result->_map[i] = true;
         }
      }
      else
      {
         if(char_less<charT>(c2, c1))
         {

            return 0;
         }

         std::memset(result->_map + static_cast<unsigned char>(c1), true, 1 + static_cast<unsigned char>(c2) - static_cast<unsigned char>(c1));
      }
   }



   typedef typename traits::char_class_type mask_type;
   mask_type m = char_set.classes();
   if(flags() & regbase::icase)
   {

      if(((m & m_lower_mask) == m_lower_mask) || ((m & m_upper_mask) == m_upper_mask))
         m |= m_alpha_mask;
   }
   if(m != 0)
   {
      for(unsigned i = 0; i < (1u << 8); ++i)
      {
         if(this->m_traits.isctype(static_cast<charT>(i), m))
            result->_map[i] = true;
      }
   }



   m = char_set.negated_classes();
   if(flags() & regbase::icase)
   {

      if(((m & m_lower_mask) == m_lower_mask) || ((m & m_upper_mask) == m_upper_mask))
         m |= m_alpha_mask;
   }
   if(m != 0)
   {
      for(unsigned i = 0; i < (1u << 8); ++i)
      {
         if(0 == this->m_traits.isctype(static_cast<charT>(i), m))
            result->_map[i] = true;
      }
   }



   first = char_set.equivalents_begin();
   last = char_set.equivalents_end();
   while(first != last)
   {
      string_type s;
      (__builtin_expect(!(static_cast<charT>(0) == first->second), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp", 652, "static_cast<charT>(0) == first->second") : (void)0);
      s = m_traits.transform_primary(&first->first, &first->first+1);
      if(s.empty())
         return 0;
      for(unsigned i = 0; i < (1u << 8); ++i)
      {
         charT c[2] = { (static_cast<charT>(i)), charT(0), };
         string_type s2 = this->m_traits.transform_primary(c, c+1);
         if(s == s2)
            result->_map[i] = true;
      }
      ++first;
   }
   if(negate)
   {
      for(unsigned i = 0; i < (1u << 8); ++i)
      {
         result->_map[i] = !(result->_map[i]);
      }
   }
   return result;
}

template <class charT, class traits>
void basic_regex_creator<charT, traits>::finalize(const charT* p1, const charT* p2)
{


   append_state(syntax_element_match);

   std::ptrdiff_t len = p2 - p1;
   m_pdata->m_expression_len = len;
   charT* ps = static_cast<charT*>(m_pdata->m_data.extend(sizeof(charT) * (1 + (p2 - p1))));
   m_pdata->m_expression = ps;
   re_detail::copy(p1, p2, ps);
   ps[p2 - p1] = 0;


   m_pdata->m_status = 0;

   m_pdata->m_first_state = static_cast<re_syntax_base*>(m_pdata->m_data.data());

   fixup_pointers(m_pdata->m_first_state);

   create_startmaps(m_pdata->m_first_state);

   std::memset(m_pdata->m_startmap, 0, sizeof(m_pdata->m_startmap));
   m_pdata->m_can_be_null = 0;

   m_bad_repeats = 0;
   create_startmap(m_pdata->m_first_state, m_pdata->m_startmap, &(m_pdata->m_can_be_null), mask_all);

   m_pdata->m_restart_type = get_restart_type(m_pdata->m_first_state);

   probe_leading_repeat(m_pdata->m_first_state);
}

template <class charT, class traits>
void basic_regex_creator<charT, traits>::fixup_pointers(re_syntax_base* state)
{
   while(state)
   {
      switch(state->type)
      {
      case syntax_element_rep:
      case syntax_element_dot_rep:
      case syntax_element_char_rep:
      case syntax_element_short_set_rep:
      case syntax_element_long_set_rep:

         static_cast<re_repeat*>(state)->id = m_repeater_id++;

      case syntax_element_alt:
         std::memset(static_cast<re_alt*>(state)->_map, 0, sizeof(static_cast<re_alt*>(state)->_map));
         static_cast<re_alt*>(state)->can_be_null = 0;

      case syntax_element_jump:
         static_cast<re_jump*>(state)->alt.p = getaddress(static_cast<re_jump*>(state)->alt.i, state);

      default:
         if(state->next.i)
            state->next.p = getaddress(state->next.i, state);
         else
            state->next.p = 0;
      }
      state = state->next.p;
   }
}

template <class charT, class traits>
void basic_regex_creator<charT, traits>::create_startmaps(re_syntax_base* state)
{
# 752 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp" 3
   bool l_icase = m_icase;
   std::vector<std::pair<bool, re_syntax_base*> > v;

   while(state)
   {
      switch(state->type)
      {
      case syntax_element_toggle_case:

         m_icase = static_cast<re_case*>(state)->icase;
         state = state->next.p;
         continue;
      case syntax_element_alt:
      case syntax_element_rep:
      case syntax_element_dot_rep:
      case syntax_element_char_rep:
      case syntax_element_short_set_rep:
      case syntax_element_long_set_rep:

         v.push_back(std::pair<bool, re_syntax_base*>(m_icase, state));
         state = state->next.p;
         break;
      case syntax_element_backstep:

         static_cast<re_brace*>(state)->index
            = this->calculate_backstep(state->next.p);
         if(static_cast<re_brace*>(state)->index < 0)
         {

            if(0 == this->m_pdata->m_status)
               this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;



            this->m_pdata->m_expression = 0;
            this->m_pdata->m_expression_len = 0;



            if(0 == (this->flags() & regex_constants::no_except))
            {
               std::string message = this->m_pdata->m_ptraits->error_string(boost::regex_constants::error_bad_pattern);
               boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
               e.raise();
            }
         }

      default:
         state = state->next.p;
      }
   }

   while(v.size())
   {
      const std::pair<bool, re_syntax_base*>& p = v.back();
      m_icase = p.first;
      state = p.second;
      v.pop_back();


      m_bad_repeats = 0;
      create_startmap(state->next.p, static_cast<re_alt*>(state)->_map, &static_cast<re_alt*>(state)->can_be_null, mask_take);
      m_bad_repeats = 0;
      create_startmap(static_cast<re_alt*>(state)->alt.p, static_cast<re_alt*>(state)->_map, &static_cast<re_alt*>(state)->can_be_null, mask_skip);

      state->type = this->get_repeat_type(state);
   }

   m_icase = l_icase;
}

template <class charT, class traits>
int basic_regex_creator<charT, traits>::calculate_backstep(re_syntax_base* state)
{
   typedef typename traits::char_class_type mask_type;
   int result = 0;
   while(state)
   {
      switch(state->type)
      {
      case syntax_element_startmark:
         if((static_cast<re_brace*>(state)->index == -1)
            || (static_cast<re_brace*>(state)->index == -2))
         {
            state = static_cast<re_jump*>(state->next.p)->alt.p->next.p;
            continue;
         }
         else if(static_cast<re_brace*>(state)->index == -3)
         {
            state = state->next.p->next.p;
            continue;
         }
         break;
      case syntax_element_endmark:
         if((static_cast<re_brace*>(state)->index == -1)
            || (static_cast<re_brace*>(state)->index == -2))
            return result;
         break;
      case syntax_element_literal:
         result += static_cast<re_literal*>(state)->length;
         break;
      case syntax_element_wild:
      case syntax_element_set:
         result += 1;
         break;
      case syntax_element_dot_rep:
      case syntax_element_char_rep:
      case syntax_element_short_set_rep:
      case syntax_element_backref:
      case syntax_element_rep:
      case syntax_element_combining:
      case syntax_element_long_set_rep:
      case syntax_element_backstep:
         {
            re_repeat* rep = static_cast<re_repeat *>(state);

            state->type = this->get_repeat_type(state);
            if((state->type == syntax_element_dot_rep)
               || (state->type == syntax_element_char_rep)
               || (state->type == syntax_element_short_set_rep))
            {
               if(rep->max != rep->min)
                  return -1;
               result += static_cast<int>(rep->min);
               state = rep->alt.p;
               continue;
            }
            else if((state->type == syntax_element_long_set_rep))
            {
               (__builtin_expect(!(rep->next.p->type == syntax_element_long_set), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_creator.hpp", 881, "rep->next.p->type == syntax_element_long_set") : (void)0);
               if(static_cast<re_set_long<mask_type>*>(rep->next.p)->singleton == 0)
                  return -1;
               if(rep->max != rep->min)
                  return -1;
               result += static_cast<int>(rep->min);
               state = rep->alt.p;
               continue;
            }
         }
         return -1;
      case syntax_element_long_set:
         if(static_cast<re_set_long<mask_type>*>(state)->singleton == 0)
            return -1;
         result += 1;
         break;
      case syntax_element_jump:
         state = static_cast<re_jump*>(state)->alt.p;
         continue;
      default:
         break;
      }
      state = state->next.p;
   }
   return -1;
}

template <class charT, class traits>
void basic_regex_creator<charT, traits>::create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask)
{
   int not_last_jump = 1;


   bool l_icase = m_icase;

   while(state)
   {
      switch(state->type)
      {
      case syntax_element_toggle_case:
         l_icase = static_cast<re_case*>(state)->icase;
         state = state->next.p;
         break;
      case syntax_element_literal:
      {


         if(l_map)
         {
            l_map[0] |= mask_init;
            charT first_char = *static_cast<charT*>(static_cast<void*>(static_cast<re_literal*>(state) + 1));
            for(unsigned int i = 0; i < (1u << 8); ++i)
            {
               if(m_traits.translate(static_cast<charT>(i), l_icase) == first_char)
                  l_map[i] |= mask;
            }
         }
         return;
      }
      case syntax_element_end_line:
      {

         if(l_map)
         {
            l_map[0] |= mask_init;
            l_map['\n'] |= mask;
            l_map['\r'] |= mask;
            l_map['\f'] |= mask;
            l_map[0x85] |= mask;
         }

         if(pnull)
            create_startmap(state->next.p, 0, pnull, mask);
         return;
      }
      case syntax_element_backref:

         if(pnull)
            *pnull |= mask;

      case syntax_element_wild:
      {

         set_all_masks(l_map, mask);
         return;
      }
      case syntax_element_match:
      {

         set_all_masks(l_map, mask);
         if(pnull)
            *pnull |= mask;
         return;
      }
      case syntax_element_word_start:
      {

         create_startmap(state->next.p, l_map, pnull, mask);
         if(l_map)
         {
            l_map[0] |= mask_init;
            for(unsigned int i = 0; i < (1u << 8); ++i)
            {
               if(!m_traits.isctype(static_cast<charT>(i), m_word_mask))
                  l_map[i] &= static_cast<unsigned char>(~mask);
            }
         }
         return;
      }
      case syntax_element_word_end:
      {

         create_startmap(state->next.p, l_map, pnull, mask);
         if(l_map)
         {
            l_map[0] |= mask_init;
            for(unsigned int i = 0; i < (1u << 8); ++i)
            {
               if(m_traits.isctype(static_cast<charT>(i), m_word_mask))
                  l_map[i] &= static_cast<unsigned char>(~mask);
            }
         }
         return;
      }
      case syntax_element_buffer_end:
      {

         if(pnull)
            *pnull |= mask;
         return;
      }
      case syntax_element_long_set:
         if(l_map)
         {
            typedef typename traits::char_class_type mask_type;
            if(static_cast<re_set_long<mask_type>*>(state)->singleton)
            {
               l_map[0] |= mask_init;
               for(unsigned int i = 0; i < (1u << 8); ++i)
               {
                  charT c = static_cast<charT>(i);
                  if(&c != re_is_set_member(&c, &c + 1, static_cast<re_set_long<mask_type>*>(state), *m_pdata, m_icase))
                     l_map[i] |= mask;
               }
            }
            else
               set_all_masks(l_map, mask);
         }
         return;
      case syntax_element_set:
         if(l_map)
         {
            l_map[0] |= mask_init;
            for(unsigned int i = 0; i < (1u << 8); ++i)
            {
               if(static_cast<re_set*>(state)->_map[
                  static_cast<unsigned char>(m_traits.translate(static_cast<charT>(i), l_icase))])
                  l_map[i] |= mask;
            }
         }
         return;
      case syntax_element_jump:

         state = static_cast<re_alt*>(state)->alt.p;
         not_last_jump = -1;
         break;
      case syntax_element_alt:
      case syntax_element_rep:
      case syntax_element_dot_rep:
      case syntax_element_char_rep:
      case syntax_element_short_set_rep:
      case syntax_element_long_set_rep:
         {
            re_alt* rep = static_cast<re_alt*>(state);
            if(rep->_map[0] & mask_init)
            {
               if(l_map)
               {

                  l_map[0] |= mask_init;
                  for(unsigned int i = 0; i <= (127 * 2 + 1); ++i)
                  {
                     if(rep->_map[i] & mask_any)
                        l_map[i] |= mask;
                  }
               }
               if(pnull)
               {
                  if(rep->can_be_null & mask_any)
                     *pnull |= mask;
               }
            }
            else
            {


               if(is_bad_repeat(state))
               {
                  set_all_masks(l_map, mask);
                  if(pnull)
                     *pnull |= mask;
                  return;
               }
               set_bad_repeat(state);
               create_startmap(state->next.p, l_map, pnull, mask);
               if((state->type == syntax_element_alt)
                  || (static_cast<re_repeat*>(state)->min == 0)
                  || (not_last_jump == 0))
                  create_startmap(rep->alt.p, l_map, pnull, mask);
            }
         }
         return;
      case syntax_element_soft_buffer_end:

         if(l_map)
         {
            l_map[0] |= mask_init;
            l_map['\n'] |= mask;
            l_map['\r'] |= mask;
         }
         if(pnull)
            *pnull |= mask;
         return;
      case syntax_element_endmark:

         if(static_cast<re_brace*>(state)->index < 0)
         {

            set_all_masks(l_map, mask);
            if(pnull)
               *pnull |= mask;
            return;
         }
         else
         {
            state = state->next.p;
            break;
         }

      case syntax_element_startmark:

         if(static_cast<re_brace*>(state)->index == -3)
         {
            state = state->next.p->next.p;
            break;
         }

      default:
         state = state->next.p;
      }
      ++not_last_jump;
   }
}

template <class charT, class traits>
unsigned basic_regex_creator<charT, traits>::get_restart_type(re_syntax_base* state)
{



   while(state)
   {
      switch(state->type)
      {
      case syntax_element_startmark:
      case syntax_element_endmark:
         state = state->next.p;
         continue;
      case syntax_element_start_line:
         return regbase::restart_line;
      case syntax_element_word_start:
         return regbase::restart_word;
      case syntax_element_buffer_start:
         return regbase::restart_buf;
      case syntax_element_restart_continue:
         return regbase::restart_continue;
      default:
         state = 0;
         continue;
      }
   }
   return regbase::restart_any;
}

template <class charT, class traits>
void basic_regex_creator<charT, traits>::set_all_masks(unsigned char* bits, unsigned char mask)
{





   if(bits)
   {
      if(bits[0] == 0)
         (std::memset)(bits, mask, 1u << 8);
      else
      {
         for(unsigned i = 0; i < (1u << 8); ++i)
            bits[i] |= mask;
      }
      bits[0] |= mask_init;
   }
}

template <class charT, class traits>
bool basic_regex_creator<charT, traits>::is_bad_repeat(re_syntax_base* pt)
{
   switch(pt->type)
   {
   case syntax_element_rep:
   case syntax_element_dot_rep:
   case syntax_element_char_rep:
   case syntax_element_short_set_rep:
   case syntax_element_long_set_rep:
      {
         unsigned id = static_cast<re_repeat*>(pt)->id;
         if(id > sizeof(m_bad_repeats) * 8)
            return true;
         static const boost::uintmax_t one = 1uL;
         return m_bad_repeats & (one << id);
      }
   default:
      return false;
   }
}

template <class charT, class traits>
void basic_regex_creator<charT, traits>::set_bad_repeat(re_syntax_base* pt)
{
   switch(pt->type)
   {
   case syntax_element_rep:
   case syntax_element_dot_rep:
   case syntax_element_char_rep:
   case syntax_element_short_set_rep:
   case syntax_element_long_set_rep:
      {
         unsigned id = static_cast<re_repeat*>(pt)->id;
         static const boost::uintmax_t one = 1uL;
         if(id <= sizeof(m_bad_repeats) * 8)
            m_bad_repeats |= (one << id);
      }
   default:
      break;
   }
}

template <class charT, class traits>
syntax_element_type basic_regex_creator<charT, traits>::get_repeat_type(re_syntax_base* state)
{
   typedef typename traits::char_class_type mask_type;
   if(state->type == syntax_element_rep)
   {

      if(state->next.p->next.p->next.p == static_cast<re_alt*>(state)->alt.p)
      {
         switch(state->next.p->type)
         {
         case re_detail::syntax_element_wild:
            return re_detail::syntax_element_dot_rep;
         case re_detail::syntax_element_literal:
            return re_detail::syntax_element_char_rep;
         case re_detail::syntax_element_set:
            return re_detail::syntax_element_short_set_rep;
         case re_detail::syntax_element_long_set:
            if(static_cast<re_detail::re_set_long<mask_type>*>(state->next.p)->singleton)
               return re_detail::syntax_element_long_set_rep;
            break;
         default:
            break;
         }
      }
   }
   return state->type;
}

template <class charT, class traits>
void basic_regex_creator<charT, traits>::probe_leading_repeat(re_syntax_base* state)
{


   do
   {
      switch(state->type)
      {
      case syntax_element_startmark:
         if(static_cast<re_brace*>(state)->index >= 0)
         {
            state = state->next.p;
            continue;
         }
         if((static_cast<re_brace*>(state)->index == -1)
            || (static_cast<re_brace*>(state)->index == -2))
         {

            state = static_cast<const re_jump*>(state->next.p)->alt.p->next.p;
            continue;
         }
         if(static_cast<re_brace*>(state)->index == -3)
         {

            state = state->next.p->next.p;
            continue;
         }
         return;
      case syntax_element_endmark:
      case syntax_element_start_line:
      case syntax_element_end_line:
      case syntax_element_word_boundary:
      case syntax_element_within_word:
      case syntax_element_word_start:
      case syntax_element_word_end:
      case syntax_element_buffer_start:
      case syntax_element_buffer_end:
      case syntax_element_restart_continue:
         state = state->next.p;
         break;
      case syntax_element_dot_rep:
      case syntax_element_char_rep:
      case syntax_element_short_set_rep:
      case syntax_element_long_set_rep:
         if(this->m_has_backrefs == 0)
            static_cast<re_repeat*>(state)->leading = true;

      default:
         return;
      }
   }while(state);
}


}

}
# 71 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_parser.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_parser.hpp" 3
namespace boost{
namespace re_detail{






template <class charT, class traits>
class basic_regex_parser : public basic_regex_creator<charT, traits>
{
public:
   basic_regex_parser(regex_data<charT, traits>* data);
   void parse(const charT* p1, const charT* p2, unsigned flags);
   void fail(regex_constants::error_type error_code, std::ptrdiff_t position);

   bool parse_all();
   bool parse_basic();
   bool parse_extended();
   bool parse_literal();
   bool parse_open_paren();
   bool parse_basic_escape();
   bool parse_extended_escape();
   bool parse_match_any();
   bool parse_repeat(std::size_t low = 0, std::size_t high = (std::numeric_limits<std::size_t>::max)());
   bool parse_repeat_range(bool isbasic);
   bool parse_alt();
   bool parse_set();
   bool parse_backref();
   void parse_set_literal(basic_char_set<charT, traits>& char_set);
   bool parse_inner_set(basic_char_set<charT, traits>& char_set);
   bool parse_QE();
   bool parse_perl_extension();
   bool add_emacs_code(bool negate);
   bool unwind_alts(std::ptrdiff_t last_paren_start);
   digraph<charT> get_next_set_literal(basic_char_set<charT, traits>& char_set);
   charT unescape_character();
   regex_constants::syntax_option_type parse_options();

private:
   typedef bool (basic_regex_parser::*parser_proc_type)();
   typedef typename traits::string_type string_type;
   typedef typename traits::char_class_type char_class_type;
   parser_proc_type m_parser_proc;
   const charT* m_base;
   const charT* m_end;
   const charT* m_position;
   unsigned m_mark_count;
   std::ptrdiff_t m_paren_start;
   std::ptrdiff_t m_alt_insert_point;
   bool m_has_case_change;






   std::vector<std::ptrdiff_t> m_alt_jumps;


   basic_regex_parser& operator=(const basic_regex_parser&);
   basic_regex_parser(const basic_regex_parser&);
};

template <class charT, class traits>
basic_regex_parser<charT, traits>::basic_regex_parser(regex_data<charT, traits>* data)
   : basic_regex_creator<charT, traits>(data), m_mark_count(0), m_paren_start(0), m_alt_insert_point(0), m_has_case_change(false)
{
}

template <class charT, class traits>
void basic_regex_parser<charT, traits>::parse(const charT* p1, const charT* p2, unsigned l_flags)
{

   this->init(l_flags);

   m_position = m_base = p1;
   m_end = p2;

   if(p1 == p2)
   {
      fail(regex_constants::error_empty, 0);
      return;
   }

   switch(l_flags & regbase::main_option_type)
   {
   case regbase::perl_syntax_group:
      m_parser_proc = &basic_regex_parser<charT, traits>::parse_extended;
      break;
   case regbase::basic_syntax_group:
      m_parser_proc = &basic_regex_parser<charT, traits>::parse_basic;
      break;
   case regbase::literal:
      m_parser_proc = &basic_regex_parser<charT, traits>::parse_literal;
      break;
   }


   bool result = parse_all();



   unwind_alts(-1);

   this->flags(l_flags);


   if(!result)
   {
      fail(regex_constants::error_paren, ::boost::re_detail::distance(m_base, m_position));
      return;
   }

   if(this->m_pdata->m_status)
      return;

   this->m_pdata->m_mark_count = 1 + m_mark_count;
   this->finalize(p1, p2);
}

template <class charT, class traits>
void basic_regex_parser<charT, traits>::fail(regex_constants::error_type error_code, std::ptrdiff_t position)
{
   if(0 == this->m_pdata->m_status)
      this->m_pdata->m_status = error_code;
   m_position = m_end;

   std::string message = this->m_pdata->m_ptraits->error_string(error_code);


   if(0 == (this->flags() & regex_constants::no_except))
   {
      boost::regex_error e(message, error_code, position);
      e.raise();
   }



}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_all()
{
   bool result = true;
   while(result && (m_position != m_end))
   {
      result = (this->*m_parser_proc)();
   }
   return result;
}





template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_basic()
{
   switch(this->m_traits.syntax_type(*m_position))
   {
   case regex_constants::syntax_escape:
      return parse_basic_escape();
   case regex_constants::syntax_dot:
      return parse_match_any();
   case regex_constants::syntax_caret:
      ++m_position;
      this->append_state(syntax_element_start_line);
      break;
   case regex_constants::syntax_dollar:
      ++m_position;
      this->append_state(syntax_element_end_line);
      break;
   case regex_constants::syntax_star:
      if(!(this->m_last_state) || (this->m_last_state->type == syntax_element_start_line))
         return parse_literal();
      else
      {
         ++m_position;
         return parse_repeat();
      }
   case regex_constants::syntax_plus:
      if(!(this->m_last_state) || (this->m_last_state->type == syntax_element_start_line) || !(this->flags() & regbase::emacs_ex))
         return parse_literal();
      else
      {
         ++m_position;
         return parse_repeat(1);
      }
   case regex_constants::syntax_question:
      if(!(this->m_last_state) || (this->m_last_state->type == syntax_element_start_line) || !(this->flags() & regbase::emacs_ex))
         return parse_literal();
      else
      {
         ++m_position;
         return parse_repeat(0, 1);
      }
   case regex_constants::syntax_open_set:
      return parse_set();
   case regex_constants::syntax_newline:
      if(this->flags() & regbase::newline_alt)
         return parse_alt();
      else
         return parse_literal();
   default:
      return parse_literal();
   }
   return true;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_extended()
{
   bool result = true;
   switch(this->m_traits.syntax_type(*m_position))
   {
   case regex_constants::syntax_open_mark:
      return parse_open_paren();
   case regex_constants::syntax_close_mark:
      return false;
   case regex_constants::syntax_escape:
      return parse_extended_escape();
   case regex_constants::syntax_dot:
      return parse_match_any();
   case regex_constants::syntax_caret:
      ++m_position;
      this->append_state(
         (this->flags() & regex_constants::no_mod_m ? syntax_element_buffer_start : syntax_element_start_line));
      break;
   case regex_constants::syntax_dollar:
      ++m_position;
      this->append_state(
         (this->flags() & regex_constants::no_mod_m ? syntax_element_buffer_end : syntax_element_end_line));
      break;
   case regex_constants::syntax_star:
      if(m_position == this->m_base)
      {
         fail(regex_constants::error_badrepeat, 0);
         return false;
      }
      ++m_position;
      return parse_repeat();
   case regex_constants::syntax_question:
      if(m_position == this->m_base)
      {
         fail(regex_constants::error_badrepeat, 0);
         return false;
      }
      ++m_position;
      return parse_repeat(0,1);
   case regex_constants::syntax_plus:
      if(m_position == this->m_base)
      {
         fail(regex_constants::error_badrepeat, 0);
         return false;
      }
      ++m_position;
      return parse_repeat(1);
   case regex_constants::syntax_open_brace:
      ++m_position;
      return parse_repeat_range(false);
   case regex_constants::syntax_close_brace:
      fail(regex_constants::error_brace, this->m_position - this->m_end);
      return false;
   case regex_constants::syntax_or:
      return parse_alt();
   case regex_constants::syntax_open_set:
      return parse_set();
   case regex_constants::syntax_newline:
      if(this->flags() & regbase::newline_alt)
         return parse_alt();
      else
         return parse_literal();
   case regex_constants::syntax_hash:




      if((this->flags()
         & (regbase::no_perl_ex|regbase::mod_x))
         == regbase::mod_x)
      {
         while((m_position != m_end) && !is_separator(*m_position++)){}
         return true;
      }

   default:
      result = parse_literal();
      break;
   }
   return result;
}




template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_literal()
{


   if(
      ((this->flags()
         & (regbase::main_option_type|regbase::mod_x|regbase::no_perl_ex))
            != regbase::mod_x)
      || !this->m_traits.isctype(*m_position, this->m_mask_space))
         this->append_literal(*m_position);
   ++m_position;
   return true;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_open_paren()
{



   if(++m_position == m_end)
   {
      fail(regex_constants::error_paren, m_position - m_base);
      return false;
   }



   if(
         ((this->flags() & (regbase::main_option_type | regbase::no_perl_ex)) == 0)
         || ((this->flags() & (regbase::main_option_type | regbase::emacs_ex)) == (regbase::basic_syntax_group|regbase::emacs_ex))
     )
   {
      if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_question)
         return parse_perl_extension();
   }



   unsigned markid = 0;
   if(0 == (this->flags() & regbase::nosubs))
      markid = ++m_mark_count;
   re_brace* pb = static_cast<re_brace*>(this->append_state(syntax_element_startmark, sizeof(re_brace)));
   pb->index = markid;
   std::ptrdiff_t last_paren_start = this->getoffset(pb);

   std::ptrdiff_t last_alt_point = m_alt_insert_point;
   this->m_pdata->m_data.align();
   m_alt_insert_point = this->m_pdata->m_data.size();



   regex_constants::syntax_option_type opts = this->flags();
   bool old_case_change = m_has_case_change;
   m_has_case_change = false;




   parse_all();



   if(0 == unwind_alts(last_paren_start))
      return false;



   if(m_has_case_change)
   {



      static_cast<re_case*>(
         this->append_state(syntax_element_toggle_case, sizeof(re_case))
         )->icase = opts & regbase::icase;
   }
   this->flags(opts);
   m_has_case_change = old_case_change;



   if(m_position == m_end)
   {
      this->fail(regex_constants::error_paren, ::boost::re_detail::distance(m_base, m_end));
      return false;
   }
   (__builtin_expect(!(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_mark), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_parser.hpp", 417, "this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_mark") : (void)0);
   ++m_position;



   pb = static_cast<re_brace*>(this->append_state(syntax_element_endmark, sizeof(re_brace)));
   pb->index = markid;
   this->m_paren_start = last_paren_start;



   this->m_alt_insert_point = last_alt_point;



   if((markid > 0) && (markid < sizeof(unsigned) * 8))
      this->m_backrefs |= 1u << (markid - 1);

   return true;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_basic_escape()
{
   ++m_position;
   bool result = true;
   switch(this->m_traits.escape_syntax_type(*m_position))
   {
   case regex_constants::syntax_open_mark:
      return parse_open_paren();
   case regex_constants::syntax_close_mark:
      return false;
   case regex_constants::syntax_plus:
      if(this->flags() & regex_constants::bk_plus_qm)
      {
         ++m_position;
         return parse_repeat(1);
      }
      else
         return parse_literal();
   case regex_constants::syntax_question:
      if(this->flags() & regex_constants::bk_plus_qm)
      {
         ++m_position;
         return parse_repeat(0, 1);
      }
      else
         return parse_literal();
   case regex_constants::syntax_open_brace:
      if(this->flags() & regbase::no_intervals)
         return parse_literal();
      ++m_position;
      return parse_repeat_range(true);
   case regex_constants::syntax_close_brace:
      if(this->flags() & regbase::no_intervals)
         return parse_literal();
      fail(regex_constants::error_brace, this->m_position - this->m_base);
      return false;
   case regex_constants::syntax_or:
      if(this->flags() & regbase::bk_vbar)
         return parse_alt();
      else
         result = parse_literal();
      break;
   case regex_constants::syntax_digit:
      return parse_backref();
   case regex_constants::escape_type_start_buffer:
      if(this->flags() & regbase::emacs_ex)
      {
         ++m_position;
         this->append_state(syntax_element_buffer_start);
      }
      else
         result = parse_literal();
      break;
   case regex_constants::escape_type_end_buffer:
      if(this->flags() & regbase::emacs_ex)
      {
         ++m_position;
         this->append_state(syntax_element_buffer_end);
      }
      else
         result = parse_literal();
      break;
   case regex_constants::escape_type_word_assert:
      if(this->flags() & regbase::emacs_ex)
      {
         ++m_position;
         this->append_state(syntax_element_word_boundary);
      }
      else
         result = parse_literal();
      break;
   case regex_constants::escape_type_not_word_assert:
      if(this->flags() & regbase::emacs_ex)
      {
         ++m_position;
         this->append_state(syntax_element_within_word);
      }
      else
         result = parse_literal();
      break;
   case regex_constants::escape_type_left_word:
      if(this->flags() & regbase::emacs_ex)
      {
         ++m_position;
         this->append_state(syntax_element_word_start);
      }
      else
         result = parse_literal();
      break;
   case regex_constants::escape_type_right_word:
      if(this->flags() & regbase::emacs_ex)
      {
         ++m_position;
         this->append_state(syntax_element_word_end);
      }
      else
         result = parse_literal();
      break;
   default:
      if(this->flags() & regbase::emacs_ex)
      {
         bool negate = true;
         switch(*m_position)
         {
         case 'w':
            negate = false;

         case 'W':
            {
            basic_char_set<charT, traits> char_set;
            if(negate)
               char_set.negate();
            char_set.add_class(this->m_word_mask);
            if(0 == this->append_set(char_set))
            {
               fail(regex_constants::error_ctype, m_position - m_base);
               return false;
            }
            ++m_position;
            return true;
            }
         case 's':
            negate = false;

         case 'S':
            return add_emacs_code(negate);
         case 'c':
         case 'C':

            fail(regex_constants::error_escape, m_position - m_base);
            return false;
         default:
            break;
         }
      }
      result = parse_literal();
      break;
   }
   return result;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_extended_escape()
{
   ++m_position;
   bool negate = false;
   switch(this->m_traits.escape_syntax_type(*m_position))
   {
   case regex_constants::escape_type_not_class:
      negate = true;

   case regex_constants::escape_type_class:
      {
         typedef typename traits::char_class_type mask_type;
         mask_type m = this->m_traits.lookup_classname(m_position, m_position+1);
         if(m != 0)
         {
            basic_char_set<charT, traits> char_set;
            if(negate)
               char_set.negate();
            char_set.add_class(m);
            if(0 == this->append_set(char_set))
            {
               fail(regex_constants::error_ctype, m_position - m_base);
               return false;
            }
            ++m_position;
            return true;
         }



         this->append_literal(unescape_character());
         break;
      }
   case regex_constants::syntax_digit:
      return parse_backref();
   case regex_constants::escape_type_left_word:
      ++m_position;
      this->append_state(syntax_element_word_start);
      break;
   case regex_constants::escape_type_right_word:
      ++m_position;
      this->append_state(syntax_element_word_end);
      break;
   case regex_constants::escape_type_start_buffer:
      ++m_position;
      this->append_state(syntax_element_buffer_start);
      break;
   case regex_constants::escape_type_end_buffer:
      ++m_position;
      this->append_state(syntax_element_buffer_end);
      break;
   case regex_constants::escape_type_word_assert:
      ++m_position;
      this->append_state(syntax_element_word_boundary);
      break;
   case regex_constants::escape_type_not_word_assert:
      ++m_position;
      this->append_state(syntax_element_within_word);
      break;
   case regex_constants::escape_type_Z:
      ++m_position;
      this->append_state(syntax_element_soft_buffer_end);
      break;
   case regex_constants::escape_type_Q:
      return parse_QE();
   case regex_constants::escape_type_C:
      return parse_match_any();
   case regex_constants::escape_type_X:
      ++m_position;
      this->append_state(syntax_element_combining);
      break;
   case regex_constants::escape_type_G:
      ++m_position;
      this->append_state(syntax_element_restart_continue);
      break;
   case regex_constants::escape_type_not_property:
      negate = true;

   case regex_constants::escape_type_property:
      {
         ++m_position;
         char_class_type m;
         if(m_position == m_end)
         {
            fail(regex_constants::error_escape, m_position - m_base);
            return false;
         }

         if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_open_brace)
         {
            const charT* base = m_position;

            while((m_position != m_end) && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_brace))
               ++m_position;
            if(m_position == m_end)
            {
               fail(regex_constants::error_escape, m_position - m_base);
               return false;
            }
            m = this->m_traits.lookup_classname(++base, m_position++);
         }
         else
         {
            m = this->m_traits.lookup_classname(m_position, m_position+1);
            ++m_position;
         }
         if(m != 0)
         {
            basic_char_set<charT, traits> char_set;
            if(negate)
               char_set.negate();
            char_set.add_class(m);
            if(0 == this->append_set(char_set))
            {
               fail(regex_constants::error_ctype, m_position - m_base);
               return false;
            }
            return true;
         }
         fail(regex_constants::error_ctype, m_position - m_base);
      }
   default:
      this->append_literal(unescape_character());
      break;
   }
   return true;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_match_any()
{



   ++m_position;
   static_cast<re_dot*>(
      this->append_state(syntax_element_wild, sizeof(re_dot))
      )->mask = static_cast<unsigned char>(this->flags() & regbase::no_mod_s
      ? re_detail::force_not_newline
         : this->flags() & regbase::mod_s ?
            re_detail::force_newline : re_detail::dont_care);
   return true;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_repeat(std::size_t low, std::size_t high)
{
   bool greedy = true;
   std::size_t insert_point;



   if((m_position != m_end)
      && (
            (0 == (this->flags() & (regbase::main_option_type | regbase::no_perl_ex)))
            || ((regbase::basic_syntax_group|regbase::emacs_ex) == (this->flags() & (regbase::main_option_type | regbase::emacs_ex)))
         )
      )
   {

      if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_question)
      {
         greedy = false;
         ++m_position;
      }
   }
   if(0 == this->m_last_state)
   {
      fail(regex_constants::error_badrepeat, ::boost::re_detail::distance(m_base, m_position));
      return false;
   }
   if(this->m_last_state->type == syntax_element_endmark)
   {

      insert_point = this->m_paren_start;
   }
   else if((this->m_last_state->type == syntax_element_literal) && (static_cast<re_literal*>(this->m_last_state)->length > 1))
   {

      re_literal* lit = static_cast<re_literal*>(this->m_last_state);
      charT c = (static_cast<charT*>(static_cast<void*>(lit+1)))[lit->length - 1];
      --(lit->length);

      lit = static_cast<re_literal*>(this->append_state(syntax_element_literal, sizeof(re_literal) + sizeof(charT)));
      lit->length = 1;
      (static_cast<charT*>(static_cast<void*>(lit+1)))[0] = c;
      insert_point = this->getoffset(this->m_last_state);
   }
   else
   {

      switch(this->m_last_state->type)
      {
      case syntax_element_start_line:
      case syntax_element_end_line:
      case syntax_element_word_boundary:
      case syntax_element_within_word:
      case syntax_element_word_start:
      case syntax_element_word_end:
      case syntax_element_buffer_start:
      case syntax_element_buffer_end:
      case syntax_element_alt:
      case syntax_element_soft_buffer_end:
      case syntax_element_restart_continue:
      case syntax_element_jump:
      case syntax_element_startmark:
      case syntax_element_backstep:

         fail(regex_constants::error_badrepeat, m_position - m_base);
         return false;
      default:

         break;
      }
      insert_point = this->getoffset(this->m_last_state);
   }



   re_repeat* rep = static_cast<re_repeat*>(this->insert_state(insert_point, syntax_element_rep, re_repeater_size));
   rep->min = low;
   rep->max = high;
   rep->greedy = greedy;
   rep->leading = false;

   std::ptrdiff_t rep_off = this->getoffset(rep);

   re_jump* jmp = static_cast<re_jump*>(this->append_state(syntax_element_jump, sizeof(re_jump)));
   jmp->alt.i = rep_off - this->getoffset(jmp);
   this->m_pdata->m_data.align();

   rep = static_cast<re_repeat*>(this->getaddress(rep_off));
   rep->alt.i = this->m_pdata->m_data.size() - rep_off;
   return true;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_repeat_range(bool isbasic)
{



   std::size_t min, max;
   int v;

   while((m_position != m_end) && this->m_traits.isctype(*m_position, this->m_mask_space))
      ++m_position;

   if(this->m_position == this->m_end)
   {
      fail(regex_constants::error_brace, this->m_position - this->m_base);
      return false;
   }

   v = this->m_traits.toi(m_position, m_end, 10);

   while((m_position != m_end) && this->m_traits.isctype(*m_position, this->m_mask_space))
      ++m_position;
   if(v < 0)
   {
      fail(regex_constants::error_badbrace, this->m_position - this->m_base);
      return false;
   }
   else if(this->m_position == this->m_end)
   {
      fail(regex_constants::error_brace, this->m_position - this->m_base);
      return false;
   }
   min = v;

   if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_comma)
   {

      ++m_position;

      while((m_position != m_end) && this->m_traits.isctype(*m_position, this->m_mask_space))
         ++m_position;
      if(this->m_position == this->m_end)
      {
         fail(regex_constants::error_brace, this->m_position - this->m_base);
         return false;
      }

      v = this->m_traits.toi(m_position, m_end, 10);
      max = (v >= 0) ? v : (std::numeric_limits<std::size_t>::max)();
   }
   else
   {

      max = min;
   }

   while((m_position != m_end) && this->m_traits.isctype(*m_position, this->m_mask_space))
      ++m_position;

   if(this->m_position == this->m_end)
   {
      fail(regex_constants::error_brace, this->m_position - this->m_base);
      return false;
   }
   if(isbasic)
   {
      if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_escape)
      {
         ++m_position;
         if(this->m_position == this->m_end)
         {
            fail(regex_constants::error_brace, this->m_position - this->m_base);
            return false;
         }
      }
      else
      {
         fail(regex_constants::error_badbrace, this->m_position - this->m_base);
         return false;
      }
   }
   if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_brace)
      ++m_position;
   else
   {
      fail(regex_constants::error_badbrace, this->m_position - this->m_base);
      return false;
   }



   if(min > max)
   {
      fail(regex_constants::error_badbrace, this->m_position - this->m_base);
      return false;
   }
   return parse_repeat(min, max);
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_alt()
{




   if((this->m_last_state == 0) || (this->m_last_state->type == syntax_element_startmark))
   {
      fail(regex_constants::error_empty, this->m_position - this->m_base);
      return false;
   }
   ++m_position;



   re_syntax_base* pj = this->append_state(re_detail::syntax_element_jump, sizeof(re_jump));
   std::ptrdiff_t jump_offset = this->getoffset(pj);



   re_alt* palt = static_cast<re_alt*>(this->insert_state(this->m_alt_insert_point, syntax_element_alt, re_alt_size));
   jump_offset += re_alt_size;
   this->m_pdata->m_data.align();
   palt->alt.i = this->m_pdata->m_data.size() - this->getoffset(palt);




   this->m_alt_insert_point = this->m_pdata->m_data.size();




   if(m_has_case_change)
   {
      static_cast<re_case*>(
         this->append_state(syntax_element_toggle_case, sizeof(re_case))
         )->icase = this->m_icase;
   }






   m_alt_jumps.push_back(jump_offset);
   return true;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_set()
{
   ++m_position;
   if(m_position == m_end)
   {
      fail(regex_constants::error_brack, m_position - m_base);
      return false;
   }
   basic_char_set<charT, traits> char_set;

   const charT* base = m_position;
   const charT* item_base = m_position;

   while(m_position != m_end)
   {
      switch(this->m_traits.syntax_type(*m_position))
      {
      case regex_constants::syntax_caret:
         if(m_position == base)
         {
            char_set.negate();
            ++m_position;
            item_base = m_position;
         }
         else
            parse_set_literal(char_set);
         break;
      case regex_constants::syntax_close_set:
         if(m_position == item_base)
         {
            parse_set_literal(char_set);
            break;
         }
         else
         {
            ++m_position;
            if(0 == this->append_set(char_set))
            {
               fail(regex_constants::error_range, m_position - m_base);
               return false;
            }
         }
         return true;
      case regex_constants::syntax_open_set:
         if(parse_inner_set(char_set))
            break;
         return true;
      case regex_constants::syntax_escape:
         {




            ++m_position;
            if(this->m_traits.escape_syntax_type(*m_position)
               == regex_constants::escape_type_class)
            {
               char_class_type m = this->m_traits.lookup_classname(m_position, m_position+1);
               if(m != 0)
               {
                  char_set.add_class(m);
                  ++m_position;
                  break;
               }
            }
            else if(this->m_traits.escape_syntax_type(*m_position)
               == regex_constants::escape_type_not_class)
            {

               char_class_type m = this->m_traits.lookup_classname(m_position, m_position+1);
               if(m != 0)
               {
                  char_set.add_negated_class(m);
                  ++m_position;
                  break;
               }
            }

            --m_position;
            parse_set_literal(char_set);
            break;
         }
      default:
         parse_set_literal(char_set);
         break;
      }
   }
   return m_position != m_end;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_inner_set(basic_char_set<charT, traits>& char_set)
{





   if(m_end == ++m_position)
   {
      fail(regex_constants::error_brack, m_position - m_base);
      return false;
   }
   switch(this->m_traits.syntax_type(*m_position))
   {
   case regex_constants::syntax_dot:



      --m_position;
      parse_set_literal(char_set);
      return true;
   case regex_constants::syntax_colon:
      {

      if((this->flags() & (regbase::main_option_type | regbase::no_char_classes))
         == (regbase::basic_syntax_group | regbase::no_char_classes))
      {
         --m_position;
         parse_set_literal(char_set);
         return true;
      }

      if(m_end == ++m_position)
      {
         fail(regex_constants::error_brack, m_position - m_base);
         return false;
      }
      const charT* name_first = m_position;

      if(m_end == ++m_position)
      {
         fail(regex_constants::error_brack, m_position - m_base);
         return false;
      }
      while((m_position != m_end)
         && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_colon))
         ++m_position;
      const charT* name_last = m_position;
      if(m_end == m_position)
      {
         fail(regex_constants::error_brack, m_position - m_base);
         return false;
      }
      if((m_end == ++m_position)
         || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_set))
      {
         fail(regex_constants::error_brack, m_position - m_base);
         return false;
      }



      bool negated = false;
      if(this->m_traits.syntax_type(*name_first) == regex_constants::syntax_caret)
      {
         ++name_first;
         negated = true;
      }
      typedef typename traits::char_class_type mask_type;
      mask_type m = this->m_traits.lookup_classname(name_first, name_last);
      if(m == 0)
      {
         if(char_set.empty() && (name_last - name_first == 1))
         {

            ++m_position;
            if( (m_position != m_end)
               && (this->m_traits.syntax_type(*m_position)
                  == regex_constants::syntax_close_set))
            {
               if(this->m_traits.escape_syntax_type(*name_first)
                  == regex_constants::escape_type_left_word)
               {
                  ++m_position;
                  this->append_state(syntax_element_word_start);
                  return false;
               }
               if(this->m_traits.escape_syntax_type(*name_first)
                  == regex_constants::escape_type_right_word)
               {
                  ++m_position;
                  this->append_state(syntax_element_word_end);
                  return false;
               }
            }
         }
         fail(regex_constants::error_ctype, name_first - m_base);
         return false;
      }
      if(negated == false)
         char_set.add_class(m);
      else
         char_set.add_negated_class(m);
      ++m_position;
      break;
   }
   case regex_constants::syntax_equal:
      {

      if(m_end == ++m_position)
      {
         fail(regex_constants::error_brack, m_position - m_base);
         return false;
      }
      const charT* name_first = m_position;

      if(m_end == ++m_position)
      {
         fail(regex_constants::error_brack, m_position - m_base);
         return false;
      }
      while((m_position != m_end)
         && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_equal))
         ++m_position;
      const charT* name_last = m_position;
      if(m_end == m_position)
      {
         fail(regex_constants::error_brack, m_position - m_base);
         return false;
      }
      if((m_end == ++m_position)
         || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_set))
      {
         fail(regex_constants::error_brack, m_position - m_base);
         return false;
      }
      string_type m = this->m_traits.lookup_collatename(name_first, name_last);
      if((0 == m.size()) || (m.size() > 2))
      {
         fail(regex_constants::error_collate, name_first - m_base);
         return false;
      }
      digraph<charT> d;
      d.first = m[0];
      if(m.size() > 1)
         d.second = m[1];
      else
         d.second = 0;
      char_set.add_equivalent(d);
      ++m_position;
      break;
   }
   default:
      --m_position;
      parse_set_literal(char_set);
      break;
   }
   return true;
}

template <class charT, class traits>
void basic_regex_parser<charT, traits>::parse_set_literal(basic_char_set<charT, traits>& char_set)
{
   digraph<charT> start_range(get_next_set_literal(char_set));
   if(m_end == m_position)
   {
      fail(regex_constants::error_brack, m_position - m_base);
      return;
   }
   if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_dash)
   {

      if(m_end == ++m_position)
      {
         fail(regex_constants::error_brack, m_position - m_base);
         return;
      }
      if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_set)
      {
         digraph<charT> end_range = get_next_set_literal(char_set);
         char_set.add_range(start_range, end_range);
         if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_dash)
         {
            if(m_end == ++m_position)
            {
               fail(regex_constants::error_brack, m_position - m_base);
               return;
            }
            if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_set)
            {

               --m_position;
               return;
            }
            fail(regex_constants::error_range, m_position - m_base);
            return;
         }
         return;
      }
      --m_position;
   }
   char_set.add_single(start_range);
}

template <class charT, class traits>
digraph<charT> basic_regex_parser<charT, traits>::get_next_set_literal(basic_char_set<charT, traits>& char_set)
{
   digraph<charT> result;
   switch(this->m_traits.syntax_type(*m_position))
   {
   case regex_constants::syntax_dash:
      if(!char_set.empty())
      {

         if((++m_position == m_end) || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_set))
         {
            fail(regex_constants::error_range, m_position - m_base);
            return result;
         }
         --m_position;
      }
      result.first = *m_position++;
      return result;
   case regex_constants::syntax_escape:

      if(this->flags() & regex_constants::no_escape_in_lists)
      {
         result = *m_position++;
         break;
      }
      ++m_position;
      result = unescape_character();
      break;
   case regex_constants::syntax_open_set:
   {
      if(m_end == ++m_position)
      {
         fail(regex_constants::error_collate, m_position - m_base);
         return result;
      }
      if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_dot)
      {
         --m_position;
         result.first = *m_position;
         ++m_position;
         return result;
      }
      if(m_end == ++m_position)
      {
         fail(regex_constants::error_collate, m_position - m_base);
         return result;
      }
      const charT* name_first = m_position;

      if(m_end == ++m_position)
      {
         fail(regex_constants::error_collate, name_first - m_base);
         return result;
      }
      while((m_position != m_end)
         && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_dot))
         ++m_position;
      const charT* name_last = m_position;
      if(m_end == m_position)
      {
         fail(regex_constants::error_collate, name_first - m_base);
         return result;
      }
      if((m_end == ++m_position)
         || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_set))
      {
         fail(regex_constants::error_collate, name_first - m_base);
         return result;
      }
      ++m_position;
      string_type s = this->m_traits.lookup_collatename(name_first, name_last);
      if(s.empty() || (s.size() > 2))
      {
         fail(regex_constants::error_collate, name_first - m_base);
         return result;
      }
      result.first = s[0];
      if(s.size() > 1)
         result.second = s[1];
      else
         result.second = 0;
      return result;
   }
   default:
      result = *m_position++;
   }
   return result;
}




template <class charT>
bool valid_value(charT, int v, const mpl::true_&)
{
   return (v >> (sizeof(charT) * 8)) == 0;
}
template <class charT>
bool valid_value(charT, int, const mpl::false_&)
{
   return true;
}
template <class charT>
bool valid_value(charT c, int v)
{
   return valid_value(c, v, mpl::bool_<(sizeof(charT) < sizeof(int))>());
}

template <class charT, class traits>
charT basic_regex_parser<charT, traits>::unescape_character()
{




   charT result(0);
   if(m_position == m_end)
   {
      fail(regex_constants::error_escape, m_position - m_base);
      return false;
   }
   switch(this->m_traits.escape_syntax_type(*m_position))
   {
   case regex_constants::escape_type_control_a:
      result = charT('\a');
      break;
   case regex_constants::escape_type_e:
      result = charT(27);
      break;
   case regex_constants::escape_type_control_f:
      result = charT('\f');
      break;
   case regex_constants::escape_type_control_n:
      result = charT('\n');
      break;
   case regex_constants::escape_type_control_r:
      result = charT('\r');
      break;
   case regex_constants::escape_type_control_t:
      result = charT('\t');
      break;
   case regex_constants::escape_type_control_v:
      result = charT('\v');
      break;
   case regex_constants::escape_type_word_assert:
      result = charT('\b');
      break;
   case regex_constants::escape_type_ascii_control:
      ++m_position;
      if(m_position == m_end)
      {
         fail(regex_constants::error_escape, m_position - m_base);
         return result;
      }
# 1425 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_parser.hpp" 3
      result = static_cast<charT>(*m_position % 32);
      break;
   case regex_constants::escape_type_hex:
      ++m_position;
      if(m_position == m_end)
      {
         fail(regex_constants::error_escape, m_position - m_base);
         return result;
      }

      if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_open_brace)
      {
         ++m_position;
         if(m_position == m_end)
         {
            fail(regex_constants::error_escape, m_position - m_base);
            return result;
         }
         int i = this->m_traits.toi(m_position, m_end, 16);
         if((m_position == m_end)
            || (i < 0)
            || ((std::numeric_limits<charT>::is_specialized) && (charT(i) > (std::numeric_limits<charT>::max)()))
            || (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_brace))
         {
            fail(regex_constants::error_badbrace, m_position - m_base);
            return result;
         }
         ++m_position;
         result = charT(i);
      }
      else
      {
         std::ptrdiff_t len = (std::min)(static_cast<std::ptrdiff_t>(2), m_end - m_position);
         int i = this->m_traits.toi(m_position, m_position + len, 16);
         if((i < 0)
            || !valid_value(charT(0), i))
         {
            fail(regex_constants::error_escape, m_position - m_base);
            return result;
         }
         result = charT(i);
      }
      return result;
   case regex_constants::syntax_digit:
      {


      std::ptrdiff_t len = (std::min)(::boost::re_detail::distance(m_position, m_end), static_cast<std::ptrdiff_t>(4));
      const charT* bp = m_position;
      int val = this->m_traits.toi(bp, bp + 1, 8);
      if(val != 0)
      {

         fail(regex_constants::error_escape, m_position - m_base);
         return result;
      }
      val = this->m_traits.toi(m_position, m_position + len, 8);
      if(val < 0)
      {
         fail(regex_constants::error_escape, m_position - m_base);
         return result;
      }
      return static_cast<charT>(val);
      }
   case regex_constants::escape_type_named_char:
      {
         ++m_position;
         if(m_position == m_end)
         {
            fail(regex_constants::error_escape, m_position - m_base);
            return false;
         }

         if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_open_brace)
         {
            const charT* base = m_position;

            while((m_position != m_end) && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_brace))
               ++m_position;
            if(m_position == m_end)
            {
               fail(regex_constants::error_escape, m_position - m_base);
               return false;
            }
            string_type s = this->m_traits.lookup_collatename(++base, m_position++);
            if(s.empty())
            {
               fail(regex_constants::error_collate, m_position - m_base);
               return false;
            }
            if(s.size() == 1)
            {
               return s[0];
            }
         }

         fail(regex_constants::error_escape, m_position - m_base);
         return false;
      }
   default:
      result = *m_position;
      break;
   }
   ++m_position;
   return result;



}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_backref()
{
   (__builtin_expect(!(m_position != m_end), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_parser.hpp", 1538, "m_position != m_end") : (void)0);
   const charT* pc = m_position;
   int i = this->m_traits.toi(pc, pc + 1, 10);
   if((i == 0) || (((this->flags() & regbase::main_option_type) == regbase::perl_syntax_group) && (this->flags() & regbase::no_bk_refs)))
   {

      charT c = unescape_character();
      this->append_literal(c);
   }
   else if((i > 0) && (this->m_backrefs & (1u << (i-1))))
   {
      m_position = pc;
      re_brace* pb = static_cast<re_brace*>(this->append_state(syntax_element_backref, sizeof(re_brace)));
      pb->index = i;
   }
   else
   {
      fail(regex_constants::error_backref, m_position - m_end);
      return false;
   }
   return true;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_QE()
{







   ++m_position;
   const charT* start = m_position;
   const charT* end;
   do
   {
      while((m_position != m_end)
         && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_escape))
         ++m_position;
      if(m_position == m_end)
      {

         end = m_position;
         break;
      }
      if(++m_position == m_end)
      {
         fail(regex_constants::error_escape, m_position - m_base);
         return false;
      }

      if(this->m_traits.escape_syntax_type(*m_position) == regex_constants::escape_type_E)
      {
         ++m_position;
         end = m_position - 2;
         break;
      }

   }while(true);



   while(start != end)
   {
      this->append_literal(*start);
      ++start;
   }
   return true;



}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::parse_perl_extension()
{
   if(++m_position == m_end)
   {
      fail(regex_constants::error_badrepeat, m_position - m_base);
      return false;
   }





   if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_hash)
   {
      while((m_position != m_end)
         && (this->m_traits.syntax_type(*m_position++) != regex_constants::syntax_close_mark))
      {}
      return true;
   }



   int markid = 0;
   std::ptrdiff_t jump_offset = 0;
   re_brace* pb = static_cast<re_brace*>(this->append_state(syntax_element_startmark, sizeof(re_brace)));
   std::ptrdiff_t last_paren_start = this->getoffset(pb);

   std::ptrdiff_t last_alt_point = m_alt_insert_point;
   this->m_pdata->m_data.align();
   m_alt_insert_point = this->m_pdata->m_data.size();
   std::ptrdiff_t expected_alt_point = m_alt_insert_point;
   bool restore_flags = true;
   regex_constants::syntax_option_type old_flags = this->flags();
   bool old_case_change = m_has_case_change;
   m_has_case_change = false;



   switch(this->m_traits.syntax_type(*m_position))
   {
   case regex_constants::syntax_colon:



      pb->index = markid = 0;
      ++m_position;
      break;
   case regex_constants::syntax_equal:
      pb->index = markid = -1;
      ++m_position;
      jump_offset = this->getoffset(this->append_state(syntax_element_jump, sizeof(re_jump)));
      this->m_pdata->m_data.align();
      m_alt_insert_point = this->m_pdata->m_data.size();
      break;
   case regex_constants::syntax_not:
      pb->index = markid = -2;
      ++m_position;
      jump_offset = this->getoffset(this->append_state(syntax_element_jump, sizeof(re_jump)));
      this->m_pdata->m_data.align();
      m_alt_insert_point = this->m_pdata->m_data.size();
      break;
   case regex_constants::escape_type_left_word:
      {

         if(++m_position == m_end)
         {
            fail(regex_constants::error_badrepeat, m_position - m_base);
            return false;
         }
         regex_constants::syntax_type t = this->m_traits.syntax_type(*m_position);
         if(t == regex_constants::syntax_not)
            pb->index = markid = -2;
         else if(t == regex_constants::syntax_equal)
            pb->index = markid = -1;
         else
         {
            fail(regex_constants::error_badrepeat, m_position - m_base);
            return false;
         }
         ++m_position;
         jump_offset = this->getoffset(this->append_state(syntax_element_jump, sizeof(re_jump)));
         this->append_state(syntax_element_backstep, sizeof(re_brace));
         this->m_pdata->m_data.align();
         m_alt_insert_point = this->m_pdata->m_data.size();
         break;
      }
   case regex_constants::escape_type_right_word:



      pb->index = markid = -3;
      ++m_position;
      jump_offset = this->getoffset(this->append_state(syntax_element_jump, sizeof(re_jump)));
      this->m_pdata->m_data.align();
      m_alt_insert_point = this->m_pdata->m_data.size();
      break;
   case regex_constants::syntax_open_mark:
      {

      pb->index = markid = -4;
      if(++m_position == m_end)
      {
         fail(regex_constants::error_badrepeat, m_position - m_base);
         return false;
      }
      int v = this->m_traits.toi(m_position, m_end, 10);
      if(v > 0)
      {
         re_brace* br = static_cast<re_brace*>(this->append_state(syntax_element_assert_backref, sizeof(re_brace)));
         br->index = v;
         if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_close_mark)
         {
            fail(regex_constants::error_badrepeat, m_position - m_base);
            return false;
         }
         if(++m_position == m_end)
         {
            fail(regex_constants::error_badrepeat, m_position - m_base);
            return false;
         }
      }
      else
      {

         if(this->m_traits.syntax_type(*m_position) != regex_constants::syntax_question)
         {
            fail(regex_constants::error_badrepeat, m_position - m_base);
            return false;
         }
         if(++m_position == m_end)
         {
            fail(regex_constants::error_badrepeat, m_position - m_base);
            return false;
         }
         if(this->m_traits.syntax_type(*m_position) == regex_constants::escape_type_left_word)
         {
            if(++m_position == m_end)
            {
               fail(regex_constants::error_badrepeat, m_position - m_base);
               return false;
            }
            if((this->m_traits.syntax_type(*m_position) != regex_constants::syntax_equal)
               && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_not))
            {
               fail(regex_constants::error_badrepeat, m_position - m_base);
               return false;
            }
            m_position -= 3;
         }
         else
         {
            if((this->m_traits.syntax_type(*m_position) != regex_constants::syntax_equal)
               && (this->m_traits.syntax_type(*m_position) != regex_constants::syntax_not))
            {
               fail(regex_constants::error_badrepeat, m_position - m_base);
               return false;
            }
            m_position -= 2;
         }
      }
      break;
      }
   case regex_constants::syntax_close_mark:
      fail(regex_constants::error_badrepeat, m_position - m_base);
      return false;
   default:



      regex_constants::syntax_option_type opts = parse_options();
      if(m_position == m_end)
         return false;

      m_has_case_change = ((opts & regbase::icase) != (this->flags() & regbase::icase));
      pb->index = markid = 0;
      if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_mark)
      {

         this->flags(opts);
         restore_flags = false;
         old_case_change |= m_has_case_change;
      }
      else if(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_colon)
      {

         this->flags(opts);
         ++m_position;
      }
      else
      {
         fail(regex_constants::error_badrepeat, m_position - m_base);
         return false;
      }


      if(m_has_case_change)
      {
         static_cast<re_case*>(
            this->append_state(syntax_element_toggle_case, sizeof(re_case))
            )->icase = opts & regbase::icase;
      }

   }




   parse_all();



   if(0 == unwind_alts(last_paren_start))
      return false;



   if(m_position == m_end)
   {
      this->fail(regex_constants::error_paren, ::boost::re_detail::distance(m_base, m_end));
      return false;
   }
   (__builtin_expect(!(this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_mark), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_parser.hpp", 1835, "this->m_traits.syntax_type(*m_position) == regex_constants::syntax_close_mark") : (void)0);
   ++m_position;



   if(restore_flags)
   {

      if(m_has_case_change)
      {
         static_cast<re_case*>(
            this->append_state(syntax_element_toggle_case, sizeof(re_case))
            )->icase = old_flags & regbase::icase;
      }
      this->flags(old_flags);
   }



   if(jump_offset)
   {
      this->m_pdata->m_data.align();
      re_jump* jmp = static_cast<re_jump*>(this->getaddress(jump_offset));
      jmp->alt.i = this->m_pdata->m_data.size() - this->getoffset(jmp);
      if(this->m_last_state == jmp)
      {

         fail(regex_constants::error_empty, m_position - m_base);
         return false;
      }
   }




   if(markid == -4)
   {
      re_syntax_base* b = this->getaddress(expected_alt_point);

      if(b->type != syntax_element_alt)
      {
         re_alt* alt = static_cast<re_alt*>(this->insert_state(expected_alt_point, syntax_element_alt, sizeof(re_alt)));
         alt->alt.i = this->m_pdata->m_data.size() - this->getoffset(alt);
      }
      else if(this->getaddress(static_cast<re_alt*>(b)->alt.i, b)->type == syntax_element_alt)
      {
         fail(regex_constants::error_bad_pattern, m_position - m_base);
         return false;
      }

      b = this->getaddress(expected_alt_point);
      b = this->getaddress(static_cast<re_alt*>(b)->next.i, b);
      if((b->type != syntax_element_assert_backref)
         && (b->type != syntax_element_startmark))
      {
         fail(regex_constants::error_badrepeat, m_position - m_base);
         return false;
      }
   }



   pb = static_cast<re_brace*>(this->append_state(syntax_element_endmark, sizeof(re_brace)));
   pb->index = markid;
   this->m_paren_start = last_paren_start;



   this->m_alt_insert_point = last_alt_point;



   m_has_case_change = old_case_change;
   return true;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::add_emacs_code(bool negate)
{



   if(++m_position == m_end)
   {
      fail(regex_constants::error_escape, m_position - m_base);
      return false;
   }
   basic_char_set<charT, traits> char_set;
   if(negate)
      char_set.negate();

   static const charT s_punct[5] = { 'p', 'u', 'n', 'c', 't', };

   switch(*m_position)
   {
   case 's':
   case ' ':
      char_set.add_class(this->m_mask_space);
      break;
   case 'w':
      char_set.add_class(this->m_word_mask);
      break;
   case '_':
      char_set.add_single(digraph<charT>(charT('$')));
      char_set.add_single(digraph<charT>(charT('&')));
      char_set.add_single(digraph<charT>(charT('*')));
      char_set.add_single(digraph<charT>(charT('+')));
      char_set.add_single(digraph<charT>(charT('-')));
      char_set.add_single(digraph<charT>(charT('_')));
      char_set.add_single(digraph<charT>(charT('<')));
      char_set.add_single(digraph<charT>(charT('>')));
      break;
   case '.':
      char_set.add_class(this->m_traits.lookup_classname(s_punct, s_punct+5));
      break;
   case '(':
      char_set.add_single(digraph<charT>(charT('(')));
      char_set.add_single(digraph<charT>(charT('[')));
      char_set.add_single(digraph<charT>(charT('{')));
      break;
   case ')':
      char_set.add_single(digraph<charT>(charT(')')));
      char_set.add_single(digraph<charT>(charT(']')));
      char_set.add_single(digraph<charT>(charT('}')));
      break;
   case '"':
      char_set.add_single(digraph<charT>(charT('"')));
      char_set.add_single(digraph<charT>(charT('\'')));
      char_set.add_single(digraph<charT>(charT('`')));
      break;
   case '\'':
      char_set.add_single(digraph<charT>(charT('\'')));
      char_set.add_single(digraph<charT>(charT(',')));
      char_set.add_single(digraph<charT>(charT('#')));
      break;
   case '<':
      char_set.add_single(digraph<charT>(charT(';')));
      break;
   case '>':
      char_set.add_single(digraph<charT>(charT('\n')));
      char_set.add_single(digraph<charT>(charT('\f')));
      break;
   default:
      fail(regex_constants::error_ctype, m_position - m_base);
      return false;
   }
   if(0 == this->append_set(char_set))
   {
      fail(regex_constants::error_ctype, m_position - m_base);
      return false;
   }
   ++m_position;
   return true;
}

template <class charT, class traits>
regex_constants::syntax_option_type basic_regex_parser<charT, traits>::parse_options()
{

   regex_constants::syntax_option_type f = this->flags();
   bool breakout = false;
   do
   {
      switch(*m_position)
      {
      case 's':
         f |= regex_constants::mod_s;
         f &= ~regex_constants::no_mod_s;
         break;
      case 'm':
         f &= ~regex_constants::no_mod_m;
         break;
      case 'i':
         f |= regex_constants::icase;
         break;
      case 'x':
         f |= regex_constants::mod_x;
         break;
      default:
         breakout = true;
         continue;
      }
      if(++m_position == m_end)
      {
         fail(regex_constants::error_paren, m_position - m_base);
         return false;
      }
   }
   while(!breakout);

   if(*m_position == static_cast<charT>('-'))
   {
      if(++m_position == m_end)
      {
         fail(regex_constants::error_paren, m_position - m_base);
         return false;
      }
      do
      {
         switch(*m_position)
         {
         case 's':
            f &= ~regex_constants::mod_s;
            f |= regex_constants::no_mod_s;
            break;
         case 'm':
            f |= regex_constants::no_mod_m;
            break;
         case 'i':
            f &= ~regex_constants::icase;
            break;
         case 'x':
            f &= ~regex_constants::mod_x;
            break;
         default:
            breakout = true;
            continue;
         }
         if(++m_position == m_end)
         {
            fail(regex_constants::error_paren, m_position - m_base);
            return false;
         }
      }
      while(!breakout);
   }
   return f;
}

template <class charT, class traits>
bool basic_regex_parser<charT, traits>::unwind_alts(std::ptrdiff_t last_paren_start)
{




   if((this->m_alt_insert_point == static_cast<std::ptrdiff_t>(this->m_pdata->m_data.size()))
      && m_alt_jumps.size() && (m_alt_jumps.back() > last_paren_start))
   {
      fail(regex_constants::error_empty, this->m_position - this->m_base);
      return false;
   }



   while(m_alt_jumps.size() && (m_alt_jumps.back() > last_paren_start))
   {




      std::ptrdiff_t jump_offset = m_alt_jumps.back();
      m_alt_jumps.pop_back();
      this->m_pdata->m_data.align();
      re_jump* jmp = static_cast<re_jump*>(this->getaddress(jump_offset));
      (__builtin_expect(!(jmp->type == syntax_element_jump), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/basic_regex_parser.hpp", 2090, "jmp->type == syntax_element_jump") : (void)0);
      jmp->alt.i = this->m_pdata->m_data.size() - jump_offset;
   }
   return true;
}





}
}
# 74 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/sub_match.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/sub_match.hpp" 3
namespace boost{

template <class BidiIterator>
struct sub_match : public std::pair<BidiIterator, BidiIterator>
{
   typedef typename re_detail::regex_iterator_traits<BidiIterator>::value_type value_type;



   typedef typename re_detail::regex_iterator_traits<BidiIterator>::difference_type difference_type;

   typedef BidiIterator iterator_type;
   typedef BidiIterator iterator;
   typedef BidiIterator const_iterator;

   bool matched;

   sub_match() : std::pair<BidiIterator, BidiIterator>(), matched(false) {}
   sub_match(BidiIterator i) : std::pair<BidiIterator, BidiIterator>(i, i), matched(false) {}




   template <class T, class A>
   operator std::basic_string<value_type, T, A> ()const
   {
      return std::basic_string<value_type, T, A>(this->first, this->second);
   }






   difference_type length()const
   {
      difference_type n = ::boost::re_detail::distance((BidiIterator)this->first, (BidiIterator)this->second);
      return n;
   }
   std::basic_string<value_type> str()const
   {
      std::basic_string<value_type> result;
      std::size_t len = ::boost::re_detail::distance((BidiIterator)this->first, (BidiIterator)this->second);
      result.reserve(len);
      BidiIterator i = this->first;
      while(i != this->second)
      {
         result.append(1, *i);
         ++i;
      }
      return result;
   }
   int compare(const sub_match& s)const
   {
      if(matched != s.matched)
         return static_cast<int>(matched) - static_cast<int>(s.matched);
      return str().compare(s.str());
   }
   int compare(const std::basic_string<value_type>& s)const
   {
      return str().compare(s);
   }
   int compare(const value_type* p)const
   {
      return str().compare(p);
   }

   bool operator==(const sub_match& that)const
   { return compare(that) == 0; }
   bool operator !=(const sub_match& that)const
   { return compare(that) != 0; }
   bool operator<(const sub_match& that)const
   { return compare(that) < 0; }
   bool operator>(const sub_match& that)const
   { return compare(that) > 0; }
   bool operator<=(const sub_match& that)const
   { return compare(that) <= 0; }
   bool operator>=(const sub_match& that)const
   { return compare(that) >= 0; }
# 137 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/sub_match.hpp" 3
   sub_match(const sub_match& that, bool



      = true
      )
      : std::pair<BidiIterator, BidiIterator>(that),
        matched(that.matched)
   {





   }
   sub_match& operator=(const sub_match& that)
   {
      this->first = that.first;
      this->second = that.second;
      matched = that.matched;




      return *this;
   }
# 180 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/sub_match.hpp" 3
};

typedef sub_match<const char*> csub_match;
typedef sub_match<std::string::const_iterator> ssub_match;

typedef sub_match<const wchar_t*> wcsub_match;
typedef sub_match<std::wstring::const_iterator> wssub_match;



template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator == (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,
                  const sub_match<RandomAccessIterator>& m)
{ return s.compare(m.str()) == 0; }
template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator != (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,
                  const sub_match<RandomAccessIterator>& m)
{ return s.compare(m.str()) != 0; }
template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator < (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,
                 const sub_match<RandomAccessIterator>& m)
{ return s.compare(m.str()) < 0; }
template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator <= (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,
                  const sub_match<RandomAccessIterator>& m)
{ return s.compare(m.str()) <= 0; }
template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator >= (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,
                  const sub_match<RandomAccessIterator>& m)
{ return s.compare(m.str()) >= 0; }
template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator > (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,
                 const sub_match<RandomAccessIterator>& m)
{ return s.compare(m.str()) > 0; }

template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator == (const sub_match<RandomAccessIterator>& m,
                  const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
{ return m.str().compare(s) == 0; }
template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator != (const sub_match<RandomAccessIterator>& m,
                  const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
{ return m.str().compare(s) != 0; }
template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator < (const sub_match<RandomAccessIterator>& m,
                  const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
{ return m.str().compare(s) < 0; }
template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator > (const sub_match<RandomAccessIterator>& m,
                  const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
{ return m.str().compare(s) > 0; }
template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator <= (const sub_match<RandomAccessIterator>& m,
                  const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
{ return m.str().compare(s) <= 0; }
template <class RandomAccessIterator, class traits, class Allocator>
inline bool operator >= (const sub_match<RandomAccessIterator>& m,
                  const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
{ return m.str().compare(s) >= 0; }

template <class RandomAccessIterator>
inline bool operator == (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
{ return m.str().compare(s) == 0; }
template <class RandomAccessIterator>
inline bool operator != (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
{ return m.str().compare(s) != 0; }
template <class RandomAccessIterator>
inline bool operator > (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
{ return m.str().compare(s) > 0; }
template <class RandomAccessIterator>
inline bool operator < (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
{ return m.str().compare(s) < 0; }
template <class RandomAccessIterator>
inline bool operator >= (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
{ return m.str().compare(s) >= 0; }
template <class RandomAccessIterator>
inline bool operator <= (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s)
{ return m.str().compare(s) <= 0; }

template <class RandomAccessIterator>
inline bool operator == (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(s) == 0; }
template <class RandomAccessIterator>
inline bool operator != (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(s) != 0; }
template <class RandomAccessIterator>
inline bool operator < (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(s) > 0; }
template <class RandomAccessIterator>
inline bool operator > (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(s) < 0; }
template <class RandomAccessIterator>
inline bool operator <= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(s) >= 0; }
template <class RandomAccessIterator>
inline bool operator >= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(s) <= 0; }


template <class RandomAccessIterator>
inline bool operator == (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
{ return m.str().compare(0, m.length(), &s, 1) == 0; }
template <class RandomAccessIterator>
inline bool operator != (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
{ return m.str().compare(0, m.length(), &s, 1) != 0; }
template <class RandomAccessIterator>
inline bool operator > (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
{ return m.str().compare(0, m.length(), &s, 1) > 0; }
template <class RandomAccessIterator>
inline bool operator < (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
{ return m.str().compare(0, m.length(), &s, 1) < 0; }
template <class RandomAccessIterator>
inline bool operator >= (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
{ return m.str().compare(0, m.length(), &s, 1) >= 0; }
template <class RandomAccessIterator>
inline bool operator <= (const sub_match<RandomAccessIterator>& m,
                  typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
{ return m.str().compare(0, m.length(), &s, 1) <= 0; }

template <class RandomAccessIterator>
inline bool operator == (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(0, m.length(), &s, 1) == 0; }
template <class RandomAccessIterator>
inline bool operator != (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(0, m.length(), &s, 1) != 0; }
template <class RandomAccessIterator>
inline bool operator < (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(0, m.length(), &s, 1) > 0; }
template <class RandomAccessIterator>
inline bool operator > (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(0, m.length(), &s, 1) < 0; }
template <class RandomAccessIterator>
inline bool operator <= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(0, m.length(), &s, 1) >= 0; }
template <class RandomAccessIterator>
inline bool operator >= (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,
                  const sub_match<RandomAccessIterator>& m)
{ return m.str().compare(0, m.length(), &s, 1) <= 0; }


template <class RandomAccessIterator, class traits, class Allocator>
inline std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>
operator + (const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s,
                  const sub_match<RandomAccessIterator>& m)
{
   std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator> result;
   result.reserve(s.size() + m.length() + 1);
   return result.append(s).append(m.first, m.second);
}
template <class RandomAccessIterator, class traits, class Allocator>
inline std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>
operator + (const sub_match<RandomAccessIterator>& m,
            const std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator>& s)
{
   std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type, traits, Allocator> result;
   result.reserve(s.size() + m.length() + 1);
   return result.append(m.first, m.second).append(s);
}

template <class RandomAccessIterator>
inline std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type>
operator + (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const* s,
                  const sub_match<RandomAccessIterator>& m)
{
   std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type> result;
   result.reserve(std::char_traits<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type>::length(s) + m.length() + 1);
   return result.append(s).append(m.first, m.second);
}
template <class RandomAccessIterator>
inline std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type>
operator + (const sub_match<RandomAccessIterator>& m,
            typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const * s)
{
   std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type> result;
   result.reserve(std::char_traits<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type>::length(s) + m.length() + 1);
   return result.append(m.first, m.second).append(s);
}
# 396 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/sub_match.hpp" 3
template <class RandomAccessIterator>
inline std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type>
operator + (typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s,
                  const sub_match<RandomAccessIterator>& m)
{
   std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type> result;
   result.reserve(m.length() + 2);
   return result.append(1, s).append(m.first, m.second);
}
template <class RandomAccessIterator>
inline std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type>
operator + (const sub_match<RandomAccessIterator>& m,
            typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type const& s)
{
   std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type> result;
   result.reserve(m.length() + 2);
   return result.append(m.first, m.second).append(1, s);
}
template <class RandomAccessIterator>
inline std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type>
operator + (const sub_match<RandomAccessIterator>& m1,
            const sub_match<RandomAccessIterator>& m2)
{
   std::basic_string<typename re_detail::regex_iterator_traits<RandomAccessIterator>::value_type> result;
   result.reserve(m1.length() + m2.length() + 1);
   return result.append(m1.first, m1.second).append(m2.first, m2.second);
}

template <class charT, class traits, class RandomAccessIterator>
std::basic_ostream<charT, traits>&
   operator << (std::basic_ostream<charT, traits>& os,
                const sub_match<RandomAccessIterator>& s)
{
   return (os << s.str());
}
# 495 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/sub_match.hpp" 3
}
# 77 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_format.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_format.hpp" 3
namespace boost{
# 41 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_format.hpp" 3
   template <class BidiIterator, class Allocator = typename std::vector<sub_match<BidiIterator> >::allocator_type >
class match_results;

namespace re_detail{






template <class charT>
struct trivial_format_traits
{
   typedef charT char_type;

   static std::ptrdiff_t length(const charT* p)
   {
      return global_length(p);
   }
   static charT tolower(charT c)
   {
      return ::boost::re_detail::global_lower(c);
   }
   static charT toupper(charT c)
   {
      return ::boost::re_detail::global_upper(c);
   }
   static int value(const charT c, int radix)
   {
      int result = global_value(c);
      return result >= radix ? -1 : result;
   }
   int toi(const charT*& p1, const charT* p2, int radix)const
   {
      return global_toi(p1, p2, radix, *this);
   }
};

template <class OutputIterator, class Results, class traits>
class basic_regex_formatter
{
public:
   typedef typename traits::char_type char_type;
   basic_regex_formatter(OutputIterator o, const Results& r, const traits& t)
      : m_traits(t), m_results(r), m_out(o), m_state(output_copy), m_restore_state(output_copy), m_have_conditional(false) {}
   OutputIterator format(const char_type* p1, const char_type* p2, match_flag_type f);
   OutputIterator format(const char_type* p1, match_flag_type f)
   {
      return format(p1, p1 + m_traits.length(p1), f);
   }
private:
   typedef typename Results::value_type sub_match_type;
   enum output_state
   {
      output_copy,
      output_next_lower,
      output_next_upper,
      output_lower,
      output_upper,
      output_none
   };

   void put(char_type c);
   void put(const sub_match_type& sub);
   void format_all();
   void format_perl();
   void format_escape();
   void format_conditional();
   void format_until_scope_end();

   const traits& m_traits;
   const Results& m_results;
   OutputIterator m_out;
   const char_type* m_position;
   const char_type* m_end;
   match_flag_type m_flags;
   output_state m_state;
   output_state m_restore_state;
   bool m_have_conditional;
private:
   basic_regex_formatter(const basic_regex_formatter&);
   basic_regex_formatter& operator=(const basic_regex_formatter&);
};

template <class OutputIterator, class Results, class traits>
OutputIterator basic_regex_formatter<OutputIterator, Results, traits>::format(const char_type* p1, const char_type* p2, match_flag_type f)
{
   m_position = p1;
   m_end = p2;
   m_flags = f;
   format_all();
   return m_out;
}

template <class OutputIterator, class Results, class traits>
void basic_regex_formatter<OutputIterator, Results, traits>::format_all()
{

   while(m_position != m_end)
   {
      switch(*m_position)
      {
      case '&':
         if(m_flags & ::boost::regex_constants::format_sed)
         {
            ++m_position;
            put(m_results[0]);
            break;
         }
         put(*m_position++);
         break;
      case '\\':
         format_escape();
         break;
      case '(':
         if(m_flags & boost::regex_constants::format_all)
         {
            ++m_position;
            bool have_conditional = m_have_conditional;
            m_have_conditional = false;
            format_until_scope_end();
            m_have_conditional = have_conditional;
            if(m_position == m_end)
               return;
            (__builtin_expect(!(*m_position == static_cast<char_type>(')')), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_format.hpp", 165, "*m_position == static_cast<char_type>(')')") : (void)0);
            ++m_position;
            break;
         }
         put(*m_position);
         ++m_position;
         break;
      case ')':
         if(m_flags & boost::regex_constants::format_all)
         {
            return;
         }
         put(*m_position);
         ++m_position;
         break;
      case ':':
         if((m_flags & boost::regex_constants::format_all) && m_have_conditional)
         {
            return;
         }
         put(*m_position);
         ++m_position;
         break;
      case '?':
         if(m_flags & boost::regex_constants::format_all)
         {
            ++m_position;
            format_conditional();
            break;
         }
         put(*m_position);
         ++m_position;
         break;
      case '$':
         if((m_flags & format_sed) == 0)
         {
            format_perl();
            break;
         }

      default:
         put(*m_position);
         ++m_position;
         break;
      }
   }
}

template <class OutputIterator, class Results, class traits>
void basic_regex_formatter<OutputIterator, Results, traits>::format_perl()
{




   (__builtin_expect(!(*m_position == '$'), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_format.hpp", 220, "*m_position == '$'") : (void)0);



   if(++m_position == m_end)
   {
      --m_position;
      put(*m_position);
      ++m_position;
      return;
   }



   switch(*m_position)
   {
   case '&':
      ++m_position;
      put(this->m_results[0]);
      break;
   case '`':
      ++m_position;
      put(this->m_results.prefix());
      break;
   case '\'':
      ++m_position;
      put(this->m_results.suffix());
      break;
   case '$':
      put(*m_position++);
      break;
   default:

      {
         std::ptrdiff_t len = ::boost::re_detail::distance(m_position, m_end);
         len = (std::min)(static_cast<std::ptrdiff_t>(2), len);
         int v = m_traits.toi(m_position, m_position + len, 10);
         if(v < 0)
         {

            --m_position;
            put(*m_position);
            ++m_position;
            break;
         }

         put(this->m_results[v]);
      }
   }
}

template <class OutputIterator, class Results, class traits>
void basic_regex_formatter<OutputIterator, Results, traits>::format_escape()
{

   if(++m_position == m_end)
   {
      put(static_cast<char_type>('\\'));
      return;
   }

   switch(*m_position)
   {
   case 'a':
      put(static_cast<char_type>('\a'));
      ++m_position;
      break;
   case 'f':
      put(static_cast<char_type>('\f'));
      ++m_position;
      break;
   case 'n':
      put(static_cast<char_type>('\n'));
      ++m_position;
      break;
   case 'r':
      put(static_cast<char_type>('\r'));
      ++m_position;
      break;
   case 't':
      put(static_cast<char_type>('\t'));
      ++m_position;
      break;
   case 'v':
      put(static_cast<char_type>('\v'));
      ++m_position;
      break;
   case 'x':
      if(++m_position == m_end)
      {
         put(static_cast<char_type>('x'));
         return;
      }

      if(*m_position == static_cast<char_type>('{'))
      {
         ++m_position;
         int val = m_traits.toi(m_position, m_end, 16);
         if(val < 0)
         {

            put(static_cast<char_type>('x'));
            put(static_cast<char_type>('{'));
            return;
         }
         if(*m_position != static_cast<char_type>('}'))
         {
            while(*m_position != static_cast<char_type>('\\'))
               --m_position;
            ++m_position;
            put(*m_position++);
            return;
         }
         ++m_position;
         put(static_cast<char_type>(val));
         return;
      }
      else
      {
         std::ptrdiff_t len = ::boost::re_detail::distance(m_position, m_end);
         len = (std::min)(static_cast<std::ptrdiff_t>(2), len);
         int val = m_traits.toi(m_position, m_position + len, 16);
         if(val < 0)
         {
            --m_position;
            put(*m_position++);
            return;
         }
         put(static_cast<char_type>(val));
      }
      break;
   case 'c':
      if(++m_position == m_end)
      {
         --m_position;
         put(*m_position++);
         return;
      }
      put(static_cast<char_type>(*m_position++ % 32));
      break;
   case 'e':
      put(static_cast<char_type>(27));
      ++m_position;
      break;
   default:

      if((m_flags & boost::regex_constants::format_sed) == 0)
      {
         bool breakout = false;
         switch(*m_position)
         {
         case 'l':
            ++m_position;
            m_restore_state = m_state;
            m_state = output_next_lower;
            breakout = true;
            break;
         case 'L':
            ++m_position;
            m_state = output_lower;
            breakout = true;
            break;
         case 'u':
            ++m_position;
            m_restore_state = m_state;
            m_state = output_next_upper;
            breakout = true;
            break;
         case 'U':
            ++m_position;
            m_state = output_upper;
            breakout = true;
            break;
         case 'E':
            ++m_position;
            m_state = output_copy;
            breakout = true;
            break;
         }
         if(breakout)
            break;
      }

      int v = m_traits.toi(m_position, m_position+1, 10);
      if((v > 0) || ((v == 0) && (m_flags & ::boost::regex_constants::format_sed)))
      {
         put(m_results[v]);
         break;
      }
      else if(v == 0)
      {

         --m_position;
         std::ptrdiff_t len = ::boost::re_detail::distance(m_position, m_end);
         len = (std::min)(static_cast<std::ptrdiff_t>(4), len);
         v = m_traits.toi(m_position, m_position + len, 8);
         (__builtin_expect(!(v >= 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_format.hpp", 416, "v >= 0") : (void)0);
         put(static_cast<char_type>(v));
         break;
      }

      put(*m_position++);
      break;
   }
}

template <class OutputIterator, class Results, class traits>
void basic_regex_formatter<OutputIterator, Results, traits>::format_conditional()
{
   if(m_position == m_end)
   {

      put(static_cast<char_type>('?'));
      return;
   }
   std::ptrdiff_t len = ::boost::re_detail::distance(m_position, m_end);
   len = (std::min)(static_cast<std::ptrdiff_t>(2), len);
   int v = m_traits.toi(m_position, m_position + len, 10);
   if(v < 0)
   {

      put(static_cast<char_type>('?'));
      return;
   }


   if(m_results[v].matched)
   {
      m_have_conditional = true;
      format_all();
      m_have_conditional = false;
      if((m_position != m_end) && (*m_position == static_cast<char_type>(':')))
      {

         ++m_position;

         output_state saved_state = m_state;
         m_state = output_none;

         format_until_scope_end();

         m_state = saved_state;
      }
   }
   else
   {

      output_state saved_state = m_state;
      m_state = output_none;

      m_have_conditional = true;
      format_all();
      m_have_conditional = false;

      m_state = saved_state;
      if((m_position != m_end) && (*m_position == static_cast<char_type>(':')))
      {

         ++m_position;

         format_until_scope_end();
      }
   }
}

template <class OutputIterator, class Results, class traits>
void basic_regex_formatter<OutputIterator, Results, traits>::format_until_scope_end()
{
   do
   {
      format_all();
      if((m_position == m_end) || (*m_position == static_cast<char_type>(')')))
         return;
      put(*m_position++);
   }while(m_position != m_end);
}

template <class OutputIterator, class Results, class traits>
void basic_regex_formatter<OutputIterator, Results, traits>::put(char_type c)
{


   switch(this->m_state)
   {
   case output_none:
      return;
   case output_next_lower:
      c = m_traits.tolower(c);
      this->m_state = m_restore_state;
      break;
   case output_next_upper:
      c = m_traits.toupper(c);
      this->m_state = m_restore_state;
      break;
   case output_lower:
      c = m_traits.tolower(c);
      break;
   case output_upper:
      c = m_traits.toupper(c);
      break;
   default:
      break;
   }
   *m_out = c;
   ++m_out;
}

template <class OutputIterator, class Results, class traits>
void basic_regex_formatter<OutputIterator, Results, traits>::put(const sub_match_type& sub)
{
   typedef typename sub_match_type::iterator iterator_type;
   iterator_type i = sub.first;
   while(i != sub.second)
   {
      put(*i);
      ++i;
   }
}

template <class S>
class string_out_iterator

   : public std::iterator<std::output_iterator_tag, typename S::value_type>

{
   S* out;
public:
   string_out_iterator(S& s) : out(&s) {}
   string_out_iterator& operator++() { return *this; }
   string_out_iterator& operator++(int) { return *this; }
   string_out_iterator& operator*() { return *this; }
   string_out_iterator& operator=(typename S::value_type v)
   {
      out->append(1, v);
      return *this;
   }
# 564 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_format.hpp" 3
};

template <class OutputIterator, class Iterator, class Alloc, class charT, class traits>
OutputIterator regex_format_imp(OutputIterator out,
                          const match_results<Iterator, Alloc>& m,
                          const charT* p1, const charT* p2,
                          match_flag_type flags,
                          const traits& t
                         )
{
   if(flags & regex_constants::format_literal)
   {
      return re_detail::copy(p1, p2, out);
   }

   re_detail::basic_regex_formatter<
      OutputIterator,
      match_results<Iterator, Alloc>,
      traits > f(out, m, t);
   return f.format(p1, p2, flags);
}


}

template <class OutputIterator, class Iterator, class charT>
OutputIterator regex_format(OutputIterator out,
                          const match_results<Iterator>& m,
                          const charT* fmt,
                          match_flag_type flags = format_all
                         )
{
   re_detail::trivial_format_traits<charT> traits;
   return re_detail::regex_format_imp(out, m, fmt, fmt + traits.length(fmt), flags, traits);
}

template <class OutputIterator, class Iterator, class charT>
OutputIterator regex_format(OutputIterator out,
                          const match_results<Iterator>& m,
                          const std::basic_string<charT>& fmt,
                          match_flag_type flags = format_all
                         )
{
   re_detail::trivial_format_traits<charT> traits;
   return re_detail::regex_format_imp(out, m, fmt.data(), fmt.data() + fmt.size(), flags, traits);
}

template <class Iterator, class charT>
std::basic_string<charT> regex_format(const match_results<Iterator>& m,
                                      const charT* fmt,
                                      match_flag_type flags = format_all)
{
   std::basic_string<charT> result;
   re_detail::string_out_iterator<std::basic_string<charT> > i(result);
   re_detail::trivial_format_traits<charT> traits;
   re_detail::regex_format_imp(i, m, fmt, fmt + traits.length(fmt), flags, traits);
   return result;
}

template <class Iterator, class charT>
std::basic_string<charT> regex_format(const match_results<Iterator>& m,
                                      const std::basic_string<charT>& fmt,
                                      match_flag_type flags = format_all)
{
   std::basic_string<charT> result;
   re_detail::string_out_iterator<std::basic_string<charT> > i(result);
   re_detail::trivial_format_traits<charT> traits;
   re_detail::regex_format_imp(i, m, fmt.data(), fmt.data() + fmt.size(), flags, traits);
   return result;
}
# 646 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_format.hpp" 3
}
# 80 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp" 1 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp" 3
namespace boost{





template <class BidiIterator, class Allocator>
class match_results
{
private:

   typedef std::vector<sub_match<BidiIterator>, Allocator> vector_type;



public:
   typedef sub_match<BidiIterator> value_type;

   typedef typename Allocator::const_reference const_reference;



   typedef const_reference reference;
   typedef typename vector_type::const_iterator const_iterator;
   typedef const_iterator iterator;
   typedef typename re_detail::regex_iterator_traits<
                                    BidiIterator>::difference_type difference_type;
   typedef typename Allocator::size_type size_type;
   typedef Allocator allocator_type;
   typedef typename re_detail::regex_iterator_traits<
                                    BidiIterator>::value_type char_type;
   typedef std::basic_string<char_type> string_type;


   explicit match_results(const Allocator& a = Allocator())

      : m_subs(a), m_base() {}



   match_results(const match_results& m)
      : m_subs(m.m_subs), m_base(m.m_base) {}
   match_results& operator=(const match_results& m)
   {
      m_subs = m.m_subs;
      m_base = m.m_base;
      return *this;
   }
   ~match_results(){}


   size_type size() const
   { return empty() ? 0 : m_subs.size() - 2; }
   size_type max_size() const
   { return m_subs.max_size(); }
   bool empty() const
   { return m_subs.size() < 2; }

   difference_type length(int sub = 0) const
   {
      sub += 2;
      if((sub < (int)m_subs.size()) && (sub > 0))
         return m_subs[sub].length();
      return 0;
   }
   difference_type position(size_type sub = 0) const
   {
      sub += 2;
      if(sub < m_subs.size())
      {
         const sub_match<BidiIterator>& s = m_subs[sub];
         if(s.matched || (sub == 2))
         {
            return ::boost::re_detail::distance((BidiIterator)(m_base), (BidiIterator)(s.first));
         }
      }
      return ~static_cast<difference_type>(0);
   }
   string_type str(int sub = 0) const
   {
      sub += 2;
      string_type result;
      if(sub < (int)m_subs.size() && (sub > 0))
      {
         const sub_match<BidiIterator>& s = m_subs[sub];
         if(s.matched)
         {
            result = s.str();
         }
      }
      return result;
   }
   const_reference operator[](int sub) const
   {
      sub += 2;
      if(sub < (int)m_subs.size() && (sub >= 0))
      {
         return m_subs[sub];
      }
      return m_null;
   }

   const_reference prefix() const
   {
      return (*this)[-1];
   }

   const_reference suffix() const
   {
      return (*this)[-2];
   }
   const_iterator begin() const
   {
      return (m_subs.size() > 2) ? (m_subs.begin() + 2) : m_subs.end();
   }
   const_iterator end() const
   {
      return m_subs.end();
   }

   template <class OutputIterator>
   OutputIterator format(OutputIterator out,
                         const string_type& fmt,
                         match_flag_type flags = format_default) const
   {
      re_detail::trivial_format_traits<char_type> traits;
      return re_detail::regex_format_imp(out, *this, fmt.data(), fmt.data() + fmt.size(), flags, traits);
   }
   string_type format(const string_type& fmt,
                      match_flag_type flags = format_default) const
   {
      string_type result;
      re_detail::string_out_iterator<string_type> i(result);
      re_detail::trivial_format_traits<char_type> traits;
      re_detail::regex_format_imp(i, *this, fmt.data(), fmt.data() + fmt.size(), flags, traits);
      return result;
   }

   template <class OutputIterator, class RegexT>
   OutputIterator format(OutputIterator out,
                         const string_type& fmt,
                         match_flag_type flags,
                         const RegexT& re) const
   {
      return ::boost::re_detail::regex_format_imp(out, *this, fmt.data(), fmt.data() + fmt.size(), flags, re.get_traits());
   }
   template <class RegexT>
   string_type format(const string_type& fmt,
                      match_flag_type flags,
                      const RegexT& re) const
   {
      string_type result;
      re_detail::string_out_iterator<string_type> i(result);
      ::boost::re_detail::regex_format_imp(i, *this, fmt.data(), fmt.data() + fmt.size(), flags, re.get_traits());
      return result;
   }

   allocator_type get_allocator() const
   {

      return m_subs.get_allocator();



   }
   void swap(match_results& that)
   {
      std::swap(m_subs, that.m_subs);
      std::swap(m_base, that.m_base);
   }
   bool operator==(const match_results& that)const
   {
      return (m_subs == that.m_subs) && (m_base == that.m_base);
   }
   bool operator!=(const match_results& that)const
   { return !(*this == that); }
# 221 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp" 3
   void set_second(BidiIterator i)
   {
      (__builtin_expect(!(m_subs.size() > 2), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp", 223, "m_subs.size() > 2") : (void)0);
      m_subs[2].second = i;
      m_subs[2].matched = true;
      m_subs[0].first = i;
      m_subs[0].matched = (m_subs[0].first != m_subs[0].second);
      m_null.first = i;
      m_null.second = i;
      m_null.matched = false;
   }

   void set_second(BidiIterator i, size_type pos, bool m = true)
   {
      pos += 2;
      (__builtin_expect(!(m_subs.size() > pos), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp", 236, "m_subs.size() > pos") : (void)0);
      m_subs[pos].second = i;
      m_subs[pos].matched = m;
      if(pos == 2)
      {
         m_subs[0].first = i;
         m_subs[0].matched = (m_subs[0].first != m_subs[0].second);
         m_null.first = i;
         m_null.second = i;
         m_null.matched = false;
      }
   }
   void set_size(size_type n, BidiIterator i, BidiIterator j)
   {
      value_type v(j);
      size_type len = m_subs.size();
      if(len > n + 2)
      {
         m_subs.erase(m_subs.begin()+n+2, m_subs.end());
         std::fill(m_subs.begin(), m_subs.end(), v);
      }
      else
      {
         std::fill(m_subs.begin(), m_subs.end(), v);
         if(n+2 != len)
            m_subs.insert(m_subs.end(), n+2-len, v);
      }
      m_subs[1].first = i;
   }
   void set_base(BidiIterator pos)
   {
      m_base = pos;
   }
   BidiIterator base()const
   {
      return m_base;
   }
   void set_first(BidiIterator i)
   {

      m_subs[1].second = i;
      m_subs[1].matched = (m_subs[1].first != i);

      m_subs[2].first = i;

      for(size_type n = 3; n < m_subs.size(); ++n)
      {
         m_subs[n].first = m_subs[n].second = m_subs[0].second;
         m_subs[n].matched = false;
      }
   }
   void set_first(BidiIterator i, size_type pos)
   {
      (__builtin_expect(!(pos+2 < m_subs.size()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp", 289, "pos+2 < m_subs.size()") : (void)0);
      if(pos)
         m_subs[pos+2].first = i;
      else
         set_first(i);
   }
   void maybe_assign(const match_results<BidiIterator, Allocator>& m);


private:
   vector_type m_subs;
   BidiIterator m_base;
   sub_match<BidiIterator> m_null;
};

template <class BidiIterator, class Allocator>
void match_results<BidiIterator, Allocator>::maybe_assign(const match_results<BidiIterator, Allocator>& m)
{
   const_iterator p1, p2;
   p1 = begin();
   p2 = m.begin();
# 320 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp" 3
   BidiIterator l_end = this->suffix().second;
   BidiIterator l_base = (p1->first == l_end) ? this->prefix().first : (*this)[0].first;
   difference_type len1 = 0;
   difference_type len2 = 0;
   difference_type base1 = 0;
   difference_type base2 = 0;
   std::size_t i;
   for(i = 0; i < size(); ++i, ++p1, ++p2)
   {







      if(p1->first == l_end)
      {
         if(p2->first != l_end)
         {


            base1 = 1;
            base2 = 0;
            break;
         }
         else
         {


            if((p1->matched == false) && (p2->matched == true))
               break;
            if((p1->matched == true) && (p2->matched == false))
               return;
            continue;
         }
      }
      else if(p2->first == l_end)
      {

         return;
      }
      base1 = ::boost::re_detail::distance(l_base, p1->first);
      base2 = ::boost::re_detail::distance(l_base, p2->first);
      (__builtin_expect(!(base1 >= 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp", 364, "base1 >= 0") : (void)0);
      (__builtin_expect(!(base2 >= 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp", 365, "base2 >= 0") : (void)0);
      if(base1 < base2) return;
      if(base2 < base1) break;

      len1 = ::boost::re_detail::distance((BidiIterator)p1->first, (BidiIterator)p1->second);
      len2 = ::boost::re_detail::distance((BidiIterator)p2->first, (BidiIterator)p2->second);
      (__builtin_expect(!(len1 >= 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp", 371, "len1 >= 0") : (void)0);
      (__builtin_expect(!(len2 >= 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp", 372, "len2 >= 0") : (void)0);
      if((len1 != len2) || ((p1->matched == false) && (p2->matched == true)))
         break;
      if((p1->matched == true) && (p2->matched == false))
         return;
   }
   if(i == size())
      return;
   if(base2 < base1)
      *this = m;
   else if((len2 > len1) || ((p1->matched == false) && (p2->matched == true)) )
      *this = m;
}

template <class BidiIterator, class Allocator>
void swap(match_results<BidiIterator, Allocator>& a, match_results<BidiIterator, Allocator>& b)
{
   a.swap(b);
}


template <class charT, class traits, class BidiIterator, class Allocator>
std::basic_ostream<charT, traits>&
   operator << (std::basic_ostream<charT, traits>& os,
                const match_results<BidiIterator, Allocator>& s)
{
   return (os << s.str());
}
# 412 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/match_results.hpp" 3
}
# 83 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/protected_call.hpp" 1 3
# 34 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/protected_call.hpp" 3
namespace boost{
namespace re_detail{

class abstract_protected_call
{
public:
   bool execute()const;

   virtual ~abstract_protected_call(){}
private:
   virtual bool call()const = 0;
};

template <class T>
class concrete_protected_call
   : public abstract_protected_call
{
public:
   typedef bool (T::*proc_type)();
   concrete_protected_call(T* o, proc_type p)
      : obj(o), proc(p) {}
private:
   virtual bool call()const;
   T* obj;
   proc_type proc;
};

template <class T>
bool concrete_protected_call<T>::call()const
{
   return (obj->*proc)();
}

}
}
# 86 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher.hpp" 1 3
# 15 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/iterator_category.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/iterator_category.hpp" 3
namespace boost{
namespace detail{

template <class I>
struct is_random_imp
{
private:
   typedef typename std::iterator_traits<I>::iterator_category cat;
public:
   static const bool value = (::boost::is_convertible<cat*, std::random_access_iterator_tag*>::value);
};

template <class I>
struct is_random_pointer_imp
{
   static const bool value = true;
};

template <bool is_pointer_type>
struct is_random_imp_selector
{
   template <class I>
   struct rebind
   {
      typedef is_random_imp<I> type;
   };
};

template <>
struct is_random_imp_selector<true>
{
   template <class I>
   struct rebind
   {
      typedef is_random_pointer_imp<I> type;
   };
};

}

template <class I>
struct is_random_access_iterator
{
private:
   typedef detail::is_random_imp_selector< ::boost::is_pointer<I>::value> selector;
   typedef typename selector::template rebind<I> bound_type;
   typedef typename bound_type::type answer;
public:
   static const bool value = answer::value;
};


template <class I>
const bool is_random_access_iterator<I>::value;


}
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher.hpp" 2 3
# 33 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher.hpp" 3
namespace boost{
namespace re_detail{




 void verify_options(boost::regex_constants::syntax_option_type ef, match_flag_type mf);



template <class charT>
inline bool can_start(charT c, const unsigned char* map, unsigned char mask)
{
   return ((c < static_cast<charT>(0)) ? true : ((c >= static_cast<charT>(1 << 8)) ? true : map[c] & mask));
}
inline bool can_start(char c, const unsigned char* map, unsigned char mask)
{
   return map[(unsigned char)c] & mask;
}
inline bool can_start(signed char c, const unsigned char* map, unsigned char mask)
{
   return map[(unsigned char)c] & mask;
}
inline bool can_start(unsigned char c, const unsigned char* map, unsigned char mask)
{
   return map[c] & mask;
}
inline bool can_start(unsigned short c, const unsigned char* map, unsigned char mask)
{
   return ((c >= (1 << 8)) ? true : map[c] & mask);
}
# 84 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher.hpp" 3
template <class C, class T, class A>
inline int string_compare(const std::basic_string<C,T,A>& s, const C* p)
{
   if(0 == *p)
   {
      if(s.empty() || ((s.size() == 1) && (s[0] == 0)))
         return 0;
   }
   return s.compare(p);
}
# 115 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher.hpp" 3
template <class Seq, class C>
inline int string_compare(const Seq& s, const C* p)
{
   std::size_t i = 0;
   while((i < s.size()) && (p[i] == s[i]))
   {
      ++i;
   }
   return (i == s.size()) ? -p[i] : s[i] - p[i];
}


template<class charT>
inline const charT* re_skip_past_null(const charT* p)
{
  while (*p != static_cast<charT>(0)) ++p;
  return ++p;
}

template <class iterator, class charT, class traits_type, class char_classT>
iterator re_is_set_member(iterator next,
                          iterator last,
                          const re_set_long<char_classT>* set_,
                          const regex_data<charT, traits_type>& e, bool icase)
{
   const charT* p = reinterpret_cast<const charT*>(set_+1);
   iterator ptr;
   unsigned int i;


   if(next == last) return next;

   typedef typename traits_type::string_type traits_string_type;
   const ::boost::regex_traits_wrapper<traits_type>& traits_inst = *(e.m_ptraits);



   (void)traits_inst;



   for(i = 0; i < set_->csingles; ++i)
   {
      ptr = next;
      if(*p == static_cast<charT>(0))
      {

         if(traits_inst.translate(*ptr, icase) != *p)
         {
            while(*p == static_cast<charT>(0))++p;
            continue;
         }
         return set_->isnot ? next : (ptr == next) ? ++next : ptr;
      }
      else
      {
         while(*p && (ptr != last))
         {
            if(traits_inst.translate(*ptr, icase) != *p)
               break;
            ++p;
            ++ptr;
         }

         if(*p == static_cast<charT>(0))
            return set_->isnot ? next : (ptr == next) ? ++next : ptr;

         p = re_skip_past_null(p);
      }
   }

   charT col = traits_inst.translate(*next, icase);


   if(set_->cranges || set_->cequivalents)
   {
      traits_string_type s1;


      if(set_->cranges)
      {
         if((e.m_flags & regex_constants::collate) == 0)
            s1.assign(1, col);
         else
         {
            charT a[2] = { col, charT(0), };
            s1 = traits_inst.transform(a, a + 1);
         }
         for(i = 0; i < set_->cranges; ++i)
         {
            if(string_compare(s1,p) >= 0)
            {
               do{ ++p; }while(*p);
               ++p;
               if(string_compare(s1,p) <= 0)
                  return set_->isnot ? next : ++next;
            }
            else
            {

               do{ ++p; }while(*p);
               ++p;
            }

            do{ ++p; }while(*p);
            ++p;
         }
      }


      if(set_->cequivalents)
      {
         charT a[2] = { col, charT(0), };
         s1 = traits_inst.transform_primary(a, a +1);
         for(i = 0; i < set_->cequivalents; ++i)
         {
            if(string_compare(s1,p) == 0)
               return set_->isnot ? next : ++next;

            do{ ++p; }while(*p);
            ++p;
         }
      }
   }
   if(traits_inst.isctype(col, set_->cclasses) == true)
      return set_->isnot ? next : ++next;
   if((set_->cnclasses != 0) && (traits_inst.isctype(col, set_->cnclasses) == false))
      return set_->isnot ? next : ++next;
   return set_->isnot ? ++next : next;
}

template <class BidiIterator>
class repeater_count
{
   repeater_count** stack;
   repeater_count* next;
   int cocoa_friendly_id;
   std::size_t count;
   BidiIterator start_pos;
public:
   repeater_count(repeater_count** s)
   {
      stack = s;
      next = 0;
      cocoa_friendly_id = -1;
      count = 0;
   }
   repeater_count(int i, repeater_count** s, BidiIterator start)
      : start_pos(start)
   {
      cocoa_friendly_id = i;
      stack = s;
      next = *stack;
      *stack = this;
      if(cocoa_friendly_id > next->cocoa_friendly_id)
         count = 0;
      else
      {
         repeater_count* p = next;
         while(p->cocoa_friendly_id != cocoa_friendly_id)
            p = p->next;
         count = p->count;
         start_pos = p->start_pos;
      }
   }
   ~repeater_count()
   {
      *stack = next;
   }
   std::size_t get_count() { return count; }
   int get_id() { return cocoa_friendly_id; }
   std::size_t operator++() { return ++count; }
   bool check_null_repeat(const BidiIterator& pos, std::size_t max)
   {



      bool result = (count == 0) ? false : (pos == start_pos);
      if(result)
         count = max;
      else
         start_pos = pos;
      return result;
   }
};

struct saved_state;

enum saved_state_type
{
   saved_type_end = 0,
   saved_type_paren = 1,
   saved_type_recurse = 2,
   saved_type_assertion = 3,
   saved_state_alt = 4,
   saved_state_repeater_count = 5,
   saved_state_extra_block = 6,
   saved_state_greedy_single_repeat = 7,
   saved_state_rep_slow_dot = 8,
   saved_state_rep_fast_dot = 9,
   saved_state_rep_char = 10,
   saved_state_rep_short_set = 11,
   saved_state_rep_long_set = 12,
   saved_state_non_greedy_long_repeat = 13,
   saved_state_count = 14
};






template <class BidiIterator, class Allocator, class traits>
class perl_matcher
{
public:
   typedef typename traits::char_type char_type;
   typedef perl_matcher<BidiIterator, Allocator, traits> self_type;
   typedef bool (self_type::*matcher_proc_type)(void);
   typedef typename traits::size_type traits_size_type;
   typedef typename is_byte<char_type>::width_type width_type;
   typedef typename regex_iterator_traits<BidiIterator>::difference_type difference_type;

   perl_matcher(BidiIterator first, BidiIterator end,
      match_results<BidiIterator, Allocator>& what,
      const basic_regex<char_type, traits>& e,
      match_flag_type f,
      BidiIterator l_base)
      : m_result(what), base(first), last(end),
         position(first), backstop(l_base), re(e), traits_inst(e.get_traits()),
         m_independent(false), next_count(&rep_obj), rep_obj(&next_count)
   {
      construct_init(e, f);
   }

   bool match();
   bool find();

   void setf(match_flag_type f)
   { m_match_flags |= f; }
   void unsetf(match_flag_type f)
   { m_match_flags &= ~f; }

private:
   void construct_init(const basic_regex<char_type, traits>& e, match_flag_type f);

   bool find_imp();
   bool match_imp();




   void estimate_max_state_count(std::random_access_iterator_tag*);
   void estimate_max_state_count(void*);
   bool match_prefix();
   bool match_all_states();


   bool match_startmark();
   bool match_endmark();
   bool match_literal();
   bool match_start_line();
   bool match_end_line();
   bool match_wild();
   bool match_match();
   bool match_word_boundary();
   bool match_within_word();
   bool match_word_start();
   bool match_word_end();
   bool match_buffer_start();
   bool match_buffer_end();
   bool match_backref();
   bool match_long_set();
   bool match_set();
   bool match_jump();
   bool match_alt();
   bool match_rep();
   bool match_combining();
   bool match_soft_buffer_end();
   bool match_restart_continue();
   bool match_long_set_repeat();
   bool match_set_repeat();
   bool match_char_repeat();
   bool match_dot_repeat_fast();
   bool match_dot_repeat_slow();
   bool match_backstep();
   bool match_assert_backref();
   bool match_toggle_case();





   bool find_restart_any();
   bool find_restart_word();
   bool find_restart_line();
   bool find_restart_buf();
   bool find_restart_lit();

private:

   match_results<BidiIterator, Allocator>& m_result;

   scoped_ptr<match_results<BidiIterator, Allocator> > m_temp_match;

   match_results<BidiIterator, Allocator>* m_presult;

   BidiIterator base;

   BidiIterator last;

   BidiIterator position;

   BidiIterator restart;

   BidiIterator search_base;

   BidiIterator backstop;

   const basic_regex<char_type, traits>& re;

   const ::boost::regex_traits_wrapper<traits>& traits_inst;

   const re_syntax_base* pstate;

   match_flag_type m_match_flags;

   boost::uintmax_t state_count;

   boost::uintmax_t max_state_count;

   bool icase;

   bool m_has_partial_match;

   bool m_has_found_match;

   bool m_independent;

   repeater_count<BidiIterator>* next_count;

   repeater_count<BidiIterator> rep_obj;

   typename traits::char_class_type m_word_mask;

   unsigned char match_any_mask;





   typedef bool (self_type::*unwind_proc_type)(bool);

   void extend_stack();
   bool unwind(bool);
   bool unwind_end(bool);
   bool unwind_paren(bool);
   bool unwind_recursion_stopper(bool);
   bool unwind_assertion(bool);
   bool unwind_alt(bool);
   bool unwind_repeater_counter(bool);
   bool unwind_extra_block(bool);
   bool unwind_greedy_single_repeat(bool);
   bool unwind_slow_dot_repeat(bool);
   bool unwind_fast_dot_repeat(bool);
   bool unwind_char_repeat(bool);
   bool unwind_short_set_repeat(bool);
   bool unwind_long_set_repeat(bool);
   bool unwind_non_greedy_repeat(bool);
   void destroy_single_repeat();
   void push_matched_paren(int index, const sub_match<BidiIterator>& sub);
   void push_recursion_stopper();
   void push_assertion(const re_syntax_base* ps, bool positive);
   void push_alt(const re_syntax_base* ps);
   void push_repeater_count(int i, repeater_count<BidiIterator>** s);
   void push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int id);
   void push_non_greedy_repeat(const re_syntax_base* ps);



   saved_state* m_stack_base;

   saved_state* m_backup_state;


   bool m_recursive_result;

   unsigned used_block_count;




   perl_matcher& operator=(const perl_matcher&)
   {
      return *this;
   }
   perl_matcher(const perl_matcher& that)
      : m_result(that.m_result), re(that.re), traits_inst(that.traits_inst), rep_obj(0) {}
};





}
# 532 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher.hpp" 3
}
# 544 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp" 1 3
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp" 3
namespace boost{
namespace re_detail{

template <class T>
inline void inplace_destroy(T* p)
{
   (void)p;
   p->~T();
}

struct saved_state
{
   union{
      unsigned int id;

      std::size_t padding1;
      std::ptrdiff_t padding2;
      void* padding3;
   };
   saved_state(unsigned i) : id(i) {}
};

template <class BidiIterator>
struct saved_matched_paren : public saved_state
{
   int index;
   sub_match<BidiIterator> sub;
   saved_matched_paren(int i, const sub_match<BidiIterator>& s) : saved_state(1), index(i), sub(s){};
};

template <class BidiIterator>
struct saved_position : public saved_state
{
   const re_syntax_base* pstate;
   BidiIterator position;
   saved_position(const re_syntax_base* ps, BidiIterator pos, int i) : saved_state(i), pstate(ps), position(pos){};
};

template <class BidiIterator>
struct saved_assertion : public saved_position<BidiIterator>
{
   bool positive;
   saved_assertion(bool p, const re_syntax_base* ps, BidiIterator pos)
      : saved_position<BidiIterator>(ps, pos, saved_type_assertion), positive(p){};
};

template <class BidiIterator>
struct saved_repeater : public saved_state
{
   repeater_count<BidiIterator> count;
   saved_repeater(int i, repeater_count<BidiIterator>** s, BidiIterator start)
      : saved_state(saved_state_repeater_count), count(i,s,start){}
};

struct saved_extra_block : public saved_state
{
   saved_state *base, *end;
   saved_extra_block(saved_state* b, saved_state* e)
      : saved_state(saved_state_extra_block), base(b), end(e) {}
};

struct save_state_init
{
   saved_state** stack;
   save_state_init(saved_state** base, saved_state** end)
      : stack(base)
   {
      *base = static_cast<saved_state*>(get_mem_block());
      *end = reinterpret_cast<saved_state*>(reinterpret_cast<char*>(*base)+4096);
      --(*end);
      (void) new (*end)saved_state(0);
      (__builtin_expect(!(*end > *base), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 111, "*end > *base") : (void)0);
   }
   ~save_state_init()
   {
      put_mem_block(*stack);
      *stack = 0;
   }
};

template <class BidiIterator>
struct saved_single_repeat : public saved_state
{
   std::size_t count;
   const re_repeat* rep;
   BidiIterator last_position;
   saved_single_repeat(std::size_t c, const re_repeat* r, BidiIterator lp, int arg_id)
      : saved_state(arg_id), count(c), rep(r), last_position(lp){}
};

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_all_states()
{
   static matcher_proc_type const s_match_vtable[29] =
   {
      (&perl_matcher<BidiIterator, Allocator, traits>::match_startmark),
      &perl_matcher<BidiIterator, Allocator, traits>::match_endmark,
      &perl_matcher<BidiIterator, Allocator, traits>::match_literal,
      &perl_matcher<BidiIterator, Allocator, traits>::match_start_line,
      &perl_matcher<BidiIterator, Allocator, traits>::match_end_line,
      &perl_matcher<BidiIterator, Allocator, traits>::match_wild,
      &perl_matcher<BidiIterator, Allocator, traits>::match_match,
      &perl_matcher<BidiIterator, Allocator, traits>::match_word_boundary,
      &perl_matcher<BidiIterator, Allocator, traits>::match_within_word,
      &perl_matcher<BidiIterator, Allocator, traits>::match_word_start,
      &perl_matcher<BidiIterator, Allocator, traits>::match_word_end,
      &perl_matcher<BidiIterator, Allocator, traits>::match_buffer_start,
      &perl_matcher<BidiIterator, Allocator, traits>::match_buffer_end,
      &perl_matcher<BidiIterator, Allocator, traits>::match_backref,
      &perl_matcher<BidiIterator, Allocator, traits>::match_long_set,
      &perl_matcher<BidiIterator, Allocator, traits>::match_set,
      &perl_matcher<BidiIterator, Allocator, traits>::match_jump,
      &perl_matcher<BidiIterator, Allocator, traits>::match_alt,
      &perl_matcher<BidiIterator, Allocator, traits>::match_rep,
      &perl_matcher<BidiIterator, Allocator, traits>::match_combining,
      &perl_matcher<BidiIterator, Allocator, traits>::match_soft_buffer_end,
      &perl_matcher<BidiIterator, Allocator, traits>::match_restart_continue,
      (::boost::is_random_access_iterator<BidiIterator>::value ? &perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_fast : &perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_slow),
      &perl_matcher<BidiIterator, Allocator, traits>::match_char_repeat,
      &perl_matcher<BidiIterator, Allocator, traits>::match_set_repeat,
      &perl_matcher<BidiIterator, Allocator, traits>::match_long_set_repeat,
      &perl_matcher<BidiIterator, Allocator, traits>::match_backstep,
      &perl_matcher<BidiIterator, Allocator, traits>::match_assert_backref,
      &perl_matcher<BidiIterator, Allocator, traits>::match_toggle_case,
   };

   push_recursion_stopper();
   do{
      while(pstate)
      {
         matcher_proc_type proc = s_match_vtable[pstate->type];
         ++state_count;
         if(!(this->*proc)())
         {
            if(state_count > max_state_count)
               raise_error(traits_inst, regex_constants::error_space);
            if((m_match_flags & match_partial) && (position == last) && (position != search_base))
               m_has_partial_match = true;
            bool successful_unwind = unwind(false);
            if((m_match_flags & match_partial) && (position == last) && (position != search_base))
               m_has_partial_match = true;
            if(false == successful_unwind)
               return m_recursive_result;
         }
      }
   }while(unwind(true));
   return m_recursive_result;
}

template <class BidiIterator, class Allocator, class traits>
void perl_matcher<BidiIterator, Allocator, traits>::extend_stack()
{
   if(used_block_count)
   {
      --used_block_count;
      saved_state* stack_base;
      saved_state* backup_state;
      stack_base = static_cast<saved_state*>(get_mem_block());
      backup_state = reinterpret_cast<saved_state*>(reinterpret_cast<char*>(stack_base)+4096);
      saved_extra_block* block = static_cast<saved_extra_block*>(backup_state);
      --block;
      (void) new (block) saved_extra_block(m_stack_base, m_backup_state);
      m_stack_base = stack_base;
      m_backup_state = block;
   }
   else
      raise_error(traits_inst, regex_constants::error_size);
}

template <class BidiIterator, class Allocator, class traits>
inline void perl_matcher<BidiIterator, Allocator, traits>::push_matched_paren(int index, const sub_match<BidiIterator>& sub)
{
   (__builtin_expect(!(index), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 212, "index") : (void)0);
   saved_matched_paren<BidiIterator>* pmp = static_cast<saved_matched_paren<BidiIterator>*>(m_backup_state);
   --pmp;
   if(pmp < m_stack_base)
   {
      extend_stack();
      pmp = static_cast<saved_matched_paren<BidiIterator>*>(m_backup_state);
      --pmp;
   }
   (void) new (pmp)saved_matched_paren<BidiIterator>(index, sub);
   m_backup_state = pmp;
}

template <class BidiIterator, class Allocator, class traits>
inline void perl_matcher<BidiIterator, Allocator, traits>::push_recursion_stopper()
{
   saved_state* pmp = m_backup_state;
   --pmp;
   if(pmp < m_stack_base)
   {
      extend_stack();
      pmp = m_backup_state;
      --pmp;
   }
   (void) new (pmp)saved_state(saved_type_recurse);
   m_backup_state = pmp;
}

template <class BidiIterator, class Allocator, class traits>
inline void perl_matcher<BidiIterator, Allocator, traits>::push_assertion(const re_syntax_base* ps, bool positive)
{
   saved_assertion<BidiIterator>* pmp = static_cast<saved_assertion<BidiIterator>*>(m_backup_state);
   --pmp;
   if(pmp < m_stack_base)
   {
      extend_stack();
      pmp = static_cast<saved_assertion<BidiIterator>*>(m_backup_state);
      --pmp;
   }
   (void) new (pmp)saved_assertion<BidiIterator>(positive, ps, position);
   m_backup_state = pmp;
}

template <class BidiIterator, class Allocator, class traits>
inline void perl_matcher<BidiIterator, Allocator, traits>::push_alt(const re_syntax_base* ps)
{
   saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
   --pmp;
   if(pmp < m_stack_base)
   {
      extend_stack();
      pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
      --pmp;
   }
   (void) new (pmp)saved_position<BidiIterator>(ps, position, saved_state_alt);
   m_backup_state = pmp;
}

template <class BidiIterator, class Allocator, class traits>
inline void perl_matcher<BidiIterator, Allocator, traits>::push_non_greedy_repeat(const re_syntax_base* ps)
{
   saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
   --pmp;
   if(pmp < m_stack_base)
   {
      extend_stack();
      pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
      --pmp;
   }
   (void) new (pmp)saved_position<BidiIterator>(ps, position, saved_state_non_greedy_long_repeat);
   m_backup_state = pmp;
}

template <class BidiIterator, class Allocator, class traits>
inline void perl_matcher<BidiIterator, Allocator, traits>::push_repeater_count(int i, repeater_count<BidiIterator>** s)
{
   saved_repeater<BidiIterator>* pmp = static_cast<saved_repeater<BidiIterator>*>(m_backup_state);
   --pmp;
   if(pmp < m_stack_base)
   {
      extend_stack();
      pmp = static_cast<saved_repeater<BidiIterator>*>(m_backup_state);
      --pmp;
   }
   (void) new (pmp)saved_repeater<BidiIterator>(i, s, position);
   m_backup_state = pmp;
}

template <class BidiIterator, class Allocator, class traits>
inline void perl_matcher<BidiIterator, Allocator, traits>::push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int id)
{
   saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
   --pmp;
   if(pmp < m_stack_base)
   {
      extend_stack();
      pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
      --pmp;
   }
   (void) new (pmp)saved_single_repeat<BidiIterator>(c, r, last_position, id);
   m_backup_state = pmp;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_startmark()
{
   int index = static_cast<const re_brace*>(pstate)->index;
   switch(index)
   {
   case 0:
      pstate = pstate->next.p;
      break;
   case -1:
   case -2:
      {

         const re_syntax_base* next_pstate = static_cast<const re_jump*>(pstate->next.p)->alt.p->next.p;
         pstate = pstate->next.p->next.p;
         push_assertion(next_pstate, index == -1);
         break;
      }
   case -3:
      {

         bool old_independent = m_independent;
         m_independent = true;
         const re_syntax_base* next_pstate = static_cast<const re_jump*>(pstate->next.p)->alt.p->next.p;
         pstate = pstate->next.p->next.p;
         bool r = match_all_states();
         pstate = next_pstate;
         m_independent = old_independent;
# 370 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp" 3
         return r;
      }
   case -4:
      {

      const re_alt* alt = static_cast<const re_alt*>(pstate->next.p);
      (__builtin_expect(!(alt->type == syntax_element_alt), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 376, "alt->type == syntax_element_alt") : (void)0);
      pstate = alt->next.p;
      if(pstate->type == syntax_element_assert_backref)
      {
         if(!match_assert_backref())
            pstate = alt->alt.p;
         break;
      }
      else
      {

         (__builtin_expect(!(pstate->type == syntax_element_startmark), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 387, "pstate->type == syntax_element_startmark") : (void)0);
         bool negated = static_cast<const re_brace*>(pstate)->index == -2;
         BidiIterator saved_position = position;
         const re_syntax_base* next_pstate = static_cast<const re_jump*>(pstate->next.p)->alt.p->next.p;
         pstate = pstate->next.p->next.p;
         bool r = match_all_states();
         position = saved_position;
         if(negated)
            r = !r;
         if(r)
            pstate = next_pstate;
         else
            pstate = alt->alt.p;
         break;
      }
      }
   default:
   {
      (__builtin_expect(!(index > 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 405, "index > 0") : (void)0);
      if((m_match_flags & match_nosubs) == 0)
      {
         push_matched_paren(index, (*m_presult)[index]);
         m_presult->set_first(position, index);
      }
      pstate = pstate->next.p;
      break;
   }
   }
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_alt()
{
   bool take_first, take_second;
   const re_alt* jmp = static_cast<const re_alt*>(pstate);


   if(position == last)
   {
      take_first = jmp->can_be_null & mask_take;
      take_second = jmp->can_be_null & mask_skip;
   }
   else
   {
      take_first = can_start(*position, jmp->_map, (unsigned char)mask_take);
      take_second = can_start(*position, jmp->_map, (unsigned char)mask_skip);
  }

   if(take_first)
   {


      if(take_second)
      {
         push_alt(jmp->alt.p);
      }
      pstate = pstate->next.p;
      return true;
   }
   if(take_second)
   {
      pstate = jmp->alt.p;
      return true;
   }
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_rep()
{







   const re_repeat* rep = static_cast<const re_repeat*>(pstate);


   bool take_first, take_second;
   if(position == last)
   {
      take_first = rep->can_be_null & mask_take;
      take_second = rep->can_be_null & mask_skip;
   }
   else
   {
      take_first = can_start(*position, rep->_map, (unsigned char)mask_take);
      take_second = can_start(*position, rep->_map, (unsigned char)mask_skip);
   }

   if(take_first || (next_count->get_id() != rep->id))
   {


      push_repeater_count(rep->id, &next_count);
   }





   next_count->check_null_repeat(position, rep->max);

   if(next_count->get_count() < rep->min)
   {

      if(take_first)
      {

         ++(*next_count);
         pstate = rep->next.p;
         return true;
      }
      return false;
   }

   bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);
   if(greedy)
   {

      if((next_count->get_count() < rep->max) && take_first)
      {
         if(take_second)
         {

            push_alt(rep->alt.p);
         }

         ++(*next_count);
         pstate = rep->next.p;
         return true;
      }
      else if(take_second)
      {
         pstate = rep->alt.p;
         return true;
      }
      return false;
   }
   else
   {

      if(take_second)
      {
         if((next_count->get_count() < rep->max) && take_first)
         {

            push_non_greedy_repeat(rep->next.p);
         }
         pstate = rep->alt.p;
         return true;
      }
      if((next_count->get_count() < rep->max) && take_first)
      {

         ++(*next_count);
         pstate = rep->next.p;
         return true;
      }
   }
   return false;






}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_slow()
{
   unsigned count = 0;
   const re_repeat* rep = static_cast<const re_repeat*>(pstate);
   re_syntax_base* psingle = rep->next.p;

   while(count < rep->min)
   {
      pstate = psingle;
      if(!match_wild())
         return false;
      ++count;
   }
   bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);
   if(greedy)
   {

      while(count < rep->max)
      {
         pstate = psingle;
         if(!match_wild())
            break;
         ++count;
      }

      if((rep->leading) && (count < rep->max))
         restart = position;

      if(count - rep->min)
         push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);

      pstate = rep->alt.p;
      return true;
   }
   else
   {

      if(count < rep->max)
         push_single_repeat(count, rep, position, saved_state_rep_slow_dot);
      pstate = rep->alt.p;
      return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
   }
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_fast()
{
   if(m_match_flags & match_not_dot_null)
      return match_dot_repeat_slow();
   if((static_cast<const re_dot*>(pstate->next.p)->mask & match_any_mask) == 0)
      return match_dot_repeat_slow();

   const re_repeat* rep = static_cast<const re_repeat*>(pstate);
   bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);
   unsigned count = static_cast<unsigned>((std::min)(static_cast<unsigned>(::boost::re_detail::distance(position, last)), static_cast<unsigned>(greedy ? rep->max : rep->min)));
   if(rep->min > count)
   {
      position = last;
      return false;
   }
   std::advance(position, count);

   if(greedy)
   {
      if((rep->leading) && (count < rep->max))
         restart = position;

      if(count - rep->min)
         push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);

      pstate = rep->alt.p;
      return true;
   }
   else
   {

      if(count < rep->max)
         push_single_repeat(count, rep, position, saved_state_rep_fast_dot);
      pstate = rep->alt.p;
      return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
   }
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_char_repeat()
{







   const re_repeat* rep = static_cast<const re_repeat*>(pstate);
   (__builtin_expect(!(1 == static_cast<const re_literal*>(rep->next.p)->length), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 654, "1 == static_cast<const re_literal*>(rep->next.p)->length") : (void)0);
   const char_type what = *reinterpret_cast<const char_type*>(static_cast<const re_literal*>(rep->next.p) + 1);
   std::size_t count = 0;



   bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);
   std::size_t desired = greedy ? rep->max : rep->min;
   if(::boost::is_random_access_iterator<BidiIterator>::value)
   {
      BidiIterator end = position;
      std::advance(end, (std::min)((std::size_t)::boost::re_detail::distance(position, last), desired));
      BidiIterator origin(position);
      while((position != end) && (traits_inst.translate(*position, icase) == what))
      {
         ++position;
      }
      count = (unsigned)::boost::re_detail::distance(origin, position);
   }
   else
   {
      while((count < desired) && (position != last) && (traits_inst.translate(*position, icase) == what))
      {
         ++position;
         ++count;
      }
   }

   if(count < rep->min)
      return false;

   if(greedy)
   {
      if((rep->leading) && (count < rep->max))
         restart = position;

      if(count - rep->min)
         push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);

      pstate = rep->alt.p;
      return true;
   }
   else
   {

      if(count < rep->max)
         push_single_repeat(count, rep, position, saved_state_rep_char);
      pstate = rep->alt.p;
      return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
   }






}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_set_repeat()
{







   const re_repeat* rep = static_cast<const re_repeat*>(pstate);
   const unsigned char* map = static_cast<const re_set*>(rep->next.p)->_map;
   std::size_t count = 0;



   bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);
   std::size_t desired = greedy ? rep->max : rep->min;
   if(::boost::is_random_access_iterator<BidiIterator>::value)
   {
      BidiIterator end = position;
      std::advance(end, (std::min)((std::size_t)::boost::re_detail::distance(position, last), desired));
      BidiIterator origin(position);
      while((position != end) && map[static_cast<unsigned char>(traits_inst.translate(*position, icase))])
      {
         ++position;
      }
      count = (unsigned)::boost::re_detail::distance(origin, position);
   }
   else
   {
      while((count < desired) && (position != last) && map[static_cast<unsigned char>(traits_inst.translate(*position, icase))])
      {
         ++position;
         ++count;
      }
   }

   if(count < rep->min)
      return false;

   if(greedy)
   {
      if((rep->leading) && (count < rep->max))
         restart = position;

      if(count - rep->min)
         push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);

      pstate = rep->alt.p;
      return true;
   }
   else
   {

      if(count < rep->max)
         push_single_repeat(count, rep, position, saved_state_rep_short_set);
      pstate = rep->alt.p;
      return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
   }






}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_long_set_repeat()
{







   typedef typename traits::char_class_type mask_type;
   const re_repeat* rep = static_cast<const re_repeat*>(pstate);
   const re_set_long<mask_type>* set = static_cast<const re_set_long<mask_type>*>(pstate->next.p);
   std::size_t count = 0;



   bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);
   std::size_t desired = greedy ? rep->max : rep->min;
   if(::boost::is_random_access_iterator<BidiIterator>::value)
   {
      BidiIterator end = position;
      std::advance(end, (std::min)((std::size_t)::boost::re_detail::distance(position, last), desired));
      BidiIterator origin(position);
      while((position != end) && (position != re_is_set_member(position, last, set, re.get_data(), icase)))
      {
         ++position;
      }
      count = (unsigned)::boost::re_detail::distance(origin, position);
   }
   else
   {
      while((count < desired) && (position != last) && (position != re_is_set_member(position, last, set, re.get_data(), icase)))
      {
         ++position;
         ++count;
      }
   }

   if(count < rep->min)
      return false;

   if(greedy)
   {
      if((rep->leading) && (count < rep->max))
         restart = position;

      if(count - rep->min)
         push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);

      pstate = rep->alt.p;
      return true;
   }
   else
   {

      if(count < rep->max)
         push_single_repeat(count, rep, position, saved_state_rep_long_set);
      pstate = rep->alt.p;
      return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
   }






}
# 856 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp" 3
template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind(bool have_match)
{
   static unwind_proc_type const s_unwind_table[14] =
   {
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_end,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_paren,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_stopper,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_assertion,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_alt,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_repeater_counter,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_extra_block,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_greedy_single_repeat,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_slow_dot_repeat,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_fast_dot_repeat,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_char_repeat,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_short_set_repeat,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_long_set_repeat,
      &perl_matcher<BidiIterator, Allocator, traits>::unwind_non_greedy_repeat,
   };

   m_recursive_result = have_match;
   unwind_proc_type unwinder;
   bool cont;



   do
   {
      unwinder = s_unwind_table[m_backup_state->id];
      cont = (this->*unwinder)(m_recursive_result);
   }while(cont);



   return pstate ? true : false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_end(bool)
{
   pstate = 0;
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_paren(bool have_match)
{
   saved_matched_paren<BidiIterator>* pmp = static_cast<saved_matched_paren<BidiIterator>*>(m_backup_state);

   if(have_match == false)
   {
      m_presult->set_first(pmp->sub.first, pmp->index);
      m_presult->set_second(pmp->sub.second, pmp->index, pmp->sub.matched);
   }
# 919 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp" 3
   m_backup_state = pmp+1;
   boost::re_detail::inplace_destroy(pmp);
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_stopper(bool)
{
   boost::re_detail::inplace_destroy(m_backup_state++);
   pstate = 0;
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_assertion(bool r)
{
   saved_assertion<BidiIterator>* pmp = static_cast<saved_assertion<BidiIterator>*>(m_backup_state);
   pstate = pmp->pstate;
   position = pmp->position;
   bool result = (r == pmp->positive);
   m_recursive_result = pmp->positive ? r : !r;
   boost::re_detail::inplace_destroy(pmp++);
   m_backup_state = pmp;
   return !result;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_alt(bool r)
{
   saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
   if(!r)
   {
      pstate = pmp->pstate;
      position = pmp->position;
   }
   boost::re_detail::inplace_destroy(pmp++);
   m_backup_state = pmp;
   return r;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_repeater_counter(bool)
{
   saved_repeater<BidiIterator>* pmp = static_cast<saved_repeater<BidiIterator>*>(m_backup_state);
   boost::re_detail::inplace_destroy(pmp++);
   m_backup_state = pmp;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_extra_block(bool)
{
   saved_extra_block* pmp = static_cast<saved_extra_block*>(m_backup_state);
   void* condemmed = m_stack_base;
   m_stack_base = pmp->base;
   m_backup_state = pmp->end;
   boost::re_detail::inplace_destroy(pmp);
   put_mem_block(condemmed);
   return true;
}

template <class BidiIterator, class Allocator, class traits>
inline void perl_matcher<BidiIterator, Allocator, traits>::destroy_single_repeat()
{
   saved_single_repeat<BidiIterator>* p = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
   boost::re_detail::inplace_destroy(p++);
   m_backup_state = p;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_greedy_single_repeat(bool r)
{
   saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);


   if(r)
   {
      destroy_single_repeat();
      return true;
   }

   const re_repeat* rep = pmp->rep;
   std::size_t count = pmp->count;
   (__builtin_expect(!(rep->next.p != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1002, "rep->next.p != 0") : (void)0);
   (__builtin_expect(!(rep->alt.p != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1003, "rep->alt.p != 0") : (void)0);

   count -= rep->min;

   if((m_match_flags & match_partial) && (position == last))
      m_has_partial_match = true;

   (__builtin_expect(!(count), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1010, "count") : (void)0);
   position = pmp->last_position;


   do
   {
      --position;
      --count;
      ++state_count;
   }while(count && !can_start(*position, rep->_map, mask_skip));


   if(count == 0)
   {
         destroy_single_repeat();
         if(!can_start(*position, rep->_map, mask_skip))
            return true;
   }
   else
   {
      pmp->count = count + rep->min;
      pmp->last_position = position;
   }
   pstate = rep->alt.p;
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_slow_dot_repeat(bool r)
{
   saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);


   if(r)
   {
      destroy_single_repeat();
      return true;
   }

   const re_repeat* rep = pmp->rep;
   std::size_t count = pmp->count;
   (__builtin_expect(!(rep->type == syntax_element_dot_rep), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1051, "rep->type == syntax_element_dot_rep") : (void)0);
   (__builtin_expect(!(rep->next.p != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1052, "rep->next.p != 0") : (void)0);
   (__builtin_expect(!(rep->alt.p != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1053, "rep->alt.p != 0") : (void)0);
   (__builtin_expect(!(rep->next.p->type == syntax_element_wild), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1054, "rep->next.p->type == syntax_element_wild") : (void)0);

   (__builtin_expect(!(count < rep->max), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1056, "count < rep->max") : (void)0);
   pstate = rep->next.p;
   position = pmp->last_position;

   if(position != last)
   {

      do
      {
         if(!match_wild())
         {

            destroy_single_repeat();
            return true;
         }
         ++count;
         ++state_count;
         pstate = rep->next.p;
      }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
   }
   if(position == last)
   {

      destroy_single_repeat();
      if((m_match_flags & match_partial) && (position == last) && (position != search_base))
         m_has_partial_match = true;
      if(0 == (rep->can_be_null & mask_skip))
         return true;
   }
   else if(count == rep->max)
   {

      destroy_single_repeat();
      if(!can_start(*position, rep->_map, mask_skip))
         return true;
   }
   else
   {
      pmp->count = count;
      pmp->last_position = position;
   }
   pstate = rep->alt.p;
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_fast_dot_repeat(bool r)
{
   saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);


   if(r)
   {
      destroy_single_repeat();
      return true;
   }

   const re_repeat* rep = pmp->rep;
   std::size_t count = pmp->count;

   (__builtin_expect(!(count < rep->max), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1116, "count < rep->max") : (void)0);
   position = pmp->last_position;
   if(position != last)
   {


      do
      {
         ++position;
         ++count;
         ++state_count;
      }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
   }

   if(position == last)
   {

      destroy_single_repeat();
      if((m_match_flags & match_partial) && (position == last) && (position != search_base))
         m_has_partial_match = true;
      if(0 == (rep->can_be_null & mask_skip))
         return true;
   }
   else if(count == rep->max)
   {

      destroy_single_repeat();
      if(!can_start(*position, rep->_map, mask_skip))
         return true;
   }
   else
   {
      pmp->count = count;
      pmp->last_position = position;
   }
   pstate = rep->alt.p;
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_char_repeat(bool r)
{
   saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);


   if(r)
   {
      destroy_single_repeat();
      return true;
   }

   const re_repeat* rep = pmp->rep;
   std::size_t count = pmp->count;
   pstate = rep->next.p;
   const char_type what = *reinterpret_cast<const char_type*>(static_cast<const re_literal*>(pstate) + 1);
   position = pmp->last_position;

   (__builtin_expect(!(rep->type == syntax_element_char_rep), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1173, "rep->type == syntax_element_char_rep") : (void)0);
   (__builtin_expect(!(rep->next.p != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1174, "rep->next.p != 0") : (void)0);
   (__builtin_expect(!(rep->alt.p != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1175, "rep->alt.p != 0") : (void)0);
   (__builtin_expect(!(rep->next.p->type == syntax_element_literal), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1176, "rep->next.p->type == syntax_element_literal") : (void)0);
   (__builtin_expect(!(count < rep->max), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1177, "count < rep->max") : (void)0);

   if(position != last)
   {

      do
      {
         if(traits_inst.translate(*position, icase) != what)
         {

            destroy_single_repeat();
            return true;
         }
         ++count;
         ++ position;
         ++state_count;
         pstate = rep->next.p;
      }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
   }

   if((rep->leading) && (count < rep->max))
      restart = position;
   if(position == last)
   {

      destroy_single_repeat();
      if((m_match_flags & match_partial) && (position == last) && (position != search_base))
         m_has_partial_match = true;
      if(0 == (rep->can_be_null & mask_skip))
         return true;
   }
   else if(count == rep->max)
   {

      destroy_single_repeat();
      if(!can_start(*position, rep->_map, mask_skip))
         return true;
   }
   else
   {
      pmp->count = count;
      pmp->last_position = position;
   }
   pstate = rep->alt.p;
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_short_set_repeat(bool r)
{
   saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);


   if(r)
   {
      destroy_single_repeat();
      return true;
   }

   const re_repeat* rep = pmp->rep;
   std::size_t count = pmp->count;
   pstate = rep->next.p;
   const unsigned char* map = static_cast<const re_set*>(rep->next.p)->_map;
   position = pmp->last_position;

   (__builtin_expect(!(rep->type == syntax_element_short_set_rep), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1242, "rep->type == syntax_element_short_set_rep") : (void)0);
   (__builtin_expect(!(rep->next.p != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1243, "rep->next.p != 0") : (void)0);
   (__builtin_expect(!(rep->alt.p != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1244, "rep->alt.p != 0") : (void)0);
   (__builtin_expect(!(rep->next.p->type == syntax_element_set), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1245, "rep->next.p->type == syntax_element_set") : (void)0);
   (__builtin_expect(!(count < rep->max), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1246, "count < rep->max") : (void)0);

   if(position != last)
   {

      do
      {
         if(!map[static_cast<unsigned char>(traits_inst.translate(*position, icase))])
         {

            destroy_single_repeat();
            return true;
         }
         ++count;
         ++ position;
         ++state_count;
         pstate = rep->next.p;
      }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
   }

   if((rep->leading) && (count < rep->max))
      restart = position;
   if(position == last)
   {

      destroy_single_repeat();
      if((m_match_flags & match_partial) && (position == last) && (position != search_base))
         m_has_partial_match = true;
      if(0 == (rep->can_be_null & mask_skip))
         return true;
   }
   else if(count == rep->max)
   {

      destroy_single_repeat();
      if(!can_start(*position, rep->_map, mask_skip))
         return true;
   }
   else
   {
      pmp->count = count;
      pmp->last_position = position;
   }
   pstate = rep->alt.p;
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_long_set_repeat(bool r)
{
   typedef typename traits::char_class_type mask_type;
   saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);


   if(r)
   {
      destroy_single_repeat();
      return true;
   }

   const re_repeat* rep = pmp->rep;
   std::size_t count = pmp->count;
   pstate = rep->next.p;
   const re_set_long<mask_type>* set = static_cast<const re_set_long<mask_type>*>(pstate);
   position = pmp->last_position;

   (__builtin_expect(!(rep->type == syntax_element_long_set_rep), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1312, "rep->type == syntax_element_long_set_rep") : (void)0);
   (__builtin_expect(!(rep->next.p != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1313, "rep->next.p != 0") : (void)0);
   (__builtin_expect(!(rep->alt.p != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1314, "rep->alt.p != 0") : (void)0);
   (__builtin_expect(!(rep->next.p->type == syntax_element_long_set), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1315, "rep->next.p->type == syntax_element_long_set") : (void)0);
   (__builtin_expect(!(count < rep->max), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_non_recursive.hpp", 1316, "count < rep->max") : (void)0);

   if(position != last)
   {

      do
      {
         if(position == re_is_set_member(position, last, set, re.get_data(), icase))
         {

            destroy_single_repeat();
            return true;
         }
         ++position;
         ++count;
         ++state_count;
         pstate = rep->next.p;
      }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
   }

   if((rep->leading) && (count < rep->max))
      restart = position;
   if(position == last)
   {

      destroy_single_repeat();
      if((m_match_flags & match_partial) && (position == last) && (position != search_base))
         m_has_partial_match = true;
      if(0 == (rep->can_be_null & mask_skip))
         return true;
   }
   else if(count == rep->max)
   {

      destroy_single_repeat();
      if(!can_start(*position, rep->_map, mask_skip))
         return true;
   }
   else
   {
      pmp->count = count;
      pmp->last_position = position;
   }
   pstate = rep->alt.p;
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::unwind_non_greedy_repeat(bool r)
{
   saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
   if(!r)
   {
      position = pmp->position;
      pstate = pmp->pstate;
      ++(*next_count);
   }
   boost::re_detail::inplace_destroy(pmp++);
   m_backup_state = pmp;
   return r;
}

}
}
# 545 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_common.hpp" 1 3
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_common.hpp" 3
namespace boost{
namespace re_detail{

template <class BidiIterator, class Allocator, class traits>
void perl_matcher<BidiIterator, Allocator, traits>::construct_init(const basic_regex<char_type, traits>& e, match_flag_type f)
{
   typedef typename regex_iterator_traits<BidiIterator>::iterator_category category;
   typedef typename basic_regex<char_type, traits>::flag_type expression_flag_type;

   if(e.empty())
   {

      std::invalid_argument ex("Invalid regular expression object");
      boost::throw_exception(ex);
   }
   pstate = 0;
   m_match_flags = f;
   estimate_max_state_count(static_cast<category*>(0));
   expression_flag_type re_f = re.flags();
   icase = re_f & regex_constants::icase;
   if(!(m_match_flags & (match_perl|match_posix)))
   {
      if((re_f & (regbase::main_option_type|regbase::no_perl_ex)) == 0)
         m_match_flags |= match_perl;
      else if((re_f & (regbase::main_option_type|regbase::emacs_ex)) == (regbase::basic_syntax_group|regbase::emacs_ex))
         m_match_flags |= match_perl;
      else
         m_match_flags |= match_posix;
   }
   if(m_match_flags & match_posix)
   {
      m_temp_match.reset(new match_results<BidiIterator, Allocator>());
      m_presult = m_temp_match.get();
   }
   else
      m_presult = &m_result;

   m_stack_base = 0;
   m_backup_state = 0;


   m_word_mask = re.get_data().m_word_mask;

   match_any_mask = static_cast<unsigned char>((f & match_not_dot_newline) ? re_detail::test_not_newline : re_detail::test_newline);
}

template <class BidiIterator, class Allocator, class traits>
void perl_matcher<BidiIterator, Allocator, traits>::estimate_max_state_count(std::random_access_iterator_tag*)
{
# 101 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_common.hpp" 3
   static const boost::uintmax_t k = 100000;
   boost::uintmax_t dist = boost::re_detail::distance(base, last);
   if(dist == 0)
      dist = 1;
   boost::uintmax_t states = re.size();
   if(states == 0)
      states = 1;
   states *= states;
   if((std::numeric_limits<boost::uintmax_t>::max)() / dist < states)
   {
      max_state_count = (std::numeric_limits<boost::uintmax_t>::max)() - 2;
      return;
   }
   states *= dist;
   if((std::numeric_limits<boost::uintmax_t>::max)() - k < states)
   {
      max_state_count = (std::numeric_limits<boost::uintmax_t>::max)() - 2;
      return;
   }
   states += k;

   max_state_count = states;




   states = dist;
   if((std::numeric_limits<boost::uintmax_t>::max)() / dist < states)
   {
      max_state_count = (std::numeric_limits<boost::uintmax_t>::max)() - 2;
      return;
   }
   states *= dist;
   if((std::numeric_limits<boost::uintmax_t>::max)() - k < states)
   {
      max_state_count = (std::numeric_limits<boost::uintmax_t>::max)() - 2;
      return;
   }
   states += k;




   if(states > 100000000)
      states = 100000000;




   if(states > max_state_count)
      max_state_count = states;
}

template <class BidiIterator, class Allocator, class traits>
inline void perl_matcher<BidiIterator, Allocator, traits>::estimate_max_state_count(void*)
{

   max_state_count = 100000000;
}
# 174 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_common.hpp" 3
template <class BidiIterator, class Allocator, class traits>
inline bool perl_matcher<BidiIterator, Allocator, traits>::match()
{



   return match_imp();

}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_imp()
{


   save_state_init init(&m_stack_base, &m_backup_state);
   used_block_count = 1024;

   try{




   position = base;
   search_base = base;
   state_count = 0;
   m_match_flags |= regex_constants::match_all;
   m_presult->set_size((m_match_flags & match_nosubs) ? 1 : re.mark_count(), search_base, last);
   m_presult->set_base(base);
   if(m_match_flags & match_posix)
      m_result = *m_presult;
   verify_options(re.flags(), m_match_flags);
   if(0 == match_prefix())
      return false;
   return m_result[0].second == last;


   }
   catch(...)
   {



      while(unwind(true)){}
      throw;
   }

}

template <class BidiIterator, class Allocator, class traits>
inline bool perl_matcher<BidiIterator, Allocator, traits>::find()
{



   return find_imp();

}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::find_imp()
{
   static matcher_proc_type const s_find_vtable[7] =
   {
      &perl_matcher<BidiIterator, Allocator, traits>::find_restart_any,
      &perl_matcher<BidiIterator, Allocator, traits>::find_restart_word,
      &perl_matcher<BidiIterator, Allocator, traits>::find_restart_line,
      &perl_matcher<BidiIterator, Allocator, traits>::find_restart_buf,
      &perl_matcher<BidiIterator, Allocator, traits>::match_prefix,
      &perl_matcher<BidiIterator, Allocator, traits>::find_restart_lit,
      &perl_matcher<BidiIterator, Allocator, traits>::find_restart_lit,
   };



   save_state_init init(&m_stack_base, &m_backup_state);
   used_block_count = 1024;

   try{



   state_count = 0;
   if((m_match_flags & regex_constants::match_init) == 0)
   {

      search_base = position = base;
      pstate = re.get_first_state();
      m_presult->set_size((m_match_flags & match_nosubs) ? 1 : re.mark_count(), base, last);
      m_presult->set_base(base);
      m_match_flags |= regex_constants::match_init;
   }
   else
   {

      search_base = position = m_result[0].second;


      if(((m_match_flags & match_not_null) == 0) && (m_result.length() == 0))
      {
         if(position == last)
            return false;
         else
            ++position;
      }

      m_presult->set_size((m_match_flags & match_nosubs) ? 1 : re.mark_count(), search_base, last);


   }
   if(m_match_flags & match_posix)
   {
      m_result.set_size(re.mark_count(), base, last);
      m_result.set_base(base);
   }

   verify_options(re.flags(), m_match_flags);

   unsigned type = (m_match_flags & match_continuous) ?
      static_cast<unsigned int>(regbase::restart_continue)
         : static_cast<unsigned int>(re.get_restart_type());


   matcher_proc_type proc = s_find_vtable[type];
   return (this->*proc)();


   }
   catch(...)
   {



      while(unwind(true)){}
      throw;
   }

}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_prefix()
{
   m_has_partial_match = false;
   m_has_found_match = false;
   pstate = re.get_first_state();
   m_presult->set_first(position);
   restart = position;
   match_all_states();
   if(!m_has_found_match && m_has_partial_match && (m_match_flags & match_partial))
   {
      m_has_found_match = true;
      m_presult->set_second(last, 0, false);
      position = last;
   }
# 341 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_common.hpp" 3
   if(!m_has_found_match)
      position = restart;
   return m_has_found_match;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_endmark()
{
   int index = static_cast<const re_brace*>(pstate)->index;
   if(index > 0)
   {
      if((m_match_flags & match_nosubs) == 0)
         m_presult->set_second(position, index);
   }
   else if((index < 0) && (index != -4))
   {

      pstate = 0;
      return true;
   }
   pstate = pstate->next.p;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_literal()
{
   unsigned int len = static_cast<const re_literal*>(pstate)->length;
   const char_type* what = reinterpret_cast<const char_type*>(static_cast<const re_literal*>(pstate) + 1);



   for(unsigned int i = 0; i < len; ++i, ++position)
   {
      if((position == last) || (traits_inst.translate(*position, icase) != what[i]))
         return false;
   }
   pstate = pstate->next.p;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_start_line()
{
   if(position == backstop)
   {
      if((m_match_flags & match_prev_avail) == 0)
      {
         if((m_match_flags & match_not_bol) == 0)
         {
            pstate = pstate->next.p;
            return true;
         }
         return false;
      }
   }
   else if(m_match_flags & match_single_line)
      return false;


   BidiIterator t(position);
   --t;
   if(position != last)
   {
      if(is_separator(*t) && !((*t == static_cast<char_type>('\r')) && (*position == static_cast<char_type>('\n'))) )
      {
         pstate = pstate->next.p;
         return true;
      }
   }
   else if(is_separator(*t))
   {
      pstate = pstate->next.p;
      return true;
   }
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_end_line()
{
   if(position != last)
   {
      if(m_match_flags & match_single_line)
         return false;

      if(is_separator(*position))
      {
         if((position != backstop) || (m_match_flags & match_prev_avail))
         {

            BidiIterator t(position);
            --t;
            if((*t == static_cast<char_type>('\r')) && (*position == static_cast<char_type>('\n')))
            {
               return false;
            }
         }
         pstate = pstate->next.p;
         return true;
      }
   }
   else if((m_match_flags & match_not_eol) == 0)
   {
      pstate = pstate->next.p;
      return true;
   }
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_wild()
{
   if(position == last)
      return false;
   if(is_separator(*position) && ((match_any_mask & static_cast<const re_dot*>(pstate)->mask) == 0))
      return false;
   if((*position == char_type(0)) && (m_match_flags & match_not_dot_null))
      return false;
   pstate = pstate->next.p;
   ++position;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_match()
{
   if((m_match_flags & match_not_null) && (position == (*m_presult)[0].first))
      return false;
   if((m_match_flags & match_all) && (position != last))
      return false;
   if((m_match_flags & regex_constants::match_not_initial_null) && (position == search_base))
      return false;
   m_presult->set_second(position);
   pstate = 0;
   m_has_found_match = true;
   if((m_match_flags & match_posix) == match_posix)
   {
      m_result.maybe_assign(*m_presult);
      if((m_match_flags & match_any) == 0)
         return false;
   }
# 491 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_common.hpp" 3
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_word_boundary()
{
   bool b;
   if(position != last)
   {




      b = traits_inst.isctype(*position, m_word_mask);

   }
   else
   {
      b = (m_match_flags & match_not_eow) ? true : false;
   }
   if((position == backstop) && ((m_match_flags & match_prev_avail) == 0))
   {
      if(m_match_flags & match_not_bow)
         b ^= true;
      else
         b ^= false;
   }
   else
   {
      --position;
      b ^= traits_inst.isctype(*position, m_word_mask);
      ++position;
   }
   if(b)
   {
      pstate = pstate->next.p;
      return true;
   }
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_within_word()
{
   if(position == last)
      return false;

   bool prev = traits_inst.isctype(*position, m_word_mask);
   {
      bool b;
      if((position == backstop) && ((m_match_flags & match_prev_avail) == 0))
         return false;
      else
      {
         --position;
         b = traits_inst.isctype(*position, m_word_mask);
         ++position;
      }
      if(b == prev)
      {
         pstate = pstate->next.p;
         return true;
      }
   }
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_word_start()
{
   if(position == last)
      return false;
   if(!traits_inst.isctype(*position, m_word_mask))
      return false;
   if((position == backstop) && ((m_match_flags & match_prev_avail) == 0))
   {
      if(m_match_flags & match_not_bow)
         return false;
   }
   else
   {

      BidiIterator t(position);
      --t;
      if(traits_inst.isctype(*t, m_word_mask))
         return false;
   }

   pstate = pstate->next.p;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_word_end()
{
   if((position == backstop) && ((m_match_flags & match_prev_avail) == 0))
      return false;
   BidiIterator t(position);
   --t;
   if(traits_inst.isctype(*t, m_word_mask) == false)
      return false;

   if(position == last)
   {
      if(m_match_flags & match_not_eow)
         return false;
   }
   else
   {

      if(traits_inst.isctype(*position, m_word_mask))
         return false;
   }
   pstate = pstate->next.p;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_buffer_start()
{
   if((position != backstop) || (m_match_flags & match_not_bob))
      return false;

   pstate = pstate->next.p;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_buffer_end()
{
   if((position != last) || (m_match_flags & match_not_eob))
      return false;

   pstate = pstate->next.p;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_backref()
{






   BidiIterator i = (*m_presult)[static_cast<const re_brace*>(pstate)->index].first;
   BidiIterator j = (*m_presult)[static_cast<const re_brace*>(pstate)->index].second;
   while(i != j)
   {
      if((position == last) || (traits_inst.translate(*position, icase) != traits_inst.translate(*i, icase)))
         return false;
      ++i;
      ++position;
   }
   pstate = pstate->next.p;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_long_set()
{
   typedef typename traits::char_class_type char_class_type;

   if(position == last)
      return false;
   BidiIterator t = re_is_set_member(position, last, static_cast<const re_set_long<char_class_type>*>(pstate), re.get_data(), icase);
   if(t != position)
   {
      pstate = pstate->next.p;
      position = t;
      return true;
   }
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_set()
{
   if(position == last)
      return false;
   if(static_cast<const re_set*>(pstate)->_map[static_cast<unsigned char>(traits_inst.translate(*position, icase))])
   {
      pstate = pstate->next.p;
      ++position;
      return true;
   }
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_jump()
{
   pstate = static_cast<const re_jump*>(pstate)->alt.p;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_combining()
{
   if(position == last)
      return false;
   if(is_combining(traits_inst.translate(*position, icase)))
      return false;
   ++position;
   while((position != last) && is_combining(traits_inst.translate(*position, icase)))
      ++position;
   pstate = pstate->next.p;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_soft_buffer_end()
{
   if(m_match_flags & match_not_eob)
      return false;
   BidiIterator p(position);
   while((p != last) && is_separator(traits_inst.translate(*p, icase)))++p;
   if(p != last)
      return false;
   pstate = pstate->next.p;
   return true;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_restart_continue()
{
   if(position == search_base)
   {
      pstate = pstate->next.p;
      return true;
   }
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_backstep()
{




   if( ::boost::is_random_access_iterator<BidiIterator>::value)
   {
      std::ptrdiff_t maxlen = ::boost::re_detail::distance(backstop, position);
      if(maxlen < static_cast<const re_brace*>(pstate)->index)
         return false;
      std::advance(position, -static_cast<const re_brace*>(pstate)->index);
   }
   else
   {
      int c = static_cast<const re_brace*>(pstate)->index;
      while(c--)
      {
         if(position == backstop)
            return false;
         --position;
      }
   }
   pstate = pstate->next.p;
   return true;



}

template <class BidiIterator, class Allocator, class traits>
inline bool perl_matcher<BidiIterator, Allocator, traits>::match_assert_backref()
{

   bool result = (*m_presult)[static_cast<const re_brace*>(pstate)->index].matched;
   pstate = pstate->next.p;
   return result;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::match_toggle_case()
{

   this->icase = static_cast<const re_case*>(pstate)->icase;
   pstate = pstate->next.p;
   return true;
}


template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_any()
{




   const unsigned char* _map = re.get_map();
   while(true)
   {

      while((position != last) && !can_start(*position, _map, (unsigned char)mask_any) )
         ++position;
      if(position == last)
      {

         if(re.can_be_null())
            return match_prefix();
         break;
      }

      if(match_prefix())
         return true;
      if(position == last)
         return false;
      ++position;
   }
   return false;



}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_word()
{





   const unsigned char* _map = re.get_map();
   if((m_match_flags & match_prev_avail) || (position != base))
      --position;
   else if(match_prefix())
      return true;
   do
   {
      while((position != last) && traits_inst.isctype(*position, m_word_mask))
         ++position;
      while((position != last) && !traits_inst.isctype(*position, m_word_mask))
         ++position;
      if(position == last)
         break;

      if(can_start(*position, _map, (unsigned char)mask_any) )
      {
         if(match_prefix())
            return true;
      }
      if(position == last)
         break;
   } while(true);
   return false;



}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_line()
{

   const unsigned char* _map = re.get_map();
   if(match_prefix())
      return true;
   while(position != last)
   {
      while((position != last) && !is_separator(*position))
         ++position;
      if(position == last)
         return false;
      ++position;
      if(position == last)
      {
         if(re.can_be_null() && match_prefix())
            return true;
         return false;
      }

      if( can_start(*position, _map, (unsigned char)mask_any) )
      {
         if(match_prefix())
            return true;
      }
      if(position == last)
         return false;

   }
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_buf()
{
   if((position == base) && ((m_match_flags & match_not_bob) == 0))
      return match_prefix();
   return false;
}

template <class BidiIterator, class Allocator, class traits>
bool perl_matcher<BidiIterator, Allocator, traits>::find_restart_lit()
{
# 945 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher_common.hpp" 3
   return false;
}

}

}
# 548 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/perl_matcher.hpp" 2 3
# 89 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3
# 97 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/instances.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/instances.hpp" 3
namespace boost{
# 128 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/instances.hpp" 3
namespace re_detail{
__extension__ extern template
std::locale cpp_regex_traits_base<char>::imbue(const std::locale& l);

__extension__ extern template
cpp_regex_traits_implementation<char>::string_type
   cpp_regex_traits_implementation<char>::transform_primary(const char* p1, const char* p2) const;
__extension__ extern template
cpp_regex_traits_implementation<char>::string_type
   cpp_regex_traits_implementation<char>::transform(const char* p1, const char* p2) const;
__extension__ extern template
cpp_regex_traits_implementation<char>::string_type
   cpp_regex_traits_implementation<char>::lookup_collatename(const char* p1, const char* p2) const;
__extension__ extern template
void cpp_regex_traits_implementation<char>::init();
__extension__ extern template
cpp_regex_traits_implementation<char>::char_class_type
   cpp_regex_traits_implementation<char>::lookup_classname_imp(const char* p1, const char* p2) const;




}
__extension__ extern template
int cpp_regex_traits<char>::toi(const char*& first, const char* last, int radix)const;
__extension__ extern template
std::string cpp_regex_traits<char>::catalog_name(const std::string& name);
__extension__ extern template
std::string& cpp_regex_traits<char>::get_catalog_name_inst();
__extension__ extern template
std::string cpp_regex_traits<char>::get_catalog_name();

__extension__ extern template
static_mutex& cpp_regex_traits<char>::get_mutex_inst();



__extension__ extern template basic_regex<char , boost::regex_traits<char > >&
   basic_regex<char , boost::regex_traits<char > >::do_assign(
      const char* p1,
      const char* p2,
      flag_type f);
__extension__ extern template basic_regex<char , boost::regex_traits<char > >::locale_type
   basic_regex<char , boost::regex_traits<char > >::imbue(locale_type l);

__extension__ extern template void
   match_results<const char*>::maybe_assign(
      const match_results<const char*>& m);

namespace re_detail{
__extension__ extern template void perl_matcher<char const *, match_results< const char* >::allocator_type , boost::regex_traits<char > >::construct_init(
      const basic_regex<char , boost::regex_traits<char > >& e, match_flag_type f);
__extension__ extern template bool perl_matcher<char const *, match_results< const char* >::allocator_type , boost::regex_traits<char > >::match();
__extension__ extern template bool perl_matcher<char const *, match_results< const char* >::allocator_type , boost::regex_traits<char > >::find();
}






__extension__ extern template void
   match_results<std::basic_string<char>::const_iterator>::maybe_assign(
      const match_results<std::basic_string<char>::const_iterator>& m);

namespace re_detail{
__extension__ extern template void perl_matcher<std::basic_string<char>::const_iterator, match_results< std::basic_string<char>::const_iterator >::allocator_type, boost::regex_traits<char > >::construct_init(
      const basic_regex<char>& e, match_flag_type f);
__extension__ extern template bool perl_matcher<std::basic_string<char>::const_iterator, match_results< std::basic_string<char>::const_iterator >::allocator_type, boost::regex_traits<char > >::match();
__extension__ extern template bool perl_matcher<std::basic_string<char>::const_iterator, match_results< std::basic_string<char>::const_iterator >::allocator_type, boost::regex_traits<char > >::find();
}
# 208 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/instances.hpp" 3
}
# 98 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3
# 108 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/instances.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/instances.hpp" 3
namespace boost{
# 128 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/instances.hpp" 3
namespace re_detail{
__extension__ extern template
std::locale cpp_regex_traits_base<wchar_t>::imbue(const std::locale& l);

__extension__ extern template
cpp_regex_traits_implementation<wchar_t>::string_type
   cpp_regex_traits_implementation<wchar_t>::transform_primary(const wchar_t* p1, const wchar_t* p2) const;
__extension__ extern template
cpp_regex_traits_implementation<wchar_t>::string_type
   cpp_regex_traits_implementation<wchar_t>::transform(const wchar_t* p1, const wchar_t* p2) const;
__extension__ extern template
cpp_regex_traits_implementation<wchar_t>::string_type
   cpp_regex_traits_implementation<wchar_t>::lookup_collatename(const wchar_t* p1, const wchar_t* p2) const;
__extension__ extern template
void cpp_regex_traits_implementation<wchar_t>::init();
__extension__ extern template
cpp_regex_traits_implementation<wchar_t>::char_class_type
   cpp_regex_traits_implementation<wchar_t>::lookup_classname_imp(const wchar_t* p1, const wchar_t* p2) const;




}
__extension__ extern template
int cpp_regex_traits<wchar_t>::toi(const wchar_t*& first, const wchar_t* last, int radix)const;
__extension__ extern template
std::string cpp_regex_traits<wchar_t>::catalog_name(const std::string& name);
__extension__ extern template
std::string& cpp_regex_traits<wchar_t>::get_catalog_name_inst();
__extension__ extern template
std::string cpp_regex_traits<wchar_t>::get_catalog_name();

__extension__ extern template
static_mutex& cpp_regex_traits<wchar_t>::get_mutex_inst();



__extension__ extern template basic_regex<wchar_t , boost::regex_traits<wchar_t > >&
   basic_regex<wchar_t , boost::regex_traits<wchar_t > >::do_assign(
      const wchar_t* p1,
      const wchar_t* p2,
      flag_type f);
__extension__ extern template basic_regex<wchar_t , boost::regex_traits<wchar_t > >::locale_type
   basic_regex<wchar_t , boost::regex_traits<wchar_t > >::imbue(locale_type l);

__extension__ extern template void
   match_results<const wchar_t*>::maybe_assign(
      const match_results<const wchar_t*>& m);

namespace re_detail{
__extension__ extern template void perl_matcher<wchar_t const *, match_results< const wchar_t* >::allocator_type , boost::regex_traits<wchar_t > >::construct_init(
      const basic_regex<wchar_t , boost::regex_traits<wchar_t > >& e, match_flag_type f);
__extension__ extern template bool perl_matcher<wchar_t const *, match_results< const wchar_t* >::allocator_type , boost::regex_traits<wchar_t > >::match();
__extension__ extern template bool perl_matcher<wchar_t const *, match_results< const wchar_t* >::allocator_type , boost::regex_traits<wchar_t > >::find();
}






__extension__ extern template void
   match_results<std::basic_string<wchar_t>::const_iterator>::maybe_assign(
      const match_results<std::basic_string<wchar_t>::const_iterator>& m);

namespace re_detail{
__extension__ extern template void perl_matcher<std::basic_string<wchar_t>::const_iterator, match_results< std::basic_string<wchar_t>::const_iterator >::allocator_type, boost::regex_traits<wchar_t > >::construct_init(
      const basic_regex<wchar_t>& e, match_flag_type f);
__extension__ extern template bool perl_matcher<std::basic_string<wchar_t>::const_iterator, match_results< std::basic_string<wchar_t>::const_iterator >::allocator_type, boost::regex_traits<wchar_t > >::match();
__extension__ extern template bool perl_matcher<std::basic_string<wchar_t>::const_iterator, match_results< std::basic_string<wchar_t>::const_iterator >::allocator_type, boost::regex_traits<wchar_t > >::find();
}
# 208 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/instances.hpp" 3
}
# 109 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3
# 128 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 3
namespace boost{







typedef match_results<const char*> cmatch;
typedef match_results<std::string::const_iterator> smatch;

typedef match_results<const wchar_t*> wcmatch;
typedef match_results<std::wstring::const_iterator> wsmatch;


}

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_match.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_match.hpp" 3
namespace boost{
# 43 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_match.hpp" 3
template <class BidiIterator, class Allocator, class charT, class traits>
bool regex_match(BidiIterator first, BidiIterator last,
                 match_results<BidiIterator, Allocator>& m,
                 const basic_regex<charT, traits>& e,
                 match_flag_type flags = match_default)
{
   re_detail::perl_matcher<BidiIterator, Allocator, traits> matcher(first, last, m, e, flags, first);
   return matcher.match();
}
template <class iterator, class charT, class traits>
bool regex_match(iterator first, iterator last,
                 const basic_regex<charT, traits>& e,
                 match_flag_type flags = match_default)
{
   match_results<iterator> m;
   return regex_match(first, last, m, e, flags | regex_constants::match_any);
}







template <class charT, class Allocator, class traits>
inline bool regex_match(const charT* str,
                        match_results<const charT*, Allocator>& m,
                        const basic_regex<charT, traits>& e,
                        match_flag_type flags = match_default)
{
   return regex_match(str, str + traits::length(str), m, e, flags);
}

template <class ST, class SA, class Allocator, class charT, class traits>
inline bool regex_match(const std::basic_string<charT, ST, SA>& s,
                 match_results<typename std::basic_string<charT, ST, SA>::const_iterator, Allocator>& m,
                 const basic_regex<charT, traits>& e,
                 match_flag_type flags = match_default)
{
   return regex_match(s.begin(), s.end(), m, e, flags);
}
template <class charT, class traits>
inline bool regex_match(const charT* str,
                        const basic_regex<charT, traits>& e,
                        match_flag_type flags = match_default)
{
   match_results<const charT*> m;
   return regex_match(str, str + traits::length(str), m, e, flags | regex_constants::match_any);
}

template <class ST, class SA, class charT, class traits>
inline bool regex_match(const std::basic_string<charT, ST, SA>& s,
                 const basic_regex<charT, traits>& e,
                 match_flag_type flags = match_default)
{
   typedef typename std::basic_string<charT, ST, SA>::const_iterator iterator;
   match_results<iterator> m;
   return regex_match(s.begin(), s.end(), m, e, flags | regex_constants::match_any);
}
# 362 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_match.hpp" 3
}
# 146 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_search.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_search.hpp" 3
namespace boost{
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_search.hpp" 3
template <class BidiIterator, class Allocator, class charT, class traits>
bool regex_search(BidiIterator first, BidiIterator last,
                  match_results<BidiIterator, Allocator>& m,
                  const basic_regex<charT, traits>& e,
                  match_flag_type flags = match_default)
{
   return regex_search(first, last, m, e, flags, first);
}

template <class BidiIterator, class Allocator, class charT, class traits>
bool regex_search(BidiIterator first, BidiIterator last,
                  match_results<BidiIterator, Allocator>& m,
                  const basic_regex<charT, traits>& e,
                  match_flag_type flags,
                  BidiIterator base)
{
   if(e.flags() & regex_constants::failbit)
      return false;

   re_detail::perl_matcher<BidiIterator, Allocator, traits> matcher(first, last, m, e, flags, base);
   return matcher.find();
}
# 66 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_search.hpp" 3
template <class charT, class Allocator, class traits>
inline bool regex_search(const charT* str,
                        match_results<const charT*, Allocator>& m,
                        const basic_regex<charT, traits>& e,
                        match_flag_type flags = match_default)
{
   return regex_search(str, str + traits::length(str), m, e, flags);
}

template <class ST, class SA, class Allocator, class charT, class traits>
inline bool regex_search(const std::basic_string<charT, ST, SA>& s,
                 match_results<typename std::basic_string<charT, ST, SA>::const_iterator, Allocator>& m,
                 const basic_regex<charT, traits>& e,
                 match_flag_type flags = match_default)
{
   return regex_search(s.begin(), s.end(), m, e, flags);
}
# 134 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_search.hpp" 3
template <class BidiIterator, class charT, class traits>
bool regex_search(BidiIterator first, BidiIterator last,
                  const basic_regex<charT, traits>& e,
                  match_flag_type flags = match_default)
{
   if(e.flags() & regex_constants::failbit)
      return false;

   match_results<BidiIterator> m;
   typedef typename match_results<BidiIterator>::allocator_type match_alloc_type;
   re_detail::perl_matcher<BidiIterator, match_alloc_type, traits> matcher(first, last, m, e, flags | regex_constants::match_any, first);
   return matcher.find();
}



template <class charT, class traits>
inline bool regex_search(const charT* str,
                        const basic_regex<charT, traits>& e,
                        match_flag_type flags = match_default)
{
   return regex_search(str, str + traits::length(str), e, flags);
}

template <class ST, class SA, class charT, class traits>
inline bool regex_search(const std::basic_string<charT, ST, SA>& s,
                 const basic_regex<charT, traits>& e,
                 match_flag_type flags = match_default)
{
   return regex_search(s.begin(), s.end(), e, flags);
}
# 213 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_search.hpp" 3
}
# 149 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_iterator.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_iterator.hpp" 3
namespace boost{
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_iterator.hpp" 3
template <class BidirectionalIterator,
          class charT,
          class traits>
class regex_iterator_implementation
{
   typedef basic_regex<charT, traits> regex_type;

   match_results<BidirectionalIterator> what;
   BidirectionalIterator base;
   BidirectionalIterator end;
   const regex_type re;
   match_flag_type flags;

public:
   regex_iterator_implementation(const regex_type* p, BidirectionalIterator last, match_flag_type f)
      : base(), end(last), re(*p), flags(f){}
   bool init(BidirectionalIterator first)
   {
      base = first;
      return regex_search(first, end, what, re, flags);
   }
   bool compare(const regex_iterator_implementation& that)
   {
      if(this == &that) return true;
      return (&re.get_data() == &that.re.get_data()) && (end == that.end) && (flags == that.flags) && (what[0].first == that.what[0].first) && (what[0].second == that.what[0].second);
   }
   const match_results<BidirectionalIterator>& get()
   { return what; }
   bool next()
   {


      BidirectionalIterator next_start = what[0].second;
      match_flag_type f(flags);
      if(!what.length())
         f |= regex_constants::match_not_initial_null;


      bool result = regex_search(next_start, end, what, re, f, base);
      if(result)
         what.set_base(base);
      return result;
   }
private:
   regex_iterator_implementation& operator=(const regex_iterator_implementation&);
};

template <class BidirectionalIterator,
          class charT = typename re_detail::regex_iterator_traits<BidirectionalIterator>::value_type,
          class traits = regex_traits<charT> >
class regex_iterator

   : public std::iterator<
         std::forward_iterator_tag,
         match_results<BidirectionalIterator>,
         typename re_detail::regex_iterator_traits<BidirectionalIterator>::difference_type,
         const match_results<BidirectionalIterator>*,
         const match_results<BidirectionalIterator>& >

{
private:
   typedef regex_iterator_implementation<BidirectionalIterator, charT, traits> impl;
   typedef shared_ptr<impl> pimpl;
public:
   typedef basic_regex<charT, traits> regex_type;
   typedef match_results<BidirectionalIterator> value_type;
   typedef typename re_detail::regex_iterator_traits<BidirectionalIterator>::difference_type
                                                                            difference_type;
   typedef const value_type* pointer;
   typedef const value_type& reference;
   typedef std::forward_iterator_tag iterator_category;

   regex_iterator(){}
   regex_iterator(BidirectionalIterator a, BidirectionalIterator b,
                  const regex_type& re,
                  match_flag_type m = match_default)
                  : pdata(new impl(&re, b, m))
   {
      if(!pdata->init(a))
      {
         pdata.reset();
      }
   }
   regex_iterator(const regex_iterator& that)
      : pdata(that.pdata) {}
   regex_iterator& operator=(const regex_iterator& that)
   {
      pdata = that.pdata;
      return *this;
   }
   bool operator==(const regex_iterator& that)const
   {
      if((pdata.get() == 0) || (that.pdata.get() == 0))
         return pdata.get() == that.pdata.get();
      return pdata->compare(*(that.pdata.get()));
   }
   bool operator!=(const regex_iterator& that)const
   { return !(*this == that); }
   const value_type& operator*()const
   { return pdata->get(); }
   const value_type* operator->()const
   { return &(pdata->get()); }
   regex_iterator& operator++()
   {
      cow();
      if(0 == pdata->next())
      {
         pdata.reset();
      }
      return *this;
   }
   regex_iterator operator++(int)
   {
      regex_iterator result(*this);
      ++(*this);
      return result;
   }
private:

   pimpl pdata;

   void cow()
   {

      if(pdata.get() && !pdata.unique())
      {
         pdata.reset(new impl(*(pdata.get())));
      }
   }
};

typedef regex_iterator<const char*> cregex_iterator;
typedef regex_iterator<std::string::const_iterator> sregex_iterator;

typedef regex_iterator<const wchar_t*> wcregex_iterator;
typedef regex_iterator<std::wstring::const_iterator> wsregex_iterator;



template <class charT, class traits>
inline regex_iterator<const charT*, charT, traits> make_regex_iterator(const charT* p, const basic_regex<charT, traits>& e, regex_constants::match_flag_type m = regex_constants::match_default)
{
   return regex_iterator<const charT*, charT, traits>(p, p+traits::length(p), e, m);
}
template <class charT, class traits, class ST, class SA>
inline regex_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, regex_constants::match_flag_type m = regex_constants::match_default)
{
   return regex_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits>(p.begin(), p.end(), e, m);
}
# 198 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_iterator.hpp" 3
}
# 152 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_token_iterator.hpp" 1 3
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_token_iterator.hpp" 3
namespace boost{
# 54 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_token_iterator.hpp" 3
template <class BidirectionalIterator,
          class charT,
          class traits>
class regex_token_iterator_implementation
{
   typedef basic_regex<charT, traits> regex_type;
   typedef sub_match<BidirectionalIterator> value_type;

   match_results<BidirectionalIterator> what;
   BidirectionalIterator base;
   BidirectionalIterator end;
   const regex_type re;
   match_flag_type flags;
   value_type result;
   int N;
   std::vector<int> subs;

public:
   regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)
      : end(last), re(*p), flags(f){ subs.push_back(sub); }
   regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const std::vector<int>& v, match_flag_type f)
      : end(last), re(*p), flags(f), subs(v){}
# 94 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_token_iterator.hpp" 3
   template <std::size_t CN>
   regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const int (&submatches)[CN], match_flag_type f)
      : end(last), re(*p), flags(f)
   {
      for(std::size_t i = 0; i < CN; ++i)
      {
         subs.push_back(submatches[i]);
      }
   }


   bool init(BidirectionalIterator first)
   {
      N = 0;
      base = first;
      if(regex_search(first, end, what, re, flags, base) == true)
      {
         N = 0;
         result = ((subs[N] == -1) ? what.prefix() : what[(int)subs[N]]);
         return true;
      }
      else if((subs[N] == -1) && (first != end))
      {
         result.first = first;
         result.second = end;
         result.matched = (first != end);
         N = -1;
         return true;
      }
      return false;
   }
   bool compare(const regex_token_iterator_implementation& that)
   {
      if(this == &that) return true;
      return (&re.get_data() == &that.re.get_data())
         && (end == that.end)
         && (flags == that.flags)
         && (N == that.N)
         && (what[0].first == that.what[0].first)
         && (what[0].second == that.what[0].second);
   }
   const value_type& get()
   { return result; }
   bool next()
   {
      if(N == -1)
         return false;
      if(N+1 < (int)subs.size())
      {
         ++N;
         result =((subs[N] == -1) ? what.prefix() : what[subs[N]]);
         return true;
      }


      BidirectionalIterator last_end(what[0].second);
      if(regex_search(last_end, end, what, re, ((what[0].first == what[0].second) ? flags | regex_constants::match_not_initial_null : flags), base))
      {
         N =0;
         result =((subs[N] == -1) ? what.prefix() : what[subs[N]]);
         return true;
      }
      else if((last_end != end) && (subs[0] == -1))
      {
         N =-1;
         result.first = last_end;
         result.second = end;
         result.matched = (last_end != end);
         return true;
      }
      return false;
   }
private:
   regex_token_iterator_implementation& operator=(const regex_token_iterator_implementation&);
};

template <class BidirectionalIterator,
          class charT = typename re_detail::regex_iterator_traits<BidirectionalIterator>::value_type,
          class traits = regex_traits<charT> >
class regex_token_iterator

   : public std::iterator<
         std::forward_iterator_tag,
         sub_match<BidirectionalIterator>,
         typename re_detail::regex_iterator_traits<BidirectionalIterator>::difference_type,
         const sub_match<BidirectionalIterator>*,
         const sub_match<BidirectionalIterator>& >

{
private:
   typedef regex_token_iterator_implementation<BidirectionalIterator, charT, traits> impl;
   typedef shared_ptr<impl> pimpl;
public:
   typedef basic_regex<charT, traits> regex_type;
   typedef sub_match<BidirectionalIterator> value_type;
   typedef typename re_detail::regex_iterator_traits<BidirectionalIterator>::difference_type
                                                                            difference_type;
   typedef const value_type* pointer;
   typedef const value_type& reference;
   typedef std::forward_iterator_tag iterator_category;

   regex_token_iterator(){}
   regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,
                        int submatch = 0, match_flag_type m = match_default)
                        : pdata(new impl(&re, b, submatch, m))
   {
      if(!pdata->init(a))
         pdata.reset();
   }
   regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,
                        const std::vector<int>& submatches, match_flag_type m = match_default)
                        : pdata(new impl(&re, b, submatches, m))
   {
      if(!pdata->init(a))
         pdata.reset();
   }
# 224 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_token_iterator.hpp" 3
   template <std::size_t N>
   regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,
                        const int (&submatches)[N], match_flag_type m = match_default)
                        : pdata(new impl(&re, b, submatches, m))
   {
      if(!pdata->init(a))
         pdata.reset();
   }


   regex_token_iterator(const regex_token_iterator& that)
      : pdata(that.pdata) {}
   regex_token_iterator& operator=(const regex_token_iterator& that)
   {
      pdata = that.pdata;
      return *this;
   }
   bool operator==(const regex_token_iterator& that)const
   {
      if((pdata.get() == 0) || (that.pdata.get() == 0))
         return pdata.get() == that.pdata.get();
      return pdata->compare(*(that.pdata.get()));
   }
   bool operator!=(const regex_token_iterator& that)const
   { return !(*this == that); }
   const value_type& operator*()const
   { return pdata->get(); }
   const value_type* operator->()const
   { return &(pdata->get()); }
   regex_token_iterator& operator++()
   {
      cow();
      if(0 == pdata->next())
      {
         pdata.reset();
      }
      return *this;
   }
   regex_token_iterator operator++(int)
   {
      regex_token_iterator result(*this);
      ++(*this);
      return result;
   }
private:

   pimpl pdata;

   void cow()
   {

      if(pdata.get() && !pdata.unique())
      {
         pdata.reset(new impl(*(pdata.get())));
      }
   }
};

typedef regex_token_iterator<const char*> cregex_token_iterator;
typedef regex_token_iterator<std::string::const_iterator> sregex_token_iterator;

typedef regex_token_iterator<const wchar_t*> wcregex_token_iterator;
typedef regex_token_iterator<std::wstring::const_iterator> wsregex_token_iterator;


template <class charT, class traits>
inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
{
   return regex_token_iterator<const charT*, charT, traits>(p, p+traits::length(p), e, submatch, m);
}
template <class charT, class traits, class ST, class SA>
inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
{
   return regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits>(p.begin(), p.end(), e, submatch, m);
}

template <class charT, class traits, std::size_t N>
inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
{
   return regex_token_iterator<const charT*, charT, traits>(p, p+traits::length(p), e, submatch, m);
}
template <class charT, class traits, class ST, class SA, std::size_t N>
inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
{
   return regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits>(p.begin(), p.end(), e, submatch, m);
}

template <class charT, class traits>
inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
{
   return regex_token_iterator<const charT*, charT, traits>(p, p+traits::length(p), e, submatch, m);
}
template <class charT, class traits, class ST, class SA>
inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
{
   return regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits>(p.begin(), p.end(), e, submatch, m);
}
# 336 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_token_iterator.hpp" 3
}
# 155 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_grep.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_grep.hpp" 3
namespace boost{
# 40 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_grep.hpp" 3
template <class Predicate, class BidiIterator, class charT, class traits>
inline unsigned int regex_grep(Predicate foo,
                               BidiIterator first,
                               BidiIterator last,
                               const basic_regex<charT, traits>& e,
                               match_flag_type flags = match_default)
{
   if(e.flags() & regex_constants::failbit)
      return false;

   typedef typename match_results<BidiIterator>::allocator_type match_allocator_type;

   match_results<BidiIterator> m;
   re_detail::perl_matcher<BidiIterator, match_allocator_type, traits> matcher(first, last, m, e, flags, first);
   unsigned int count = 0;
   while(matcher.find())
   {
      ++count;
      if(0 == foo(m))
         return count;
      if(m[0].second == last)
         return count;
      if(m.length() == 0)
      {
         if(m[0].second == last)
            return count;


         match_results<BidiIterator, match_allocator_type> m2(m);
         matcher.setf(match_not_null | match_continuous);
         if(matcher.find())
         {
            ++count;
            if(0 == foo(m))
               return count;
         }
         else
         {

            m = m2;
         }
         matcher.unsetf((match_not_null | match_continuous) & ~flags);
      }
   }
   return count;
}
# 94 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_grep.hpp" 3
template <class Predicate, class charT, class traits>
inline unsigned int regex_grep(Predicate foo, const charT* str,
                        const basic_regex<charT, traits>& e,
                        match_flag_type flags = match_default)
{
   return regex_grep(foo, str, str + traits::length(str), e, flags);
}

template <class Predicate, class ST, class SA, class charT, class traits>
inline unsigned int regex_grep(Predicate foo, const std::basic_string<charT, ST, SA>& s,
                 const basic_regex<charT, traits>& e,
                 match_flag_type flags = match_default)
{
   return regex_grep(foo, s.begin(), s.end(), e, flags);
}
# 152 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_grep.hpp" 3
}
# 158 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_replace.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_replace.hpp" 3
namespace boost{
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_replace.hpp" 3
template <class OutputIterator, class BidirectionalIterator, class traits, class charT>
OutputIterator regex_replace(OutputIterator out,
                         BidirectionalIterator first,
                         BidirectionalIterator last,
                         const basic_regex<charT, traits>& e,
                         const charT* fmt,
                         match_flag_type flags = match_default)
{
   regex_iterator<BidirectionalIterator, charT, traits> i(first, last, e, flags);
   regex_iterator<BidirectionalIterator, charT, traits> j;
   if(i == j)
   {
      if(!(flags & regex_constants::format_no_copy))
         out = re_detail::copy(first, last, out);
   }
   else
   {
      BidirectionalIterator last_m(first);
      while(i != j)
      {
         if(!(flags & regex_constants::format_no_copy))
            out = re_detail::copy(i->prefix().first, i->prefix().second, out);
         out = i->format(out, fmt, flags, e);
         last_m = (*i)[0].second;
         if(flags & regex_constants::format_first_only)
            break;
         ++i;
      }
      if(!(flags & regex_constants::format_no_copy))
         out = re_detail::copy(last_m, last, out);
   }
   return out;
}

template <class OutputIterator, class Iterator, class traits, class charT>
inline OutputIterator regex_replace(OutputIterator out,
                         Iterator first,
                         Iterator last,
                         const basic_regex<charT, traits>& e,
                         const std::basic_string<charT>& fmt,
                         match_flag_type flags = match_default)
{
   return regex_replace(out, first, last, e, fmt.c_str(), flags);
}

template <class traits, class charT>
std::basic_string<charT> regex_replace(const std::basic_string<charT>& s,
                         const basic_regex<charT, traits>& e,
                         const charT* fmt,
                         match_flag_type flags = match_default)
{
   std::basic_string<charT> result;
   re_detail::string_out_iterator<std::basic_string<charT> > i(result);
   regex_replace(i, s.begin(), s.end(), e, fmt, flags);
   return result;
}

template <class traits, class charT>
std::basic_string<charT> regex_replace(const std::basic_string<charT>& s,
                         const basic_regex<charT, traits>& e,
                         const std::basic_string<charT>& fmt,
                         match_flag_type flags = match_default)
{
   std::basic_string<charT> result;
   re_detail::string_out_iterator<std::basic_string<charT> > i(result);
   regex_replace(i, s.begin(), s.end(), e, fmt.c_str(), flags);
   return result;
}
# 118 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_replace.hpp" 3
}
# 161 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_merge.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_merge.hpp" 3
namespace boost{
# 38 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_merge.hpp" 3
template <class OutputIterator, class Iterator, class traits, class charT>
inline OutputIterator regex_merge(OutputIterator out,
                         Iterator first,
                         Iterator last,
                         const basic_regex<charT, traits>& e,
                         const charT* fmt,
                         match_flag_type flags = match_default)
{
   return regex_replace(out, first, last, e, fmt, flags);
}

template <class OutputIterator, class Iterator, class traits, class charT>
inline OutputIterator regex_merge(OutputIterator out,
                         Iterator first,
                         Iterator last,
                         const basic_regex<charT, traits>& e,
                         const std::basic_string<charT>& fmt,
                         match_flag_type flags = match_default)
{
   return regex_merge(out, first, last, e, fmt.c_str(), flags);
}

template <class traits, class charT>
inline std::basic_string<charT> regex_merge(const std::basic_string<charT>& s,
                         const basic_regex<charT, traits>& e,
                         const charT* fmt,
                         match_flag_type flags = match_default)
{
   return regex_replace(s, e, fmt, flags);
}

template <class traits, class charT>
inline std::basic_string<charT> regex_merge(const std::basic_string<charT>& s,
                         const basic_regex<charT, traits>& e,
                         const std::basic_string<charT>& fmt,
                         match_flag_type flags = match_default)
{
   return regex_replace(s, e, fmt, flags);
}
# 89 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_merge.hpp" 3
}
# 164 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_split.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_split.hpp" 3
namespace boost{
# 42 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_split.hpp" 3
namespace re_detail{

template <class charT>
const basic_regex<charT>& get_default_expression(charT)
{
   static const charT expression_text[4] = { '\\', 's', '+', '\00', };
   static const basic_regex<charT> e(expression_text);
   return e;
}

template <class OutputIterator, class charT, class Traits1, class Alloc1>
class split_pred
{
   typedef std::basic_string<charT, Traits1, Alloc1> string_type;
   typedef typename string_type::const_iterator iterator_type;
   iterator_type* p_last;
   OutputIterator* p_out;
   std::size_t* p_max;
   std::size_t initial_max;
public:
   split_pred(iterator_type* a, OutputIterator* b, std::size_t* c)
      : p_last(a), p_out(b), p_max(c), initial_max(*c) {}

   bool operator()(const match_results<iterator_type>& what);
};

template <class OutputIterator, class charT, class Traits1, class Alloc1>
bool split_pred<OutputIterator, charT, Traits1, Alloc1>::operator()
   (const match_results<iterator_type>& what)
{
   *p_last = what[0].second;
   if(what.size() > 1)
   {

      for(unsigned i = 1; i < what.size(); ++i)
      {
         *(*p_out) = what.str(i);
         ++(*p_out);
         if(0 == --*p_max) return false;
      }
      return *p_max != 0;
   }
   else
   {

      const sub_match<iterator_type>& sub = what[-1];
      if((sub.first != sub.second) || (*p_max != initial_max))
      {
         *(*p_out) = sub.str();
         ++(*p_out);
         return --*p_max;
      }
   }


   return true;
}

}

template <class OutputIterator, class charT, class Traits1, class Alloc1, class Traits2>
std::size_t regex_split(OutputIterator out,
                   std::basic_string<charT, Traits1, Alloc1>& s,
                   const basic_regex<charT, Traits2>& e,
                   match_flag_type flags,
                   std::size_t max_split)
{
   typedef typename std::basic_string<charT, Traits1, Alloc1>::const_iterator ci_t;
   typedef typename match_results<ci_t>::allocator_type match_allocator;
   ci_t last = s.begin();
   std::size_t init_size = max_split;
   re_detail::split_pred<OutputIterator, charT, Traits1, Alloc1> pred(&last, &out, &max_split);
   ci_t i, j;
   i = s.begin();
   j = s.end();
   regex_grep(pred, i, j, e, flags);




   if(max_split && (last != s.end()) && (e.mark_count() == 1))
   {
      *out = std::basic_string<charT, Traits1, Alloc1>((ci_t)last, (ci_t)s.end());
      ++out;
      last = s.end();
      --max_split;
   }


   s.erase(0, last - s.begin());


   return init_size - max_split;
}

template <class OutputIterator, class charT, class Traits1, class Alloc1, class Traits2>
inline std::size_t regex_split(OutputIterator out,
                   std::basic_string<charT, Traits1, Alloc1>& s,
                   const basic_regex<charT, Traits2>& e,
                   match_flag_type flags = match_default)
{
   return regex_split(out, s, e, flags, (2147483647 * 2U + 1U));
}

template <class OutputIterator, class charT, class Traits1, class Alloc1>
inline std::size_t regex_split(OutputIterator out,
                   std::basic_string<charT, Traits1, Alloc1>& s)
{
   return regex_split(out, s, re_detail::get_default_expression(charT(0)), match_default, (2147483647 * 2U + 1U));
}
# 168 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex_split.hpp" 3
}
# 167 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex/v4/regex.hpp" 2 3
# 32 "/Library/Application Support/MonkeyWorks/Developer/include/boost/regex.hpp" 2 3
# 42 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentRegistry.h" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered_map.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered_map.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash.hpp" 1 3
# 10 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/hash.hpp" 1 3
# 13 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/hash.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash_fwd.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash_fwd.hpp" 3
namespace boost
{
    template <class T> struct hash;




    template <class T> void hash_combine(std::size_t& seed, T const& v);


    template <class It> std::size_t hash_range(It, It);
    template <class It> void hash_range(std::size_t&, It, It);





}
# 14 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/hash.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/hash_float.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/hash_float.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/float_functions.hpp" 1 3
# 81 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/float_functions.hpp" 3
namespace boost
{
    namespace hash_detail
    {

        inline float call_ldexp(float v, int exp)
        {
            using namespace std;


            return ldexp(v, exp);



        }

        inline double call_ldexp(double v, int exp)
        {
            using namespace std;
            return ldexp(v, exp);
        }

        inline long double call_ldexp(long double v, int exp)
        {
            using namespace std;

            return ldexp(v, exp);



        }

        inline float call_frexp(float v, int* exp)
        {
            using namespace std;


            return frexp(v, exp);



        }

        inline double call_frexp(double v, int* exp)
        {
            using namespace std;
            return frexp(v, exp);
        }

        inline long double call_frexp(long double v, int* exp)
        {
            using namespace std;

            return frexp(v, exp);



        }
    }
}
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/hash_float.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/integer/static_log2.hpp" 1 3
# 21 "/Library/Application Support/MonkeyWorks/Developer/include/boost/integer/static_log2.hpp" 3
namespace boost {

 namespace detail {

     namespace static_log2_impl {
# 44 "/Library/Application Support/MonkeyWorks/Developer/include/boost/integer/static_log2.hpp" 3
     typedef unsigned long argument_type;
     typedef int result_type;


     template <result_type n>
     struct choose_initial_n {

         enum { c = (argument_type(1) << n << n) != 0 };
         static const result_type value = !c*n + choose_initial_n<2*c*n>::value;




     };

     template <>
     struct choose_initial_n<0> {
         static const result_type value = 0;
     };




     const result_type n_zero = 16;
     const result_type initial_n = choose_initial_n<n_zero>::value;
# 85 "/Library/Application Support/MonkeyWorks/Developer/include/boost/integer/static_log2.hpp" 3
     template <argument_type x, result_type n = initial_n>
     struct static_log2_impl {

         enum { c = (x >> n) > 0 };
         static const result_type value = c*n + (static_log2_impl< (x>>c*n), n/2 >::value);




     };

     template <>
     struct static_log2_impl<1, 0> {
        static const result_type value = 0;
     };

     }
 }







 typedef detail::static_log2_impl::argument_type static_log2_argument_type;
 typedef detail::static_log2_impl::result_type static_log2_result_type;


 template <static_log2_argument_type x>
 struct static_log2 {

     static const static_log2_result_type value = detail::static_log2_impl::static_log2_impl<x>::value;




 };


 template <>
 struct static_log2<0> { };

}
# 27 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/hash_float.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/cstdint.hpp" 1 3
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/hash_float.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 30 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/hash_float.hpp" 2 3
# 64 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/hash_float.hpp" 3
namespace boost
{
    namespace hash_detail
    {
        template <class T>
        struct limits : std::numeric_limits<T> {};
# 94 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/hash_float.hpp" 3
        inline void hash_float_combine(std::size_t& seed, std::size_t value)
        {
            seed ^= value + (seed<<6) + (seed>>2);
        }
# 127 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/hash_float.hpp" 3
        template <class T>
        inline std::size_t float_hash_impl(T v)
        {
            int exp = 0;

            v = boost::hash_detail::call_frexp(v, &exp);



            if(v < 0) {
                v = -v;
                exp += limits<T>::max_exponent -
                    limits<T>::min_exponent;
            }



            v -= T(0.5);
            v = boost::hash_detail::call_ldexp(v,
                    limits<std::size_t>::digits + 1);
            std::size_t seed = static_cast<std::size_t>(v);
            v -= seed;


            std::size_t const length
                = (limits<T>::digits *
                        boost::static_log2<limits<T>::radix>::value - 1)
                / limits<std::size_t>::digits;

            for(std::size_t i = 0; i != length; ++i)
            {
                v = boost::hash_detail::call_ldexp(v,
                        limits<std::size_t>::digits);
                std::size_t part = static_cast<std::size_t>(v);
                v -= part;
                hash_float_combine(seed, part);
            }

            hash_float_combine(seed, exp);

            return seed;
        }


        template <class T>
        inline std::size_t float_hash_value(T v)
        {
# 191 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/hash_float.hpp" 3
            return v == 0 ? 0 : float_hash_impl(v);

        }
    }
}
# 16 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/hash.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/container_fwd.hpp" 1 3
# 60 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/detail/container_fwd.hpp" 3
namespace std
{
    template <class T> class allocator;
    template <class charT, class traits, class Allocator> class basic_string;
    template <class charT> struct char_traits;
    template <class T> class complex;
}


namespace std
{

    template <class T, class Allocator> class deque;


    template <class T, class Allocator> class list;
    template <class T, class Allocator> class vector;
    template <class Key, class T, class Compare, class Allocator> class map;
    template <class Key, class T, class Compare, class Allocator>
    class multimap;
    template <class Key, class Compare, class Allocator> class set;
    template <class Key, class Compare, class Allocator> class multiset;


    template <size_t N> class bitset;

    template <class T1, class T2> struct pair;
}
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/hash.hpp" 2 3
# 31 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/hash.hpp" 3
namespace boost
{
    std::size_t hash_value(bool);
    std::size_t hash_value(char);
    std::size_t hash_value(unsigned char);
    std::size_t hash_value(signed char);
    std::size_t hash_value(short);
    std::size_t hash_value(unsigned short);
    std::size_t hash_value(int);
    std::size_t hash_value(unsigned int);
    std::size_t hash_value(long);
    std::size_t hash_value(unsigned long);


    std::size_t hash_value(wchar_t);



    std::size_t hash_value(boost::long_long_type);
    std::size_t hash_value(boost::ulong_long_type);



    template <class T> std::size_t hash_value(T* const&);





    template< class T, unsigned N >
    std::size_t hash_value(const T (&array)[N]);

    template< class T, unsigned N >
    std::size_t hash_value(T (&array)[N]);


    std::size_t hash_value(float v);
    std::size_t hash_value(double v);
    std::size_t hash_value(long double v);

    template <class Ch, class A>
    std::size_t hash_value(std::basic_string<Ch, std::char_traits<Ch>, A> const&);

    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const&);
    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const&);
    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v);
    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v);

    template <class T>
    std::size_t hash_value(std::complex<T> const&);



    namespace hash_detail
    {
        template <class T>
        inline std::size_t hash_value_signed(T val)
        {
             const int size_t_bits = std::numeric_limits<std::size_t>::digits;

             const int length = (std::numeric_limits<T>::digits - 1)
                 / size_t_bits;

             std::size_t seed = 0;
             T positive = val < 0 ? -1 - val : val;


             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (positive >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);

             return seed;
        }

        template <class T>
        inline std::size_t hash_value_unsigned(T val)
        {
             const int size_t_bits = std::numeric_limits<std::size_t>::digits;

             const int length = (std::numeric_limits<T>::digits - 1)
                 / size_t_bits;

             std::size_t seed = 0;


             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (val >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);

             return seed;
        }
    }

    inline std::size_t hash_value(bool v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(char v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned char v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(signed char v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(short v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned short v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(int v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned int v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(long v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned long v)
    {
        return static_cast<std::size_t>(v);
    }


    inline std::size_t hash_value(wchar_t v)
    {
        return static_cast<std::size_t>(v);
    }



    inline std::size_t hash_value(boost::long_long_type v)
    {
        return hash_detail::hash_value_signed(v);
    }

    inline std::size_t hash_value(boost::ulong_long_type v)
    {
        return hash_detail::hash_value_unsigned(v);
    }




    template <class T> std::size_t hash_value(T* const& v)



    {
        std::size_t x = static_cast<std::size_t>(
           reinterpret_cast<std::ptrdiff_t>(v));

        return x + (x >> 3);
    }





    template <class T>
    inline void hash_combine(std::size_t& seed, T const& v)

    {
        boost::hash<T> hasher;
        seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
    }

    template <class It>
    inline std::size_t hash_range(It first, It last)
    {
        std::size_t seed = 0;

        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }

        return seed;
    }

    template <class It>
    inline void hash_range(std::size_t& seed, It first, It last)
    {
        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }
    }
# 283 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/hash.hpp" 3
    template< class T, unsigned N >
    inline std::size_t hash_value(const T (&array)[N])
    {
        return hash_range(array, array + N);
    }

    template< class T, unsigned N >
    inline std::size_t hash_value(T (&array)[N])
    {
        return hash_range(array, array + N);
    }


    template <class Ch, class A>
    inline std::size_t hash_value(std::basic_string<Ch, std::char_traits<Ch>, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    inline std::size_t hash_value(float v)
    {
        return boost::hash_detail::float_hash_value(v);
    }

    inline std::size_t hash_value(double v)
    {
        return boost::hash_detail::float_hash_value(v);
    }

    inline std::size_t hash_value(long double v)
    {
        return boost::hash_detail::float_hash_value(v);
    }

    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const& v)
    {
        std::size_t seed = 0;
        hash_combine(seed, v.first);
        hash_combine(seed, v.second);
        return seed;
    }

    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class T>
    std::size_t hash_value(std::complex<T> const& v)
    {
        boost::hash<T> hasher;
        std::size_t seed = hasher(v.imag());
        seed ^= hasher(v.real()) + (seed<<6) + (seed>>2);
        return seed;
    }
# 441 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/hash.hpp" 3
    template <> struct hash<bool> : public std::unary_function<bool, std::size_t> { std::size_t operator()(bool v) const { return boost::hash_value(v); } };
    template <> struct hash<char> : public std::unary_function<char, std::size_t> { std::size_t operator()(char v) const { return boost::hash_value(v); } };
    template <> struct hash<signed char> : public std::unary_function<signed char, std::size_t> { std::size_t operator()(signed char v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned char> : public std::unary_function<unsigned char, std::size_t> { std::size_t operator()(unsigned char v) const { return boost::hash_value(v); } };

    template <> struct hash<wchar_t> : public std::unary_function<wchar_t, std::size_t> { std::size_t operator()(wchar_t v) const { return boost::hash_value(v); } };

    template <> struct hash<short> : public std::unary_function<short, std::size_t> { std::size_t operator()(short v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned short> : public std::unary_function<unsigned short, std::size_t> { std::size_t operator()(unsigned short v) const { return boost::hash_value(v); } };
    template <> struct hash<int> : public std::unary_function<int, std::size_t> { std::size_t operator()(int v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned int> : public std::unary_function<unsigned int, std::size_t> { std::size_t operator()(unsigned int v) const { return boost::hash_value(v); } };
    template <> struct hash<long> : public std::unary_function<long, std::size_t> { std::size_t operator()(long v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned long> : public std::unary_function<unsigned long, std::size_t> { std::size_t operator()(unsigned long v) const { return boost::hash_value(v); } };

    template <> struct hash<float> : public std::unary_function<float, std::size_t> { std::size_t operator()(float v) const { return boost::hash_value(v); } };
    template <> struct hash<double> : public std::unary_function<double, std::size_t> { std::size_t operator()(double v) const { return boost::hash_value(v); } };
    template <> struct hash<long double> : public std::unary_function<long double, std::size_t> { std::size_t operator()(long double v) const { return boost::hash_value(v); } };

    template <> struct hash<std::string> : public std::unary_function<std::string, std::size_t> { std::size_t operator()(std::string const& v) const { return boost::hash_value(v); } };

    template <> struct hash<std::wstring> : public std::unary_function<std::wstring, std::size_t> { std::size_t operator()(std::wstring const& v) const { return boost::hash_value(v); } };






    template <class T>
    struct hash<T*>
        : public std::unary_function<T*, std::size_t>
    {
        std::size_t operator()(T* v) const
        {

            return boost::hash_value(v);






        }
    };
# 518 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/hash.hpp" 3
}
# 528 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/hash.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/extensions.hpp" 1 3
# 17 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/extensions.hpp" 3
namespace boost
{
# 66 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/extensions.hpp" 3
    template <class T> struct hash
        : std::unary_function<T, std::size_t>
    {

        std::size_t operator()(T const& val) const
        {
            return hash_value(val);
        }






    };
# 180 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/extensions.hpp" 3
}
# 529 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash/hash.hpp" 2 3
# 11 "/Library/Application Support/MonkeyWorks/Developer/include/boost/functional/hash.hpp" 2 3
# 22 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered_map.hpp" 2 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table.hpp" 1 3
# 25 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 1 3
# 36 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.5.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
void __eprintf(const char *, const char *, unsigned, const char *) __attribute__((__noreturn__));
}
# 37 "/Library/Application Support/MonkeyWorks/Developer/include/boost/assert.hpp" 2 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table.hpp" 2 3

# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/allocator_helpers.hpp" 1 3
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/allocator_helpers.hpp" 3
namespace boost {
    namespace unordered_detail {





        template <class Alloc, class T>
        struct rebind_wrap
        {
            typedef typename
                Alloc::template rebind<T>::other
                type;
        };



        template <class T>
        inline void reset(T& x) { x = T(); }

        template <class Ptr>
        inline Ptr null_ptr() { return Ptr(); }
# 62 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/allocator_helpers.hpp" 3
        template <class Allocator> struct allocator_value_type
        {
            typedef typename Allocator::value_type type;
        };

        template <class Allocator> struct allocator_pointer
        {
            typedef typename Allocator::pointer type;
        };

        template <class Allocator> struct allocator_const_pointer
        {
            typedef typename Allocator::const_pointer type;
        };

        template <class Allocator> struct allocator_reference
        {
            typedef typename Allocator::reference type;
        };

        template <class Allocator> struct allocator_const_reference
        {
            typedef typename Allocator::const_reference type;
        };
# 121 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/allocator_helpers.hpp" 3
        template <class Allocator>
        struct allocator_constructor
        {
            typedef typename allocator_value_type<Allocator>::type value_type;
            typedef typename allocator_pointer<Allocator>::type pointer;

            Allocator& alloc_;
            pointer ptr_;
            bool constructed_;

            allocator_constructor(Allocator& a)
                : alloc_(a), ptr_(), constructed_(false)
            {



            }

            ~allocator_constructor() {
                if(ptr_) {
                    if(constructed_) alloc_.destroy(ptr_);
                    alloc_.deallocate(ptr_, 1);
                }
            }

            template <class V>
            void construct(V const& v) {
                (__builtin_expect(!(!ptr_ && !constructed_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/allocator_helpers.hpp", 148, "!ptr_ && !constructed_") : (void)0);
                ptr_ = alloc_.allocate(1);
                alloc_.construct(ptr_, value_type(v));
                constructed_ = true;
            }

            void construct(value_type const& v) {
                (__builtin_expect(!(!ptr_ && !constructed_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/allocator_helpers.hpp", 155, "!ptr_ && !constructed_") : (void)0);
                ptr_ = alloc_.allocate(1);
                alloc_.construct(ptr_, v);
                constructed_ = true;
            }

            pointer get() const
            {
                return ptr_;
            }


            pointer release()
            {
                pointer p = ptr_;
                constructed_ = false;
                unordered_detail::reset(ptr_);
                return p;
            }
        };

        template <class Allocator>
        struct allocator_array_constructor
        {
            typedef typename allocator_pointer<Allocator>::type pointer;

            Allocator& alloc_;
            pointer ptr_;
            pointer constructed_;
            std::size_t length_;

            allocator_array_constructor(Allocator& a)
                : alloc_(a), ptr_(), constructed_(), length_(0)
            {




            }

            ~allocator_array_constructor() {
                if (ptr_) {
                    for(pointer p = ptr_; p != constructed_; ++p)
                        alloc_.destroy(p);

                    alloc_.deallocate(ptr_, length_);
                }
            }

            template <class V>
            void construct(V const& v, std::size_t l)
            {
                (__builtin_expect(!(!ptr_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/allocator_helpers.hpp", 207, "!ptr_") : (void)0);
                length_ = l;
                ptr_ = alloc_.allocate(length_);
                pointer end = ptr_ + static_cast<std::ptrdiff_t>(length_);
                for(constructed_ = ptr_; constructed_ != end; ++constructed_)
                    alloc_.construct(constructed_, v);
            }

            pointer get() const
            {
                return ptr_;
            }

            pointer release()
            {
                pointer p(ptr_);
                unordered_detail::reset(ptr_);
                return p;
            }
        private:
            allocator_array_constructor(allocator_array_constructor const&);
            allocator_array_constructor& operator=(allocator_array_constructor const&);
        };
    }
}
# 28 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table.hpp" 2 3
# 54 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table.hpp" 3
namespace boost {
    namespace unordered_detail {
        template <class T> struct type_wrapper {};

        static const std::size_t default_initial_bucket_count = 50;
        static const float minimum_max_load_factor = 1e-3f;

        template <class T>
        inline void hash_swap(T& x, T& y)
        {



            using std::swap;
            swap(x, y);

        }

        inline std::size_t double_to_size_t(double f)
        {
            return f >= static_cast<double>((std::numeric_limits<std::size_t>::max)()) ?
                (std::numeric_limits<std::size_t>::max)() :
                static_cast<std::size_t>(f);
        }



        template<typename T> struct prime_list_template
        {
            static std::size_t const value[];
            static std::ptrdiff_t const length;
        };

        template<typename T>
        std::size_t const prime_list_template<T>::value[] = {
            53ul, 97ul, 193ul, 389ul, 769ul,
            1543ul, 3079ul, 6151ul, 12289ul, 24593ul,
            49157ul, 98317ul, 196613ul, 393241ul, 786433ul,
            1572869ul, 3145739ul, 6291469ul, 12582917ul, 25165843ul,
            50331653ul, 100663319ul, 201326611ul, 402653189ul, 805306457ul,
            1610612741ul, 3221225473ul, 4294967291ul };

        template<typename T>
        std::ptrdiff_t const prime_list_template<T>::length = 28;

        typedef prime_list_template<std::size_t> prime_list;


        inline std::size_t next_prime(std::size_t n) {
            std::size_t const* const prime_list_begin = prime_list::value;
            std::size_t const* const prime_list_end = prime_list_begin +
                prime_list::length;
            std::size_t const* bound =
                std::lower_bound(prime_list_begin, prime_list_end, n);
            if(bound == prime_list_end)
                bound--;
            return *bound;
        }


        inline std::size_t prev_prime(std::size_t n) {
            std::size_t const* const prime_list_begin = prime_list::value;
            std::size_t const* const prime_list_end = prime_list_begin +
                prime_list::length;
            std::size_t const* bound =
                std::upper_bound(prime_list_begin,prime_list_end, n);
            if(bound != prime_list_begin)
                bound--;
            return *bound;
        }





        struct bucket_manager {
            std::size_t bucket_count_;

            bucket_manager()
                : bucket_count_(0) {}

            explicit bucket_manager(std::size_t n)
                : bucket_count_(next_prime(n)) {}

            std::size_t bucket_count() const {
                return bucket_count_;
            }

            std::size_t bucket_from_hash(std::size_t hashed) const {
                return hashed % bucket_count_;
            }

            std::size_t max_bucket_count(std::size_t max_size) const {
                return prev_prime(max_size);
            }
        };



        template <class Dst1, class Dst2, class Src1, class Src2>
        inline std::pair<Dst1, Dst2> pair_cast(std::pair<Src1, Src2> const& x)
        {
            return std::pair<Dst1, Dst2>(Dst1(x.first), Dst2(x.second));
        }


        using ::std::distance;
# 170 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table.hpp" 3
        struct move_tag {};




        template <typename Hash, typename Pred>
        struct buffered_functions
        {
            typedef Hash hasher;
            typedef Pred key_equal;

            class functions
            {
                std::pair<hasher, key_equal> functions_;

            public:

                functions(hasher const& h, key_equal const& k)
                    : functions_(h, k) {}

                hasher const& hash_function() const
                {
                    return functions_.first;
                }

                key_equal const& key_eq() const
                {
                    return functions_.second;
                }
            };

            typedef functions buffered_functions::*functions_ptr;

            buffered_functions(hasher const& h, key_equal const& k)
                : func1_(h, k), func2_(h, k), func_(&buffered_functions::func1_) {}







            functions_ptr buffer(buffered_functions const& x) {
                functions_ptr ptr = func_ == &buffered_functions::func1_
                    ? &buffered_functions::func2_ : &buffered_functions::func1_;
                this->*ptr = x.current();
                return ptr;
            }

            void set(functions_ptr ptr) {
                (__builtin_expect(!(ptr != func_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table.hpp", 220, "ptr != func_") : (void)0);
                func_ = ptr;
            }

            functions const& current() const {
                return this->*func_;
            }

        private:
            functions func1_;
            functions func2_;
            functions_ptr func_;
        };

    }
}


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
namespace boost {
    namespace unordered_detail {






        template <typename Alloc>
        class hash_table_data_equivalent_keys
        {
        public:
            typedef hash_table_data_equivalent_keys data;

            struct node_base;
            struct node;
            struct bucket;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;

            typedef Alloc value_allocator;

            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, node>::type
                node_allocator;
            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, node_base>::type
                node_base_allocator;
            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, bucket>::type
                bucket_allocator;

            typedef typename allocator_value_type<Alloc>::type value_type;
            typedef typename allocator_pointer<node_allocator>::type node_ptr;
            typedef typename allocator_pointer<bucket_allocator>::type bucket_ptr;
            typedef typename allocator_reference<value_allocator>::type reference;
            typedef typename allocator_reference<bucket_allocator>::type bucket_reference;

            typedef bucket_ptr link_ptr;





            struct bucket
            {
            private:
                bucket& operator=(bucket const&);
            public:
                link_ptr next_;

                bucket() : next_()
                {
                    ;
                }

                bucket(bucket const& x) : next_(x.next_)
                {

                    (__builtin_expect(!(!x.next_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 82, "!x.next_") : (void)0);
                }

                bool empty() const
                {
                    return !this->next_;
                }
            };





            struct node_base : bucket
            {

            public:
                node_base() : group_prev_()
                {
                    ;
                }

                link_ptr group_prev_;

            };

            struct node : node_base
            {
            public:





                node(value_type const& v) : node_base(), value_(v) {}


                value_type value_;
            };
# 219 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            struct allocators
            {
                node_allocator node_alloc_;
                bucket_allocator bucket_alloc_;
                value_allocator value_alloc_;
                node_base_allocator node_base_alloc_;

                allocators(value_allocator const& a)
                    : node_alloc_(a), bucket_alloc_(a),
                    value_alloc_(a), node_base_alloc_(a)
                {}

                void destroy(link_ptr ptr)
                {
                    node_ptr n(node_alloc_.address(*static_cast<node*>(&*ptr)));
                    value_alloc_.destroy(value_alloc_.address(n->value_));
                    node_base_alloc_.destroy(node_base_alloc_.address(*n));
                    node_alloc_.deallocate(n, 1);
                }

                void swap(allocators& x)
                {
                    unordered_detail::hash_swap(node_alloc_, x.node_alloc_);
                    unordered_detail::hash_swap(bucket_alloc_, x.bucket_alloc_);
                    unordered_detail::hash_swap(value_alloc_, x.value_alloc_);
                    unordered_detail::hash_swap(node_base_alloc_, x.node_base_alloc_);
                }

                bool operator==(allocators const& x)
                {
                    return value_alloc_ == x.value_alloc_;
                }
            };





            class node_constructor
            {
                allocators& allocators_;

                node_ptr node_;
                bool value_constructed_;
                bool node_base_constructed_;

            public:

                node_constructor(allocators& a)
                    : allocators_(a),
                    node_(), value_constructed_(false), node_base_constructed_(false)
                {
                    ;
                }

                ~node_constructor()
                {
                    if (node_) {
                        if (value_constructed_)
                            allocators_.value_alloc_.destroy(
                                allocators_.value_alloc_.address(node_->value_));
                        if (node_base_constructed_)
                            allocators_.node_base_alloc_.destroy(
                                allocators_.node_base_alloc_.address(*node_));

                        allocators_.node_alloc_.deallocate(node_, 1);
                    }
                }

                template <typename V>
                void construct(V const& v)
                {
                    (__builtin_expect(!(!node_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 291, "!node_") : (void)0);
                    value_constructed_ = false;
                    node_base_constructed_ = false;

                    node_ = allocators_.node_alloc_.allocate(1);

                    allocators_.node_base_alloc_.construct(
                            allocators_.node_base_alloc_.address(*node_),
                            node_base());
                    node_base_constructed_ = true;

                    allocators_.value_alloc_.construct(
                            allocators_.value_alloc_.address(node_->value_), v);
                    value_constructed_ = true;
                }

                node_ptr get() const
                {
                    (__builtin_expect(!(node_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 309, "node_") : (void)0);
                    return node_;
                }


                link_ptr release()
                {
                    node_ptr p = node_;
                    unordered_detail::reset(node_);
                    return link_ptr(allocators_.bucket_alloc_.address(*p));
                }

            private:
                node_constructor(node_constructor const&);
                node_constructor& operator=(node_constructor const&);
            };





            static inline link_ptr& prev_in_group(link_ptr n) {
                return static_cast<node*>(&*n)->group_prev_;
            }


            static inline link_ptr& next_group(link_ptr n) {
                (__builtin_expect(!(n && n != prev_in_group(n)->next_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 336, "n && n != prev_in_group(n)->next_") : (void)0);
                return prev_in_group(n)->next_;
            }
# 347 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            static inline node& get_node(link_ptr p) {
                (__builtin_expect(!(p), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 348, "p") : (void)0);
                return *static_cast<node*>(&*p);
            }


            static inline reference get_value(link_ptr p) {
                (__builtin_expect(!(p), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 354, "p") : (void)0);
                return static_cast<node*>(&*p)->value_;
            }

            class iterator_base
            {
                typedef hash_table_data_equivalent_keys<Alloc> data;
            public:
                bucket_ptr bucket_;
                link_ptr node_;

                iterator_base()
                    : bucket_(), node_()
                {
                    ;
                    ;
                }

                explicit iterator_base(bucket_ptr b)
                    : bucket_(b), node_(b->next_) {}

                iterator_base(bucket_ptr b, link_ptr n)
                    : bucket_(b), node_(n) {}

                bool operator==(iterator_base const& x) const
                {
                    return node_ == x.node_;
                }

                bool operator!=(iterator_base const& x) const
                {
                    return node_ != x.node_;
                }

                reference operator*() const
                {
                    return get_value(node_);
                }

                void increment()
                {
                    (__builtin_expect(!(bucket_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 395, "bucket_") : (void)0);
                    node_ = node_->next_;

                    while (!node_) {
                        ++bucket_;
                        node_ = bucket_->next_;
                    }
                }

                void increment_group()
                {
                    node_ = data::next_group(node_);

                    while (!node_) {
                        ++bucket_;
                        node_ = bucket_->next_;
                    }
                }
            };



            allocators allocators_;
            bucket_ptr buckets_;
            bucket_manager bucket_manager_;
            bucket_ptr cached_begin_bucket_;
            size_type size_;



            hash_table_data_equivalent_keys(size_type n, value_allocator const& a)
              : allocators_(a),
                buckets_(), bucket_manager_(n),
                cached_begin_bucket_(), size_(0)
            {
                ;
                create_buckets();
            }

            hash_table_data_equivalent_keys(hash_table_data_equivalent_keys const& x, size_type n)
              : allocators_(x.allocators_),
                buckets_(), bucket_manager_(n),
                cached_begin_bucket_(), size_(0)
            {
                ;
                create_buckets();
            }

            hash_table_data_equivalent_keys(hash_table_data_equivalent_keys& x, move_tag)
                : allocators_(x.allocators_),
                buckets_(x.buckets_), bucket_manager_(x.bucket_manager_),
                cached_begin_bucket_(x.cached_begin_bucket_), size_(x.size_)
            {
                unordered_detail::reset(x.buckets_);
            }

            hash_table_data_equivalent_keys(hash_table_data_equivalent_keys& x,
                    value_allocator const& a, size_type n, move_tag)
                : allocators_(a), buckets_(), bucket_manager_(),
                cached_begin_bucket_(), size_(0)
            {
                if(allocators_ == x.allocators_) {
                    buckets_ = x.buckets_;
                    bucket_manager_ = x.bucket_manager_;
                    cached_begin_bucket_ = x.cached_begin_bucket_;
                    size_ = x.size_;
                    unordered_detail::reset(x.buckets_);
                }
                else {
                    ;
                    bucket_manager_ = bucket_manager(n);
                    create_buckets();
                }
            }


            ~hash_table_data_equivalent_keys()
            {
                delete_buckets();
            }

            void create_buckets() {
                size_type bucket_count = bucket_manager_.bucket_count();



                allocator_array_constructor<bucket_allocator>
                    constructor(allocators_.bucket_alloc_);


                constructor.construct(bucket(), bucket_count + 1);

                cached_begin_bucket_ = constructor.get() + static_cast<difference_type>(bucket_count);


                cached_begin_bucket_->next_ = link_ptr(cached_begin_bucket_);



                buckets_ = constructor.release();
            }


            void delete_buckets()
            {
                if(buckets_) {
                    bucket_ptr begin = cached_begin_bucket_;
                    bucket_ptr end = buckets_end();
                    while(begin != end) {
                        clear_bucket(begin);
                        ++begin;
                    }


                    ++end;
                    for(begin = buckets_; begin != end; ++begin)
                        allocators_.bucket_alloc_.destroy(begin);

                    allocators_.bucket_alloc_.deallocate(buckets_,
                        bucket_manager_.bucket_count() + 1);
                }
            }

        private:

            hash_table_data_equivalent_keys(hash_table_data_equivalent_keys const&);
            hash_table_data_equivalent_keys& operator=(hash_table_data_equivalent_keys const&);

        public:


            void swap(hash_table_data_equivalent_keys& other)
            {
                std::swap(buckets_, other.buckets_);
                std::swap(bucket_manager_, other.bucket_manager_);
                std::swap(cached_begin_bucket_, other.cached_begin_bucket_);
                std::swap(size_, other.size_);
            }


            void move(hash_table_data_equivalent_keys& other)
            {
                delete_buckets();
                buckets_ = other.buckets_;
                unordered_detail::reset(other.buckets_);
                bucket_manager_ = other.bucket_manager_;
                cached_begin_bucket_ = other.cached_begin_bucket_;
                size_ = other.size_;
            }




            size_type bucket_from_hash(size_type hashed) const
            {
                return bucket_manager_.bucket_from_hash(hashed);
            }




            bucket_ptr bucket_ptr_from_hash(size_type hashed) const
            {
                return buckets_ + static_cast<difference_type>(
                    bucket_manager_.bucket_from_hash(hashed));
            }





            bucket_ptr buckets_end() const
            {
                return buckets_ + static_cast<difference_type>(bucket_manager_.bucket_count());
            }

            iterator_base begin() const
            {
                return size_
                    ? iterator_base(cached_begin_bucket_)
                    : end();
            }

            iterator_base end() const
            {
                return iterator_base(buckets_end());
            }

            link_ptr begin(size_type n) const
            {
                return (buckets_ + static_cast<difference_type>(n))->next_;
            }

            link_ptr end(size_type) const
            {
                return unordered_detail::null_ptr<link_ptr>();
            }

            link_ptr begin(bucket_ptr b) const
            {
                return b->next_;
            }




            static inline size_type node_count(link_ptr it)
            {
                size_type count = 0;
                while(it) {
                    ++count;
                    it = it->next_;
                }
                return count;
            }

            static inline size_type node_count(link_ptr it1, link_ptr it2)
            {
                size_type count = 0;
                while(it1 != it2) {
                    ++count;
                    it1 = it1->next_;
                }
                return count;
            }

            size_type bucket_size(size_type n) const
            {
                return node_count(begin(n));
            }


            static inline size_type group_count(link_ptr it)
            {
                return node_count(it, next_group(it));
            }
# 645 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            static link_ptr* get_for_erase(iterator_base r)
            {
                link_ptr n = r.node_;




                link_ptr* it = &prev_in_group(n)->next_;
                if(*it == n) return it;



                it = &r.bucket_->next_;
                while(*it != n) it = &hash_table_data_equivalent_keys::next_group(*it);
                return it;
            }
# 681 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            link_ptr link_node(node_constructor& a, link_ptr pos)
            {
                link_ptr n = a.release();
                node& node_ref = get_node(n);
                node& pos_ref = get_node(pos);
                node_ref.next_ = pos_ref.group_prev_->next_;
                node_ref.group_prev_ = pos_ref.group_prev_;
                pos_ref.group_prev_->next_ = n;
                pos_ref.group_prev_ = n;
                ++size_;
                return n;
            }

            link_ptr link_node_in_bucket(node_constructor& a, bucket_ptr base)
            {
                link_ptr n = a.release();
                node& node_ref = get_node(n);
                node_ref.next_ = base->next_;
                node_ref.group_prev_ = n;
                base->next_ = n;
                ++size_;
                if(base < cached_begin_bucket_) cached_begin_bucket_ = base;
                return n;
            }

            void link_group(link_ptr n, bucket_ptr base, size_type count)
            {
                node& node_ref = get_node(n);
                node& last_ref = get_node(node_ref.group_prev_);
                last_ref.next_ = base->next_;
                base->next_ = n;
                size_ += count;
                if(base < cached_begin_bucket_) cached_begin_bucket_ = base;
            }
# 738 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void unlink_node(iterator_base it)
            {
                link_ptr* pos = get_for_erase(it);
                node* n = &get_node(it.node_);
                link_ptr next = n->next_;

                if(n->group_prev_ == *pos) {


                }
                else if(next && prev_in_group(next) == *pos)
                {


                    prev_in_group(next) = n->group_prev_;
                }
                else {



                    link_ptr it = n->group_prev_;
                    while(prev_in_group(it) != *pos) {
                        it = prev_in_group(it);
                    }
                    prev_in_group(it) = n->group_prev_;
                }
                *pos = next;
                --size_;
            }

            size_type unlink_group(link_ptr* pos)
            {
                size_type count = group_count(*pos);
                size_ -= count;
                *pos = next_group(*pos);
                return count;
            }
# 791 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void unlink_nodes(iterator_base n)
            {
                link_ptr* it = get_for_erase(n);
                split_group(*it);
                unordered_detail::reset(*it);
                size_ -= node_count(n.node_);
            }

            void unlink_nodes(iterator_base begin, iterator_base end)
            {
                (__builtin_expect(!(begin.bucket_ == end.bucket_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 801, "begin.bucket_ == end.bucket_") : (void)0);
                size_ -= node_count(begin.node_, end.node_);
                link_ptr* it = get_for_erase(begin);
                split_group(*it, end.node_);
                *it = end.node_;
            }

            void unlink_nodes(bucket_ptr base, iterator_base end)
            {
                (__builtin_expect(!(base == end.bucket_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 810, "base == end.bucket_") : (void)0);

                split_group(end.node_);

                link_ptr ptr(base->next_);
                base->next_ = end.node_;

                size_ -= node_count(ptr, end.node_);
            }





            static inline link_ptr split_group(link_ptr split)
            {


                if(prev_in_group(split)->next_ != split)
                    return unordered_detail::null_ptr<link_ptr>();


                link_ptr start = split;
                do {
                    start = prev_in_group(start);
                } while(prev_in_group(start)->next_ == start);

                link_ptr last = prev_in_group(start);
                prev_in_group(start) = prev_in_group(split);
                prev_in_group(split) = last;

                return start;
            }

            static inline void split_group(link_ptr split1, link_ptr split2)
            {
                link_ptr begin1 = split_group(split1);
                link_ptr begin2 = split_group(split2);

                if(begin1 && split1 == begin2) {
                    link_ptr end1 = prev_in_group(begin1);
                    prev_in_group(begin1) = prev_in_group(begin2);
                    prev_in_group(begin2) = end1;
                }
            }
# 871 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void copy_group(link_ptr it, bucket_ptr dst)
            {
                node_constructor a(allocators_);

                link_ptr end = next_group(it);

                a.construct(get_value(it));
                link_ptr n = link_node_in_bucket(a, dst);

                for(it = it->next_; it != end; it = it->next_) {
                    a.construct(get_value(it));
                    link_node(a, n);
                }
            }
# 902 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void delete_to_bucket_end(link_ptr begin)
            {
                while(begin) {
                    link_ptr node = begin;
                    begin = begin->next_;
                    allocators_.destroy(node);
                }
            }

            void delete_nodes(link_ptr begin, link_ptr end)
            {
                while(begin != end) {
                    link_ptr node = begin;
                    begin = begin->next_;
                    allocators_.destroy(node);
                }
            }


            void delete_group(link_ptr first_node)
            {
                delete_nodes(first_node, prev_in_group(first_node)->next_);
            }
# 938 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void clear_bucket(bucket_ptr b)
            {
                link_ptr first_node = b->next_;
                unordered_detail::reset(b->next_);
                delete_to_bucket_end(first_node);
            }

            void clear()
            {
                bucket_ptr begin = cached_begin_bucket_;
                bucket_ptr end = buckets_end();

                size_ = 0;
                cached_begin_bucket_ = end;

                while(begin != end) {
                    clear_bucket(begin);
                    ++begin;
                }
            }





            iterator_base erase(iterator_base r)
            {
                (__builtin_expect(!(r != end()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 965, "r != end()") : (void)0);
                iterator_base next = r;
                next.increment();
                unlink_node(r);
                allocators_.destroy(r.node_);

                recompute_begin_bucket(r.bucket_, next.bucket_);
                return next;
            }

            iterator_base erase_range(iterator_base r1, iterator_base r2)
            {
                if(r1 != r2)
                {
                    (__builtin_expect(!(r1 != end()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 979, "r1 != end()") : (void)0);

                    if (r1.bucket_ == r2.bucket_) {
                        unlink_nodes(r1, r2);
                        delete_nodes(r1.node_, r2.node_);




                        (__builtin_expect(!(!r1.bucket_->empty()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 988, "!r1.bucket_->empty()") : (void)0);
                    }
                    else {
                        (__builtin_expect(!(r1.bucket_ < r2.bucket_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 991, "r1.bucket_ < r2.bucket_") : (void)0);

                        unlink_nodes(r1);
                        delete_to_bucket_end(r1.node_);

                        bucket_ptr i = r1.bucket_;
                        for(++i; i != r2.bucket_; ++i) {
                            size_ -= node_count(i->next_);
                            clear_bucket(i);
                        }

                        if(r2 != end()) {
                            link_ptr first = r2.bucket_->next_;
                            unlink_nodes(r2.bucket_, r2);
                            delete_nodes(first, r2.node_);
                        }



                        recompute_begin_bucket(r1.bucket_, r2.bucket_);
                    }
                }

                return r2;
            }
# 1024 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void recompute_begin_bucket(bucket_ptr b)
            {
                (__builtin_expect(!(!(b < cached_begin_bucket_)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1026, "!(b < cached_begin_bucket_)") : (void)0);

                if(b == cached_begin_bucket_)
                {
                    if (size_ != 0) {
                        while (cached_begin_bucket_->empty())
                            ++cached_begin_bucket_;
                    } else {
                        cached_begin_bucket_ = buckets_end();
                    }
                }
            }





            void recompute_begin_bucket(bucket_ptr b1, bucket_ptr b2)
            {
                (__builtin_expect(!(!(b1 < cached_begin_bucket_) && !(b2 < b1)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1045, "!(b1 < cached_begin_bucket_) && !(b2 < b1)") : (void)0);
                (__builtin_expect(!(b2 == buckets_end() || !b2->empty()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1046, "b2 == buckets_end() || !b2->empty()") : (void)0);

                if(b1 == cached_begin_bucket_ && b1->empty())
                    cached_begin_bucket_ = b2;
            }

            size_type erase_group(link_ptr* it, bucket_ptr bucket)
            {
                link_ptr pos = *it;
                size_type count = unlink_group(it);
                delete_group(pos);

                this->recompute_begin_bucket(bucket);

                return count;
            }
        };
# 1078 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
        template <typename ValueType, typename KeyType,
            typename Hash, typename Pred,
            typename Alloc>
        class hash_table_equivalent_keys
        {
            typedef hash_table_data_equivalent_keys<Alloc> data;

            typedef typename data::node_constructor node_constructor;
            typedef typename data::bucket_ptr bucket_ptr;
            typedef typename data::link_ptr link_ptr;

        public:

            typedef typename data::value_allocator value_allocator;
            typedef typename data::node_allocator node_allocator;



            typedef KeyType key_type;
            typedef Hash hasher;
            typedef Pred key_equal;
            typedef ValueType value_type;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;



            typedef typename data::iterator_base iterator_base;

        private:


            typedef boost::unordered_detail::buffered_functions<Hash, Pred>
                function_store;
            typedef typename function_store::functions functions;
            typedef typename function_store::functions_ptr
                functions_ptr;

            function_store functions_;
            float mlf_;
            size_type max_load_;

        public:

            data data_;






            hash_table_equivalent_keys(size_type n,
                    hasher const& hf, key_equal const& eq,
                    value_allocator const& a)
                : functions_(hf, eq),
                mlf_(1.0f),
                data_(n, a)
            {
                calculate_max_load();
            }
# 1149 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            template <typename I>
            size_type initial_size(I i, I j, size_type n,
                    boost::forward_traversal_tag)
            {

                return (std::max)(static_cast<size_type>(unordered_detail::distance(i, j)) + 1, n);
            }

            template <typename I>
            size_type initial_size(I, I, size_type n,
                    boost::incrementable_traversal_tag)
            {
                return n;
            }

            template <typename I>
            size_type initial_size(I i, I j, size_type n)
            {
                typename boost::iterator_traversal<I>::type
                    iterator_traversal_tag;
                return initial_size(i, j, n, iterator_traversal_tag);
            }

            template <typename I>
            hash_table_equivalent_keys(I i, I j, size_type n,
                    hasher const& hf, key_equal const& eq,
                    value_allocator const& a)
                : functions_(hf, eq),
                  mlf_(1.0f),
                  data_(initial_size(i, j, n), a)
            {
                calculate_max_load();


                insert_range(i, j);
            }



            hash_table_equivalent_keys(hash_table_equivalent_keys const& x)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, x.min_buckets_for_size(x.size()))
            {
                calculate_max_load();



                copy_buckets(x.data_, data_, functions_.current());
            }



            hash_table_equivalent_keys(hash_table_equivalent_keys const& x,
                    value_allocator const& a)
                : functions_(x.functions_),
                mlf_(x.mlf_),
                data_(x.min_buckets_for_size(x.size()), a)
            {
                calculate_max_load();



                copy_buckets(x.data_, data_, functions_.current());
            }



            hash_table_equivalent_keys(hash_table_equivalent_keys& x, move_tag m)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, m)
            {
                calculate_max_load();
            }

            hash_table_equivalent_keys(hash_table_equivalent_keys& x,
                    value_allocator const& a, move_tag m)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, a,
                        x.min_buckets_for_size(x.size()), m)
            {
                calculate_max_load();

                if(x.data_.buckets_) {


                    copy_buckets(x.data_, data_, functions_.current());
                }
            }
# 1248 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            hash_table_equivalent_keys& operator=(hash_table_equivalent_keys const& x)
            {
                if(this != &x)
                {
                    data_.clear();
                    functions_.set(functions_.buffer(x.functions_));

                    mlf_ = x.mlf_;
                    calculate_max_load();
                    reserve(x.size());
                    copy_buckets(x.data_, data_, functions_.current());
                }

                return *this;
            }
# 1278 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void swap(hash_table_equivalent_keys& x)
            {





                if(this == &x) return;




                functions_ptr new_func_this = functions_.buffer(x.functions_);
                functions_ptr new_func_that = x.functions_.buffer(functions_);

                if(data_.allocators_ == x.data_.allocators_) {
                    data_.swap(x.data_);
                }
                else {



                    data new_this(data_, x.min_buckets_for_size(x.data_.size_));
                    copy_buckets(x.data_, new_this, functions_.*new_func_this);

                    data new_that(x.data_, min_buckets_for_size(data_.size_));
                    x.copy_buckets(data_, new_that, x.functions_.*new_func_that);


                    data_.swap(new_this);
                    x.data_.swap(new_that);
                }


                std::swap(mlf_, x.mlf_);

                functions_.set(new_func_this);
                x.functions_.set(new_func_that);

                calculate_max_load();
                x.calculate_max_load();
            }
# 1330 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void move(hash_table_equivalent_keys& x)
            {



                functions_ptr new_func_this = functions_.buffer(x.functions_);

                if(data_.allocators_ == x.data_.allocators_) {
                    data_.move(x.data_);
                }
                else {



                    data new_this(data_, x.min_buckets_for_size(x.data_.size_));
                    copy_buckets(x.data_, new_this, functions_.*new_func_this);


                    data_.move(new_this);
                }


                mlf_ = x.mlf_;
                functions_.set(new_func_this);
                calculate_max_load();
            }
# 1366 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            value_allocator get_allocator() const
            {
                return data_.allocators_.value_alloc_;
            }



            hasher const& hash_function() const
            {
                return functions_.current().hash_function();
            }


            key_equal const& key_eq() const
            {
                return functions_.current().key_eq();
            }


            size_type size() const
            {
                return data_.size_;
            }


            bool empty() const
            {
                return data_.size_ == 0;
            }


            size_type max_size() const
            {
                using namespace std;


                return double_to_size_t(ceil(
                        (double) mlf_ * max_bucket_count())) - 1;
            }


            size_type bucket(key_type const& k) const
            {

                return data_.bucket_from_hash(hash_function()(k));
            }



            bucket_ptr get_bucket(key_type const& k) const
            {
                return data_.buckets_ + static_cast<difference_type>(bucket(k));
            }


            size_type bucket_count() const
            {
                return data_.bucket_manager_.bucket_count();
            }


            size_type max_bucket_count() const
            {

                return prev_prime(data_.allocators_.bucket_alloc_.max_size() - 1);
            }

        private:


            size_type min_buckets_for_size(size_type n) const
            {
                (__builtin_expect(!(mlf_ != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1438, "mlf_ != 0") : (void)0);

                using namespace std;







                return double_to_size_t(floor(n / (double) mlf_)) + 1;
            }


            void calculate_max_load()
            {
                using namespace std;



                max_load_ = double_to_size_t(ceil(
                        (double) mlf_ * data_.bucket_manager_.bucket_count()));
            }


            bool reserve(size_type n)
            {
                bool need_to_reserve = n >= max_load_;

                if (need_to_reserve) rehash_impl(min_buckets_for_size(n));
                (__builtin_expect(!(n < max_load_ || n > max_size()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1468, "n < max_load_ || n > max_size()") : (void)0);
                return need_to_reserve;
            }

        public:


            float max_load_factor() const
            {
                return mlf_;
            }


            void max_load_factor(float z)
            {
                (__builtin_expect(!(z > 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1483, "z > 0") : (void)0);
                mlf_ = (std::max)(z, minimum_max_load_factor);
                calculate_max_load();
            }


            float load_factor() const
            {
                (__builtin_expect(!(data_.bucket_manager_.bucket_count() != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1491, "data_.bucket_manager_.bucket_count() != 0") : (void)0);
                return static_cast<float>(data_.size_)
                    / static_cast<float>(data_.bucket_manager_.bucket_count());
            }




            static key_type const& extract_key(value_type const& v)
            {
                return extract(v, (type_wrapper<value_type>*)0);
            }

            static key_type const& extract(value_type const& v,
                    type_wrapper<key_type>*)
            {
                return v;
            }

            static key_type const& extract(value_type const& v,
                    void*)
            {
                return v.first;
            }
# 1551 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
        public:



            void rehash(size_type n)
            {
                using namespace std;


                size_type min_size = min_buckets_for_size(size());

                rehash_impl(min_size > n ? min_size : n);

                (__builtin_expect(!((float) bucket_count() > (float) size() / max_load_factor() && bucket_count() >= n), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1565, "(float) bucket_count() > (float) size() / max_load_factor() && bucket_count() >= n") : (void)0);

            }

        private:



            void rehash_impl(size_type n)
            {
                n = next_prime(n);

                if (n == bucket_count())
                    return;

                data new_buckets(data_, n);
                move_buckets(data_, new_buckets, hash_function());

                new_buckets.swap(data_);
                calculate_max_load();
            }






            static void move_buckets(data& src, data& dst, hasher const& hf)
            {
                (__builtin_expect(!(dst.size_ == 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1593, "dst.size_ == 0") : (void)0);


                bucket_ptr end = src.buckets_end();

                for(; src.cached_begin_bucket_ != end;
                        ++src.cached_begin_bucket_) {
                    bucket_ptr src_bucket = src.cached_begin_bucket_;
                    while(src_bucket->next_) {




                        bucket_ptr dst_bucket = dst.bucket_ptr_from_hash(
                                hf(extract_key(data::get_value(src_bucket->next_))));

                        link_ptr n = src_bucket->next_;
                        size_type count = src.unlink_group(&src_bucket->next_);
                        dst.link_group(n, dst_bucket, count);
                    }
                }
            }




            static void copy_buckets(data const& src, data& dst, functions const& f)
            {
                (__builtin_expect(!(dst.size_ == 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1621, "dst.size_ == 0") : (void)0);

                bucket_ptr end = src.buckets_end();
                hasher const& hf = f.hash_function();


                for(bucket_ptr i = src.cached_begin_bucket_; i != end; ++i) {

                    for(link_ptr it = src.begin(i);
                            it; it = data::next_group(it)) {

                        bucket_ptr dst_bucket = dst.bucket_ptr_from_hash(
                                hf(extract_key(data::get_value(it))));

                        dst.copy_group(it, dst_bucket);
                    }
                }
            }

        public:
# 1654 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            iterator_base insert(value_type const& v)
            {


                node_constructor a(data_.allocators_);
                a.construct(v);

                return insert_impl(a);
            }





            iterator_base insert_hint(iterator_base const& it, value_type const& v)
            {


                node_constructor a(data_.allocators_);
                a.construct(v);

                return insert_hint_impl(it, a);
            }
# 1714 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            iterator_base insert_impl(node_constructor& a)
            {
                key_type const& k = extract_key(a.get()->value_);
                size_type hash_value = hash_function()(k);
                bucket_ptr bucket = data_.bucket_ptr_from_hash(hash_value);
                link_ptr position = find_iterator(bucket, k);



                if(reserve(size() + 1))
                    bucket = data_.bucket_ptr_from_hash(hash_value);



                return iterator_base(bucket,
                    (position) ?
                    data_.link_node(a, position) :
                    data_.link_node_in_bucket(a, bucket)
                );
            }

            iterator_base insert_hint_impl(iterator_base const& it, node_constructor& a)
            {

                if (it == data_.end() || !equal(extract_key(a.get()->value_), *it)) {


                    return insert_impl(a);
                }
                else {



                    link_ptr start(it.node_);
                    while(data_.prev_in_group(start)->next_ == start)
                        start = data_.prev_in_group(start);



                    bucket_ptr base = reserve(size() + 1) ?
                        get_bucket(extract_key(a.get()->value_)) : it.bucket_;



                    return iterator_base(base,
                            data_.link_node(a, start));
                }
            }



        private:



            template <typename I>
            void insert_for_range(I i, I j, forward_traversal_tag)
            {
                size_type distance = unordered_detail::distance(i, j);
                if(distance == 1) {
                    insert(*i);
                }
                else {

                    reserve(size() + distance);
                    node_constructor a(data_.allocators_);

                    for (; i != j; ++i) {
                        a.construct(*i);

                        key_type const& k = extract_key(a.get()->value_);
                        bucket_ptr bucket = get_bucket(k);
                        link_ptr position = find_iterator(bucket, k);

                        if(position)
                            data_.link_node(a, position);
                        else
                            data_.link_node_in_bucket(a, bucket);
                    }
                }
            }



            template <typename I>
            void insert_for_range(I i, I j,
                    boost::incrementable_traversal_tag)
            {


                for (; i != j; ++i) insert(*i);
            }

        public:



            template <typename I>
            void insert_range(I i, I j)
            {
                typename boost::iterator_traversal<I>::type
                    iterator_traversal_tag;
                insert_for_range(i, j, iterator_traversal_tag);
            }
# 2060 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
        public:




            size_type erase_key(key_type const& k)
            {

                bucket_ptr bucket = get_bucket(k);
                link_ptr* it = find_for_erase(bucket, k);


                return *it ? data_.erase_group(it, bucket) : 0;
            }




            size_type count(key_type const& k) const
            {
                link_ptr it = find_iterator(k);
                return it ? data::group_count(it) : 0;
            }




            iterator_base find(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);

                if (it)
                    return iterator_base(bucket, it);
                else
                    return data_.end();
            }

            value_type& at(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);

                if (it)
                    return data::get_value(it);
                else
                    throw std::out_of_range("Unable to find key in unordered_map.");
            }




            std::pair<iterator_base, iterator_base> equal_range(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);
                if (it) {
                    iterator_base first(iterator_base(bucket, it));
                    iterator_base second(first);
                    second.increment_group();
                    return std::pair<iterator_base, iterator_base>(first, second);
                }
                else {
                    return std::pair<iterator_base, iterator_base>(
                            data_.end(), data_.end());
                }
            }


            bool equal(key_type const& k, value_type const& v) const
            {
                return key_eq()(k, extract_key(v));
            }


            link_ptr find_iterator(key_type const& k) const
            {
                return find_iterator(get_bucket(k), k);
            }


            link_ptr find_iterator(bucket_ptr bucket,
                    key_type const& k) const
            {
                link_ptr it = data_.begin(bucket);
                while (it && !equal(k, data::get_value(it)))
                    it = data::next_group(it);

                return it;
            }


            link_ptr* find_for_erase(bucket_ptr bucket, key_type const& k) const
            {
                link_ptr* it = &bucket->next_;
                while(*it && !equal(k, data::get_value(*it)))
                    it = &data::next_group(*it);

                return it;
            }
        };






        template <typename A, typename KeyType>
        inline bool group_equals(
                hash_table_data_equivalent_keys<A>*,
                typename hash_table_data_equivalent_keys<A>::link_ptr it1,
                typename hash_table_data_equivalent_keys<A>::link_ptr it2,
                KeyType*,
                type_wrapper<KeyType>*)
        {
            typedef hash_table_data_equivalent_keys<A> data;
            return data::group_count(it1) == data::group_count(it2);
        }

        template <typename A, typename KeyType>
        inline bool group_equals(
                hash_table_data_equivalent_keys<A>*,
                typename hash_table_data_equivalent_keys<A>::link_ptr it1,
                typename hash_table_data_equivalent_keys<A>::link_ptr it2,
                KeyType*,
                void*)
        {
            typedef hash_table_data_equivalent_keys<A> data;
            typename hash_table_data_equivalent_keys<A>::link_ptr end1 = data::next_group(it1);
            typename hash_table_data_equivalent_keys<A>::link_ptr end2 = data::next_group(it2);

            do {
                if(data::get_value(it1).second != data::get_value(it2).second) return false;
                it1 = it1->next_;
                it2 = it2->next_;
            } while(it1 != end1 && it2 != end2);
            return it1 == end1 && it2 == end2;
        }
# 2223 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
        template <typename V, typename K, typename H, typename P, typename A>
        bool equals(hash_table_equivalent_keys<V, K, H, P, A> const& t1,
                hash_table_equivalent_keys<V, K, H, P, A> const& t2)
        {
            typedef hash_table_data_equivalent_keys<A> data;
            typedef typename data::bucket_ptr bucket_ptr;
            typedef typename data::link_ptr link_ptr;

            if(t1.size() != t2.size()) return false;

            for(bucket_ptr i = t1.data_.cached_begin_bucket_,
                    j = t1.data_.buckets_end(); i != j; ++i)
            {
                for(link_ptr it(i->next_); it; it = data::next_group(it))
                {
                    link_ptr other_pos = t2.find_iterator(t2.extract_key(data::get_value(it)));
                    if(!other_pos ||
                        !group_equals((data*)0, it, other_pos, (K*)0, (type_wrapper<V>*)0))
                        return false;
                }
            }

            return true;
        }



        template <typename Alloc> class hash_iterator_equivalent_keys;
        template <typename Alloc> class hash_const_iterator_equivalent_keys;
        template <typename Alloc> class hash_local_iterator_equivalent_keys;
        template <typename Alloc> class hash_const_local_iterator_equivalent_keys;
        class iterator_access;





        template <typename Alloc>
        class hash_local_iterator_equivalent_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_pointer<Alloc>::type,
                typename allocator_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef hash_table_data_equivalent_keys<Alloc> data;
            typedef typename data::link_ptr ptr;
            typedef hash_const_local_iterator_equivalent_keys<Alloc> const_local_iterator;

            friend class hash_const_local_iterator_equivalent_keys<Alloc>;
            ptr ptr_;

        public:
            hash_local_iterator_equivalent_keys() : ptr_() {
                ;
            }
            explicit hash_local_iterator_equivalent_keys(ptr x) : ptr_(x) {}
            typename allocator_reference<Alloc>::type operator*() const
                { return data::get_value(ptr_); }
            value_type* operator->() const { return &data::get_value(ptr_); }
            hash_local_iterator_equivalent_keys& operator++() { ptr_ = ptr_->next_; return *this; }
            hash_local_iterator_equivalent_keys operator++(int) { hash_local_iterator_equivalent_keys tmp(ptr_); ptr_ = ptr_->next_; return tmp; }
            bool operator==(hash_local_iterator_equivalent_keys x) const { return ptr_ == x.ptr_; }
            bool operator==(const_local_iterator x) const { return ptr_ == x.ptr_; }
            bool operator!=(hash_local_iterator_equivalent_keys x) const { return ptr_ != x.ptr_; }
            bool operator!=(const_local_iterator x) const { return ptr_ != x.ptr_; }
        };

        template <typename Alloc>
        class hash_const_local_iterator_equivalent_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_const_pointer<Alloc>::type,
                typename allocator_const_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef hash_table_data_equivalent_keys<Alloc> data;
            typedef typename data::link_ptr ptr;
            typedef hash_local_iterator_equivalent_keys<Alloc> local_iterator;
            friend class hash_local_iterator_equivalent_keys<Alloc>;
            ptr ptr_;

        public:
            hash_const_local_iterator_equivalent_keys() : ptr_() {
                ;
            }
            explicit hash_const_local_iterator_equivalent_keys(ptr x) : ptr_(x) {}
            hash_const_local_iterator_equivalent_keys(local_iterator x) : ptr_(x.ptr_) {}
            typename allocator_const_reference<Alloc>::type
                operator*() const { return data::get_value(ptr_); }
            value_type const* operator->() const { return &data::get_value(ptr_); }
            hash_const_local_iterator_equivalent_keys& operator++() { ptr_ = ptr_->next_; return *this; }
            hash_const_local_iterator_equivalent_keys operator++(int) { hash_const_local_iterator_equivalent_keys tmp(ptr_); ptr_ = ptr_->next_; return tmp; }
            bool operator==(local_iterator x) const { return ptr_ == x.ptr_; }
            bool operator==(hash_const_local_iterator_equivalent_keys x) const { return ptr_ == x.ptr_; }
            bool operator!=(local_iterator x) const { return ptr_ != x.ptr_; }
            bool operator!=(hash_const_local_iterator_equivalent_keys x) const { return ptr_ != x.ptr_; }
        };






        template <typename Alloc>
        class hash_iterator_equivalent_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_pointer<Alloc>::type,
                typename allocator_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef typename hash_table_data_equivalent_keys<Alloc>::iterator_base base;
            typedef hash_const_iterator_equivalent_keys<Alloc> const_iterator;
            friend class hash_const_iterator_equivalent_keys<Alloc>;
            base base_;

        public:

            hash_iterator_equivalent_keys() : base_() {}
            explicit hash_iterator_equivalent_keys(base const& x) : base_(x) {}
            typename allocator_reference<Alloc>::type
                operator*() const { return *base_; }
            value_type* operator->() const { return &*base_; }
            hash_iterator_equivalent_keys& operator++() { base_.increment(); return *this; }
            hash_iterator_equivalent_keys operator++(int) { hash_iterator_equivalent_keys tmp(base_); base_.increment(); return tmp; }
            bool operator==(hash_iterator_equivalent_keys const& x) const { return base_ == x.base_; }
            bool operator==(const_iterator const& x) const { return base_ == x.base_; }
            bool operator!=(hash_iterator_equivalent_keys const& x) const { return base_ != x.base_; }
            bool operator!=(const_iterator const& x) const { return base_ != x.base_; }
        };

        template <typename Alloc>
        class hash_const_iterator_equivalent_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_const_pointer<Alloc>::type,
                typename allocator_const_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef typename hash_table_data_equivalent_keys<Alloc>::iterator_base base;
            typedef hash_iterator_equivalent_keys<Alloc> iterator;
            friend class hash_iterator_equivalent_keys<Alloc>;
            friend class iterator_access;
            base base_;

        public:

            hash_const_iterator_equivalent_keys() : base_() {}
            explicit hash_const_iterator_equivalent_keys(base const& x) : base_(x) {}
            hash_const_iterator_equivalent_keys(iterator const& x) : base_(x.base_) {}
            typename allocator_const_reference<Alloc>::type
                operator*() const { return *base_; }
            value_type const* operator->() const { return &*base_; }
            hash_const_iterator_equivalent_keys& operator++() { base_.increment(); return *this; }
            hash_const_iterator_equivalent_keys operator++(int) { hash_const_iterator_equivalent_keys tmp(base_); base_.increment(); return tmp; }
            bool operator==(iterator const& x) const { return base_ == x.base_; }
            bool operator==(hash_const_iterator_equivalent_keys const& x) const { return base_ == x.base_; }
            bool operator!=(iterator const& x) const { return base_ != x.base_; }
            bool operator!=(hash_const_iterator_equivalent_keys const& x) const { return base_ != x.base_; }
        };
    }
}
# 239 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table.hpp" 2 3



# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
namespace boost {
    namespace unordered_detail {






        template <typename Alloc>
        class hash_table_data_unique_keys
        {
        public:
            typedef hash_table_data_unique_keys data;

            struct node_base;
            struct node;
            struct bucket;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;

            typedef Alloc value_allocator;

            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, node>::type
                node_allocator;
            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, node_base>::type
                node_base_allocator;
            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, bucket>::type
                bucket_allocator;

            typedef typename allocator_value_type<Alloc>::type value_type;
            typedef typename allocator_pointer<node_allocator>::type node_ptr;
            typedef typename allocator_pointer<bucket_allocator>::type bucket_ptr;
            typedef typename allocator_reference<value_allocator>::type reference;
            typedef typename allocator_reference<bucket_allocator>::type bucket_reference;

            typedef bucket_ptr link_ptr;





            struct bucket
            {
            private:
                bucket& operator=(bucket const&);
            public:
                link_ptr next_;

                bucket() : next_()
                {
                    ;
                }

                bucket(bucket const& x) : next_(x.next_)
                {

                    (__builtin_expect(!(!x.next_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 82, "!x.next_") : (void)0);
                }

                bool empty() const
                {
                    return !this->next_;
                }
            };





            struct node_base : bucket
            {
# 106 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            };

            struct node : node_base
            {
            public:





                node(value_type const& v) : node_base(), value_(v) {}


                value_type value_;
            };
# 219 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            struct allocators
            {
                node_allocator node_alloc_;
                bucket_allocator bucket_alloc_;
                value_allocator value_alloc_;
                node_base_allocator node_base_alloc_;

                allocators(value_allocator const& a)
                    : node_alloc_(a), bucket_alloc_(a),
                    value_alloc_(a), node_base_alloc_(a)
                {}

                void destroy(link_ptr ptr)
                {
                    node_ptr n(node_alloc_.address(*static_cast<node*>(&*ptr)));
                    value_alloc_.destroy(value_alloc_.address(n->value_));
                    node_base_alloc_.destroy(node_base_alloc_.address(*n));
                    node_alloc_.deallocate(n, 1);
                }

                void swap(allocators& x)
                {
                    unordered_detail::hash_swap(node_alloc_, x.node_alloc_);
                    unordered_detail::hash_swap(bucket_alloc_, x.bucket_alloc_);
                    unordered_detail::hash_swap(value_alloc_, x.value_alloc_);
                    unordered_detail::hash_swap(node_base_alloc_, x.node_base_alloc_);
                }

                bool operator==(allocators const& x)
                {
                    return value_alloc_ == x.value_alloc_;
                }
            };





            class node_constructor
            {
                allocators& allocators_;

                node_ptr node_;
                bool value_constructed_;
                bool node_base_constructed_;

            public:

                node_constructor(allocators& a)
                    : allocators_(a),
                    node_(), value_constructed_(false), node_base_constructed_(false)
                {
                    ;
                }

                ~node_constructor()
                {
                    if (node_) {
                        if (value_constructed_)
                            allocators_.value_alloc_.destroy(
                                allocators_.value_alloc_.address(node_->value_));
                        if (node_base_constructed_)
                            allocators_.node_base_alloc_.destroy(
                                allocators_.node_base_alloc_.address(*node_));

                        allocators_.node_alloc_.deallocate(node_, 1);
                    }
                }

                template <typename V>
                void construct(V const& v)
                {
                    (__builtin_expect(!(!node_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 291, "!node_") : (void)0);
                    value_constructed_ = false;
                    node_base_constructed_ = false;

                    node_ = allocators_.node_alloc_.allocate(1);

                    allocators_.node_base_alloc_.construct(
                            allocators_.node_base_alloc_.address(*node_),
                            node_base());
                    node_base_constructed_ = true;

                    allocators_.value_alloc_.construct(
                            allocators_.value_alloc_.address(node_->value_), v);
                    value_constructed_ = true;
                }

                node_ptr get() const
                {
                    (__builtin_expect(!(node_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 309, "node_") : (void)0);
                    return node_;
                }


                link_ptr release()
                {
                    node_ptr p = node_;
                    unordered_detail::reset(node_);
                    return link_ptr(allocators_.bucket_alloc_.address(*p));
                }

            private:
                node_constructor(node_constructor const&);
                node_constructor& operator=(node_constructor const&);
            };
# 340 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            static inline link_ptr& next_group(link_ptr n) {
                (__builtin_expect(!(n), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 341, "n") : (void)0);
                return n->next_;
            }



            static inline node& get_node(link_ptr p) {
                (__builtin_expect(!(p), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 348, "p") : (void)0);
                return *static_cast<node*>(&*p);
            }


            static inline reference get_value(link_ptr p) {
                (__builtin_expect(!(p), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 354, "p") : (void)0);
                return static_cast<node*>(&*p)->value_;
            }

            class iterator_base
            {
                typedef hash_table_data_unique_keys<Alloc> data;
            public:
                bucket_ptr bucket_;
                link_ptr node_;

                iterator_base()
                    : bucket_(), node_()
                {
                    ;
                    ;
                }

                explicit iterator_base(bucket_ptr b)
                    : bucket_(b), node_(b->next_) {}

                iterator_base(bucket_ptr b, link_ptr n)
                    : bucket_(b), node_(n) {}

                bool operator==(iterator_base const& x) const
                {
                    return node_ == x.node_;
                }

                bool operator!=(iterator_base const& x) const
                {
                    return node_ != x.node_;
                }

                reference operator*() const
                {
                    return get_value(node_);
                }

                void increment()
                {
                    (__builtin_expect(!(bucket_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 395, "bucket_") : (void)0);
                    node_ = node_->next_;

                    while (!node_) {
                        ++bucket_;
                        node_ = bucket_->next_;
                    }
                }

                void increment_group()
                {
                    node_ = data::next_group(node_);

                    while (!node_) {
                        ++bucket_;
                        node_ = bucket_->next_;
                    }
                }
            };



            allocators allocators_;
            bucket_ptr buckets_;
            bucket_manager bucket_manager_;
            bucket_ptr cached_begin_bucket_;
            size_type size_;



            hash_table_data_unique_keys(size_type n, value_allocator const& a)
              : allocators_(a),
                buckets_(), bucket_manager_(n),
                cached_begin_bucket_(), size_(0)
            {
                ;
                create_buckets();
            }

            hash_table_data_unique_keys(hash_table_data_unique_keys const& x, size_type n)
              : allocators_(x.allocators_),
                buckets_(), bucket_manager_(n),
                cached_begin_bucket_(), size_(0)
            {
                ;
                create_buckets();
            }

            hash_table_data_unique_keys(hash_table_data_unique_keys& x, move_tag)
                : allocators_(x.allocators_),
                buckets_(x.buckets_), bucket_manager_(x.bucket_manager_),
                cached_begin_bucket_(x.cached_begin_bucket_), size_(x.size_)
            {
                unordered_detail::reset(x.buckets_);
            }

            hash_table_data_unique_keys(hash_table_data_unique_keys& x,
                    value_allocator const& a, size_type n, move_tag)
                : allocators_(a), buckets_(), bucket_manager_(),
                cached_begin_bucket_(), size_(0)
            {
                if(allocators_ == x.allocators_) {
                    buckets_ = x.buckets_;
                    bucket_manager_ = x.bucket_manager_;
                    cached_begin_bucket_ = x.cached_begin_bucket_;
                    size_ = x.size_;
                    unordered_detail::reset(x.buckets_);
                }
                else {
                    ;
                    bucket_manager_ = bucket_manager(n);
                    create_buckets();
                }
            }


            ~hash_table_data_unique_keys()
            {
                delete_buckets();
            }

            void create_buckets() {
                size_type bucket_count = bucket_manager_.bucket_count();



                allocator_array_constructor<bucket_allocator>
                    constructor(allocators_.bucket_alloc_);


                constructor.construct(bucket(), bucket_count + 1);

                cached_begin_bucket_ = constructor.get() + static_cast<difference_type>(bucket_count);


                cached_begin_bucket_->next_ = link_ptr(cached_begin_bucket_);



                buckets_ = constructor.release();
            }


            void delete_buckets()
            {
                if(buckets_) {
                    bucket_ptr begin = cached_begin_bucket_;
                    bucket_ptr end = buckets_end();
                    while(begin != end) {
                        clear_bucket(begin);
                        ++begin;
                    }


                    ++end;
                    for(begin = buckets_; begin != end; ++begin)
                        allocators_.bucket_alloc_.destroy(begin);

                    allocators_.bucket_alloc_.deallocate(buckets_,
                        bucket_manager_.bucket_count() + 1);
                }
            }

        private:

            hash_table_data_unique_keys(hash_table_data_unique_keys const&);
            hash_table_data_unique_keys& operator=(hash_table_data_unique_keys const&);

        public:


            void swap(hash_table_data_unique_keys& other)
            {
                std::swap(buckets_, other.buckets_);
                std::swap(bucket_manager_, other.bucket_manager_);
                std::swap(cached_begin_bucket_, other.cached_begin_bucket_);
                std::swap(size_, other.size_);
            }


            void move(hash_table_data_unique_keys& other)
            {
                delete_buckets();
                buckets_ = other.buckets_;
                unordered_detail::reset(other.buckets_);
                bucket_manager_ = other.bucket_manager_;
                cached_begin_bucket_ = other.cached_begin_bucket_;
                size_ = other.size_;
            }




            size_type bucket_from_hash(size_type hashed) const
            {
                return bucket_manager_.bucket_from_hash(hashed);
            }




            bucket_ptr bucket_ptr_from_hash(size_type hashed) const
            {
                return buckets_ + static_cast<difference_type>(
                    bucket_manager_.bucket_from_hash(hashed));
            }





            bucket_ptr buckets_end() const
            {
                return buckets_ + static_cast<difference_type>(bucket_manager_.bucket_count());
            }

            iterator_base begin() const
            {
                return size_
                    ? iterator_base(cached_begin_bucket_)
                    : end();
            }

            iterator_base end() const
            {
                return iterator_base(buckets_end());
            }

            link_ptr begin(size_type n) const
            {
                return (buckets_ + static_cast<difference_type>(n))->next_;
            }

            link_ptr end(size_type) const
            {
                return unordered_detail::null_ptr<link_ptr>();
            }

            link_ptr begin(bucket_ptr b) const
            {
                return b->next_;
            }




            static inline size_type node_count(link_ptr it)
            {
                size_type count = 0;
                while(it) {
                    ++count;
                    it = it->next_;
                }
                return count;
            }

            static inline size_type node_count(link_ptr it1, link_ptr it2)
            {
                size_type count = 0;
                while(it1 != it2) {
                    ++count;
                    it1 = it1->next_;
                }
                return count;
            }

            size_type bucket_size(size_type n) const
            {
                return node_count(begin(n));
            }







            static inline size_type group_count(link_ptr)
            {
                return 1;
            }
# 662 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            static link_ptr* get_for_erase(iterator_base r)
            {
                link_ptr n = r.node_;
                link_ptr* it = &r.bucket_->next_;
                while(*it != n) it = &(*it)->next_;
                return it;
            }
# 716 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void link_node(link_ptr n, bucket_ptr base)
            {
                n->next_ = base->next_;
                base->next_ = n;
                ++size_;
                if(base < cached_begin_bucket_) cached_begin_bucket_ = base;
            }

            link_ptr link_node_in_bucket(node_constructor& a, bucket_ptr base)
            {
                link_ptr n = a.release();
                link_node(n, base);
                return n;
            }

            void link_group(link_ptr n, bucket_ptr base, size_type)
            {
                link_node(n, base);
            }
# 776 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void unlink_node(iterator_base n)
            {
                link_ptr* pos = get_for_erase(n);
                *pos = (*pos)->next_;
                --size_;
            }

            size_type unlink_group(link_ptr* pos)
            {
                *pos = (*pos)->next_;
                --size_;
                return 1;
            }


            void unlink_nodes(iterator_base n)
            {
                link_ptr* it = get_for_erase(n);
                split_group(*it);
                unordered_detail::reset(*it);
                size_ -= node_count(n.node_);
            }

            void unlink_nodes(iterator_base begin, iterator_base end)
            {
                (__builtin_expect(!(begin.bucket_ == end.bucket_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 801, "begin.bucket_ == end.bucket_") : (void)0);
                size_ -= node_count(begin.node_, end.node_);
                link_ptr* it = get_for_erase(begin);
                split_group(*it, end.node_);
                *it = end.node_;
            }

            void unlink_nodes(bucket_ptr base, iterator_base end)
            {
                (__builtin_expect(!(base == end.bucket_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 810, "base == end.bucket_") : (void)0);

                split_group(end.node_);

                link_ptr ptr(base->next_);
                base->next_ = end.node_;

                size_ -= node_count(ptr, end.node_);
            }
# 856 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            static inline void split_group(link_ptr)
            {
            }

            static inline void split_group(link_ptr, link_ptr)
            {
            }
# 886 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void copy_group(link_ptr it, bucket_ptr dst)
            {
                node_constructor a(allocators_);

                a.construct(get_value(it));
                link_node_in_bucket(a, dst);
            }
# 902 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void delete_to_bucket_end(link_ptr begin)
            {
                while(begin) {
                    link_ptr node = begin;
                    begin = begin->next_;
                    allocators_.destroy(node);
                }
            }

            void delete_nodes(link_ptr begin, link_ptr end)
            {
                while(begin != end) {
                    link_ptr node = begin;
                    begin = begin->next_;
                    allocators_.destroy(node);
                }
            }







            void delete_group(link_ptr node)
            {
                allocators_.destroy(node);
            }
# 938 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void clear_bucket(bucket_ptr b)
            {
                link_ptr first_node = b->next_;
                unordered_detail::reset(b->next_);
                delete_to_bucket_end(first_node);
            }

            void clear()
            {
                bucket_ptr begin = cached_begin_bucket_;
                bucket_ptr end = buckets_end();

                size_ = 0;
                cached_begin_bucket_ = end;

                while(begin != end) {
                    clear_bucket(begin);
                    ++begin;
                }
            }





            iterator_base erase(iterator_base r)
            {
                (__builtin_expect(!(r != end()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 965, "r != end()") : (void)0);
                iterator_base next = r;
                next.increment();
                unlink_node(r);
                allocators_.destroy(r.node_);

                recompute_begin_bucket(r.bucket_, next.bucket_);
                return next;
            }

            iterator_base erase_range(iterator_base r1, iterator_base r2)
            {
                if(r1 != r2)
                {
                    (__builtin_expect(!(r1 != end()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 979, "r1 != end()") : (void)0);

                    if (r1.bucket_ == r2.bucket_) {
                        unlink_nodes(r1, r2);
                        delete_nodes(r1.node_, r2.node_);




                        (__builtin_expect(!(!r1.bucket_->empty()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 988, "!r1.bucket_->empty()") : (void)0);
                    }
                    else {
                        (__builtin_expect(!(r1.bucket_ < r2.bucket_), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 991, "r1.bucket_ < r2.bucket_") : (void)0);

                        unlink_nodes(r1);
                        delete_to_bucket_end(r1.node_);

                        bucket_ptr i = r1.bucket_;
                        for(++i; i != r2.bucket_; ++i) {
                            size_ -= node_count(i->next_);
                            clear_bucket(i);
                        }

                        if(r2 != end()) {
                            link_ptr first = r2.bucket_->next_;
                            unlink_nodes(r2.bucket_, r2);
                            delete_nodes(first, r2.node_);
                        }



                        recompute_begin_bucket(r1.bucket_, r2.bucket_);
                    }
                }

                return r2;
            }
# 1024 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void recompute_begin_bucket(bucket_ptr b)
            {
                (__builtin_expect(!(!(b < cached_begin_bucket_)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1026, "!(b < cached_begin_bucket_)") : (void)0);

                if(b == cached_begin_bucket_)
                {
                    if (size_ != 0) {
                        while (cached_begin_bucket_->empty())
                            ++cached_begin_bucket_;
                    } else {
                        cached_begin_bucket_ = buckets_end();
                    }
                }
            }





            void recompute_begin_bucket(bucket_ptr b1, bucket_ptr b2)
            {
                (__builtin_expect(!(!(b1 < cached_begin_bucket_) && !(b2 < b1)), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1045, "!(b1 < cached_begin_bucket_) && !(b2 < b1)") : (void)0);
                (__builtin_expect(!(b2 == buckets_end() || !b2->empty()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1046, "b2 == buckets_end() || !b2->empty()") : (void)0);

                if(b1 == cached_begin_bucket_ && b1->empty())
                    cached_begin_bucket_ = b2;
            }

            size_type erase_group(link_ptr* it, bucket_ptr bucket)
            {
                link_ptr pos = *it;
                size_type count = unlink_group(it);
                delete_group(pos);

                this->recompute_begin_bucket(bucket);

                return count;
            }
        };
# 1078 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
        template <typename ValueType, typename KeyType,
            typename Hash, typename Pred,
            typename Alloc>
        class hash_table_unique_keys
        {
            typedef hash_table_data_unique_keys<Alloc> data;

            typedef typename data::node_constructor node_constructor;
            typedef typename data::bucket_ptr bucket_ptr;
            typedef typename data::link_ptr link_ptr;

        public:

            typedef typename data::value_allocator value_allocator;
            typedef typename data::node_allocator node_allocator;



            typedef KeyType key_type;
            typedef Hash hasher;
            typedef Pred key_equal;
            typedef ValueType value_type;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;



            typedef typename data::iterator_base iterator_base;

        private:


            typedef boost::unordered_detail::buffered_functions<Hash, Pred>
                function_store;
            typedef typename function_store::functions functions;
            typedef typename function_store::functions_ptr
                functions_ptr;

            function_store functions_;
            float mlf_;
            size_type max_load_;

        public:

            data data_;






            hash_table_unique_keys(size_type n,
                    hasher const& hf, key_equal const& eq,
                    value_allocator const& a)
                : functions_(hf, eq),
                mlf_(1.0f),
                data_(n, a)
            {
                calculate_max_load();
            }
# 1149 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            template <typename I>
            size_type initial_size(I i, I j, size_type n,
                    boost::forward_traversal_tag)
            {

                return (std::max)(static_cast<size_type>(unordered_detail::distance(i, j)) + 1, n);
            }

            template <typename I>
            size_type initial_size(I, I, size_type n,
                    boost::incrementable_traversal_tag)
            {
                return n;
            }

            template <typename I>
            size_type initial_size(I i, I j, size_type n)
            {
                typename boost::iterator_traversal<I>::type
                    iterator_traversal_tag;
                return initial_size(i, j, n, iterator_traversal_tag);
            }

            template <typename I>
            hash_table_unique_keys(I i, I j, size_type n,
                    hasher const& hf, key_equal const& eq,
                    value_allocator const& a)
                : functions_(hf, eq),
                  mlf_(1.0f),
                  data_(initial_size(i, j, n), a)
            {
                calculate_max_load();


                insert_range(i, j);
            }



            hash_table_unique_keys(hash_table_unique_keys const& x)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, x.min_buckets_for_size(x.size()))
            {
                calculate_max_load();



                copy_buckets(x.data_, data_, functions_.current());
            }



            hash_table_unique_keys(hash_table_unique_keys const& x,
                    value_allocator const& a)
                : functions_(x.functions_),
                mlf_(x.mlf_),
                data_(x.min_buckets_for_size(x.size()), a)
            {
                calculate_max_load();



                copy_buckets(x.data_, data_, functions_.current());
            }



            hash_table_unique_keys(hash_table_unique_keys& x, move_tag m)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, m)
            {
                calculate_max_load();
            }

            hash_table_unique_keys(hash_table_unique_keys& x,
                    value_allocator const& a, move_tag m)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, a,
                        x.min_buckets_for_size(x.size()), m)
            {
                calculate_max_load();

                if(x.data_.buckets_) {


                    copy_buckets(x.data_, data_, functions_.current());
                }
            }
# 1248 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            hash_table_unique_keys& operator=(hash_table_unique_keys const& x)
            {
                if(this != &x)
                {
                    data_.clear();
                    functions_.set(functions_.buffer(x.functions_));

                    mlf_ = x.mlf_;
                    calculate_max_load();
                    reserve(x.size());
                    copy_buckets(x.data_, data_, functions_.current());
                }

                return *this;
            }
# 1278 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void swap(hash_table_unique_keys& x)
            {





                if(this == &x) return;




                functions_ptr new_func_this = functions_.buffer(x.functions_);
                functions_ptr new_func_that = x.functions_.buffer(functions_);

                if(data_.allocators_ == x.data_.allocators_) {
                    data_.swap(x.data_);
                }
                else {



                    data new_this(data_, x.min_buckets_for_size(x.data_.size_));
                    copy_buckets(x.data_, new_this, functions_.*new_func_this);

                    data new_that(x.data_, min_buckets_for_size(data_.size_));
                    x.copy_buckets(data_, new_that, x.functions_.*new_func_that);


                    data_.swap(new_this);
                    x.data_.swap(new_that);
                }


                std::swap(mlf_, x.mlf_);

                functions_.set(new_func_this);
                x.functions_.set(new_func_that);

                calculate_max_load();
                x.calculate_max_load();
            }
# 1330 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            void move(hash_table_unique_keys& x)
            {



                functions_ptr new_func_this = functions_.buffer(x.functions_);

                if(data_.allocators_ == x.data_.allocators_) {
                    data_.move(x.data_);
                }
                else {



                    data new_this(data_, x.min_buckets_for_size(x.data_.size_));
                    copy_buckets(x.data_, new_this, functions_.*new_func_this);


                    data_.move(new_this);
                }


                mlf_ = x.mlf_;
                functions_.set(new_func_this);
                calculate_max_load();
            }
# 1366 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            value_allocator get_allocator() const
            {
                return data_.allocators_.value_alloc_;
            }



            hasher const& hash_function() const
            {
                return functions_.current().hash_function();
            }


            key_equal const& key_eq() const
            {
                return functions_.current().key_eq();
            }


            size_type size() const
            {
                return data_.size_;
            }


            bool empty() const
            {
                return data_.size_ == 0;
            }


            size_type max_size() const
            {
                using namespace std;


                return double_to_size_t(ceil(
                        (double) mlf_ * max_bucket_count())) - 1;
            }


            size_type bucket(key_type const& k) const
            {

                return data_.bucket_from_hash(hash_function()(k));
            }



            bucket_ptr get_bucket(key_type const& k) const
            {
                return data_.buckets_ + static_cast<difference_type>(bucket(k));
            }


            size_type bucket_count() const
            {
                return data_.bucket_manager_.bucket_count();
            }


            size_type max_bucket_count() const
            {

                return prev_prime(data_.allocators_.bucket_alloc_.max_size() - 1);
            }

        private:


            size_type min_buckets_for_size(size_type n) const
            {
                (__builtin_expect(!(mlf_ != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1438, "mlf_ != 0") : (void)0);

                using namespace std;







                return double_to_size_t(floor(n / (double) mlf_)) + 1;
            }


            void calculate_max_load()
            {
                using namespace std;



                max_load_ = double_to_size_t(ceil(
                        (double) mlf_ * data_.bucket_manager_.bucket_count()));
            }


            bool reserve(size_type n)
            {
                bool need_to_reserve = n >= max_load_;

                if (need_to_reserve) rehash_impl(min_buckets_for_size(n));
                (__builtin_expect(!(n < max_load_ || n > max_size()), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1468, "n < max_load_ || n > max_size()") : (void)0);
                return need_to_reserve;
            }

        public:


            float max_load_factor() const
            {
                return mlf_;
            }


            void max_load_factor(float z)
            {
                (__builtin_expect(!(z > 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1483, "z > 0") : (void)0);
                mlf_ = (std::max)(z, minimum_max_load_factor);
                calculate_max_load();
            }


            float load_factor() const
            {
                (__builtin_expect(!(data_.bucket_manager_.bucket_count() != 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1491, "data_.bucket_manager_.bucket_count() != 0") : (void)0);
                return static_cast<float>(data_.size_)
                    / static_cast<float>(data_.bucket_manager_.bucket_count());
            }




            static key_type const& extract_key(value_type const& v)
            {
                return extract(v, (type_wrapper<value_type>*)0);
            }

            static key_type const& extract(value_type const& v,
                    type_wrapper<key_type>*)
            {
                return v;
            }

            static key_type const& extract(value_type const& v,
                    void*)
            {
                return v.first;
            }
# 1551 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
        public:



            void rehash(size_type n)
            {
                using namespace std;


                size_type min_size = min_buckets_for_size(size());

                rehash_impl(min_size > n ? min_size : n);

                (__builtin_expect(!((float) bucket_count() > (float) size() / max_load_factor() && bucket_count() >= n), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1565, "(float) bucket_count() > (float) size() / max_load_factor() && bucket_count() >= n") : (void)0);

            }

        private:



            void rehash_impl(size_type n)
            {
                n = next_prime(n);

                if (n == bucket_count())
                    return;

                data new_buckets(data_, n);
                move_buckets(data_, new_buckets, hash_function());

                new_buckets.swap(data_);
                calculate_max_load();
            }






            static void move_buckets(data& src, data& dst, hasher const& hf)
            {
                (__builtin_expect(!(dst.size_ == 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1593, "dst.size_ == 0") : (void)0);


                bucket_ptr end = src.buckets_end();

                for(; src.cached_begin_bucket_ != end;
                        ++src.cached_begin_bucket_) {
                    bucket_ptr src_bucket = src.cached_begin_bucket_;
                    while(src_bucket->next_) {




                        bucket_ptr dst_bucket = dst.bucket_ptr_from_hash(
                                hf(extract_key(data::get_value(src_bucket->next_))));

                        link_ptr n = src_bucket->next_;
                        size_type count = src.unlink_group(&src_bucket->next_);
                        dst.link_group(n, dst_bucket, count);
                    }
                }
            }




            static void copy_buckets(data const& src, data& dst, functions const& f)
            {
                (__builtin_expect(!(dst.size_ == 0), 0) ? __assert_rtn(__func__, "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp", 1621, "dst.size_ == 0") : (void)0);

                bucket_ptr end = src.buckets_end();
                hasher const& hf = f.hash_function();


                for(bucket_ptr i = src.cached_begin_bucket_; i != end; ++i) {

                    for(link_ptr it = src.begin(i);
                            it; it = data::next_group(it)) {

                        bucket_ptr dst_bucket = dst.bucket_ptr_from_hash(
                                hf(extract_key(data::get_value(it))));

                        dst.copy_group(it, dst_bucket);
                    }
                }
            }

        public:
# 1821 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            value_type& operator[](key_type const& k)
            {
                typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( !boost::is_same<value_type, key_type>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_1824;

                typedef typename value_type::second_type mapped_type;

                size_type hash_value = hash_function()(k);
                bucket_ptr bucket = data_.bucket_ptr_from_hash(hash_value);
                link_ptr pos = find_iterator(bucket, k);

                if (pos)
                    return data::get_value(pos);
                else
                {




                    node_constructor a(data_.allocators_);
                    a.construct(value_type(k, mapped_type()));



                    if(reserve(size() + 1))
                        bucket = data_.bucket_ptr_from_hash(hash_value);



                    return data::get_value(data_.link_node_in_bucket(a, bucket));
                }
            }







            std::pair<iterator_base, bool> insert(value_type const& v)
            {

                key_type const& k = extract_key(v);
                size_type hash_value = hash_function()(k);
                bucket_ptr bucket = data_.bucket_ptr_from_hash(hash_value);
                link_ptr pos = find_iterator(bucket, k);

                if (pos) {

                    return std::pair<iterator_base, bool>(
                        iterator_base(bucket, pos), false);

                } else {





                    node_constructor a(data_.allocators_);
                    a.construct(v);



                    if(reserve(size() + 1))
                        bucket = data_.bucket_ptr_from_hash(hash_value);



                    link_ptr n = data_.link_node_in_bucket(a, bucket);

                    return std::pair<iterator_base, bool>(
                        iterator_base(bucket, n), true);
                }
            }





            iterator_base insert_hint(iterator_base const& it, value_type const& v)
            {
                if(it != data_.end() && equal(extract_key(v), *it))
                    return it;
                else
                    return insert(v).first;
            }
# 2006 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
            template <typename I>
            size_type insert_size(I i, I j, boost::forward_traversal_tag)
            {
                return unordered_detail::distance(i, j);
            }

            template <typename I>
            size_type insert_size(I, I, boost::incrementable_traversal_tag)
            {
                return 1;
            }

            template <typename I>
            size_type insert_size(I i, I j)
            {
                typename boost::iterator_traversal<I>::type
                    iterator_traversal_tag;
                return insert_size(i, j, iterator_traversal_tag);
            }



            template <typename InputIterator>
            void insert_range(InputIterator i, InputIterator j)
            {
                node_constructor a(data_.allocators_);

                for (; i != j; ++i) {

                    size_type hash_value = hash_function()(extract_key(*i));
                    bucket_ptr bucket = data_.bucket_ptr_from_hash(hash_value);
                    link_ptr pos = find_iterator(bucket, extract_key(*i));

                    if (!pos) {





                        a.construct(*i);



                        if(size() + 1 >= max_load_) {
                            reserve(size() + insert_size(i, j));
                            bucket = data_.bucket_ptr_from_hash(hash_value);
                        }


                        data_.link_node_in_bucket(a, bucket);
                    }
                }
            }

        public:




            size_type erase_key(key_type const& k)
            {

                bucket_ptr bucket = get_bucket(k);
                link_ptr* it = find_for_erase(bucket, k);


                return *it ? data_.erase_group(it, bucket) : 0;
            }




            size_type count(key_type const& k) const
            {
                link_ptr it = find_iterator(k);
                return it ? data::group_count(it) : 0;
            }




            iterator_base find(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);

                if (it)
                    return iterator_base(bucket, it);
                else
                    return data_.end();
            }

            value_type& at(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);

                if (it)
                    return data::get_value(it);
                else
                    throw std::out_of_range("Unable to find key in unordered_map.");
            }




            std::pair<iterator_base, iterator_base> equal_range(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);
                if (it) {
                    iterator_base first(iterator_base(bucket, it));
                    iterator_base second(first);
                    second.increment_group();
                    return std::pair<iterator_base, iterator_base>(first, second);
                }
                else {
                    return std::pair<iterator_base, iterator_base>(
                            data_.end(), data_.end());
                }
            }


            bool equal(key_type const& k, value_type const& v) const
            {
                return key_eq()(k, extract_key(v));
            }


            link_ptr find_iterator(key_type const& k) const
            {
                return find_iterator(get_bucket(k), k);
            }


            link_ptr find_iterator(bucket_ptr bucket,
                    key_type const& k) const
            {
                link_ptr it = data_.begin(bucket);
                while (it && !equal(k, data::get_value(it)))
                    it = data::next_group(it);

                return it;
            }


            link_ptr* find_for_erase(bucket_ptr bucket, key_type const& k) const
            {
                link_ptr* it = &bucket->next_;
                while(*it && !equal(k, data::get_value(*it)))
                    it = &data::next_group(*it);

                return it;
            }
        };
# 2199 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table_impl.hpp" 3
        template <typename A, typename KeyType>
        inline bool group_equals(
                hash_table_data_unique_keys<A>*,
                typename hash_table_data_unique_keys<A>::link_ptr,
                typename hash_table_data_unique_keys<A>::link_ptr,
                KeyType*,
                type_wrapper<KeyType>*)
        {
            return true;
        }

        template <typename A, typename KeyType>
        inline bool group_equals(
                hash_table_data_unique_keys<A>*,
                typename hash_table_data_unique_keys<A>::link_ptr it1,
                typename hash_table_data_unique_keys<A>::link_ptr it2,
                KeyType*,
                void*)
        {
            typedef hash_table_data_unique_keys<A> data;
            return data::get_value(it1).second == data::get_value(it2).second;
        }


        template <typename V, typename K, typename H, typename P, typename A>
        bool equals(hash_table_unique_keys<V, K, H, P, A> const& t1,
                hash_table_unique_keys<V, K, H, P, A> const& t2)
        {
            typedef hash_table_data_unique_keys<A> data;
            typedef typename data::bucket_ptr bucket_ptr;
            typedef typename data::link_ptr link_ptr;

            if(t1.size() != t2.size()) return false;

            for(bucket_ptr i = t1.data_.cached_begin_bucket_,
                    j = t1.data_.buckets_end(); i != j; ++i)
            {
                for(link_ptr it(i->next_); it; it = data::next_group(it))
                {
                    link_ptr other_pos = t2.find_iterator(t2.extract_key(data::get_value(it)));
                    if(!other_pos ||
                        !group_equals((data*)0, it, other_pos, (K*)0, (type_wrapper<V>*)0))
                        return false;
                }
            }

            return true;
        }



        template <typename Alloc> class hash_iterator_unique_keys;
        template <typename Alloc> class hash_const_iterator_unique_keys;
        template <typename Alloc> class hash_local_iterator_unique_keys;
        template <typename Alloc> class hash_const_local_iterator_unique_keys;
        class iterator_access;





        template <typename Alloc>
        class hash_local_iterator_unique_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_pointer<Alloc>::type,
                typename allocator_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef hash_table_data_unique_keys<Alloc> data;
            typedef typename data::link_ptr ptr;
            typedef hash_const_local_iterator_unique_keys<Alloc> const_local_iterator;

            friend class hash_const_local_iterator_unique_keys<Alloc>;
            ptr ptr_;

        public:
            hash_local_iterator_unique_keys() : ptr_() {
                ;
            }
            explicit hash_local_iterator_unique_keys(ptr x) : ptr_(x) {}
            typename allocator_reference<Alloc>::type operator*() const
                { return data::get_value(ptr_); }
            value_type* operator->() const { return &data::get_value(ptr_); }
            hash_local_iterator_unique_keys& operator++() { ptr_ = ptr_->next_; return *this; }
            hash_local_iterator_unique_keys operator++(int) { hash_local_iterator_unique_keys tmp(ptr_); ptr_ = ptr_->next_; return tmp; }
            bool operator==(hash_local_iterator_unique_keys x) const { return ptr_ == x.ptr_; }
            bool operator==(const_local_iterator x) const { return ptr_ == x.ptr_; }
            bool operator!=(hash_local_iterator_unique_keys x) const { return ptr_ != x.ptr_; }
            bool operator!=(const_local_iterator x) const { return ptr_ != x.ptr_; }
        };

        template <typename Alloc>
        class hash_const_local_iterator_unique_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_const_pointer<Alloc>::type,
                typename allocator_const_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef hash_table_data_unique_keys<Alloc> data;
            typedef typename data::link_ptr ptr;
            typedef hash_local_iterator_unique_keys<Alloc> local_iterator;
            friend class hash_local_iterator_unique_keys<Alloc>;
            ptr ptr_;

        public:
            hash_const_local_iterator_unique_keys() : ptr_() {
                ;
            }
            explicit hash_const_local_iterator_unique_keys(ptr x) : ptr_(x) {}
            hash_const_local_iterator_unique_keys(local_iterator x) : ptr_(x.ptr_) {}
            typename allocator_const_reference<Alloc>::type
                operator*() const { return data::get_value(ptr_); }
            value_type const* operator->() const { return &data::get_value(ptr_); }
            hash_const_local_iterator_unique_keys& operator++() { ptr_ = ptr_->next_; return *this; }
            hash_const_local_iterator_unique_keys operator++(int) { hash_const_local_iterator_unique_keys tmp(ptr_); ptr_ = ptr_->next_; return tmp; }
            bool operator==(local_iterator x) const { return ptr_ == x.ptr_; }
            bool operator==(hash_const_local_iterator_unique_keys x) const { return ptr_ == x.ptr_; }
            bool operator!=(local_iterator x) const { return ptr_ != x.ptr_; }
            bool operator!=(hash_const_local_iterator_unique_keys x) const { return ptr_ != x.ptr_; }
        };






        template <typename Alloc>
        class hash_iterator_unique_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_pointer<Alloc>::type,
                typename allocator_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef typename hash_table_data_unique_keys<Alloc>::iterator_base base;
            typedef hash_const_iterator_unique_keys<Alloc> const_iterator;
            friend class hash_const_iterator_unique_keys<Alloc>;
            base base_;

        public:

            hash_iterator_unique_keys() : base_() {}
            explicit hash_iterator_unique_keys(base const& x) : base_(x) {}
            typename allocator_reference<Alloc>::type
                operator*() const { return *base_; }
            value_type* operator->() const { return &*base_; }
            hash_iterator_unique_keys& operator++() { base_.increment(); return *this; }
            hash_iterator_unique_keys operator++(int) { hash_iterator_unique_keys tmp(base_); base_.increment(); return tmp; }
            bool operator==(hash_iterator_unique_keys const& x) const { return base_ == x.base_; }
            bool operator==(const_iterator const& x) const { return base_ == x.base_; }
            bool operator!=(hash_iterator_unique_keys const& x) const { return base_ != x.base_; }
            bool operator!=(const_iterator const& x) const { return base_ != x.base_; }
        };

        template <typename Alloc>
        class hash_const_iterator_unique_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_const_pointer<Alloc>::type,
                typename allocator_const_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef typename hash_table_data_unique_keys<Alloc>::iterator_base base;
            typedef hash_iterator_unique_keys<Alloc> iterator;
            friend class hash_iterator_unique_keys<Alloc>;
            friend class iterator_access;
            base base_;

        public:

            hash_const_iterator_unique_keys() : base_() {}
            explicit hash_const_iterator_unique_keys(base const& x) : base_(x) {}
            hash_const_iterator_unique_keys(iterator const& x) : base_(x.base_) {}
            typename allocator_const_reference<Alloc>::type
                operator*() const { return *base_; }
            value_type const* operator->() const { return &*base_; }
            hash_const_iterator_unique_keys& operator++() { base_.increment(); return *this; }
            hash_const_iterator_unique_keys operator++(int) { hash_const_iterator_unique_keys tmp(base_); base_.increment(); return tmp; }
            bool operator==(iterator const& x) const { return base_ == x.base_; }
            bool operator==(hash_const_iterator_unique_keys const& x) const { return base_ == x.base_; }
            bool operator!=(iterator const& x) const { return base_ != x.base_; }
            bool operator!=(hash_const_iterator_unique_keys const& x) const { return base_ != x.base_; }
        };
    }
}
# 243 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/hash_table.hpp" 2 3


namespace boost {
    namespace unordered_detail {
        class iterator_access
        {
        public:
            template <class Iterator>
            static typename Iterator::base const& get(Iterator const& it) {
                return it.base_;
            }
        };

        template <class ValueType, class KeyType,
            class Hash, class Pred, class Alloc>
        class hash_types_unique_keys
        {
        public:
            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, ValueType>::type
                value_allocator;

            typedef hash_table_unique_keys<ValueType, KeyType, Hash, Pred,
                    value_allocator> hash_table;
            typedef hash_table_data_unique_keys<value_allocator> data;
            typedef typename data::iterator_base iterator_base;

            typedef hash_const_local_iterator_unique_keys<value_allocator> const_local_iterator;
            typedef hash_local_iterator_unique_keys<value_allocator> local_iterator;
            typedef hash_const_iterator_unique_keys<value_allocator> const_iterator;
            typedef hash_iterator_unique_keys<value_allocator> iterator;

            typedef typename data::size_type size_type;
            typedef std::ptrdiff_t difference_type;
        };

        template <class ValueType, class KeyType,
            class Hash, class Pred, class Alloc>
        class hash_types_equivalent_keys
        {
        public:
            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, ValueType>::type
                value_allocator;

            typedef hash_table_equivalent_keys<ValueType, KeyType, Hash, Pred,
                    value_allocator> hash_table;
            typedef hash_table_data_equivalent_keys<value_allocator> data;
            typedef typename data::iterator_base iterator_base;

            typedef hash_const_local_iterator_equivalent_keys<value_allocator> const_local_iterator;
            typedef hash_local_iterator_equivalent_keys<value_allocator> local_iterator;
            typedef hash_const_iterator_equivalent_keys<value_allocator> const_iterator;
            typedef hash_iterator_equivalent_keys<value_allocator> iterator;

            typedef typename data::size_type size_type;
            typedef std::ptrdiff_t difference_type;
        };
    }
}
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered_map.hpp" 2 3


# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/move.hpp" 1 3
# 23 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/move.hpp" 3
# 1 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/config.hpp" 1 3
# 24 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/move.hpp" 2 3



namespace boost {
namespace unordered_detail {



namespace move_detail {







template <typename T>
struct class_has_move_assign {
    class type {
        typedef T& (T::*E)(T t);
        typedef char (&no_type)[1];
        typedef char (&yes_type)[2];
        template <E e> struct sfinae { typedef yes_type type; };
        template <class U>
        static typename sfinae<&U::operator=>::type test(int);
        template <class U>
        static no_type test(...);
    public:
        enum {value = sizeof(test<T>(1)) == sizeof(yes_type)};
    };
 };



template<typename T>
struct has_move_assign : boost::mpl::and_<boost::is_class<T>, class_has_move_assign<T> > {};



class test_can_convert_anything { };
# 76 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/move.hpp" 3
template <typename T, typename U>
struct is_convertible : boost::mpl::or_<
    boost::is_same<T, U>,
    boost::is_convertible<T, U>
> { };



}
# 94 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/move.hpp" 3
template <typename T>
struct move_from
{
    explicit move_from(T& x) : source(x) { }
    T& source;
};
# 111 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/move.hpp" 3
template <typename T>
struct is_movable : boost::mpl::and_<
                        boost::is_convertible<move_from<T>, T>,
                        move_detail::has_move_assign<T>,
                        boost::mpl::not_<boost::is_convertible<move_detail::test_can_convert_anything, T> >
                    > { };
# 143 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/move.hpp" 3
template <typename T,
          typename U = T,
          typename R = void*>
struct copy_sink : boost::enable_if<
                        boost::mpl::and_<
                            boost::unordered_detail::move_detail::is_convertible<T, U>,
                            boost::mpl::not_<is_movable<T> >
                        >,
                        R
                    >
{ };
# 164 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/move.hpp" 3
template <typename T,
          typename U = T,
          typename R = void*>
struct move_sink : boost::enable_if<
                        boost::mpl::and_<
                            boost::unordered_detail::move_detail::is_convertible<T, U>,
                            is_movable<T>
                        >,
                        R
                    >
{ };
# 185 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/move.hpp" 3
template <typename T>
T move(T& x, typename move_sink<T>::type = 0) { return T(move_from<T>(x)); }
# 195 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/move.hpp" 3
template <typename T>
T& move(T& x, typename copy_sink<T>::type = 0) { return x; }
# 221 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered/detail/move.hpp" 3
}
}
# 26 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered_map.hpp" 2 3


namespace boost
{
    template <class Key,
        class T,
        class Hash = hash<Key>,
        class Pred = std::equal_to<Key>,
        class Alloc = std::allocator<std::pair<const Key, T> > >
    class unordered_map;
    template <class K, class T, class H, class P, class A>
    bool operator==(unordered_map<K, T, H, P, A> const&,
        unordered_map<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    bool operator!=(unordered_map<K, T, H, P, A> const&,
        unordered_map<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    void swap(unordered_map<K, T, H, P, A>&,
            unordered_map<K, T, H, P, A>&);

    template <class Key,
        class T,
        class Hash = hash<Key>,
        class Pred = std::equal_to<Key>,
        class Alloc = std::allocator<std::pair<const Key, T> > >
    class unordered_multimap;
    template <class K, class T, class H, class P, class A>
    bool operator==(unordered_multimap<K, T, H, P, A> const&,
        unordered_multimap<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    bool operator!=(unordered_multimap<K, T, H, P, A> const&,
        unordered_multimap<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    void swap(unordered_multimap<K, T, H, P, A>&,
            unordered_multimap<K, T, H, P, A>&);

    template <class Key, class T, class Hash, class Pred, class Alloc>
    class unordered_map
    {
        typedef boost::unordered_detail::hash_types_unique_keys<
            std::pair<const Key, T>, Key, Hash, Pred, Alloc
        > implementation;

        typename implementation::hash_table base;

    public:



        typedef Key key_type;
        typedef std::pair<const Key, T> value_type;
        typedef T mapped_type;
        typedef Hash hasher;
        typedef Pred key_equal;

        typedef Alloc allocator_type;
        typedef typename allocator_type::pointer pointer;
        typedef typename allocator_type::const_pointer const_pointer;
        typedef typename allocator_type::reference reference;
        typedef typename allocator_type::const_reference const_reference;

        typedef typename implementation::size_type size_type;
        typedef typename implementation::difference_type difference_type;

        typedef typename implementation::iterator iterator;
        typedef typename implementation::const_iterator const_iterator;
        typedef typename implementation::local_iterator local_iterator;
        typedef typename implementation::const_local_iterator const_local_iterator;



        explicit unordered_map(
                size_type n = boost::unordered_detail::default_initial_bucket_count,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
            : base(n, hf, eql, a)
        {
        }

        explicit unordered_map(allocator_type const& a)
            : base(boost::unordered_detail::default_initial_bucket_count,
                hasher(), key_equal(), a)
        {
        }

        unordered_map(unordered_map const& other, allocator_type const& a)
            : base(other.base, a)
        {
        }

        template <class InputIterator>
        unordered_map(InputIterator f, InputIterator l)
            : base(f, l, boost::unordered_detail::default_initial_bucket_count,
                hasher(), key_equal(), allocator_type())
        {
        }

        template <class InputIterator>
        unordered_map(InputIterator f, InputIterator l,
                size_type n,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
            : base(f, l, n, hf, eql, a)
        {
        }
# 151 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered_map.hpp" 3
        unordered_map(boost::unordered_detail::move_from<unordered_map<Key, T, Hash, Pred, Alloc> > other)
            : base(other.source.base, boost::unordered_detail::move_tag())
        {
        }


        unordered_map& operator=(unordered_map x)
        {
            base.move(x.base);
            return *this;
        }



    private:

        typename implementation::iterator_base const&
            get(const_iterator const& it)
        {
            return boost::unordered_detail::iterator_access::get(it);
        }

    public:

        allocator_type get_allocator() const
        {
            return base.get_allocator();
        }



        bool empty() const
        {
            return base.empty();
        }

        size_type size() const
        {
            return base.size();
        }

        size_type max_size() const
        {
            return base.max_size();
        }



        iterator begin()
        {
            return iterator(base.data_.begin());
        }

        const_iterator begin() const
        {
            return const_iterator(base.data_.begin());
        }

        iterator end()
        {
            return iterator(base.data_.end());
        }

        const_iterator end() const
        {
            return const_iterator(base.data_.end());
        }

        const_iterator cbegin() const
        {
            return const_iterator(base.data_.begin());
        }

        const_iterator cend() const
        {
            return const_iterator(base.data_.end());
        }
# 246 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered_map.hpp" 3
        std::pair<iterator, bool> insert(const value_type& obj)
        {
            return boost::unordered_detail::pair_cast<iterator, bool>(
                    base.insert(obj));
        }

        iterator insert(const_iterator hint, const value_type& obj)
        {
            return iterator(base.insert_hint(get(hint), obj));
        }

        template <class InputIterator>
            void insert(InputIterator first, InputIterator last)
        {
            base.insert_range(first, last);
        }

        iterator erase(const_iterator position)
        {
            return iterator(base.data_.erase(get(position)));
        }

        size_type erase(const key_type& k)
        {
            return base.erase_key(k);
        }

        iterator erase(const_iterator first, const_iterator last)
        {
            return iterator(base.data_.erase_range(get(first), get(last)));
        }

        void clear()
        {
            base.data_.clear();
        }

        void swap(unordered_map& other)
        {
            base.swap(other.base);
        }



        hasher hash_function() const
        {
            return base.hash_function();
        }

        key_equal key_eq() const
        {
            return base.key_eq();
        }

        mapped_type& operator[](const key_type &k)
        {
            return base[k].second;
        }

        mapped_type& at(const key_type& k)
        {
            return base.at(k).second;
        }

        mapped_type const& at(const key_type& k) const
        {
            return base.at(k).second;
        }



        iterator find(const key_type& k)
        {
            return iterator(base.find(k));
        }

        const_iterator find(const key_type& k) const
        {
            return const_iterator(base.find(k));
        }

        size_type count(const key_type& k) const
        {
            return base.count(k);
        }

        std::pair<iterator, iterator>
            equal_range(const key_type& k)
        {
            return boost::unordered_detail::pair_cast<iterator, iterator>(
                    base.equal_range(k));
        }

        std::pair<const_iterator, const_iterator>
            equal_range(const key_type& k) const
        {
            return boost::unordered_detail::pair_cast<const_iterator, const_iterator>(
                    base.equal_range(k));
        }



        size_type bucket_count() const
        {
            return base.bucket_count();
        }

        size_type max_bucket_count() const
        {
            return base.max_bucket_count();
        }

        size_type bucket_size(size_type n) const
        {
            return base.data_.bucket_size(n);
        }

        size_type bucket(const key_type& k) const
        {
            return base.bucket(k);
        }

        local_iterator begin(size_type n)
        {
            return local_iterator(base.data_.begin(n));
        }

        const_local_iterator begin(size_type n) const
        {
            return const_local_iterator(base.data_.begin(n));
        }

        local_iterator end(size_type n)
        {
            return local_iterator(base.data_.end(n));
        }

        const_local_iterator end(size_type n) const
        {
            return const_local_iterator(base.data_.end(n));
        }

        const_local_iterator cbegin(size_type n) const
        {
            return const_local_iterator(base.data_.begin(n));
        }

        const_local_iterator cend(size_type n) const
        {
            return const_local_iterator(base.data_.end(n));
        }



        float load_factor() const
        {
            return base.load_factor();
        }

        float max_load_factor() const
        {
            return base.max_load_factor();
        }

        void max_load_factor(float m)
        {
            base.max_load_factor(m);
        }

        void rehash(size_type n)
        {
            base.rehash(n);
        }





        friend bool operator==<>(unordered_map const&, unordered_map const&);
        friend bool operator!=<>(unordered_map const&, unordered_map const&);

    };

    template <class K, class T, class H, class P, class A>
    inline bool operator==(unordered_map<K, T, H, P, A> const& m1,
        unordered_map<K, T, H, P, A> const& m2)
    {
        return boost::unordered_detail::equals(m1.base, m2.base);
    }

    template <class K, class T, class H, class P, class A>
    inline bool operator!=(unordered_map<K, T, H, P, A> const& m1,
        unordered_map<K, T, H, P, A> const& m2)
    {
        return !boost::unordered_detail::equals(m1.base, m2.base);
    }

    template <class K, class T, class H, class P, class A>
    inline void swap(unordered_map<K, T, H, P, A> &m1,
            unordered_map<K, T, H, P, A> &m2)
    {
        m1.swap(m2);
    }

    template <class Key, class T, class Hash, class Pred, class Alloc>
    class unordered_multimap
    {
        typedef boost::unordered_detail::hash_types_equivalent_keys<
            std::pair<const Key, T>, Key, Hash, Pred, Alloc
        > implementation;

        typename implementation::hash_table base;

        public:



        typedef Key key_type;
        typedef std::pair<const Key, T> value_type;
        typedef T mapped_type;
        typedef Hash hasher;
        typedef Pred key_equal;

        typedef Alloc allocator_type;
        typedef typename allocator_type::pointer pointer;
        typedef typename allocator_type::const_pointer const_pointer;
        typedef typename allocator_type::reference reference;
        typedef typename allocator_type::const_reference const_reference;

        typedef typename implementation::size_type size_type;
        typedef typename implementation::difference_type difference_type;

        typedef typename implementation::iterator iterator;
        typedef typename implementation::const_iterator const_iterator;
        typedef typename implementation::local_iterator local_iterator;
        typedef typename implementation::const_local_iterator const_local_iterator;



        explicit unordered_multimap(
                size_type n = boost::unordered_detail::default_initial_bucket_count,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
          : base(n, hf, eql, a)
        {
        }

        explicit unordered_multimap(allocator_type const& a)
            : base(boost::unordered_detail::default_initial_bucket_count,
                hasher(), key_equal(), a)
        {
        }

        unordered_multimap(unordered_multimap const& other, allocator_type const& a)
            : base(other.base, a)
        {
        }

        template <class InputIterator>
        unordered_multimap(InputIterator f, InputIterator l)
            : base(f, l, boost::unordered_detail::default_initial_bucket_count,
                hasher(), key_equal(), allocator_type())
        {
        }

        template <class InputIterator>
        unordered_multimap(InputIterator f, InputIterator l,
                size_type n,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
          : base(f, l, n, hf, eql, a)
        {
        }
# 539 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered_map.hpp" 3
        unordered_multimap(boost::unordered_detail::move_from<unordered_multimap<Key, T, Hash, Pred, Alloc> > other)
            : base(other.source.base, boost::unordered_detail::move_tag())
        {
        }


        unordered_multimap& operator=(unordered_multimap x)
        {
            base.move(x.base);
            return *this;
        }




    private:

        typename implementation::iterator_base const&
            get(const_iterator const& it)
        {
            return boost::unordered_detail::iterator_access::get(it);
        }

    public:

        allocator_type get_allocator() const
        {
            return base.get_allocator();
        }



        bool empty() const
        {
            return base.empty();
        }

        size_type size() const
        {
            return base.size();
        }

        size_type max_size() const
        {
            return base.max_size();
        }



        iterator begin()
        {
            return iterator(base.data_.begin());
        }

        const_iterator begin() const
        {
            return const_iterator(base.data_.begin());
        }

        iterator end()
        {
            return iterator(base.data_.end());
        }

        const_iterator end() const
        {
            return const_iterator(base.data_.end());
        }

        const_iterator cbegin() const
        {
            return const_iterator(base.data_.begin());
        }

        const_iterator cend() const
        {
            return const_iterator(base.data_.end());
        }
# 634 "/Library/Application Support/MonkeyWorks/Developer/include/boost/unordered_map.hpp" 3
        iterator insert(const value_type& obj)
        {
            return iterator(base.insert(obj));
        }

        iterator insert(const_iterator hint, const value_type& obj)
        {
            return iterator(base.insert_hint(get(hint), obj));
        }

        template <class InputIterator>
            void insert(InputIterator first, InputIterator last)
        {
            base.insert_range(first, last);
        }

        iterator erase(const_iterator position)
        {
            return iterator(base.data_.erase(get(position)));
        }

        size_type erase(const key_type& k)
        {
            return base.erase_key(k);
        }

        iterator erase(const_iterator first, const_iterator last)
        {
            return iterator(base.data_.erase_range(get(first), get(last)));
        }

        void clear()
        {
            base.data_.clear();
        }

        void swap(unordered_multimap& other)
        {
            base.swap(other.base);
        }



        hasher hash_function() const
        {
            return base.hash_function();
        }

        key_equal key_eq() const
        {
            return base.key_eq();
        }



        iterator find(const key_type& k)
        {
            return iterator(base.find(k));
        }

        const_iterator find(const key_type& k) const
        {
            return const_iterator(base.find(k));
        }

        size_type count(const key_type& k) const
        {
            return base.count(k);
        }

        std::pair<iterator, iterator>
            equal_range(const key_type& k)
        {
            return boost::unordered_detail::pair_cast<iterator, iterator>(
                    base.equal_range(k));
        }

        std::pair<const_iterator, const_iterator>
            equal_range(const key_type& k) const
        {
            return boost::unordered_detail::pair_cast<const_iterator, const_iterator>(
                    base.equal_range(k));
        }



        size_type bucket_count() const
        {
            return base.bucket_count();
        }

        size_type max_bucket_count() const
        {
            return base.max_bucket_count();
        }

        size_type bucket_size(size_type n) const
        {
            return base.data_.bucket_size(n);
        }

        size_type bucket(const key_type& k) const
        {
            return base.bucket(k);
        }

        local_iterator begin(size_type n)
        {
            return local_iterator(base.data_.begin(n));
        }

        const_local_iterator begin(size_type n) const
        {
            return const_local_iterator(base.data_.begin(n));
        }

        local_iterator end(size_type n)
        {
            return local_iterator(base.data_.end(n));
        }

        const_local_iterator end(size_type n) const
        {
            return const_local_iterator(base.data_.end(n));
        }

        const_local_iterator cbegin(size_type n) const
        {
            return const_local_iterator(base.data_.begin(n));
        }

        const_local_iterator cend(size_type n) const
        {
            return const_local_iterator(base.data_.end(n));
        }



        float load_factor() const
        {
            return base.load_factor();
        }

        float max_load_factor() const
        {
            return base.max_load_factor();
        }

        void max_load_factor(float m)
        {
            base.max_load_factor(m);
        }

        void rehash(size_type n)
        {
            base.rehash(n);
        }





        friend bool operator==<>(unordered_multimap const&, unordered_multimap const&);
        friend bool operator!=<>(unordered_multimap const&, unordered_multimap const&);

    };

    template <class K, class T, class H, class P, class A>
    inline bool operator==(unordered_multimap<K, T, H, P, A> const& m1,
        unordered_multimap<K, T, H, P, A> const& m2)
    {
        return boost::unordered_detail::equals(m1.base, m2.base);
    }

    template <class K, class T, class H, class P, class A>
    inline bool operator!=(unordered_multimap<K, T, H, P, A> const& m1,
        unordered_multimap<K, T, H, P, A> const& m2)
    {
        return !boost::unordered_detail::equals(m1.base, m2.base);
    }

    template <class K, class T, class H, class P, class A>
    inline void swap(unordered_multimap<K, T, H, P, A> &m1,
            unordered_multimap<K, T, H, P, A> &m2)
    {
        m1.swap(m2);
    }

}
# 43 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentRegistry.h" 2 3


namespace mw {
 class ComponentRegistry {

 protected:

  static shared_ptr<ComponentRegistry> shared_component_registry;


  std::map< std::string, shared_ptr<ComponentFactory> > factories;


    boost::unordered_map< std::string, shared_ptr<mw::Component> > instances;
  std::map< std::string, shared_ptr<StimulusNode> > stimulus_nodes;
  std::map< long, std::string > tagnames_by_id;



    boost::regex r1, r2, r3, r4, u1, strip_it;

    boost::unordered_map< std::string, shared_ptr<Variable> > variable_cache;
    boost::unordered_map< std::string, shared_ptr<Data> > data_cache;

 public:

  ComponentRegistry();

  static shared_ptr<ComponentRegistry> getSharedRegistry(){
   if(shared_component_registry == __null){
    shared_ptr<ComponentRegistry> shared(new ComponentRegistry());
    shared_component_registry = shared;
   }

   return shared_component_registry;
  }

  void resetInstances(){
   instances = boost::unordered_map< std::string, shared_ptr<mw::Component> >();
   stimulus_nodes = std::map< std::string, shared_ptr<StimulusNode> >();
  }


  void registerFactory(std::string type_name,
        ComponentFactory *factory);

  shared_ptr<ComponentFactory> getFactory(std::string type_name);






  shared_ptr<mw::Component> registerNewObject(std::string tag_name,
               std::string type_name,
               std::map<std::string, std::string> params);

  shared_ptr<mw::Component> createNewObject(const std::string &type_name,
             const std::map<std::string, std::string> &params);


  void registerObject(std::string tag_name, shared_ptr<mw::Component> component, bool force = false);
  void registerAltObject(const std::string &tag_name, shared_ptr<mw::Component> component);


  void registerStimulusNode(const std::string &tag_name, shared_ptr<StimulusNode> stimNode);

  shared_ptr<StimulusNode> getStimulusNode(std::string tag_name){
   return stimulus_nodes[tag_name];
  }






  template <class T>
  shared_ptr<T> getObject(std::string tag_name, std::string parent_scope){


   vector<string> scope_components;
   split(scope_components, parent_scope, is_any_of("/"));

   shared_ptr<T> candidate;

   for(int i = scope_components.size(); i >= 0; i--){
    string qualified_tag = "";

    for(int j=0; j < i; j++){
     qualified_tag += scope_components[j] + "/";
    }

    qualified_tag += tag_name;

    candidate = getObject<T>(qualified_tag);
    if(candidate != __null){
     return candidate;
    }
   }

   return candidate;
  }

  template <class T>
  shared_ptr<T> getObject(std::string tag_name){
   shared_ptr<mw::Component> obj = instances[tag_name];
# 158 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/ComponentRegistry.h" 3
   if(obj == __null){

    return shared_ptr<T>();
   }
   return dynamic_pointer_cast<T, mw::Component>(obj);
  }


  shared_ptr<Variable> getVariable(std::string expression);
  shared_ptr<Variable> getVariable(std::string expression,
           std::string default_expression);
  shared_ptr<StimulusNode> getStimulus(std::string expression);


  bool getBoolean(std::string expression);
  Data getNumber(std::string expression, GenericDataType type = M_FLOAT);
  boost::filesystem::path getPath(std::string working,
          std::string expression);

  Data getComponentCodec(){

   int dict_size = tagnames_by_id.empty() ? 1 : tagnames_by_id.size();

   Data codec(M_DICTIONARY, dict_size);
   std::map< long, std::string>::const_iterator it;

   for(it = tagnames_by_id.begin(); it != tagnames_by_id.end(); it++){
    codec.addElement((*it).first, (*it).second);
   }

   return codec;
  }


 };


}
# 27 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Plugin.h" 2 3

namespace mw {

 class Plugin {

    public:
        virtual ~Plugin() { }
  virtual void registerComponents(shared_ptr<ComponentRegistry> registry) { }

 };
}
# 15 "/Users/graham/Developer/mwMaskStimulus/mwMaskStimulus.h" 2
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StandardStimuli.h" 1 3
# 23 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StandardStimuli.h" 3
# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Experiment.h" 1 3






# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/KeyTrigger.h" 1 3
# 16 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/KeyTrigger.h" 3
namespace mw {
enum KeyModifier{ NO_MODIFIER, OPTION_KEY, COMMAND_KEY, ALT_KEY, CONTROL_KEY, SHIFT_KEY};


class KeyTrigger{

 protected:

  char key;
  KeyModifier modifier;
  Variable *togglevar;
  Variable *active;

  bool setadditionalvalue;
  Variable *radiovar;
  Data value;
# 51 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/KeyTrigger.h" 3
 public:

  KeyTrigger(char _key, Variable *_toggle, Variable *_active){
   key = _key;
   modifier = NO_MODIFIER;
   togglevar = _toggle;
   active = _active;

   setadditionalvalue = false;
  }

  KeyTrigger(KeyModifier _modifier, char _key, Variable *_toggle, Variable *_active){

   key = _key;
   modifier = _modifier;
   togglevar = _toggle;
   active = _active;

   setadditionalvalue = false;
  }

  KeyTrigger(char _code, Variable *_toggle, Variable *_radiovar, Data _val, Variable *_active){

   key = _code;
   modifier = NO_MODIFIER;
   togglevar = _toggle;
   active = _active;

   radiovar = _radiovar;
   value = _val;

   setadditionalvalue = true;
  }

  KeyTrigger(KeyModifier _modifier, char _key, Variable *_toggle, Variable *_radiovar, Data _val, Variable *_active){

   key = _key;
   modifier = _modifier;
   togglevar = _toggle;
   active = _active;

   radiovar = _radiovar;
   value = _val;

   setadditionalvalue = true;
  }

  void trigger();

        char getKey() { return key; }
        KeyModifier getKeyModifier() { return modifier; }
        bool isAdditionalValueSet() { return setadditionalvalue; }
        bool isActive();
        Variable * getToggleVar() { return togglevar; }

        Variable * getRadioVar() { return radiovar; }
        Data * getValue() { return &value; }
# 126 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/KeyTrigger.h" 3
};
}
# 8 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Experiment.h" 2 3




# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/BlockAndProtocol.h" 1 3
# 16 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/BlockAndProtocol.h" 3
namespace mw {

class Block : public ListState{

public:

 Block();

 virtual shared_ptr<mw::Component> createInstanceObject();

 virtual void action();
 virtual weak_ptr<State> next();
};


class Protocol : public ListState {


public:

 Protocol();

 virtual shared_ptr<mw::Component> createInstanceObject();
};


class GenericListState : public ListState {

public:

 GenericListState();

 virtual shared_ptr<mw::Component> createInstanceObject();


};


class Trial : public ListState {

public:

 Trial();


 virtual void action();
 virtual weak_ptr<State> next();
 virtual shared_ptr<mw::Component> createInstanceObject();

};


class BlockFactory : public ListStateFactory<Block>{};
class TrialFactory : public ListStateFactory<Trial>{};
class ProtocolFactory : public ListStateFactory<mw::Protocol>{};
class GenericListStateFactory : public ListStateFactory<GenericListState>{};
}
# 13 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Experiment.h" 2 3


# 1 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/LoadingUtilities.h" 1 3
# 12 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/LoadingUtilities.h" 3
namespace mw {
 bool loadSetupVariables();
 bool loadExperimentFromXMLParser(const boost::filesystem::path filepath);
 void parseMediaTagsFromExperiment(const boost::filesystem::path filepath);

 void unloadExperiment(bool announce = true);

 boost::filesystem::path expandPath(std::string working_directory, std::string path);




 void prepareStimulusDisplay();

 void expandRangeReplicatorItems(const boost::filesystem::path filepath);
 void modifyExperimentMediaPaths(const boost::filesystem::path filepath);
 void createExperimentInstallDirectoryStructure(const std::string expName);

 std::string removeSpacesFromString(std::string s);
}
# 16 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Experiment.h" 2 3
# 144 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/Experiment.h" 3
namespace mw {
extern void setCurrentExperiment(Experiment *exp);
extern shared_ptr<Experiment> GlobalCurrentExperiment;

enum{M_INFO, M_STATUS};

class Experiment : public ContainerState {
    protected:


     weak_ptr<State> current_state;


  shared_ptr<mw::Protocol> current_protocol;





  shared_ptr<VariableRegistry> variable_registry;


  shared_ptr<StimulusDisplay> stimulus_display;

  int n_protocols;


  std::string experimentName;
  std::string experimentPath;


  void logChange(Variable *variable, const Data& data);
  void logChange(Variable *variable, const Data& data, MonkeyWorksTime timeUS);

    public:
  Experiment(shared_ptr<VariableRegistry> variable_reg);
  virtual ~Experiment();



     void createVariableContexts();


    virtual void requestVariableContext(){ };







  virtual weak_ptr<State> getCurrentState();
     virtual void setCurrentState(weak_ptr<State> newstate);



  virtual void action();
  virtual weak_ptr<State> next();



  void update();
  virtual void reset();




  void setExperimentName(std::string);
        std::string getExperimentName();
        void setExperimentPath(std::string);
  std::string getExperimentPath();







  virtual void announceLocalVariables(){
   ScopedVariableEnvironment::announceAll();
  }



     shared_ptr<StimulusDisplay> getStimulusDisplay();
        void setStimulusDisplay(shared_ptr<StimulusDisplay> newdisplay);



     void setCurrentProtocol(unsigned int protocol_number);
        void setCurrentProtocol(std::string);
     shared_ptr<mw::Protocol> getCurrentProtocol();
     shared_ptr<VariableRegistry> getVariableRegistry();



  virtual State *getStateInstance();




  virtual void finalize(std::map<std::string, std::string> parameters,
            ComponentRegistry *reg) {
   current_state = getSelfPtr<State>();
   experiment = getSelfPtr<Experiment>();
   environment = getSelfPtr<ScopedVariableEnvironment>();
   createVariableContexts();
  }

  virtual void addChild(std::map<std::string, std::string> parameters,
        ComponentRegistry *reg,
        shared_ptr<mw::Component> child){

   ContainerState::addChild(parameters, reg, child);

   if(current_protocol == __null) {
    shared_ptr<State> first_protocol = list->operator[](0);
    current_protocol = boost::dynamic_pointer_cast<mw::Protocol, State>(first_protocol);
    current_state = weak_ptr<State>(first_protocol);
   }
   n_protocols++;
  }
};



class ExperimentFactory : public ComponentFactory {

 public:

 virtual shared_ptr<mw::Component> createObject(std::map<std::string, std::string> parameters,
            ComponentRegistry *reg) {
  GlobalCurrentExperiment = shared_ptr<Experiment>(new Experiment(GlobalVariableRegistry));





  prepareStimulusDisplay();

  shared_ptr<mw::Component> experiment = dynamic_pointer_cast<mw::Component, Experiment>(GlobalCurrentExperiment);

  if(!parameters["tag"].empty()){
   GlobalCurrentExperiment->setExperimentName(parameters["tag"]);
  }
  return experiment;
 }

};

}
# 24 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StandardStimuli.h" 2 3

namespace mw {



class OffsetStimulusContainer : public Stimulus {
 protected:
  shared_ptr<Stimulus> stim;
  shared_ptr<Variable> xoffset;
  shared_ptr<Variable> yoffset;

 public:



  OffsetStimulusContainer(std::string _tag, shared_ptr<Stimulus> _stim);
  OffsetStimulusContainer(std::string _tag, shared_ptr<Stimulus> _stim,
         shared_ptr<Variable> _xdeg,
         shared_ptr<Variable> _ydeg);

        OffsetStimulusContainer(OffsetStimulusContainer& copy);
  ~OffsetStimulusContainer();
        virtual Stimulus * frozenClone();

  virtual void draw(StimulusDisplay * display, float x, float y);
  virtual void draw(StimulusDisplay * display, float x, float y,
                                                    float sizex, float sizey);
    private:



        void operator=(const OffsetStimulusContainer& l) { }
};



class BasicTransformStimulus : public Stimulus {

 protected:
  shared_ptr<Variable> xoffset;
  shared_ptr<Variable> yoffset;

  shared_ptr<Variable> xscale;
  shared_ptr<Variable> yscale;

  shared_ptr<Variable> rotation;
  shared_ptr<Variable> alpha_multiplier;


        float last_posx, last_posy, last_sizex, last_sizey, last_rot;

 public:
        BasicTransformStimulus(std::string _tag,
        shared_ptr<Variable> _xoffset,
        shared_ptr<Variable> _yoffset,
        shared_ptr<Variable> _xscale,
        shared_ptr<Variable> _yscale,
        shared_ptr<Variable> _rot,
        shared_ptr<Variable> _alpha);
  BasicTransformStimulus(const BasicTransformStimulus& tocopy);
  ~BasicTransformStimulus();

        virtual Stimulus * frozenClone();

  virtual void setTranslation(shared_ptr<Variable> _x,
         shared_ptr<Variable> _y);
        virtual void setScale(shared_ptr<Variable> _scale);
        virtual void setScale(shared_ptr<Variable> _xscale,
         shared_ptr<Variable> _yscale);
        virtual void setRotation(shared_ptr<Variable> rot);
        virtual void draw(StimulusDisplay * display);
        virtual void draw(StimulusDisplay * display,float x, float y,
                                                    float sizex, float sizey);
        virtual Data getCurrentAnnounceDrawData();

    virtual shared_ptr<Variable> getXScale(){ return xscale; }
    virtual shared_ptr<Variable> getYScale(){ return yscale; }
    virtual shared_ptr<Variable> getXOffset(){ return xoffset; }
    virtual shared_ptr<Variable> getYOffset(){ return yoffset; }
};

class OpenGLImageLoader {
 protected:


 public:
  static bool initialized;
  static Lockable *lock;

  static GLuint load(std::string filename, StimulusDisplay *display,
                                                   int *width, int *height);
};


class ImageStimulus : public BasicTransformStimulus {
    protected:
        std::string filename;
        ExpandableList<GLuint> *texture_maps;
  int width, height;


  ConstantVariable *const0, *const2;

    public:
        ImageStimulus(std::string _tag, std::string filename,
        shared_ptr<Variable> _xoffset,
        shared_ptr<Variable> _yoffset,
        shared_ptr<Variable> _xscale,
        shared_ptr<Variable> _yscale,
        shared_ptr<Variable> _rot,
         shared_ptr<Variable> _alpha);

  ImageStimulus(std::string _tag, std::string _filename,
        ExpandableList<GLuint> *_texture_maps,
        int _width,
        int _height,
        shared_ptr<Variable> _xoffset,
                                shared_ptr<Variable> _yoffset,
        shared_ptr<Variable> _xscale,
                                shared_ptr<Variable> _yscale,
        shared_ptr<Variable> _rot,
        shared_ptr<Variable> _alpha);

        ImageStimulus(ImageStimulus& copy);
        virtual ~ImageStimulus();
  virtual Stimulus * frozenClone();

        std::string getFilename();
        virtual void drawInUnitSquare(StimulusDisplay *display);
        virtual void load(StimulusDisplay *display);
        virtual Data getCurrentAnnounceDrawData();
};

class ImageStimulusFactory : public ComponentFactory {
 virtual shared_ptr<mw::Component> createObject(std::map<std::string, std::string> parameters,
            ComponentRegistry *reg);
};




class PointStimulus : public BasicTransformStimulus {
    protected:
        shared_ptr<Variable> r;
  shared_ptr<Variable> g;
  shared_ptr<Variable> b;
        float last_r,last_g,last_b;

    public:
        PointStimulus(std::string _tag, shared_ptr<Variable> _xoffset,
          shared_ptr<Variable> _yoffset,
                                        shared_ptr<Variable> _xscale,
                                        shared_ptr<Variable> _yscale,
        shared_ptr<Variable> _rot,
        shared_ptr<Variable> _alpha,
                                        shared_ptr<Variable> _r,
                                        shared_ptr<Variable> _g,
                                        shared_ptr<Variable> _b);
  PointStimulus(const PointStimulus &tocopy);
  ~PointStimulus();
  virtual Stimulus * frozenClone();

        virtual void drawInUnitSquare(StimulusDisplay *display);
        virtual Data getCurrentAnnounceDrawData();

};
# 231 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StandardStimuli.h" 3
class CompoundStimulus : public Stimulus {

    protected:
        ExpandableList<OffsetStimulusContainer> *stimList;
        std::string currentSubTag;

 public:
        CompoundStimulus(std::string _tag);
        ~CompoundStimulus();

  virtual Stimulus * frozenClone();

        void addStimulus(shared_ptr<Stimulus> stim);
        void addStimulus(shared_ptr<Stimulus> stim,
       shared_ptr<Variable> _xloc,
       shared_ptr<Variable> _yloc);

        virtual void draw(StimulusDisplay * display,
        float xdeg, float ydeg);
        void makeSubTag();
        virtual void announceStimulusDraw(MonkeyWorksTime now);

};

class BlankScreen : public Stimulus{


    protected:
        shared_ptr<Variable> r;
  shared_ptr<Variable> g;
  shared_ptr<Variable> b;
        float last_r,last_g,last_b;

    public:
        BlankScreen(std::string _tag,
      shared_ptr<Variable> r,
      shared_ptr<Variable> g,
      shared_ptr<Variable> b);
  virtual ~BlankScreen();
  virtual Stimulus * frozenClone();

        virtual void drawInUnitSquare(StimulusDisplay *display);
        virtual Data getCurrentAnnounceDrawData();
};

class BlankScreenFactory : public ComponentFactory {
 virtual shared_ptr<mw::Component> createObject(std::map<std::string, std::string> parameters,
            ComponentRegistry *reg);
};
# 298 "/Developer/SDKs/MacOSX10.5.sdk/Library/Frameworks/MonkeyWorksCore.framework/Headers/StandardStimuli.h" 3
}
# 16 "/Users/graham/Developer/mwMaskStimulus/mwMaskStimulus.h" 2

using namespace mw;

class mwMaskStimulus : public ImageStimulus{

protected:
    shared_ptr<Variable> random_seed;
    float *image_data;
public:
 mwMaskStimulus(std::string _tag, std::string filename,
                                        shared_ptr<Variable> _xoffset,
                                        shared_ptr<Variable> _yoffset,
                                        shared_ptr<Variable> _xscale,
                                        shared_ptr<Variable> _yscale,
                                        shared_ptr<Variable> _rot,
                                        shared_ptr<Variable> _alpha,
                                        shared_ptr<Variable> _random_seed);
 mwMaskStimulus(const mwMaskStimulus &tocopy);
 ~mwMaskStimulus();
    shared_ptr<Variable> getRandomSeed();

    virtual void makeMask(StimulusDisplay *display);
    virtual void load(StimulusDisplay *display);

    virtual Data getCurrentAnnounceDrawData();
};
# 11 "/Users/graham/Developer/mwMaskStimulus/mwMaskStimulus.cpp" 2


mwMaskStimulus::mwMaskStimulus(std::string _tag, std::string _filename,
                               shared_ptr<Variable> _xoffset,
                               shared_ptr<Variable> _yoffset,
                               shared_ptr<Variable> _xscale,
                               shared_ptr<Variable> _yscale,
                               shared_ptr<Variable> _rot,
                               shared_ptr<Variable> _alpha,
                               shared_ptr<Variable> _random_seed)
                                : ImageStimulus (_tag, _filename, _xoffset, _yoffset, _xscale, _yscale, _rot, _alpha) {

    random_seed = _random_seed;
}

mwMaskStimulus::mwMaskStimulus(const mwMaskStimulus &tocopy)
    :ImageStimulus((ImageStimulus&) tocopy) {
        random_seed = tocopy.random_seed;
}

mwMaskStimulus::~mwMaskStimulus(){
    if(loaded){
        free(image_data);
    }
}

shared_ptr<Variable> mwMaskStimulus::getRandomSeed() {
    return random_seed;
}

void mwMaskStimulus::makeMask(StimulusDisplay *display) {
    if(!loaded){
        return;
    }







}

void mwMaskStimulus::load(StimulusDisplay *display) {



    if(loaded){
  return;
 }
# 69 "/Users/graham/Developer/mwMaskStimulus/mwMaskStimulus.cpp"
 for(int i = 0; i < display->getNContexts(); i++){
  display->setCurrent(i);
  GLuint texture_map = OpenGLImageLoader::load(filename, display, &width, &height);
  texture_maps->addElement(i, texture_map);

  if(texture_map){
   mprintf("Image loaded into texture_map %d", texture_map);
  }
 }


    if (display->getNContexts() < 1) {
        throw SimpleException("no display contexts currently defined");
    }

    image_data = (float*) calloc(4 * height * width, sizeof(float));


    display->setCurrent(0);

    glBindTexture(0x0DE1, *(texture_maps->getElement(display->getCurrentContextIndex())));
    glGetTexImage(0x0DE1, 0, 0x1908, 0x1406, image_data);

    glBindTexture(0x0DE1, 0);

    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            std::cout << image_data[x+y*width];
        }
    }
    std::cout << "\n";

    loaded = true;
# 110 "/Users/graham/Developer/mwMaskStimulus/mwMaskStimulus.cpp"
}





Data mwMaskStimulus::getCurrentAnnounceDrawData() {



    Data announceData(M_DICTIONARY, 9);
    announceData.addElement("name",tag);
    announceData.addElement("action","draw");
    announceData.addElement("type","image");
    announceData.addElement("filename",filename);
    announceData.addElement("pos_x",last_posx);
    announceData.addElement("pos_y",last_posy);
    announceData.addElement("size_x",last_sizex);
    announceData.addElement("size_y",last_sizey);
    announceData.addElement("rotation",last_rot);


    return (announceData);
}
